#score: {'data3D.txt': -0.0024282}
#standard deviation: 0.04654176237273359
#island_id: 1
#version_generated: 3
#generate time00:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N + j][0] += np.exp(-h[i][j][k])
          priorities[i*N + j][1] -= h[i][j][k]
        elif h[i][j][k] < 0:
          priorities[i*N + j][0] -= np.exp(h[i][j][k])
          priorities[i*N + j][1] = -h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_magnetism = total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_magnetism
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_magnetism = total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + spin_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*spin_magnetism
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.508779}
#standard deviation: 0.04096868070856078
#island_id: 1
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.23075180000000017}
#standard deviation: 0.04760910035654946
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff - np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.33962779999999976}
#standard deviation: 0.04562009543128991
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        site_magnetism = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - site_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff + site_magnetism
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.3327961999999998}
#standard deviation: 0.04548874262452194
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.2990554000000001}
#standard deviation: 0.04644272871871332
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
        interaction_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > 0))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff - interaction_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (hamming_distance > 0.5) - total_spin - neighbor_magnetism_coeff + interaction_coeff
          priorities[i*N*N+j*N+k][1] = 2 - 2*total_spin + h[i][j][k]
  return(priorities)




#score: {'data3D.txt': -0.46250700000000006}
#standard deviation: 0.04256300025844043
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for k in range(N):
      if h[i][k][0] > 0:
        priorities[i*N + k][0] += np.exp(h[i][k][0])
        priorities[i*N + k][1] -= h[i][k][0]
      elif h[i][k][0] < 0:
        priorities[i*N + k][0] -= np.exp(h[i][k][0])
        priorities[i*N + k][1] = -h[i][k][0]

  return(priorities)




#score: {'data3D.txt': -0.4017014}
#standard deviation: 0.042320664432874876
#island_id: 1
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for k in range(N):
      if h[i][k][0] > 0:
        priorities[i*N + k][0] += np.exp(h[i][k][0])
        priorities[i*N + k][1] -= h[i][k][0]
      elif h[i][k][0] < 0:
        priorities[i*N + k][0] -= np.exp(h[i][k][0])
        priorities[i*N + k][1] = -h[i][k][0]

  return priorities




#score: {'data3D.txt': -0.4025982}
#standard deviation: 0.04234428647125844
#island_id: 1
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4017014}
#standard deviation: 0.042320664432874876
#island_id: 1
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  # Additional improvement: 
  # Prioritize assigning spin to sites with same magnetism as the current site
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]
  
  for i in range(N):
    for k in range(N):
      if h[i][k][0] > 0:
        priorities[i*N + k][0] += np.exp(h[i][k][0])
        priorities[i*N + k][1] -= h[i][k][0]
      elif h[i][k][0] < 0:
        priorities[i*N + k][0] -= np.exp(h[i][k][0])
        priorities[i*N + k][1] = -h[i][k][0]
  
  return priorities




#score: {'data3D.txt': -0.21358900000000028}
#standard deviation: 0.04669823978481415
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
          # Additional improvement: 
          # Prioritize assigning spin to sites with same magnetism as the current site
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))
            
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin + sum(val for val in site_neighbors if val > 0)
          
        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.32277539999999977}
#standard deviation: 0.044773529622311424
#island_id: 1
#version_generated: 3
#generate time00:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.32277539999999977}
#standard deviation: 0.044773529622311424
#island_id: 1
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][0])
        priorities[i*N + j][1] -= h[i][j][0]
      elif h[i][j][0] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][0])
        priorities[i*N + j][1] = -h[i][j][0]

  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.49438059999999995}
#standard deviation: 0.042496233052354185
#island_id: 0
#version_generated: 2
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1 + sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0]) > len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 1 - sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0)
  return(priorities)




#score: {'data3D.txt': -0.38466859999999997}
#standard deviation: 0.04114459349708051
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = ((i + k % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N ** 2 + j * N + k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N ** 2 + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N ** 2 + j * N + k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i * N ** 2 + j * N + k][1] = -2 + 2 * total_spin

        for d in range(3):
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i * N ** 2 + j * N + k][0] += neighbor_magnetism_coeff
  return(priorities)




#score: {'data3D.txt': -0.30135740000000005}
#standard deviation: 0.04209836653885754
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = ((i + k%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in [0,1]:
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][d] += neighbor_magnetism_coeff
        
        site_nbr = ((i + k%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14457380000000022}
#standard deviation: 0.04854912227383726
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][0] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - h[i][j][0]
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + h[i][j][0]
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][0] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] = -2 - 2*total_spin - h[i][j][0]
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - np.exp(h[i][j][0])
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin + h[i][j][0]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.30633940000000004}
#standard deviation: 0.04351724586459947
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_nbr = ((i + k%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        elif h[i][j][k] < 0:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_nbr = ((i + k%2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) - total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4918986000000001}
#standard deviation: 0.04156922416932989
#island_id: 2
#version_generated: 2
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.20584539999999998}
#standard deviation: 0.04688170708112067
#island_id: 2
#version_generated: 2
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 4 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14279260000000002}
#standard deviation: 0.05085330495887166
#island_id: 3
#version_generated: 2
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        for d in [0,1]:
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 2
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5351134}
#standard deviation: 0.03919921402834501
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (total_spin > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.36011300000000007}
#standard deviation: 0.04288802153282429
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
        # New: add term based on sum of absolute values of interacting spins
        priorities[i*N*N+j*N+k][0] += abs(sum(val for val in interacting_spins))
        priorities[i*N*N+j*N+k][1] -= abs(sum(val for val in interacting_spins if val > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        hamming_weight = int(hamming_distance > 0.5)
        site_magnetism = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += (hamming_weight * magnetism_coeff) + (site_magnetism - total_spin)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5043118000000001}
#standard deviation: 0.041472838590576364
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_up_count += sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5376746}
#standard deviation: 0.03931241018864145
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Add new term to account for the magnetism of the site itself
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.2901197999999999}
#standard deviation: 0.04771008622880491
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 4 + 2*total_spin
        
  # Calculate the priority based on the site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.36506819999999995}
#standard deviation: 0.044656970214738044
#island_id: 3
#version_generated: 3
#generate time01:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46594939999999996}
#standard deviation: 0.04221089100741656
#island_id: 3
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0029658}
#standard deviation: 0.046977310165227645
#island_id: 3
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.35048019999999996}
#standard deviation: 0.04124170423200283
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        total_spin_site = sum(J[d, site_nbr, j, k] for d in [0, 1, 2])
        if h[site_nbr][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin_site))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 * abs(total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.236287}
#standard deviation: 0.04342625923332564
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]

  return priorities




#score: {'data3D.txt': -0.04799460000000003}
#standard deviation: 0.04944132937978104
#island_id: 2
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority based on the Hamming distance and magnetism
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += 3 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 6 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 3 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 6 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) / max(len(site_neighbors), 1)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Calculate the priority based on the site's magnetization
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07922939999999999}
#standard deviation: 0.04935483821916551
#island_id: 3
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        for d in [0,1]:
          site_neighbors = []
          if d == 0 and k > 0:
            site_neighbors.append(J[1,i,j,k-1])
          elif d == 0 and k < N-1:
            site_neighbors.append(J[1,i,j,k+1])
          elif d == 1 and i > 0:
            site_neighbors.append(J[2,(i-1)%N,j,k])
          elif d == 1 and i < N-1:
            site_neighbors.append(J[2,(i+1)%N,j,k])
          
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5043118000000001}
#standard deviation: 0.041472838590576364
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_up_count = sum(val > 0 for val in interacting_spins) + (h[i][j][k] < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_up_count += sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4332122}
#standard deviation: 0.039882412805145075
#island_id: 2
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + site_magnetism - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          spin_up_count = sum(val > 0 for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3669634}
#standard deviation: 0.04285286618698918
#island_id: 1
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          if h[i][j][k] > 0:
            priorities[i*N + j][0] += np.exp(h[i][j][0])
            priorities[i*N + j][1] -= h[i][j][0]
          elif h[i][j][k] < 0:
            priorities[i*N + j][0] -= np.exp(h[i][j][0])
            priorities[i*N + j][1] = -h[i][j][0]

        # Additional improvement: 
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            priorities[i*N + j][0] += np.exp(h[i][j][d])
            priorities[i*N + j][1] -= h[i][j][d]
        else:
          for d in range(3):
            site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
            priorities[i*N + j][0] -= np.exp(h[i][j][d])
            priorities[i*N + j][1] = -h[i][j][d]

  return(priorities)




#score: {'data3D.txt': -0.4226014}
#standard deviation: 0.04152348200765442
#island_id: 1
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.39105100000000004}
#standard deviation: 0.04255599604051114
#island_id: 1
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = ((i + k % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N**2+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N**2+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N**2+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement:
        # Prioritize assigning spin to sites with same magnetism as the current site
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N**2+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N**2+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N**2+j*N+k][1] = -h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0055569999999999994}
#standard deviation: 0.047605035353416134
#island_id: 1
#version_generated: 3
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(val for val in interacting_spins if val < 0)
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N + j][0] += np.exp(h[i][j][k])
        priorities[i*N + j][1] -= h[i][j][k]
      elif h[i][j][k] < 0:
        priorities[i*N + j][0] -= np.exp(h[i][j][k])
        priorities[i*N + j][1] = -h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.26714380000000004}
#standard deviation: 0.04845391874306967
#island_id: 1
#version_generated: 3
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.46594939999999996}
#standard deviation: 0.04221089100741656
#island_id: 3
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.5101622}
#standard deviation: 0.04090296090945006
#island_id: 3
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4983746}
#standard deviation: 0.042414806316191045
#island_id: 3
#version_generated: 3
#generate time02:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4268294000000003}
#standard deviation: 0.04765126709375103
#island_id: 0
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)

        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.20893740000000022}
#standard deviation: 0.048496734335829225
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3955258}
#standard deviation: 0.043135916060285544
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
  
  return(priorities)




#score: {'data3D.txt': -0.474787}
#standard deviation: 0.041359001329819366
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0029658}
#standard deviation: 0.046977310165227645
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > sum(1 for val in interacting_spins if val > 0))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) > sum(1 for val in interacting_spins if val > 0))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3666922000000001}
#standard deviation: 0.04460282165020504
#island_id: 3
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4559234000000003}
#standard deviation: 0.046763637288388935
#island_id: 0
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]

        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

          # Add neighbor interactions with magnetism
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]

            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

          # Add neighbor interactions with magnetism
          for d in range(3):
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]

            if h[i][j][k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
              priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)

  return priorities




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 0
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.4183650000000003}
#standard deviation: 0.04803587341768649
#island_id: 0
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
        
        # Add bias term
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + (total_spin + sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
  
  return priorities




#score: {'data3D.txt': -0.4268294000000003}
#standard deviation: 0.04765126709375103
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism and spin value
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions and spin value
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.4571482000000002}
#standard deviation: 0.04579450793228376
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
        
        # Add neighbor magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (sum(1 for val in interacting_spins if val > 0) + sum(1 for val in site_neighbors))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - (sum(val for val in interacting_spins) + sum(val for val in site_neighbors))
  
  return priorities




#score: {'data3D.txt': -0.4268294000000003}
#standard deviation: 0.04765126709375103
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors)
        
        # Add magnetism term with neighbor interactions
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * sum(1 for val in interacting_spins if val > 0) + h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] - sum(val for val in interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.5358278000000001}
#standard deviation: 0.03964554637232283
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.474787}
#standard deviation: 0.041359001329819366
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2990274000000001}
#standard deviation: 0.04612857259053221
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5358278000000001}
#standard deviation: 0.03964554637232283
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # Add neighbor interactions
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)

        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.34315820000000014}
#standard deviation: 0.050816598594947304
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43909180000000014}
#standard deviation: 0.04811941908169716
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add neighbor interactions with magnetism
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in site_neighbors if val < 0)
        
        # Add magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2367586000000002}
#standard deviation: 0.049729270314775385
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin) / N)
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2548998000000002}
#standard deviation: 0.0492818254527975
#island_id: 1
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate magnetism coefficients and hamming distances
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        hamming_distance = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0]) / max(len([J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]), 1)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate site magnetization
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Calculate site neighbors' magnetization
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = magnetism_coeff * (hamming_distance > 0.5) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Calculate site magnetization with neighborhood and h
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.20893740000000022}
#standard deviation: 0.048496734335829225
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])

        # Calculate the priority values
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin

  return priorities




#score: {'data3D.txt': -0.2485318000000002}
#standard deviation: 0.04937528479674826
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': 0.07246979999999997}
#standard deviation: 0.04791097293898341
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Calculate the priority values for the neighbors
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) - total_spin
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.24824580000000002}
#standard deviation: 0.045293634236612104
#island_id: 3
#version_generated: 2
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5270058}
#standard deviation: 0.03991027344381394
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4928978}
#standard deviation: 0.04171011957738793
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        # Remove duplicate calculations for site neighbors
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5035598}
#standard deviation: 0.04131457786254145
#island_id: 1
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0])))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2159042}
#standard deviation: 0.04309388706487267
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        if i < N-1 and j < N-1 and k < N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.19600459999999997}
#standard deviation: 0.04326629656950084
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          else:
            priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val > 0])))

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.24824580000000002}
#standard deviation: 0.045293634236612104
#island_id: 3
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049936999999999995}
#standard deviation: 0.045422850538027665
#island_id: 3
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N, i]
        for site in site_neighbors:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        site_neighbors = [(i+1)%N, (j+1)%N, i]
        for site in site_neighbors:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        if k > 0:
          site_neighbors = [(i+1)%N, (j+1)%N, i]
          for site in site_neighbors:
            J_val = J[3,i,site,k-1] if site == (i+1)%N else J[4,i,j,k-1] if site == (j+1)%N else J[5,i,j,site]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
            priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3368566000000003}
#standard deviation: 0.04969523555070446
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.2485318000000002}
#standard deviation: 0.04937528479674826
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values based on the magnetism and interactions
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + 1
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions - 1
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin + 1
        
  return priorities




#score: {'data3D.txt': -0.22800260000000025}
#standard deviation: 0.04763292593616311
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions - sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
  
  return priorities




#score: {'data3D.txt': -0.0033894}
#standard deviation: 0.04694445321483679
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3524102000000003}
#standard deviation: 0.04863536178502222
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2]) + np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2]) - np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3235758000000003}
#standard deviation: 0.04984060046147117
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        # Add the site magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': 0.07246979999999997}
#standard deviation: 0.04791097293898341
#island_id: 1
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((neg_interactions - pos_interactions) / max(neg_interactions + pos_interactions, 1)) - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Calculate the priority values for the neighbors
        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])) / max(sum([val for val in site_neighbors]), 1)) - total_spin
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.22800260000000025}
#standard deviation: 0.04763292593616311
#island_id: 1
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions - sum(J[d, i, j, k] for d in [0,1])
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin - sum(J[d, i, j, k] for d in [0,1])
  
  return priorities




#score: {'data3D.txt': -0.29026860000000015}
#standard deviation: 0.04840507219331462
#island_id: 1
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for d in [0,1]:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1568338}
#standard deviation: 0.04575847132018288
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total
        
  return(priorities)




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10316299999999999}
#standard deviation: 0.04903459055605543
#island_id: 3
#version_generated: 3
#generate time03:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priority = np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority + total_spin
          priorities[i*N*N+j*N+k][1] -= priority - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority + total_spin
          priorities[i*N*N+j*N+k][1] = priority - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0072774}
#standard deviation: 0.047595297763959835
#island_id: 3
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.07601179999999999}
#standard deviation: 0.04980927283910095
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0410938}
#standard deviation: 0.0493548186255405
#island_id: 3
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        for d in range(3):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(6):
          site_neighbors = [J[d,i,j,(k+1)%N], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.18311860000000002}
#standard deviation: 0.047175512864620774
#island_id: 3
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.24832980000000032}
#standard deviation: 0.049066915859466854
#island_id: 1
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
          
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31840140000000006}
#standard deviation: 0.044322795467343884
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_spin_sum = np.sum(J[:, i, j, k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_sum
          priorities[i*N*N+j*N+k][1] -= total_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_sum
          priorities[i*N*N+j*N+k][1] = -total_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.2485318000000002}
#standard deviation: 0.04937528479674826
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values based on the magnetism and interactions
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3561538000000003}
#standard deviation: 0.04902511178528816
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(J[d, site_nbr, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(J[d, site_nbr, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.3631238000000003}
#standard deviation: 0.0447049607265234
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d, site_nbr, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin + 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 2
        
  return priorities




#score: {'data3D.txt': -0.0476338}
#standard deviation: 0.046682693340894546
#island_id: 1
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0,i,j,k],J[1,(i+1)%N,j,k],J[2,i,(j+1)%N,k]] if val < 0])
        pos_interactions = len([val for val in [J[0,i,j,k],J[1,(i+1)%N,j,k],J[2,i,(j+1)%N,k]] if val > 0])
        
        # Calculate the priority values based on the magnetism and interactions
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
  
  return priorities




#score: {'data3D.txt': 0.07002900000000001}
#standard deviation: 0.04689732016864077
#island_id: 3
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0056302}
#standard deviation: 0.04776897746404041
#island_id: 3
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        magnetism_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.060711800000000024}
#standard deviation: 0.047903200944822054
#island_id: 3
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) > len([val for val in interacting_spins if val < 0])) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.014241799999999999}
#standard deviation: 0.04584453438262843
#island_id: 3
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.0072774}
#standard deviation: 0.047595297763959835
#island_id: 3
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N]
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.14771220000000002}
#standard deviation: 0.04261923147078089
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        magnetization = np.sum([h[i][j][k] for i, j, k in itertools.product(range(N), range(N), range(N))])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -magnetization
          priorities[i*N*N+j*N+k][1] -= magnetization
        else:
          priorities[i*N*N+j*N+k][0] -= -magnetization
          priorities[i*N*N+j*N+k][1] = magnetization
        
  return(priorities)




#score: {'data3D.txt': -0.04744619999999999}
#standard deviation: 0.049298780365846784
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = 2*sum(val for val in site_neighbors) + h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0458818}
#standard deviation: 0.04975173473116289
#island_id: 3
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = 2*sum(val for val in site_neighbors) + h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.0623034}
#standard deviation: 0.04998737028930408
#island_id: 3
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2*sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          neighbor_sites = [(i+1)%N, (j+1)%N]
          for d in range(6):
            site_neighbors = [J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = 2*sum(val for val in site_neighbors) - h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.21641700000000022}
#standard deviation: 0.050153729980929644
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.3253510000000001}
#standard deviation: 0.04724477239864746
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Additional term to account for nearest neighbor interactions
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (neg_interactions > pos_interactions))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional term to account for magnetic field
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1769402000000003}
#standard deviation: 0.05036294336076875
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neg_interactions > pos_interactions) + total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (neg_interactions > pos_interactions) + total_spin + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.29442940000000023}
#standard deviation: 0.05014911261069333
#island_id: 1
#version_generated: 3
#generate time04:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (pos_interactions - neg_interactions) + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (neg_interactions - pos_interactions) + sum(J[d, i, j, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
  return priorities




#score: {'data3D.txt': -0.5228126}
#standard deviation: 0.03996013765291607
#island_id: 1
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3253510000000001}
#standard deviation: 0.04724477239864746
#island_id: 1
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])

        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-abs(total_spin)) + neg_interactions - pos_interactions
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
        # Additional term to account for nearest neighbor interactions
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (neg_interactions > pos_interactions))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional term to account for magnetic field
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4972918}
#standard deviation: 0.04124089442240553
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in site_neighbors if val < 0) > sum(1 for val in interacting_spins if val < 0)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in site_neighbors if val > 0) < sum(1 for val in interacting_spins if val > 0)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin + sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1847754}
#standard deviation: 0.05021847622977026
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Improved calculation of neighbor magnetism coefficient
        neighbor_magnetism_coeff = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) / len([val for val in interacting_spins if val < 0])
        
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        # Improved calculation of magnetism coefficient
        magnetism_coeff = np.exp(h[i][j][k]) * (h[i][j][k] > 0) + (-1) * (h[i][j][k] < 0)
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.5384482}
#standard deviation: 0.03923028672798607
#island_id: 0
#version_generated: 2
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3470737999999996}
#standard deviation: 0.04395288606633242
#island_id: 1
#version_generated: 3
#generate time04:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 4 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -4 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -8 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 4 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 4 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = 8 * (neg_interactions - pos_interactions)
        
        # Add the magnetism term
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.38299060000000007}
#standard deviation: 0.04615623155804642
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        
        # Add the magnetism term
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.25082100000000024}
#standard deviation: 0.046545831166711384
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values based on the interaction strength
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + (neg_interactions - pos_interactions) * J[0, i, j, k]
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - (pos_interactions - neg_interactions) * J[0, i, j, k]
          else:
            priorities[i*N*N+j*N+k][1] -= 2 * (neg_interactions - pos_interactions) * J[0, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin - (neg_interactions - pos_interactions) * J[0, i, j, k]
          elif pos_interactions > neg_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + (pos_interactions - neg_interactions) * J[0, i, j, k]
          else:
            priorities[i*N*N+j*N+k][1] -= 2 * (neg_interactions - pos_interactions) * J[0, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.019520600000000242}
#standard deviation: 0.049221844496524114
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the number of negative and positive interactions
        neg_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val < 0])
        pos_interactions = len([val for val in [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]] if val > 0])
        
        # Calculate the priority values
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 * (neg_interactions - pos_interactions)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          if neg_interactions > pos_interactions:
            priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 * (neg_interactions - pos_interactions)
        
  return(priorities)




#score: {'data3D.txt': -0.408851}
#standard deviation: 0.04583480335945601
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0766822}
#standard deviation: 0.04724068080754129
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        total_site_magnetism = h[i][j][k] + sum(J[d,i,j,k] for d in [3,4,5])
        if total_site_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(total_site_magnetism)
          priorities[i*N*N+j*N+k][1] -= total_site_magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_site_magnetism)
          priorities[i*N*N+j*N+k][1] += total_site_magnetism
        
  return(priorities)




#score: {'data3D.txt': -0.2527746}
#standard deviation: 0.04556095823004605
#island_id: 3
#version_generated: 3
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_sites = [(i+1)%N, (j+1)%N, i]
        for site in neighbor_sites:
          J_val = J[3,i,site,k] if site == (i+1)%N else J[4,i,j,k] if site == (j+1)%N else J[5,i,j,site]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * J_val
          priorities[i*N*N+j*N+k][1] -= 2*J_val
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42277539999999997}
#standard deviation: 0.043217879573620915
#island_id: 3
#version_generated: 3
#generate time04:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors_1d = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in site_neighbors_1d if val < 0) > sum(1 for val in interacting_spins if val < 0)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors_1d)
        priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4867994}
#standard deviation: 0.041241506757634355
#island_id: 0
#version_generated: 2
#generate time04:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5372013999999999}
#standard deviation: 0.03953245297271597
#island_id: 0
#version_generated: 2
#generate time04:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032470000000000008}
#standard deviation: 0.04703315756995271
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.06962940000000001}
#standard deviation: 0.048736997605925626
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2

        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.1178762}
#standard deviation: 0.04834775189768393
#island_id: 3
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.26180540000000013}
#standard deviation: 0.04787520120939439
#island_id: 1
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * (3 - total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 + 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin) * (3 + total_spin)
          priorities[i*N*N+j*N+k][1] = 3 - 3*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return priorities




#score: {'data3D.txt': -0.2406462000000001}
#standard deviation: 0.05163958622568544
#island_id: 1
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        
        # Calculate the priority values
        if sum(val for val in site_neighbors) >= 2:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        elif sum(val for val in site_neighbors) <= -2:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum([val if val > 0 else -val for val in site_neighbors]))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.13420180000000032}
#standard deviation: 0.04947274357421469
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional improvement: consider the number of neighboring sites with same spin
        num_same_spin_neighbors = len([val for val in site_neighbors if val == J[0, i, j, k]])
        priorities[i*N*N+j*N+k][0] += np.exp(-num_same_spin_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*num_same_spin_neighbors

  return priorities




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.11993020000000032}
#standard deviation: 0.04966494506148175
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 3 - 3*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] = 3 + 3*total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in site_neighbors if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return priorities




#score: {'data3D.txt': -0.4961702}
#standard deviation: 0.04116157567392191
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) < len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin + sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2912741999999999}
#standard deviation: 0.04652442169828659
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.44130939999999996}
#standard deviation: 0.0414878294399695
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val > 0]) < len([val for val in interacting_spins if val > 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= -1 - total_spin + sum(val for val in site_neighbors if val > 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4983954}
#standard deviation: 0.041370421545350484
#island_id: 3
#version_generated: 3
#generate time05:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1568338}
#standard deviation: 0.04575847132018288
#island_id: 3
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total

        else:
          priority_total = np.sum([J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

  return priorities




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.07434179999999999}
#standard deviation: 0.048833599219799476
#island_id: 3
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.46816740000000007}
#standard deviation: 0.040473716128371515
#island_id: 2
#version_generated: 2
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0)) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.46816740000000007}
#standard deviation: 0.040473716128371515
#island_id: 2
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0)) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priority_total = np.zeros((N**3, 2))
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          priority_total[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > sum(val for val in interacting_spins if val < 0))
          priority_total[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 2
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.46080100000000007}
#standard deviation: 0.041150725376352726
#island_id: 2
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.369459}
#standard deviation: 0.04057767365189877
#island_id: 3
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        total_spin_neighbors = sum(J[d,site_nbr,i,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.4932626}
#standard deviation: 0.04194558428774118
#island_id: 3
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4718414}
#standard deviation: 0.038532275381036096
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.3641098000000001}
#standard deviation: 0.047768571089786646
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          if J[d,i,j,k] < 0:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4718414}
#standard deviation: 0.038532275381036096
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.391165}
#standard deviation: 0.040518029752197975
#island_id: 3
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        site_neighbors = [(i+1)%N, (j+1)%N]
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= 2*np.exp(h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.3641098000000001}
#standard deviation: 0.047768571089786646
#island_id: 3
#version_generated: 3
#generate time05:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(6):
          if J[d,i,j,k] < 0:
            if h[i][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.4245346000000001}
#standard deviation: 0.041271265583211765
#island_id: 3
#version_generated: 3
#generate time05:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(6):
          if J[d,i,j,k] < 0:
            site_neighbors = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k]]
            neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
            priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 2
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5045362}
#standard deviation: 0.041113516628476336
#island_id: 1
#version_generated: 2
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[0,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)




#score: {'data3D.txt': -0.40828020000000004}
#standard deviation: 0.041899691740632176
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        if site_nbr == i:
          for d in range(6):
            if J[d,i,j,k] < 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        elif site_nbr == (i+1)%N:
          for d in range(6):
            if J[d,i,j,k] < 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff
        elif site_nbr == (i-1)%N:
          for d in range(6):
            if J[d,i,j,k] < 0 and h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.312785}
#standard deviation: 0.0456207748180585
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
        
        # Additional improvement: take into account the magnetization of neighboring sites
        for site in site_neighbors:
          if h[site_nbr][i%N][j%N] > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.49948220000000004}
#standard deviation: 0.0408856963149706
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (h[site_nbr][i%N][k] > 0)
            priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff * (h[site_nbr][i%N][k] > 0)
          
  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.07434179999999999}
#standard deviation: 0.048833599219799476
#island_id: 3
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.0912406}
#standard deviation: 0.04638194726011404
#island_id: 3
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total
        
        site_neighbors = [(i+1)%N, (j+1)%N]
        site_magnetism_coeff = np.exp(-abs(total_spin))
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2*site_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.07434179999999999}
#standard deviation: 0.048833599219799476
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) - priority_total
          priorities[i*N*N+j*N+k][1] -= 2 + 2*total_spin + priority_total
        else:
          priority_total = np.sum(J[:,i,j,k]) + total_spin
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + priority_total

        neighbor_sites = [(i+1)%N, (j+1)%N]
        site_neighbors = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
        for d in range(6):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2*neighbor_magnetism_coeff

        spin_value = np.sign(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += spin_value * (np.exp(h[i][j][k]) + np.sum(J[:,i,j,k]))
        priorities[i*N*N+j*N+k][1] -= 2*spin_value * (h[i][j][k] - np.sum(J[:,i,j,k]))

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4644582}
#standard deviation: 0.042403716025367404
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # add the magnetism coefficient
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= np.exp(-h[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4988642}
#standard deviation: 0.04194687495344558
#island_id: 0
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.47078580000000003}
#standard deviation: 0.044853058740291066
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.23535180000000003}
#standard deviation: 0.05303813379786284
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
          for neighbor in site_neighbors:
            if J[d,neighbor[0],neighbor[1],neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbrs = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_nbrs:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.281755}
#standard deviation: 0.05297517545983213
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
          for neighbor in site_neighbors:
            if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4617798}
#standard deviation: 0.045712929811597074
#island_id: 1
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4817702}
#standard deviation: 0.04506366287775551
#island_id: 1
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4311346}
#standard deviation: 0.04721089538273978
#island_id: 1
#version_generated: 3
#generate time06:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_2d = [(i+1)%N,i,(j+1)%N],[(i+1)%N,j], [i,(j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0,neighbor[0],neighbor[1],k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4238102}
#standard deviation: 0.04642644866840452
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_2d = [(i+1)%N,i,(j+1)%N],[(i+1)%N,j], [i,(j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0,neighbor[0],neighbor[1],k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_3d = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors_3d:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4311346}
#standard deviation: 0.04721089538273978
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N, i, (j+1)%N, k], [(i+1)%N, j, k], [i, (j+1)%N, k]
        for neighbor in site_neighbors:
          if J[0, neighbor[0], neighbor[1], neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors_2d = [(i+1)%N, i, (j+1)%N], [(i+1)%N, j], [i, (j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0, neighbor[0], neighbor[1], k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.48002859999999997}
#standard deviation: 0.04112038450744351
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_neighbor = J[2,i,j,(k+1)%N]
        site_magnetism_coeff = np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= site_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time06:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time06:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44477739999999993}
#standard deviation: 0.04489506976539852
#island_id: 0
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0]))
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4311346}
#standard deviation: 0.04721089538273978
#island_id: 1
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_3d = [(i+1)%N,i,(j+1)%N,k],[(i+1)%N,j,k], [i,(j+1)%N,k]
        for neighbor in site_neighbors_3d:
          if J[0,neighbor[0],neighbor[1],neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors_2d = [(i+1)%N,i,(j+1)%N],[(i+1)%N,j], [i,(j+1)%N]
        for neighbor in site_neighbors_2d:
          if J[0,neighbor[0],neighbor[1],k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5370874}
#standard deviation: 0.039752541569565085
#island_id: 3
#version_generated: 2
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4230534}
#standard deviation: 0.04532318510916902
#island_id: 0
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.47726979999999997}
#standard deviation: 0.04152077321004511
#island_id: 0
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New improvement: add a term based on the magnetism at the current site
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.13260300000000003}
#standard deviation: 0.054742609647330485
#island_id: 0
#version_generated: 3
#generate time06:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5124034000000001}
#standard deviation: 0.04123906240980753
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5147986}
#standard deviation: 0.04028881678629939
#island_id: 3
#version_generated: 3
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        total_spin_sum = np.sum(J[0,i,j,k])
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * total_spin_sum
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * total_spin_sum

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.5138978000000001}
#standard deviation: 0.04207246219512236
#island_id: 2
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5007078}
#standard deviation: 0.040375926728187926
#island_id: 2
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors_magnetism = [h[site_nbr][i%N][k], h[(i+1)%N][j][k], h[i][(k+1)%N][j]]
        priorities[i*N*N+j*N+k][0] += np.exp(sum(neighbors_magnetism))
        priorities[i*N*N+j*N+k][1] -= sum(neighbors_magnetism)
        
  return(priorities)




#score: {'data3D.txt': -0.5138978000000001}
#standard deviation: 0.04207246219512236
#island_id: 2
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4988642}
#standard deviation: 0.04194687495344558
#island_id: 0
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4825298}
#standard deviation: 0.0416584175402763
#island_id: 0
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.24813220000000002}
#standard deviation: 0.04250175435390873
#island_id: 3
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        for d in range(3):
          site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N, (i+1) % N, i]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N) if J[d,site_nbr_neighbors[0],j,k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.5270058}
#standard deviation: 0.03991027344381394
#island_id: 0
#version_generated: 3
#generate time06:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        if any(abs(val) > 1 for val in interacting_spins):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        else:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          elif total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 0
        if any(val < 0 for val in interacting_spins):
          neighbor_magnetism_coeff += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        
        neighbor_magnetism_coeff = np.sum(np.abs(J[:,i,j,k]), axis=0)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.40289620000000004}
#standard deviation: 0.04414803082312958
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N, (i+1) % N, i]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N) if J[d,site_nbr_neighbors[0],j,k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.40289620000000004}
#standard deviation: 0.04414803082312958
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Additional priority calculation
        site_nbr_neighbors = [(i + ((k-1)%2 - 1)) % N, (i+1) % N, i]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(J[d,site_nbr_neighbors[0],j,k] for j in range(N) if J[d,site_nbr_neighbors[0],j,k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.44423419999999997}
#standard deviation: 0.04328755745430781
#island_id: 3
#version_generated: 3
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Calculate distance from each spin to the center of the grid
        center_x, center_y, center_z = N // 2, N // 2, N // 2
        dist_to_center = np.sqrt((i - center_x)**2 + (j - center_y)**2 + (k - center_z)**2)

        # Prioritize spins closer to the center of the grid
        priorities[i*N*N+j*N+k][0] += np.exp(-dist_to_center)
        priorities[i*N*N+j*N+k][1] -= dist_to_center

  return priorities




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4712014000000002}
#standard deviation: 0.044354917179947474
#island_id: 2
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.46302620000000005}
#standard deviation: 0.043795016994630794
#island_id: 2
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.00042579999999999994}
#standard deviation: 0.044740300561797744
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New improvement: calculate the number of neighbors that are aligned with the current spin and the total magnetization
        num_aligned_neighbors = sum(1 for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]] if val > 0)
        priorities[i*N*N+j*N+k][0] += 2 * (num_aligned_neighbors - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4967498000000001}
#standard deviation: 0.04427399959298911
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4988642}
#standard deviation: 0.04194687495344558
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # Additional improvement
        if i == N-1 and j == N-1 and k == N-1:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': -0.4949106}
#standard deviation: 0.04148965229596411
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.029304200000000002}
#standard deviation: 0.04742723418416891
#island_id: 3
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Calculate the distance from each spin to its neighbors
        distances = []
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_distances = np.sqrt((i - ((d+1)%2))**2 + (j - 0)**2 + (k - 0)**2)
          distances.append(neighbor_distances)

        # Prioritize spins closer to their neighbors
        for distance in distances:
          priorities[i*N*N+j*N+k][0] += np.exp(-distance)
          priorities[i*N*N+j*N+k][1] -= distance

  return priorities




#score: {'data3D.txt': -0.2270874}
#standard deviation: 0.04315819738172576
#island_id: 3
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        center_x, center_y, center_z = N // 2, N // 2, N // 2
        dist_to_center = np.sqrt((i - center_x)**2 + (j - center_y)**2 + (k - center_z)**2)
        
        # Prioritize spins that are closer to the center of the grid and have higher magnetism
        priorities[i*N*N+j*N+k][0] += np.exp(-dist_to_center) * np.exp(abs(h[i][j][k]))
        priorities[i*N*N+j*N+k][1] -= dist_to_center - abs(h[i][j][k])
  
  return priorities




#score: {'data3D.txt': -0.44423419999999997}
#standard deviation: 0.04328755745430781
#island_id: 3
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # Calculate distance from each spin to the center of the grid
        center_x, center_y, center_z = N // 2, N // 2, N // 2
        dist_to_center = np.sqrt((i - center_x)**2 + (j - center_y)**2 + (k - center_z)**2)

        # Prioritize spins closer to the center of the grid
        priorities[i*N*N+j*N+k][0] += np.exp(-dist_to_center)
        priorities[i*N*N+j*N+k][1] -= dist_to_center

  return priorities




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.4940942}
#standard deviation: 0.04095731883754111
#island_id: 0
#version_generated: 3
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)




#score: {'data3D.txt': -0.48356420000000006}
#standard deviation: 0.041610105964296706
#island_id: 0
#version_generated: 3
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        # New term
        if i > 0 and j > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff

  return(priorities)




#score: {'data3D.txt': -0.40886700000000004}
#standard deviation: 0.047902902949612566
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [(i+1)%N,j,k], [i,(j+1)%N,k], [(i+1)%N,(j+1)%N,k]
        for neighbor in site_neighbors:
          if h[neighbor[0]][neighbor[1]][neighbor[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in [J[d,neighbor[0],neighbor[1],neighbor[2]] for d in [0,1,2]] if val < 0) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in [J[d,neighbor[0],neighbor[1],neighbor[2]] for d in [0,1,2]] if val > 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.49317660000000013}
#standard deviation: 0.04276040659816041
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.506773}
#standard deviation: 0.043632984209196604
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in site_neighbors if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.36848100000000006}
#standard deviation: 0.0437250660262509
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * sum(1 for val in site_neighbors if val < 0))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.466317}
#standard deviation: 0.04710316964918603
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.005967000000000044}
#standard deviation: 0.04610356852782657
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4635354}
#standard deviation: 0.04254398696455235
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': 0.17582100000000003}
#standard deviation: 0.04564686275090546
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,(i+1)%N,j,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4635354}
#standard deviation: 0.04254398696455235
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time07:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.44820500000000013}
#standard deviation: 0.044002285565638524
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.43769420000000026}
#standard deviation: 0.04674303420147221
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_direction = np.sign(h[i][j][k])
        if spin_direction == 1:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.16233260000000013}
#standard deviation: 0.04620070710757575
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin ** 2
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin ** 2
          priorities[i*N*N+j*N+k][1] += 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.10507500000000004}
#standard deviation: 0.04672909687764145
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New improvement
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib
        
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.05977740000000006}
#standard deviation: 0.11615759367876051
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  # Another additional improvement
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  return priorities




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 2
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 2
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4697422}
#standard deviation: 0.04114674882855266
#island_id: 2
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5007078}
#standard deviation: 0.040375926728187926
#island_id: 2
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        neighbors_magnetism = [h[site_nbr][i%N][k], h[(i+1)%N][j][k], h[i][(k+1)%N][j]]
        priorities[i*N*N+j*N+k][0] += np.exp(sum(neighbors_magnetism))
        priorities[i*N*N+j*N+k][1] -= sum(neighbors_magnetism)
        
  return(priorities)




#score: {'data3D.txt': -0.10507500000000004}
#standard deviation: 0.04672909687764145
#island_id: 0
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # New improvements
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib
        
  return(priorities)




#score: {'data3D.txt': -0.10507500000000004}
#standard deviation: 0.04672909687764145
#island_id: 0
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        # New improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # New improvement
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib

  return(priorities)




#score: {'data3D.txt': -0.11982980000000007}
#standard deviation: 0.04840494470568064
#island_id: 0
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvements
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # New improvements
        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib
        
        # Improvement based on site interactions
        site_interactions = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_interaction_coeff = 2 * sum(val for val in site_interactions) / len(site_interactions)
        priorities[i*N*N+j*N+k][0] += site_interaction_coeff
        priorities[i*N*N+j*N+k][1] -= site_interaction_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4816502}
#standard deviation: 0.04188654199095457
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors) < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4496598000000002}
#standard deviation: 0.04563889288709796
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= spin_coeff - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += spin_coeff + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.40324220000000005}
#standard deviation: 0.04173520838764316
#island_id: 2
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += magnetism
          priorities[i*N*N+j*N+k][1] -= magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism
          priorities[i*N*N+j*N+k][1] += magnetism
  
  return priorities




#score: {'data3D.txt': -0.19323220000000021}
#standard deviation: 0.04908278438678882
#island_id: 2
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.13954660000000008}
#standard deviation: 0.0482783494792438
#island_id: 0
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Another additional improvement
        total_spin_sum = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_sum = sum(h[site_nbr][j][k] for _ in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_sum - 3 * site_nbr_sum / N**3))
        
  return priorities




#score: {'data3D.txt': -0.4982022}
#standard deviation: 0.04257542243078746
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in neighbors if val < 0)
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3282598000000004}
#standard deviation: 0.05008388307589577
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Priority based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i][j][k])) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i][j][k])) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.19418100000000008}
#standard deviation: 0.051970690191684
#island_id: 0
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Another additional improvement
        if h[i][j][k] > 0:
          if (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            total_spin_coeff = 2 * total_spin / abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 * total_spin
        else:
          if (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 * total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            total_spin_coeff = 2 * total_spin / abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        
  return priorities




#score: {'data3D.txt': -0.13508380000000006}
#standard deviation: 0.0495949454839906
#island_id: 0
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
          
  return priorities




#score: {'data3D.txt': -0.23432380000000036}
#standard deviation: 0.04476066569612207
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757374}
#standard deviation: 0.04204740136132077
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4081586000000001}
#standard deviation: 0.04393126183072825
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4250734000000001}
#standard deviation: 0.044614149464491645
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.06330780000000001}
#standard deviation: 0.21953395295297717
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
  # New term
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1876134}
#standard deviation: 0.0527265013104416
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  
  return(priorities)




#score: {'data3D.txt': 0.07439220000000005}
#standard deviation: 0.047381750697499565
#island_id: 0
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return priorities




#score: {'data3D.txt': -0.1403622000000001}
#standard deviation: 0.047260174895571425
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,jr%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2977354000000003}
#standard deviation: 0.049791340882125265
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.16192500000000007}
#standard deviation: 0.046661363192688654
#island_id: 0
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * total_spin / abs(total_spin)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        for d in range(3):
          site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
          neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1403622000000001}
#standard deviation: 0.047260174895571425
#island_id: 0
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,jr%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1403622000000001}
#standard deviation: 0.047260174895571425
#island_id: 0
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        # Additional improvement
        neighbor_interacting_spins = [J[0,ir,jr,k] for ir in site_nbrs for jr in site_nbrs]
        neighbor_total_spin = sum(J[d,ir,jr,k] for d in range(3) for ir in site_nbrs for jr in site_nbrs)
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,jr%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.3156405999999998}
#standard deviation: 0.047314717283737394
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
        if h[i][j][k] > 0 and total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(total_spin))
        elif h[i][j][k] < 0 and total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3144554000000003}
#standard deviation: 0.046560523309344355
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.13508380000000006}
#standard deviation: 0.0495949454839906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
          
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.14724940000000006}
#standard deviation: 0.04940451881801906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return priorities




#score: {'data3D.txt': -0.13508380000000006}
#standard deviation: 0.0495949454839906
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.4083394}
#standard deviation: 0.04199644708353315
#island_id: 1
#version_generated: 3
#generate time07:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        neighbor_sum = sum(J[d,i,(j+1)%N,k] for d in [0,1,2]) + sum(J[d,(i+1)%N,j,k] for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_sum > 0) - total_spin
        priorities[i*N*N+j*N+k][1] -= 1 + total_spin

  return(priorities)




#score: {'data3D.txt': -0.4322438}
#standard deviation: 0.04138919329438543
#island_id: 1
#version_generated: 3
#generate time07:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4279710000000001}
#standard deviation: 0.04535825304175636
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
  return priorities




#score: {'data3D.txt': -0.4279710000000001}
#standard deviation: 0.04535825304175636
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4279710000000001}
#standard deviation: 0.04535825304175636
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.43367100000000003}
#standard deviation: 0.05643875724181035
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
      
  for i in range(N):
    for j in range(N):
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+N-1][0] += 2*total_spin
        priorities[i*N*N+j*N+N-1][1] -= 2 - total_spin
      else:
        priorities[i*N*N+j*N+N-1][0] -= 2 + total_spin
        priorities[i*N*N+j*N+N-1][1] = -2 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14851940000000002}
#standard deviation: 0.08760719481663591
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    for d in [0,1]:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N][d] > 0:
        priorities[i][d] += 1 + total_spin
        priorities[i][1-d] -= 1 - total_spin
      else:
        priorities[i][d] -= 1 + total_spin
        priorities[i][1-d] = -1 + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5255634000000001}
#standard deviation: 0.041010218000395955
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.3658178000000003}
#standard deviation: 0.04881379521364836
#island_id: 2
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.1317714000000001}
#standard deviation: 0.04715481589445557
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
        if h[i][j][k] > 0:
          total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
          priorities[i*N*N+j*N+k][1] += total_spin_contrib
        else:
          site_interaction_coeff = 2 * sum(val for val in interacting_spins) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= site_interaction_coeff
          priorities[i*N*N+j*N+k][1] += site_interaction_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.11982980000000007}
#standard deviation: 0.04840494470568064
#island_id: 0
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib

        site_interactions = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_interaction_coeff = 2 * sum(val for val in site_interactions) / len(site_interactions)
        priorities[i*N*N+j*N+k][0] += site_interaction_coeff
        priorities[i*N*N+j*N+k][1] -= site_interaction_coeff

  return(priorities)




#score: {'data3D.txt': -0.11982980000000007}
#standard deviation: 0.04840494470568064
#island_id: 0
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          total_spin_coeff = 2 * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) * total_spin_coeff + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = 2 * sum(val for val in [h[site_nbr][j][k] + h[sr%N,j,k] + h[i,(jr+1)%N,k] for sr in site_nbrs for jr in site_nbrs]) / len(site_nbrs)
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        total_spin_contrib = 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) / abs(total_spin)
        priorities[i*N*N+j*N+k][1] += total_spin_contrib

        site_interactions = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_interaction_coeff = 2 * sum(val for val in site_interactions) / len(site_interactions)
        priorities[i*N*N+j*N+k][0] += site_interaction_coeff
        priorities[i*N*N+j*N+k][1] -= site_interaction_coeff

  return(priorities)




#score: {'data3D.txt': -0.5253858}
#standard deviation: 0.042492344703016806
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0) if h[i][j][k] > 0 else -np.exp(-total_h)
        priorities[i*N*N+j*N+k][1] -= total_h
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
  
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4330190000000002}
#standard deviation: 0.04681049795718905
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4139198000000002}
#standard deviation: 0.04650348038545073
#island_id: 2
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        spin_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= spin_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] += spin_coeff
        
        if i < N-1 and j < N-1 and k < N-1:  # check for neighboring sites
          adjacent_sites = [J[3,i,(j+1)%N,k], J[4,(i+1)%N,j,k], J[5,i,j,(k+1)%N]]
          if sum(val for val in adjacent_sites) < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in adjacent_sites if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in adjacent_sites if val > 0]) - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.38685660000000044}
#standard deviation: 0.047225075928366694
#island_id: 3
#version_generated: 3
#generate time08:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for neighbor in site_neighbors:
          if h[i][j][k] > 0 and neighbor < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] -= h[i][j][k]
          elif h[i][j][k] < 0 and neighbor > 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k])
            priorities[i*N*N+j*N+k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 3
#generate time08:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
  
  return priorities




#score: {'data3D.txt': -0.13979900000000003}
#standard deviation: 0.04680873635337744
#island_id: 3
#version_generated: 3
#generate time08:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4254198000000001}
#standard deviation: 0.047419985322224634
#island_id: 3
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.20538340000000005}
#standard deviation: 0.0458472307172418
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3092614000000002}
#standard deviation: 0.04631319326110001
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= np.exp(-total_h) * (total_spin < 0)
  
  return priorities




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.44424620000000004}
#standard deviation: 0.045206160482394425
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
        
  return(priorities)




#score: {'data3D.txt': -0.47838660000000016}
#standard deviation: 0.043234359720481584
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_h = h[i][j][k]
        priorities[i*N*N+j*N+k][0] += np.exp(total_h) * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= total_h
        
  return(priorities)




#score: {'data3D.txt': -0.48180700000000004}
#standard deviation: 0.04082668332108304
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (1 + total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (1 + total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
  
  return(priorities)




#score: {'data3D.txt': -0.4649982}
#standard deviation: 0.0424539811650215
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        for d in range(2):
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        # New term
        if i > 0 and j > 0 and k > 0:
          neighbor_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i-1,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_coeff
          priorities[i*N*N+j*N+k][1] -= neighbor_coeff
        
        # Additional improvement
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in [J[0,i,jr,k] for jr in site_nbrs] + [J[d,ir,j,k] for d in range(3) for ir in site_nbrs]]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4757374}
#standard deviation: 0.04204740136132077
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757374}
#standard deviation: 0.04204740136132077
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_neighbor_magnetism = sum(h[site_nbr][i%N][k] for i in range(N))
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin + site_neighbor_magnetism
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0815902}
#standard deviation: 0.07426463723711306
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
      
  for i in range(N**3):
    site_neighbors = [J[0,i//N%N,(i//N)%N,0], J[1,(i//N+1)%N,(i//N)%N,0], J[2,i//N%N,(i//N)%N,0]]
    if sum(h[i//N%N][i//N%N][k] for k in range(N)) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.42442900000000033}
#standard deviation: 0.047812994875870304
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0031834000000000003}
#standard deviation: 0.04699338341128462
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
        return priorities




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.43634300000000015}
#standard deviation: 0.043266936001986556
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.13979900000000003}
#standard deviation: 0.04680873635337744
#island_id: 3
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.14834780000000003}
#standard deviation: 0.04597185873074961
#island_id: 3
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
      else:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
  
  return(priorities)




#score: {'data3D.txt': -0.2200830000000002}
#standard deviation: 0.05247079140817299
#island_id: 3
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k]) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k] - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k]) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k] + total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= h[i][j][k] - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[i][j][k]) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -h[i][j][k] + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13979900000000003}
#standard deviation: 0.04680873635337744
#island_id: 3
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1123462}
#standard deviation: 0.052688832455844
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.43049460000000017}
#standard deviation: 0.04511069729942112
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3269350000000002}
#standard deviation: 0.04458518290867495
#island_id: 3
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.002945}
#standard deviation: 0.04675148997625637
#island_id: 2
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[0,i//N%N,i%N,0], J[1,(i//N+1)%N,i%N,0], J[2,i//N%N,i%N,0]]
    total_spin = sum(J[d,i//N%N,i%N,0] for d in [0,1,2])
    
    if h[site_nbr][i//N%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.08292859999999999}
#standard deviation: 0.05943515779435603
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
      priorities[i][1] -= 1 - sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
    else:
      priorities[i][0] -= 1 + sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
      priorities[i][1] = -1 + sum(J[d,site_nbr,i%N,0] for d in [0,1,2])
      
  for i in range(N**3):
    site_neighbors = [J[0,i//N%N,(i//N)%N,0], J[1,(i//N+1)%N,(i//N)%N,0], J[2,i//N%N,(i//N)%N,0]]
    if sum(h[i//N%N][i//N%N][k] for k in range(N)) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
      
  return(priorities)




#score: {'data3D.txt': -0.0004045999999999992}
#standard deviation: 0.0470033098711144
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      priorities[i][1] -= 2 - 2*np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) - 2*np.sum([h[site_nbr][k][0] for k in range(N)])
    else:
      priorities[i][0] -= np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      priorities[i][1] = -2 + 2*np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + 2*np.sum([h[site_nbr][k][0] for k in range(N)])
      
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.09839340000000002}
#standard deviation: 0.041808713881677825
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        # Add interactions with neighboring sites
        for x in range(-1, 2):
          for y in range(-1, 2):
            if i+x >= N or j+y >= N:
              continue
            site = (i+x) * N*N + (j+y) * N + k
            priorities[i*N*N+j*N+k][0] += np.exp(h[i+x][j+y][k]) * len([val for val in [J[0,i+x,j+y,k], J[1,(i+x+1)%N,j+y,k], J[2,i+x,(j+y+1)%N,k]] if val < 0])
            priorities[i*N*N+j*N+k][1] -= h[i+x][j+y][k]
        
  return(priorities)




#score: {'data3D.txt': -0.16183220000000018}
#standard deviation: 0.04665884999825864
#island_id: 3
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time08:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5106282}
#standard deviation: 0.0422656537245078
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5162774000000002}
#standard deviation: 0.042542108660008855
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.33196979999999965}
#standard deviation: 0.04521094743488571
#island_id: 3
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbor_spin = sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbor_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          
          site_neighbor_spin = sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*site_neighbor_spin
        
  return priorities




#score: {'data3D.txt': 0.22193660000000032}
#standard deviation: 0.04520538840049934
#island_id: 3
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
        # Calculate the probability of being in a low energy state
        if h[i][j][k] > 0:
          probabilities = np.exp(-np.sum([J[d,i,j,k] for d in [0,1,2]], axis=0))
        else:
          probabilities = np.exp(np.sum([J[d,i,j,k] for d in [0,1,2]], axis=0))
        
        # Update the priorities based on the probability
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] *= probabilities
          priorities[i*N*N+j*N+k][1] *= (1 - probabilities)
        else:
          priorities[i*N*N+j*N+k][0] = (1-probabilities) * priorities[i*N*N+j*N+k][0]
          priorities[i*N*N+j*N+k][1] = probabilities * priorities[i*N*N+j*N+k][1]
  
  return priorities




#score: {'data3D.txt': -0.4103446000000001}
#standard deviation: 0.050018970109749365
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3004070000000001}
#standard deviation: 0.04694090828903932
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3624178000000002}
#standard deviation: 0.04726851767466376
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_sum = sum(J[0,i,j,k] for j in range(N) for k in range(N))
        site_avg = site_sum / (N**2)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_avg)) * len([val for val in interacting_spins if val < 0]) + site_avg
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_avg
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_avg)) * len([val for val in interacting_spins if val > 0]) + site_avg
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_avg
        
  return(priorities)




#score: {'data3D.txt': -0.3004070000000001}
#standard deviation: 0.04694090828903932
#island_id: 0
#version_generated: 3
#generate time08:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.48257220000000006}
#standard deviation: 0.04416906866982821
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3950458}
#standard deviation: 0.0397398442669319
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # New priority rule: prioritize spins that have the same value as their neighbors
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], J[1,(i//N+1)%N,i%N, (i//N//N)%N], J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if site_nbrs.count(J[0,(i//N)%N,i%N, (i//N//N)%N]) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], J[1,(i//N+1)%N,i%N, (i//N//N)%N], J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.41461020000000004}
#standard deviation: 0.04315232109585764
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if all(val < 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        elif any(val > 0 for val in interacting_spins):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0027982000000000003}
#standard deviation: 0.04696454276110862
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if site_nbrs.count(0) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    elif site_nbrs.count(1) > 0:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      if h[(i//N)%N,(i%N)][(i//N//N)%N] > 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.30956340000000004}
#standard deviation: 0.04673236031317057
#island_id: 2
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        # New addition: Consider the interaction between neighboring sites and adjust the priority accordingly
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.4712014000000002}
#standard deviation: 0.044354917179947474
#island_id: 2
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin

        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin

        # New addition: Adjust the priority based on the magnetization at each site
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28724860000000024}
#standard deviation: 0.043523586226780514
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2607814000000004}
#standard deviation: 0.04534254970819352
#island_id: 3
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 1
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

    return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
          J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
          J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]

    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.39115140000000004}
#standard deviation: 0.0510151538078638
#island_id: 0
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1233586}
#standard deviation: 0.060012072835721984
#island_id: 0
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.45503580000000005}
#standard deviation: 0.042874552340053655
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.0688006}
#standard deviation: 0.04755855295990406
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    neighbor_site_nbr = ((i // N**2) % N + ((i // N - 1) % 2 - 1)) % N
    if h[neighbor_site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.03962179999999999}
#standard deviation: 0.04795258788386712
#island_id: 2
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    site_neighbors = [J[0,i//N%N,(i//N//N)%N,(i%N+1)%N], J[1,(i//N-1)%N%N,(i//N//N)%N,(i%N)%N], J[2,i//N%N,(i//N//N)%N,(i%N+2)%N]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin))
    if sum(val for val in site_neighbors) > 0:
      priorities[i][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
    else:
      priorities[i][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][1] += np.exp(h[site_nbr][i//N%N][(i%N)%N])
    else:
      priorities[i][1] -= h[site_nbr][i//N%N][(i%N)%N]
    
  return(priorities)




#score: {'data3D.txt': -0.14435500000000004}
#standard deviation: 0.04652567135464032
#island_id: 3
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
      else:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
  
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[d,i,j,k] for d in [0,1,2])
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] -= total_spin
      else:
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
        priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.14834780000000003}
#standard deviation: 0.04597185873074961
#island_id: 3
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
      else:
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
        priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
  
  return(priorities)




#score: {'data3D.txt': -0.08725420000000003}
#standard deviation: 0.060796803060358375
#island_id: 3
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
  return(priorities)




#score: {'data3D.txt': -0.1941218}
#standard deviation: 0.09110360083311746
#island_id: 3
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.48257220000000006}
#standard deviation: 0.04416906866982821
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49317660000000013}
#standard deviation: 0.04276040659816041
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48257220000000006}
#standard deviation: 0.04416906866982821
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0031678000000000006}
#standard deviation: 0.047000323862288446
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.004029800000000002}
#standard deviation: 0.04540896862911555
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Added this part to consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.0032089999999999996}
#standard deviation: 0.046996565395781856
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
                 J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
                 J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbr = (i // N ** 2 + ((i % N) - 1) // N) % N
    if h[(i // N) % N][i % N][(i // N // N) % N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.00018500000000000005}
#standard deviation: 0.04628639168265334
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      site_neighbors = [(i+1)%N,(i+N)%N]
      for j in site_neighbors:
        if h[j][i%N][0] > 0:
          priorities[i][0] += J[2,site_nbr,i%N,0]
          break
    else:
      priorities[i][0] -= np.sum([J[d,site_nbr,i%N,0] for d in range(3)]) + np.sum([h[site_nbr][k][0] for k in range(N)])
      site_neighbors = [(i+1)%N,(i+N)%N]
      for j in site_neighbors:
        if h[j][i%N][0] > 0:
          priorities[i][0] -= J[2,site_nbr,i%N,0]
          break
    
  return(priorities)




#score: {'data3D.txt': -0.4816502}
#standard deviation: 0.04188654199095457
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in site_neighbors) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors) < 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.494389}
#standard deviation: 0.042531144341529305
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin = sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[site_nbr][j][k] > 0:
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*sum(J[d,i,j,k] for d in [0,1,2])
        else:
          site_neighbors = [-x for x in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in [0,1,2])))
          priorities[i*N*N+j*N+k][1] = -2 + 2*sum(J[d,i,j,k] for d in [0,1,2])
        
  return(priorities)




#score: {'data3D.txt': 2.5800000000000712e-05}
#standard deviation: 0.0464110445299392
#island_id: 2
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + sum(h[site_nbr][k][0] for k in range(N))
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) + sum([J[d,site_nbr,i%N,0] for d in [1,2]]) * total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) - sum([J[d,site_nbr,i%N,0] for d in [1,2]]) * total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.26788260000000036}
#standard deviation: 0.046236094312128044
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if sum(val for val in interacting_spins) < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.3035622000000003}
#standard deviation: 0.04838116793918888
#island_id: 2
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        magnetism_coeff = np.exp(h[i][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.08725420000000003}
#standard deviation: 0.060796803060358375
#island_id: 3
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()

  return(priorities)




#score: {'data3D.txt': -0.131473}
#standard deviation: 0.07715211980885554
#island_id: 3
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        if J[0,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-J[0,i,j,k])
          priorities[i*N*N+j*N+k][1] -= np.exp(J[0,i,j,k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(J[0,i,j,k])
          priorities[i*N*N+j*N+k][1] += np.exp(-J[0,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.194975}
#standard deviation: 0.07677348015428247
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()

        if h[i][j][k] > 0 and total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(total_spin))
        elif h[i][j][k] < 0 and total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-total_spin))

  return(priorities)




#score: {'data3D.txt': -0.1990334}
#standard deviation: 0.08133915197763007
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        spin_product = h[i][j][k] * total_spin
        if spin_product > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(spin_product))
        elif spin_product < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-spin_product))
        
  return(priorities)




#score: {'data3D.txt': -0.11466820000000007}
#standard deviation: 0.0813434871932597
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.log(np.cosh(total_spin))
        elif h[i][j][k] < 0 and total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= np.log(np.cosh(-total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.45267660000000015}
#standard deviation: 0.0468923628370335
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.45267660000000015}
#standard deviation: 0.0468923628370335
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1580374000000001}
#standard deviation: 0.04667733498433687
#island_id: 3
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -h[site_nbr][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0032089999999999996}
#standard deviation: 0.046996565395781856
#island_id: 1
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
                 J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
                 J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbr = (i // N ** 2 + ((i % N) - 1) // N) % N
    if h[(i // N) % N][i % N][(i // N // N) % N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0032089999999999996}
#standard deviation: 0.046996565395781856
#island_id: 1
#version_generated: 3
#generate time08:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
                 J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
                 J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbr = (i // N ** 2 + ((i % N) - 1) // N) % N
    if h[(i // N) % N][i % N][(i // N // N) % N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2 * total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs + [J[0,site_nbr,i%N,(i//N//N)%N], J[1,site_nbr,i%N,(i//N//N)%N]] if val > 0]) + total_spin
      priorities[i][1] = -2 + 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0017262}
#standard deviation: 0.04682202423603662
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.005098600000000001}
#standard deviation: 0.0447476095231913
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
           J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0030394000000000003}
#standard deviation: 0.047011194492801396
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * sum(1 for val in site_nbrs if val < 0) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * sum(1 for val in site_nbrs if val > 0) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.003773400000000001}
#standard deviation: 0.046165131132056794
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    site_nbrs.sort()
    if all(val < 0 for val in site_nbrs):
      priorities[i][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
      priorities[i][1] -= 2 - 2*total_spin
    elif any(val > 0 for val in site_nbrs):
      priorities[i][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
      priorities[i][1] = -2 + 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.004866999999999999}
#standard deviation: 0.04450849032488072
#island_id: 1
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr_z = J[1,(i//N)%N,(i//N)%N,(i//N//N)%N]
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
      else:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
      else:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
    
  return(priorities)




#score: {'data3D.txt': -0.30956340000000004}
#standard deviation: 0.04673236031317057
#island_id: 2
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin

        # New addition: Consider the interaction between neighboring sites and adjust the priority accordingly
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin

        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.09359620000000003}
#standard deviation: 0.04658188087185832
#island_id: 2
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        # New addition: Consider the magnetization at each site and adjust the priority accordingly
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        
        # New addition: Consider the interaction between neighboring sites and adjust the priority accordingly
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        # New addition: Adjust the priority based on the interaction between neighboring sites
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.29483260000000006}
#standard deviation: 0.04277614308513567
#island_id: 2
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0044214}
#standard deviation: 0.045143470646816695
#island_id: 1
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins = site_nbrs_x + site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= len([val for val in interacting_spins if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.12493620000000012}
#standard deviation: 0.04565511898527919
#island_id: 1
#version_generated: 3
#generate time08:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        interacting_spins_y = [J[2,i,j,(k+1)%N], J[0,i,j,(k-1)%N]]
        
        total_spin_x = sum(J[d,i,(j+1)%N,k] for d in [0, 1])
        total_spin_y = sum(J[d,i,j,(k+1)%N] for d in [2, 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins_x + interacting_spins_y if val < 0]) + total_spin_x + total_spin_y
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_x - 2*total_spin_y
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins_x + interacting_spins_y if val > 0]) + total_spin_x + total_spin_y
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_x + 2*total_spin_y
        
  return(priorities)




#score: {'data3D.txt': -0.0047745999999999995}
#standard deviation: 0.045422568342620165
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbrs_z = [J[1,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,(i//N)%N, (i//N//N)%N]]
    
    total_spin_z = sum(J[d,(i//N)%N,(i//N)%N, (i//N//N)%N] for d in [1])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbrs_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

    site_nbrs_z = [J[3,(i//N)%N,i%N, (i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    interacting_spins_z = [val for val in site_nbrs_z if val < 0]

    priorities[i][0] += np.exp(-abs(sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3]))) * len(interacting_spins_z) + sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3])
    priorities[i][1] -= 2 - 2*sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': 0.0010354000000000001}
#standard deviation: 0.045692569930350826
#island_id: 1
#version_generated: 3
#generate time08:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
    site_nbr = (i//N)%N
    if h[site_nbr,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 - 2*total_spin_x
      
      priorities[i][0] = -np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 - 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.1476542}
#standard deviation: 0.09295196298282248
#island_id: 3
#version_generated: 3
#generate time08:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i].sum() > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val < 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] -= 2 - 2*h[i].sum()
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(h[i].sum())) * len([val for val in site_neighbors if val > 0]) + h[i].sum()
          priorities[i*N*N+j*N+k][1] = -2 + 2*h[i].sum()
        
  return(priorities)




#score: {'data3D.txt': -0.32505900000000015}
#standard deviation: 0.04707586301917363
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5036462}
#standard deviation: 0.04119095125825573
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        total_magnetism = sum(h[s][t][k] for s in range(N) for t in range(N))
        priority_total = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][0] += priority_total
        
  return(priorities)




#score: {'data3D.txt': -0.04739100000000011}
#standard deviation: 0.05016405524875357
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.12872900000000015}
#standard deviation: 0.04976944804797418
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        for d in [0,1]:
          if magnetism > 0:
            priorities[i*N*N+j*N+k][d] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][d] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
        
        for d in [0,1]:
          for k_ in range(3):
            site = (i + ((k_-1)%2 - 1)) % N
            interacting_sites = [J[0,i,j,k_], J[1,(i+1)%N,j,k_], J[2,i,(j+1)%N,k_]]
            
            if magnetism > 0:
              priorities[i*N*N+j*N+k][d] += np.exp(-abs(total_spin)) * len([val for val in interacting_sites + interacting_spins if val < 0]) - total_spin
            else:
              priorities[i*N*N+j*N+k][d] -= np.exp(abs(total_spin)) * len([val for val in interacting_sites + interacting_spins if val > 0]) - total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.11432100000000037}
#standard deviation: 0.04758921179216987
#island_id: 3
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
        # Add the bias term
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 2 - total_spin
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - total_spin
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.003139}
#standard deviation: 0.04700711519546802
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    return(priorities)




#score: {'data3D.txt': -0.002924200000000001}
#standard deviation: 0.047102411555673025
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    return(priorities)




#score: {'data3D.txt': -0.0044802}
#standard deviation: 0.04508262024283859
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * sum(1 for val in interacting_spins_x if val < 0) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * sum(1 for val in interacting_spins_y if val < 0) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * sum(1 for val in interacting_spins_x if val > 0) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * sum(1 for val in interacting_spins_y if val > 0) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.004521000000000001}
#standard deviation: 0.04541866619573939
#island_id: 1
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += sum(1 for val in interacting_spins_x + interacting_spins_y if val < 0) + total_spin_x + total_spin_y
      priorities[i][1] -= 2 - 2*(total_spin_x + total_spin_y)
    else:
      priorities[i][0] -= sum(1 for val in interacting_spins_x + interacting_spins_y if val > 0) + total_spin_x + total_spin_y
      priorities[i][1] = -2 + 2*(total_spin_x + total_spin_y)
  
  return(priorities)




#score: {'data3D.txt': -0.215261}
#standard deviation: 0.047827678168608605
#island_id: 0
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_avg = (h[site_nbr][j][k] + h[(i+1)%N,j,k] + h[i,(j+1)%N,k] +
              h[(i-1)%N,j,k] + h[i,(j-1)%N,k] + h[i,j,(k-1)%N]) / 6
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(site_avg))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_avg
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_avg))
          priorities[i*N*N+j*N+k][1] = -2 + 2*site_avg
        
  return(priorities)




#score: {'data3D.txt': -0.1343518}
#standard deviation: 0.05162814306906651
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] += 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.241393}
#standard deviation: 0.05864106676212499
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        avg_neighbor_spin = sum(J[d,site_nbr,j,k] for d in range(6)) / 6
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(avg_neighbor_spin))
        priorities[i*N*N+j*N+k][1] -= 2 - 2*avg_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1233586}
#standard deviation: 0.060012072835721984
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i-1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(6):
          if J[d,site_nbr,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.004691400000000001}
#standard deviation: 0.04484690586919013
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins_x + interacting_spins_y if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
    
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= len([val for val in interacting_spins_x + interacting_spins_y if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.005151000000000001}
#standard deviation: 0.04530891434364766
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0044802}
#standard deviation: 0.04508262024283859
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': 0.002951799999999999}
#standard deviation: 0.04773568850200026
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      total_spin = np.sum([J[d,site_nbr,i%N,0] for d in range(3)])
      interacting_spins = [J[0,site_nbr,i%N,0], J[1,(site_nbr+1)%N,i%N,0], J[2,site_nbr,(i%N+1)%N,0]]
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= h[site_nbr][i%N][0]
    else:
      total_spin = -np.sum([J[d,site_nbr,i%N,0] for d in range(3)])
      interacting_spins = [J[0,site_nbr,i%N,0], J[1,(site_nbr+1)%N,i%N,0], J[2,site_nbr,(i%N+1)%N,0]]
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] += h[site_nbr][i%N][0]

  return(priorities)




#score: {'data3D.txt': -0.0004938000000000004}
#standard deviation: 0.046197412498537184
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + h[site_nbr][i%N][0]
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val > 0]) + total_spin
      priorities[i][1] += 2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.004866999999999999}
#standard deviation: 0.04450849032488072
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr_z = J[1,(i//N)%N,(i//N)%N,(i//N//N)%N]
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
      else:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
      else:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
  
  return(priorities)




#score: {'data3D.txt': -0.004866999999999999}
#standard deviation: 0.04450849032488072
#island_id: 1
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr_z = J[1,(i//N)%N,(i//N)%N,(i//N//N)%N]
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
      else:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      if site_nbr_z > 0:
        priorities[i][0] -= np.exp(abs(site_nbr_z))
        priorities[i][1] = -2 + 2*site_nbr_z
      else:
        priorities[i][0] += np.exp(-abs(site_nbr_z))
        priorities[i][1] -= 2 - 2*site_nbr_z
  
  return(priorities)




#score: {'data3D.txt': -0.3438390000000002}
#standard deviation: 0.04750840724545498
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
        # add magnetism coefficient to each term
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.22691460000000035}
#standard deviation: 0.04758617726651299
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_nbr + sum(h[site_nbr][i%N][k] for i in range(N))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          if sum(val for val in site_neighbors) > 0:
            priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * len([val for val in site_neighbors if val < 0]) + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * len([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3658178000000003}
#standard deviation: 0.04881379521364836
#island_id: 2
#version_generated: 3
#generate time09:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(1 for val in site_neighbors if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        
        magnetism_coeff = np.exp(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.0027298}
#standard deviation: 0.04686065121143751
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + h[site_nbr][i%N][0]
    
    interacting_spins = [J[0,site_nbr,i%N,0], J[1,(site_nbr+1)%N,i%N,0], J[2,site_nbr,(i%N+1)%N,0]]
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
      priorities[i][1] += 2 - 2*total_spin
    
    return(priorities)




#score: {'data3D.txt': 0.0019970000000000005}
#standard deviation: 0.047906044201123515
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,site_nbr,i%N,0] for d in [0,1,2]) + h[site_nbr][i%N][0]

    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:,site_nbr,i%N,0] if val > 0]) + total_spin
      priorities[i][1] += 2 - 2*total_spin

    site_neighbors = [J[0,site_nbr,i%N,0], J[1,(i+1)%N,site_nbr,0], J[2,site_nbr,(i+2)%N,0]]
    priorities[i][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors if val < 0) > sum(val for val in [J[d,site_nbr,i%N,0] for d in [0,1,2]] if val < 0))
    priorities[i][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0005434000000000001}
#standard deviation: 0.04614171080963514
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,site_nbr,i%N,0] for d in [0,1,2]]
    total_spin = sum(interacting_spins) + h[site_nbr][i%N][0]
    
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
      priorities[i][1] += 2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0005434000000000001}
#standard deviation: 0.04614171080963514
#island_id: 2
#version_generated: 3
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,site_nbr,i%N,0] for d in [0,1,2]]
    total_spin = sum(interacting_spins) + h[site_nbr][i%N][0]

    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
      priorities[i][1] += 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.2943918000000002}
#standard deviation: 0.049333661254360575
#island_id: 3
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
        
  return priorities




#score: {'data3D.txt': -0.33196979999999965}
#standard deviation: 0.04521094743488571
#island_id: 3
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbor_spin = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*site_neighbor_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2*total_spin
          
          site_neighbor_spin = sum(val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]])
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val > 0]) + site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2*site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5207554}
#standard deviation: 0.0403781689882045
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr_neighbors = [J[0,site_nbr,(j+1)%N,k], J[1,(i+1)%N,site_nbr,k], J[2,i,site_nbr,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k]) * len([val for val in site_nbr_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.19654980000000014}
#standard deviation: 0.04875886544988509
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          for d in [0,1,2]:
            site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k], J[d,i,j,(k+1)%N]]
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            
            if h[site_nbr][j][k] < 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] += h[site_nbr][j][k]
            else:
              priorities[i*N*N+j*N+k][0] += np.exp(h[site_nbr][j][k])
              priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5186118000000001}
#standard deviation: 0.04155245432895631
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.3718922000000001}
#standard deviation: 0.04985959024260027
#island_id: 0
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
        priorities[i*N*N+j*N+k][0] += h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][1] -= h[site_nbr][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0485186}
#standard deviation: 0.0503486164064118
#island_id: 2
#version_generated: 3
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if h[(i % N + ((i//N-1)%2 - 1)) % N][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0475058}
#standard deviation: 0.048061840646816685
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Additional term to favor spins that align with the magnetism
    priorities[i][0] += np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] > 0)
    priorities[i][1] -= np.abs(h[site_nbr][i//N%N][(i%N)%N]) * (h[site_nbr][i//N%N][(i%N)%N] < 0)
  
  return(priorities)




#score: {'data3D.txt': -0.030189}
#standard deviation: 0.04785200767992917
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    if sum(val for val in interacting_spins) < 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0369818}
#standard deviation: 0.047034913295976206
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin * sum(val for val in interacting_spins)
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin * sum(val for val in interacting_spins)
      priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.03962179999999999}
#standard deviation: 0.04795258788386712
#island_id: 2
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    site_neighbors = [J[0,i//N%N,(i//N//N)%N,(i%N+1)%N], J[1,(i//N-1)%N%N,(i//N//N)%N,(i%N)%N], J[2,i//N%N,(i//N//N)%N,(i%N+2)%N]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin))
    if sum(val for val in site_neighbors) > 0:
      priorities[i][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
    else:
      priorities[i][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
    
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][1] += np.exp(h[site_nbr][i//N%N][(i%N)%N])
    else:
      priorities[i][1] -= h[site_nbr][i//N%N][(i%N)%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0354162}
#standard deviation: 0.04709596264606977
#island_id: 2
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    interacting_spins = [J[0,i//N%N,(i//N//N)%N,(i%N)%N], 
               J[1,(i//N-1)%N%N,(i//N//N)%N,(i%N)%N], 
               J[2,i//N%N,(i//N//N)%N,(i+2)%N]]
    total_spin = sum(J[d,i//N%N,(i//N//N)%N,(i%N)%N] for d in [0,1,2])
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][(i%N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    site_neighbors = [J[0,(i//N-1)%N%N,(i//N//N)%N,(i+1)%N], 
              J[1,i//N%N,(i//N//N)%N,(i+2)%N]]
    neighbor_magnetism_coeff = np.exp(-abs(total_spin))
    if sum(val for val in site_neighbors) > 0:
      priorities[i][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
    else:
      priorities[i][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
    
    magnetism_coeff = np.exp(h[site_nbr][i//N%N][(i%N)%N])
    priorities[i][1] += magnetism_coeff
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i//N%N][(i%N)%N]
    
    if total_spin > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = -1
    
    for d in range(3):
      site_neighbors = [J[d,site_nbr,(i//N//N)%N,(i%N)%N], J[d,(site_nbr+1)%N,i//N//N,(i%N)%N], J[d,site_nbr,(i//N//N)%N,(i%N+1)%N]]
      magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in site_neighbors if val < 0]) > len([val for val in [J[d,site_nbr,i//N//N,(i%N)%N] for d in range(3)] if val < 0])))
      priorities[i][0] += magnetism_coeff + total_spin
      priorities[i][1] -= magnetism_coeff - total_spin
    
    priorities[i][0] += np.exp(h[site_nbr][i//N%N][(i%N)%N])
    priorities[i][1] -= h[site_nbr][i//N%N][(i%N)%N]
  
  return(priorities)




#score: {'data3D.txt': -0.0045238000000000006}
#standard deviation: 0.04698863174811542
#island_id: 1
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x

      if interacting_spins_y: 
        priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
        priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x

      if interacting_spins_y: 
        priorities[i][0] -= np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
        priorities[i][1] = -2 + 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.0020429999999999992}
#standard deviation: 0.045967561073000165
#island_id: 1
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin = -1
    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priority_spin = 1

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y

    if priority_spin == 1:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] = 1

  return(priorities)




#score: {'data3D.txt': -0.09304580000000014}
#standard deviation: 0.05189621048169125
#island_id: 3
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_site_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(J[d,i,j,k]))
            priorities[i*N*N+j*N+k][1] -= np.exp(np.abs(J[d,i,j,k]))
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(np.abs(J[d,i,j,k]))
            priorities[i*N*N+j*N+k][1] += np.exp(-np.abs(J[d,i,j,k]))
  
  return priorities




#score: {'data3D.txt': -0.04739100000000011}
#standard deviation: 0.05016405524875357
#island_id: 3
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
  
  return(priorities)




#score: {'data3D.txt': -0.1123462}
#standard deviation: 0.052688832455844
#island_id: 3
#version_generated: 3
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_site_neighbor_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= np.exp(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += np.exp(-J[d,i,j,k])
        
  return(priorities)




#score: {'data3D.txt': -0.29367899999999997}
#standard deviation: 0.04549847952404563
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.24160420000000035}
#standard deviation: 0.04511871742813618
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        magnetism = h[i][j][k]
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*magnetism) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2*magnetism - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-2*abs(magnetism)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2*abs(magnetism) - 2*total_spin
  
  return priorities




#score: {'data3D.txt': -0.29367899999999997}
#standard deviation: 0.04549847952404563
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.32221939999999977}
#standard deviation: 0.04463019587274965
#island_id: 3
#version_generated: 3
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2*h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(2*h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2*h[i][j][k]
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 2*J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] = -2*J[d,i,j,k]
  
  return(priorities)




#score: {'data3D.txt': -0.002924200000000001}
#standard deviation: 0.047102411555673025
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
    return(priorities)




#score: {'data3D.txt': -0.0050777999999999995}
#standard deviation: 0.046963743325676245
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    interacting_spins_x = site_nbrs_x
    interacting_spins_y = site_nbrs_y
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(h[(i//N)%N,i%N,(i//N//N)%N])
      priorities[i][1] -= h[(i//N)%N,i%N,(i//N//N)%N]
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= h[(i//N)%N,i%N,(i//N//N)%N]
      priorities[i][1] = 2 - 2*h[(i//N)%N,i%N,(i//N//N)%N]
  
  return priorities




#score: {'data3D.txt': -0.22938100000000036}
#standard deviation: 0.04736858873768565
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin_x = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbrs_y = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin_y = sum(J[d,i,(j+1)%N,k] for d in [0,2])
        
        site_nbrs_z = [J[0,i,(j+1)%N,(k+1)%N], J[1,(i+1)%N,j,(k+1)%N], J[2,i,(j+1)%N,(k+1)%N]]
        total_spin_z = sum(J[d,i,(j+1)%N,(k+1)%N] for d in [0,2])
        
        interacting_spins_y = site_nbrs_y
        interacting_spins_z = site_nbrs_z
        
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin_x
          
          priorities[i*N**2+j*N+k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin_y
          
          priorities[i*N**2+j*N+k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) + total_spin_z
          priorities[i*N**2+j*N+k][1] -= 2 - 2*total_spin_z
          
        else:
          priorities[i*N**2+j*N+k][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin_x
          
          priorities[i*N**2+j*N+k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin_y
          
          priorities[i*N**2+j*N+k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) + total_spin_z
          priorities[i*N**2+j*N+k][1] = -2 + 2*total_spin_z
  
  return priorities




#score: {'data3D.txt': -0.13267500000000007}
#standard deviation: 0.045328509516638645
#island_id: 1
#version_generated: 3
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [J[0,(i+((k-1)%2 - 1))%N,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbrs_y = [J[d, (i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1]]
        
        total_spin_x = sum(val for val in site_nbrs_x if val < 0) - len([val for val in site_nbrs_x if val > 0])
        total_spin_y = sum(J[d,(i + ((k-1)%2 - 1)) % N, j, k] for d in [0, 1]) - sum(J[d,i,j,k] for d in [0, 1, 2])
        
        interacting_spins_x = site_nbrs_x
        interacting_spins_y = site_nbrs_y
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_x
        
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin_y
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_x
        
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) + total_spin_y
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 0
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4721686}
#standard deviation: 0.043530618351224924
#island_id: 0
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          total_spin -= h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4721686}
#standard deviation: 0.043530618351224924
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          total_spin -= h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4721686}
#standard deviation: 0.043530618351224924
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          total_spin -= h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3030058}
#standard deviation: 0.04656857831585585
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.484327}
#standard deviation: 0.04463422981300339
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        # symmetry: flip sign and site nbrs for flipped spin
        flipped_site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.43279819999999997}
#standard deviation: 0.045226780968359886
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          
          # Add the interaction with site's neighbors
          site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.475359}
#standard deviation: 0.04256788412641624
#island_id: 0
#version_generated: 3
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.5290678000000001}
#standard deviation: 0.040797563691475504
#island_id: 2
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0]))
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4586318000000001}
#standard deviation: 0.042015511287618525
#island_id: 2
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val < 0]) > np.sum([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val > 0]) > np.sum([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[d,i,(j+1)%N,k] for d in range(6)] + [J[d,i,j,(k+1)%N] for d in range(6)]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if np.sum([val for val in site_neighbors]) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (np.sum([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (np.sum([val for val in site_neighbors if val > 0]) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4936030000000001}
#standard deviation: 0.04195864381745435
#island_id: 2
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k]) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.46080100000000007}
#standard deviation: 0.041150725376352726
#island_id: 2
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.13033659999999997}
#standard deviation: 0.04796040638318237
#island_id: 2
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        # New approach: use a more sophisticated magnetization coefficient
        magnetization_coeff = np.exp(-abs(total_spin))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetization_coeff * (sum(val for val in interacting_spins if val < 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetization_coeff * (sum(val for val in interacting_spins if val > 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.29483260000000006}
#standard deviation: 0.04277614308513567
#island_id: 2
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin))
        if sum(val for val in site_neighbors) > 0:
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val < 0) > len([val for val in interacting_spins if val < 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (sum(val for val in site_neighbors if val > 0) < len([val for val in interacting_spins if val > 0])) - total_spin
        
        site_neighbors_mag = [h[(i+1)%N][j][k], h[i][(j+1)%N][k], h[i][j][(k+1)%N]]
        if sum(val for val in site_neighbors_mag) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val > 0) > len([val for val in interacting_spins if val > 0])) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (sum(val for val in site_neighbors_mag if val < 0) < len([val for val in interacting_spins if val < 0])) - total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.003480200000000001}
#standard deviation: 0.045505616444126984
#island_id: 1
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  # Consider all neighbors and add a new rule to prioritize spins that have the same value as their neighbors
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if site_nbrs.count(0) > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0050658}
#standard deviation: 0.04635333720844703
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin

    # Added this part to consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d,site,i%N,(i//N//N)%N] for d in range(3)] if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d,site,i%N,(i//N//N)%N] for d in range(3)] if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0024394000000000004}
#standard deviation: 0.04473272636046231
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] -= 2 - 2*total_spin
    else:
      priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    
    # Consider all neighbors
    for k in range(3):
      site = (i//N + ((k-1)%2 - 1)) % N
      if h[site,(i%N),(i//N//N)%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Prioritize spins that have the same value as their neighbors
    for d in [0,1,2]:
      site_nbr = (i//N + ((d-1)%2 - 1)) % N
      if J[d,site_nbr,i%N,(i//N//N)%N] < 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0028174000000000007}
#standard deviation: 0.0442928072856079
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0, 2])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [1, 0])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.0044802}
#standard deviation: 0.04508262024283859
#island_id: 1
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x

      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x

      priorities[i][0] -= np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y

  return(priorities)




#score: {'data3D.txt': -0.5386842000000001}
#standard deviation: 0.039862838714271216
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5225534000000001}
#standard deviation: 0.04006656796432657
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31238020000000005}
#standard deviation: 0.05059511170024235
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors) + np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*np.exp(h[site_nbr][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors) - np.exp(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + 2*np.exp(h[site_nbr][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.153085}
#standard deviation: 0.05030878427272915
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in range(3):
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38314420000000005}
#standard deviation: 0.04371125857670997
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        magnetism_coeff = np.exp(h[site_nbr][j][k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff
        
  return(priorities)




#score: {'data3D.txt': -0.4497454000000001}
#standard deviation: 0.04697509743300167
#island_id: 2
#version_generated: 3
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,(j+1)%N,k] for d in [0,1,2]) + sum(J[d,(i+1)%N,j,k] for d in [0,1,2]) + sum(J[d,i,j,(k+1)%N] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4164538}
#standard deviation: 0.047073735623593765
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - np.sum(np.sign(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum(val for val in interacting_spins) / 3
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + np.sum(np.sign(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.4524514000000002}
#standard deviation: 0.04712465721933688
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5106421999999999}
#standard deviation: 0.04042277005797599
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5225534000000001}
#standard deviation: 0.04006656796432657
#island_id: 3
#version_generated: 3
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0017262}
#standard deviation: 0.04682202423603662
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -2.819999999999945e-05}
#standard deviation: 0.047768745898966194
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
    # Calculate the priority based on the magnetism at each site
    priorities[i][0] += np.exp(-abs(h[(i//N)%N,i%N,(i//N//N)%N])) * len([val for val in [h[(i//N)%N,i%N,0], h[(i//N-1)%N,i%N, (i//N//N-1)%N]] if val > 0]) + sum(h[(i//N)%N,i%N,k] for k in range(N))
    priorities[i][1] -= 2 - 2*sum(h[(i//N)%N,i%N,k] for k in range(N))
    
  return(priorities)




#score: {'data3D.txt': -0.0017262}
#standard deviation: 0.04682202423603662
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0017301999999999994}
#standard deviation: 0.0469609570596682
#island_id: 1
#version_generated: 3
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
           J[1,(i//N+1)%N,i%N, (i//N//N)%N], 
           J[2,(i//N)%N,(i//N)%N,(i//N//N)%N]]
    total_spin = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0,1,2])
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] = np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
      priorities[i][1] = -2 + 2*total_spin
    else:
      priorities[i][0] = -np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
      priorities[i][1] = -2 - 2*total_spin
    
    neighbor_sites = [(i//N)%N, ((i//N+1)%N), (i//N)//N]
    if all(x == y for x, y in zip(neighbor_sites, [0,1,2])):
      if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
        priorities[i][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
        priorities[i][1] -= 2 - 2*total_spin
      else:
        priorities[i][0] -= np.exp(abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
        priorities[i][1] = -2 + 2*total_spin
    
  return(priorities)




#score: {'data3D.txt': 0.0010354000000000001}
#standard deviation: 0.045692569930350826
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
        J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
        J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priorities[i][1] -= 2 - 2*total_spin_x

    priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
    priorities[i][1] -= 2 - 2*total_spin_y
    
    site_nbr = (i//N)%N
    if h[site_nbr,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 - 2*total_spin_x
      
      priorities[i][0] = -np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 - 2*total_spin_y
    
    # added new term to take into account of magnetism
    if h[site_nbr,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
    else:
      priorities[i][0] = -np.exp(abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 - 2*total_spin_x
      
      priorities[i][0] = -np.exp(abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 - 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.0050777999999999995}
#standard deviation: 0.046963743325676245
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_total_spin = np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priority_non_interacting_spin_x = -2 + 2*total_spin_x

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += priority_total_spin + priority_non_interacting_spin_x
      priorities[i][1] -= 4 - 2*(priority_total_spin + priority_non_interacting_spin_x)
    else:
      priorities[i][0] -= priority_total_spin + priority_non_interacting_spin_x
      priorities[i][1] = 4 - 2*(priority_total_spin + priority_non_interacting_spin_x)

  return(priorities)




#score: {'data3D.txt': -0.0035594000000000008}
#standard deviation: 0.045283246257749675
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_total_spin_x = total_spin_x
    priority_total_spin_y = total_spin_y

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(priority_total_spin_x)) * len(interacting_spins_x) + priority_total_spin_x
      priorities[i][1] -= 2 - 2*priority_total_spin_x

      if interacting_spins_y: 
        priorities[i][0] += np.exp(-abs(priority_total_spin_y)) * len(interacting_spins_y) + priority_total_spin_y
        priorities[i][1] -= 2 - 2*priorities[i][0]
    else:
      priorities[i][0] -= np.exp(-abs(priority_total_spin_x)) * len(interacting_spins_x) + priority_total_spin_x
      priorities[i][1] = -2 + 2*priority_total_spin_x

      if interacting_spins_y: 
        priorities[i][0] -= np.exp(-abs(priority_total_spin_y)) * len(interacting_spins_y) + priority_total_spin_y
        priorities[i][1] = -2 + 2*priorities[i][0]

  return(priorities)




#score: {'data3D.txt': -0.001959}
#standard deviation: 0.04720936558565472
#island_id: 1
#version_generated: 3
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]

    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])

    interacting_spins_x = [val for val in site_nbrs_x if val < 0]
    interacting_spins_y = [val for val in site_nbrs_y if val < 0]

    priority_spin_x = np.exp(-abs(total_spin_x)) * len(interacting_spins_x) + total_spin_x
    priority_spin_y = np.exp(-abs(total_spin_y)) * len(interacting_spins_y) + total_spin_y

    if h[(i//N)%N][i%N][(i//N//N)%N] > 0:
      priorities[i][0] += priority_spin_x + priority_spin_y
      priorities[i][1] -= 2 - 2*(priority_spin_x + priority_spin_y)
    else:
      priorities[i][0] -= priority_spin_x + priority_spin_y
      priorities[i][1] = -2 + 2*(priority_spin_x + priority_spin_y)

  return(priorities)




#score: {'data3D.txt': -0.006829}
#standard deviation: 0.046681784873759916
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbr_z = [J[3,(i//N)%N,(i//N)%N,(i//N//N)%N], 
           J[4,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    total_spin_z = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [3, 4])
    
    site_neighbors = [site_nbrs_x[0], site_nbrs_y[0], site_nbr_z[0]]
    site_neighbors.sort()
    
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_neighbors if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
      
      priorities[i][0] += np.exp(-abs(total_spin_z)) * len([val for val in site_nbr_z if val < 0]) + total_spin_z
      priorities[i][1] -= 2 - 2*total_spin_z
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_neighbors if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
      
      priorities[i][0] -= np.exp(-abs(total_spin_z)) * len([val for val in site_nbr_z if val > 0]) + total_spin_z
      priorities[i][1] = -2 + 2*total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.005098600000000001}
#standard deviation: 0.0447476095231913
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs_x = [J[0,(i//N)%N,i%N, (i//N//N)%N], 
            J[1,(i//N+1)%N,i%N, (i//N//N)%N]]
    site_nbrs_y = [J[2,(i//N)%N,(i//N)%N,(i//N//N)%N], 
            J[0,(i//N+1)%N,i%N, (i//N//N)%N]]
    
    total_spin_x = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [0])
    total_spin_y = sum(J[d,(i//N)%N,i%N, (i//N//N)%N] for d in [2])
    
    site_nbr = ((i//N+N-1)%N) + ((i%N+N-1)%N*N + (i//N//N))
    if h[(i//N)%N,i%N,(i//N//N)%N] > 0:
      priorities[i][0] += np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val < 0]) + total_spin_x
      priorities[i][1] -= 2 - 2*total_spin_x
      
      priorities[i][0] += np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val < 0]) + total_spin_y
      priorities[i][1] -= 2 - 2*total_spin_y
    else:
      priorities[i][0] -= np.exp(-abs(total_spin_x)) * len([val for val in site_nbrs_x if val > 0]) + total_spin_x
      priorities[i][1] = -2 + 2*total_spin_x
      
      priorities[i][0] -= np.exp(-abs(total_spin_y)) * len([val for val in site_nbrs_y if val > 0]) + total_spin_y
      priorities[i][1] = -2 + 2*total_spin_y
    
  return(priorities)




#score: {'data3D.txt': -0.5106421999999999}
#standard deviation: 0.04042277005797599
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_center if val < 0]) + sum(val for val in site_center)
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5276417999999999}
#standard deviation: 0.041633278669352965
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_center = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        site_nbr_spin = sum(val for val in interacting_spins)
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5067654000000001}
#standard deviation: 0.04245578267845265
#island_id: 3
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)




