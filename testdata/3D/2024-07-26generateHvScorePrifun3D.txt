#score: {'data3D.txt': -0.3749574}
#standard deviation: 0.051588973872718186
#island_id: 2
#version_generated: 3
#generate time00:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_0 = [J[0, i, j, k] for j in range(N)]
        site_neighbors_1 = [J[1, i, j, k] for j in range(N)]
        site_neighbors_2 = [J[2, i, j, k] for j in range(N)]
        
        site_neighbors = [val for sublist in [site_neighbors_0, site_neighbors_1, site_neighbors_2] for val in sublist]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.1314685999999998}
#standard deviation: 0.044289424178239216
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.4701862}
#standard deviation: 0.04759571923566236
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the priority based on the magnetism and interaction
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the priority based on the magnetism and interaction
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0706290000000003}
#standard deviation: 0.0488853581249028
#island_id: 3
#version_generated: 3
#generate time00:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(interacting_spins)
        
        site_nbr_spin = J[2, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * (site_nbr_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (site_nbr_spin < 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * (site_nbr_spin > 0)
          priorities[i * N * N + j * N + k][1] += (site_nbr_spin > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0012073999999999993}
#standard deviation: 0.04716164103633376
#island_id: 0
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i * N * N + j * N + k][0] > 0:
          priorities[i * N * N + j * N + k][1] = np.sign(priorities[i * N * N + j * N + k][0])
        elif priorities[i * N * N + j * N + k][0] < 0:
          priorities[i * N * N + j * N + k][1] = -np.sign(priorities[i * N * N + j * N + k][0])

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i * N * N + j * N + k][0] > 0:
          priorities[i * N * N + j * N + k][1] = np.tanh(priorities[i * N * N + j * N + k][0])
        elif priorities[i * N * N + j * N + k][0] < 0:
          priorities[i * N * N + j * N + k][1] = -np.tanh(-priorities[i * N * N + j * N + k][0])

  return(priorities)




#score: {'data3D.txt': -0.20687339999999999}
#standard deviation: 0.06260658377870494
#island_id: 0
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 if total_spin > 0 else -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 if total_spin < 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': 0.0013369999999999996}
#standard deviation: 0.048927208698228426
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] * interacting_spins[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [0, 1, 2, 4, 5])
    
    if h[(i//N**(2))%N][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = np.tanh(total_spin)
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    if h[(i//N**(2))%N][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.002245}
#standard deviation: 0.049341832302823935
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] * interacting_spins[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [0, 1, 2, 4, 5])
    
    if h[(i//N**(2))%N][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5247178000000001}
#standard deviation: 0.042473051257944726
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 2
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.062881}
#standard deviation: 0.044281961553210354
#island_id: 2
#version_generated: 2
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5496554}
#standard deviation: 0.04128540772282624
#island_id: 2
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5189649999999999}
#standard deviation: 0.045262791065068
#island_id: 2
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    
  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
  
  return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0153366}
#standard deviation: 0.047071787096306425
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.0064118}
#standard deviation: 0.05048127713083337
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin) * (h[i][j][k] - sum(J[d, i, j, k] for d in range(6)))
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin) * (h[i][j][k] + sum(J[d, i, j, k] for d in range(6)))
        
  return(priorities)




#score: {'data3D.txt': 0.0002906000000000004}
#standard deviation: 0.04368430555290996
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2]) - sum(J[d, i, j, k] * (d-1) for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.0010045999999999992}
#standard deviation: 0.04612708378859431
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  interacting_spins_sum = np.zeros((6, N, N, N))
  for i in range(6):
    interacting_spins_sum[i] = np.sum(interacting_spins[i], axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins_sum[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.5295082}
#standard deviation: 0.040842448662635304
#island_id: 1
#version_generated: 2
#generate time00:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_neighbors = list(set([site_nbr, i, (i + 1) % N]))
        for d in [0, 1]:
          if site_neighbors[d] == i:
            neighbor_spin = J[1 - d, site_neighbors[1], j, k]
          elif site_neighbors[d] == i - 1:
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, site_neighbors[0], j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.129493}
#standard deviation: 0.046868944419519415
#island_id: 1
#version_generated: 2
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 2
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 1
#version_generated: 2
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.0006077999999999999}
#standard deviation: 0.04719900485349241
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, (j-1)%N, k] * d + J[d, i, j, (k-1)%N] * h[i][j][k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i-((i//N)**2)%N, (j+i//N)%N, (k+(k//N)**2)%N] * interacting_spins[d, i, j, k] 
                    for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4150462}
#standard deviation: 0.04090896412230454
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(1 for val in site_neighbors if val < 0) - sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (interacting_spins - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, site_nbr, j, k]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4140146}
#standard deviation: 0.04240176678913273
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + ((k - 1) % 2 - 1)) % N, (j + ((k - 1) % 2 - 1)) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [(i + (k + 1) % N), (j + (k + 1) % N)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5295082}
#standard deviation: 0.040842448662635304
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_neighbors = list(set([site_nbr, i, (i + 1) % N]))
        for d in [0, 1]:
          if site_neighbors[d] == i:
            neighbor_spin = J[1 - d, site_neighbors[1], j, k]
          elif site_neighbors[d] == i - 1:
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, site_neighbors[0], j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5295082}
#standard deviation: 0.040842448662635304
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_neighbors = list(set([site_nbr, i, (i + 1) % N]))
        for d in [0, 1]:
          if site_neighbors[d] == i:
            neighbor_spin = J[1 - d, site_neighbors[1], j, k]
          elif site_neighbors[d] == i - 1:
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, site_neighbors[0], j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.17260019999999998}
#standard deviation: 0.054044328841794304
#island_id: 3
#version_generated: 3
#generate time00:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) - total_spin
        
        # Add a new term based on the interaction with other sites
        site_interactions = [J[0, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0]) - len([val for val in site_interactions if val > 0])
        
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.37802299999999994}
#standard deviation: 0.0460607363271583
#island_id: 1
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37802299999999994}
#standard deviation: 0.0460607363271583
#island_id: 1
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1280838}
#standard deviation: 0.04640639759300435
#island_id: 1
#version_generated: 3
#generate time00:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5272650000000001}
#standard deviation: 0.041248348997262915
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.31657899999999994}
#standard deviation: 0.04467301734828307
#island_id: 3
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == -J[d, (i + 1) % N, j, k]])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == J[d, (i + 1) % N, j, k]])
        
        # Add a new term based on the local energy and interactions with neighboring sites
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.31657899999999994}
#standard deviation: 0.04467301734828307
#island_id: 3
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and interactions with neighboring sites
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == -J[d, (i + 1) % N, j, k]])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == J[d, (i + 1) % N, j, k]])
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors_z = [J[3, i, j, (k + 1) % N], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        interacting_spins_z = [-val for val in site_neighbors_z if val < 0] + [val for val in site_neighbors_z if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins_z)
        priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins_z if val < 0]) > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.010423400000000001}
#standard deviation: 0.04703512105267722
#island_id: 2
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with same spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[0, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[0, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

      return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': 0.025069400000000002}
#standard deviation: 0.04676278716714819
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  # Calculate total spin for each site
  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N)

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          # Calculate priority for spin up
          priority_up = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][0] = -priority_up
          priorities[i * N * N + j * N + k][1] = np.tanh(-priority_up)
        else:
          # Calculate priority for spin down
          priority_down = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][0] = -priority_down
          priorities[i * N * N + j * N + k][1] = np.tanh(priority_down)

  return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.5330114000000001}
#standard deviation: 0.040887107870819145
#island_id: 3
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4855742}
#standard deviation: 0.04055491603196831
#island_id: 3
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the interaction with the current spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in J[2, i, j, :k+1] if val < 0])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.023756199999999998}
#standard deviation: 0.04580084062066983
#island_id: 0
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0045526}
#standard deviation: 0.04540434024672091
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 4
  
  return(priorities)




#score: {'data3D.txt': 0.011507}
#standard deviation: 0.04567926740874902
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 2 * abs(neighbor_spin)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 2 * abs(neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.024069}
#standard deviation: 0.047023646806686525
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 2 * neighbor_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.191995}
#standard deviation: 0.04930154495550824
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 * J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.129493}
#standard deviation: 0.046868944419519415
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.129493}
#standard deviation: 0.046868944419519415
#island_id: 1
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 3
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  priorities = h.flatten() + (J.sum(axis=0).flatten())
  
  return np.array([priorities, np.zeros(N**3)]).T




#score: {'data3D.txt': 0.17260019999999998}
#standard deviation: 0.054044328841794304
#island_id: 3
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) - total_spin
        
        # Add a new term based on the interaction with other sites
        site_interactions = [J[0, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0]) - len([val for val in site_interactions if val > 0])
        
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.0029317999999999996}
#standard deviation: 0.0477089579508922
#island_id: 3
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) - total_spin
        
        # Add a new term based on the interaction with other sites
        site_interactions = [J[0, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0]) - len([val for val in site_interactions if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k]) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return priorities




#score: {'data3D.txt': 0.16299419999999998}
#standard deviation: 0.05337573986709692
#island_id: 3
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Your logic goes here...
  return(priorities)




#score: {'data3D.txt': -0.5038737999999999}
#standard deviation: 0.04469331620678869
#island_id: 3
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.18839499999999998}
#standard deviation: 0.05758404583736714
#island_id: 3
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.05318899999999999}
#standard deviation: 0.047731312982150415
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, ii, jj, kk] for (ii, jj, kk) in [(i, j, l) for l in range(N)] if d == 0 or d == 1) for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0032834}
#standard deviation: 0.04696570881441054
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        return(priorities)




#score: {'data3D.txt': -0.3504334}
#standard deviation: 0.04192085262062307
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.164363}
#standard deviation: 0.04979444176813312
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4291986}
#standard deviation: 0.039209747232544105
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2257922000000004}
#standard deviation: 0.047048094320174115
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2304026}
#standard deviation: 0.038962432588841266
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.555909}
#standard deviation: 0.03988630640959376
#island_id: 0
#version_generated: 2
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 2
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)

        for d in [0, 1]:
          if d == 0:
            site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          else:
            site_neighbors = [J[1 - d, (i - 1) % N, j, k], J[1 - d, i, (j - 1) % N, k], J[1 - d, i, j, (k - 1) % N]]
          interacting_spins.extend(site_neighbors)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4984578}
#standard deviation: 0.041926684333011596
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4273810000000002}
#standard deviation: 0.049854737778871124
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0020558000000000004}
#standard deviation: 0.047048668061487144
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.47650740000000014}
#standard deviation: 0.04487500980768696
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.37315060000000017}
#standard deviation: 0.054157368470412234
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N + j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.1309526000000002}
#standard deviation: 0.040558639440198184
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(h[i, j, k]) - abs(total_spin)
        priorities[i * N * N + j * N + k][1] = -h[i, j, k] - total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5038737999999999}
#standard deviation: 0.04469331620678869
#island_id: 3
#version_generated: 3
#generate time01:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37802299999999994}
#standard deviation: 0.0460607363271583
#island_id: 2
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2498762000000002}
#standard deviation: 0.04480571384946344
#island_id: 1
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
          
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
          
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.08994219999999999}
#standard deviation: 0.052366251528632446
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0025018}
#standard deviation: 0.047245268088561
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        
        if total_spin < 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k]*interacting_spins[d][i][j][k] for d in range(6)] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin

        elif total_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k]*interacting_spins[d][i][j][k] for d in range(6)] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4291986}
#standard deviation: 0.039209747232544105
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Check neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47002059999999996}
#standard deviation: 0.038901265990196256
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5189649999999999}
#standard deviation: 0.045262791065068
#island_id: 2
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.14646019999999996}
#standard deviation: 0.04835199453962578
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif sum(site_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.29731779999999997}
#standard deviation: 0.0445126463284312
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * (1 if d == 0 and i > 0 else -1 if d == 0 and i < N-1 
                           else 1 if d == 1 and j > 0 else -1 if d == 1 and j < N-1 
                           else 1 if d == 2 and k > 0 else -1 if d == 2 and k < N-1 
                           else 0) for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if site_spin * val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin

  return(priorities)




#score: {'data3D.txt': 0.002269}
#standard deviation: 0.04546280852521102
#island_id: 0
#version_generated: 3
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.33942859999999964}
#standard deviation: 0.04452487688966696
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
        else:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.459885}
#standard deviation: 0.044070465563685615
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4181542}
#standard deviation: 0.03989438885808379
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.21624259999999998}
#standard deviation: 0.04163337489610949
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, i, j, k], J[5, i, (j - 1) % N, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2

        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.4984578}
#standard deviation: 0.041926684333011596
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.539453}
#standard deviation: 0.042087715440494035
#island_id: 2
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2697534}
#standard deviation: 0.04653369476454669
#island_id: 2
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0 and i < N - 1:
          neighbor_spin = J[2, i + 1, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1 and i > 0:
          neighbor_spin = J[2, i - 1, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0 and j < N - 1:
          neighbor_spin = J[1, i - 1, j + 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N - 1 and j > 0:
          neighbor_spin = J[1, i + 1, j - 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.33186140000000003}
#standard deviation: 0.049819321051575965
#island_id: 2
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (total_spin > 0)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a term based on the interaction with neighboring spins
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and total_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.33766740000000006}
#standard deviation: 0.04233088396478392
#island_id: 2
#version_generated: 3
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5277785999999999}
#standard deviation: 0.04174621877535736
#island_id: 2
#version_generated: 3
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with negative spin
        if J[0, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[1, (i + 1) % N, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[2, i, j, (k + 1) % N] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with positive spin
        if J[0, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, (i + 1) % N, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, (k + 1) % N] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.41892019999999996}
#standard deviation: 0.043728709927918066
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2569974000000003}
#standard deviation: 0.046015759400883524
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0024438000000000003}
#standard deviation: 0.06583570795214402
#island_id: 3
#version_generated: 3
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 1] = -priorities[i*N**2 + j*N + k, 0]
        else:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 1] += J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 0] = -priorities[i*N**2 + j*N + k, 1]
  
  return(priorities)




#score: {'data3D.txt': -0.5370182}
#standard deviation: 0.04031558940112373
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3315474}
#standard deviation: 0.04115066844220152
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4143258}
#standard deviation: 0.04351607397686515
#island_id: 3
#version_generated: 3
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4175242}
#standard deviation: 0.0443628941161417
#island_id: 3
#version_generated: 3
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          if (j + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i, j + d, k]
          else:
            neighbor_spin = J[2, i, j - d, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          if (k + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i, j, k + d]
          else:
            neighbor_spin = J[2, i, j, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4815618}
#standard deviation: 0.041449642950935055
#island_id: 3
#version_generated: 3
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4145078}
#standard deviation: 0.039836222952985896
#island_id: 1
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  # Add a new term based on the local energy
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  # Add a new term based on the sum of neighboring spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4920458}
#standard deviation: 0.041459288251970754
#island_id: 1
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0018601999999999998}
#standard deviation: 0.046995432288255416
#island_id: 0
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4920458}
#standard deviation: 0.041459288251970754
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4920458}
#standard deviation: 0.041459288251970754
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0142502}
#standard deviation: 0.057800760548283446
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k]) + 2 * total_spin
          priorities[i * N * N + j * N + k][1] = h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3086761999999999}
#standard deviation: 0.045019119422307664
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        for d in range(3):
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= h[i][j][k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
            priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5616446}
#standard deviation: 0.0405200026016781
#island_id: 2
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46650140000000007}
#standard deviation: 0.04404627655137266
#island_id: 0
#version_generated: 3
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41999620000000004}
#standard deviation: 0.039255659790150006
#island_id: 0
#version_generated: 3
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.33842179999999994}
#standard deviation: 0.04408835452542997
#island_id: 0
#version_generated: 3
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_energy_change = sum(J[d, i, j, k] * (h[i][j][k] + 1) if d == 0 or d == 1 or d == 2 else h[i][j][k] - 1 for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_energy_change))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_energy_change
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2569974000000003}
#standard deviation: 0.046015759400883524
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.3472118}
#standard deviation: 0.046303604835476915
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5051434}
#standard deviation: 0.04078953537906506
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2569974000000003}
#standard deviation: 0.046015759400883524
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.45911740000000006}
#standard deviation: 0.04176899923675453
#island_id: 3
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if J[3, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        elif J[3, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[d], 1, axis=i) for d in range(6) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[3, i, j, k] > 0 or J[4, i, j, k] > 0 or J[5, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[3, i, j, k] < 0 or J[4, i, j, k] < 0 or J[5, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.04698020000000001}
#standard deviation: 0.04710278429095248
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [3, 4, 5]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0012194000000000003}
#standard deviation: 0.0455892310051398
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(J[0, i, (j + 1) % N, k], J[0, i, j, (k + 1) % N]),
                  (J[1, (i + 1) % N, j, k], J[1, i, j, (k + 1) % N]),
                  (J[2, i, j, (k + 1) % N]),]
        for d in range(3):
          if all(J[d, i, j, k] > 0 for d in [0, 1, 2]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 3
          elif all(J[d, i, j, k] < 0 for d in [0, 1, 2]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.0012194000000000003}
#standard deviation: 0.0455892310051398
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.274149}
#standard deviation: 0.0433891414872431
#island_id: 0
#version_generated: 3
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in [3, 4]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2592402}
#standard deviation: 0.04645117979082986
#island_id: 0
#version_generated: 3
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in [0,1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d,i+d,j,k]
          else:
            neighbor_spin = J[1-d,i-d,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] += 3
          elif neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] -= 3
        
        site_neighbors = [J[0,i,j,(k+1)%N], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        for d in [0,1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d,i+d,j,k]
          else:
            neighbor_spin = J[1-d,i-d,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] += 3
          elif neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[3, i, j, (k + 1) % N], J[4, (i + 1) % N, j, k], J[5, i, (j + 1) % N, k]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.480461}
#standard deviation: 0.04502232600610502
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48764620000000003}
#standard deviation: 0.044667230780069636
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.344897}
#standard deviation: 0.04807033504147854
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if sum(J[d, i, j, k] for d in [0, 1]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        if sum(J[d, i, j, k] for d in [0, 1]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        if site_neighbors[2] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        if site_neighbors[2] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.33942859999999964}
#standard deviation: 0.04452487688966696
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
        else:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.36530260000000025}
#standard deviation: 0.048522295012086956
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[0], -1, axis=1), 
             np.roll(J[1], -1, axis=0), 
             np.roll(J[2], -1, axis=2)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d][i,j,k] for d in [0, 1, 2]])
        
        site_neighbors = [J[0][i,(j+1)%N,k], J[1][i,j,(k+1)%N], J[2][(i+1)%N,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins[0][i,j,k] + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins[0][i,j,k] + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.37031980000000025}
#standard deviation: 0.04763544654939219
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in [J[0, i, j, k]] + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in [J[0, i, j, k]] + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.33942859999999964}
#standard deviation: 0.04452487688966696
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
        else:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.371261}
#standard deviation: 0.046690339032823484
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.1481286000000002}
#standard deviation: 0.04866889830312579
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.252671}
#standard deviation: 0.05532557129393243
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.331057}
#standard deviation: 0.04750782494494986
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(val for val in interacting_spins if val < 0) - sum(val for val in site_neighbors if val > 0))
        priorities[i * N * N + j * N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37170180000000025}
#standard deviation: 0.045093367990869784
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37170180000000025}
#standard deviation: 0.045093367990869784
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2177398}
#standard deviation: 0.054361956697308096
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the site itself and its neighbors
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2607154}
#standard deviation: 0.05457226404355971
#island_id: 0
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Calculate the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] > 0) * len([val for val in interacting_spins if val < 0]) - (h[i, j, k] > 0) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2390918}
#standard deviation: 0.05268946396349084
#island_id: 0
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N],
          J[3, i, (j - 1) % N, k], 
          J[4, (i - 1) % N, j, k], 
          J[5, i, j, (k - 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0024438000000000003}
#standard deviation: 0.06583570795214402
#island_id: 3
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 1] = -priorities[i*N**2 + j*N + k, 0]
        else:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 1] += J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 0] = -priorities[i*N**2 + j*N + k, 1]

  return(priorities)




#score: {'data3D.txt': -0.05214979999999999}
#standard deviation: 0.0516512605844233
#island_id: 3
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[i*N**2 + j*N + k, 0] += -J[0,i,j,k]*interacting_spins[0,i,j,k]
          priorities[i*N**2 + j*N + k, 1] = -priorities[i*N**2 + j*N + k, 0]
          for d in [1, 2]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[3 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i*N**2 + j*N + k, 0] += np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 1] -= 1
            elif neighbor_spin > 0:
              priorities[i*N**2 + j*N + k, 0] += np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 1] += 1
        else:
          priorities[i*N**2 + j*N + k, 1] += J[0,i,j,k]*interacting_spins[0,i,j,k]
          priorities[i*N**2 + j*N + k, 0] = -priorities[i*N**2 + j*N + k, 1]
          for d in [1, 2]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[3 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i*N**2 + j*N + k, 1] += np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 0] -= 1
            elif neighbor_spin < 0:
              priorities[i*N**2 + j*N + k, 1] -= np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 0] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34071900000000005}
#standard deviation: 0.04818165749535813
#island_id: 0
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(val for val in interacting_spins if val < 0) - sum(val for val in site_neighbors if val > 0))
        priorities[i * N * N + j * N + k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.12758619999999998}
#standard deviation: 0.05612372982580541
#island_id: 0
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.36605540000000014}
#standard deviation: 0.0442857061684693
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3352354000000001}
#standard deviation: 0.046499033826951724
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[d, i, (j + 1) % N, k] if d == 0 else 
                  J[d, (i + 1) % N, j, k] if d == 1 else 
                  J[d, i, j, (k + 1) % N] for d in range(3)]
        total_spin = sum(interacting_spins) + sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.353573}
#standard deviation: 0.04640796861531433
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2086342}
#standard deviation: 0.044992187659192565
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(interacting_spins)
        site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(site_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(site_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.07225460000000002}
#standard deviation: 0.04803328948593881
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + i1) % N, (j + j1) % N, (k + k1) % N] 
                   for d, i1, j1, k1 in [(0, -1, 0, 0), (0, 0, -1, 0), (0, 0, 0, -1),
                               (1, 1, 0, 0), (1, 0, 1, 0), (1, 0, 0, 1),
                               (2, 0, 1, 0), (2, 0, 0, 1), (2, -1, 0, 0)]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i + i1) % N, (j + j1) % N, (k + k1) % N] 
                  for i1, j1, k1 in [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, 0, -1)]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46611060000000004}
#standard deviation: 0.04327603364034186
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1473346}
#standard deviation: 0.047343084002206694
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [1, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2410634}
#standard deviation: 0.04580157923521852
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31666700000000003}
#standard deviation: 0.043397150494012854
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3315474}
#standard deviation: 0.04115066844220152
#island_id: 2
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4442194}
#standard deviation: 0.04191382186868671
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+di) % N, (j+dj) % N, (k+dk) % N] 
                   for d,(di,dj,dk) in enumerate([(0,0,1),(1,0,-1),(2,-1,0)])]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_energy = -h[i][j][k]*J[0, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4938485999999999}
#standard deviation: 0.04413561009026612
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors_sum = sum(site_neighbors)
        neighbor_opposite_count = len([val for val in site_neighbors if val < 0])
        neighbor_same_count = len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_opposite_count - neighbor_same_count) + site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.3471754}
#standard deviation: 0.045531984305979906
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(1 if val < 0 else -1 for val in site_neighbors)
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) + neighbor_spin_sum + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.4619774}
#standard deviation: 0.0418215878373837
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N**2 + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbor_sum
        priorities[i*N**2 + j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.555909}
#standard deviation: 0.03988630640959376
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.0021934000000000003}
#standard deviation: 0.0639015417375825
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3110498}
#standard deviation: 0.0468049206810566
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2451578}
#standard deviation: 0.04492373202617966
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4308514}
#standard deviation: 0.044412400498509426
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.020932199999999998}
#standard deviation: 0.04594296554598974
#island_id: 0
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.sort()
        if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
          priorities[i * N * N + j * N + k][0] = -1
        elif len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
          priorities[i * N * N + j * N + k][0] = 1
        else:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] = 1
          elif total_spin < 0:
            priorities[i * N * N + j * N + k][0] = -1
          else:
            priorities[i * N * N + j * N + k][0] = 0
        
        if site_neighbors.count(-1) > site_neighbors.count(1):
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_neighbors.count(1) > site_neighbors.count(-1):
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.43024219999999996}
#standard deviation: 0.04690970580977886
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          if d < 3:
            site_neighbors[d] += np.roll(h, -1, axis = d)[i,j,k]
          else:
            site_neighbors[d-3] += np.roll(h, 1, axis = (d-3)%3)[i,j,k]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(s)) for s in interacting_spins])
        priorities[i * N * N + j * N + k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.33090579999999997}
#standard deviation: 0.047956041187320705
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in [3, 4, 5]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022858000000000006}
#standard deviation: 0.047019193084952025
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        return(priorities)




#score: {'data3D.txt': -0.16766419999999999}
#standard deviation: 0.044233201990812286
#island_id: 0
#version_generated: 3
#generate time03:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 1
        
        edge_neighbors = [J[5, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        for d in [5]:
          if (i + (d - 4) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.5582694}
#standard deviation: 0.040148867277172345
#island_id: 3
#version_generated: 2
#generate time03:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and (i + (d - 1) % 2 == 0 or k > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and (i + (d - 1) % 2 == 0 or k < N - 1):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2177398}
#standard deviation: 0.054361956697308096
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))

        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the site itself and its neighbors
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.25694259999999997}
#standard deviation: 0.04310125503091528
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3900738}
#standard deviation: 0.047098165925649374
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4964970000000001}
#standard deviation: 0.04324651004416426
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        local_energy = h[i][j][k] - total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + local_energy
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + local_energy
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 2
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 1
#version_generated: 2
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5328622000000001}
#standard deviation: 0.03925982897517512
#island_id: 1
#version_generated: 2
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5582694}
#standard deviation: 0.040148867277172345
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and (i + (d - 1) % 2 == 0 or k > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and (i + (d - 1) % 2 == 0 or k < N - 1):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5582694}
#standard deviation: 0.040148867277172345
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and (i + (d - 1) % 2 == 0 or k > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and (i + (d - 1) % 2 == 0 or k < N - 1):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36506819999999995}
#standard deviation: 0.044656970214738044
#island_id: 2
#version_generated: 3
#generate time03:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])) - h[i][j][k]
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])) + h[i][j][k]
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5405582000000001}
#standard deviation: 0.04032161966935356
#island_id: 3
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5322462}
#standard deviation: 0.04140017567064179
#island_id: 3
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 8.460000000000046e-05}
#standard deviation: 0.04685864533722673
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        edge_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in range(3):
          if edge_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif edge_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.10656940000000001}
#standard deviation: 0.046402914387352875
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.07465540000000001}
#standard deviation: 0.044649891498636365
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in range(6):
          if site_neighbors[d-3] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif site_neighbors[d-3] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3738678000000001}
#standard deviation: 0.04561675748187283
#island_id: 2
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.5019669999999999}
#standard deviation: 0.04357444011114773
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d - 3, j, k]
          else:
            neighbor_spin = J[1 - d, i - d + 3, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4602366}
#standard deviation: 0.04166057873385822
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.5535793999999999}
#standard deviation: 0.04099644296326207
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3390794}
#standard deviation: 0.05004735652999067
#island_id: 0
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Calculate the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] > 0) * len([val for val in interacting_spins if val < 0]) - (h[i, j, k] > 0) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a bias to the priority based on the interaction energy
        priorities[i * N * N + j * N + k][0] += np.sum([abs(val) for val in interacting_spins]) / len(interacting_spins)
        priorities[i * N * N + j * N + k][1] -= np.sum([abs(val) for val in site_neighbors]) / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': 0.14111900000000008}
#standard deviation: 0.045772767001788305
#island_id: 0
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_priority = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        magnetism_priority = h[i, j, k]
        
        priorities[i * N * N + j * N + k][0] += site_priority
        priorities[i * N * N + j * N + k][1] += magnetism_priority
        
  return(priorities)




#score: {'data3D.txt': -0.2607154}
#standard deviation: 0.05457226404355971
#island_id: 0
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] > 0) * len([val for val in interacting_spins if val < 0]) - (h[i, j, k] > 0) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.2568342}
#standard deviation: 0.05512986913062646
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
         J[0, i, (j + 1) % N, k], 
         J[1, (i + 1) % N, j, k], 
         J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the magnetism and interactions
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the interactions
        for d in range(6):
          if interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[d, i, j, k] > 0) * len([val for val in [J[e, i, j, k] for e in range(6)] if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (J[d, i, j, k] < 0) * len([val for val in [J[e, i, j, k] for e in range(6)] if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2790666000000002}
#standard deviation: 0.0449435904711673
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5322462}
#standard deviation: 0.04140017567064179
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5535793999999999}
#standard deviation: 0.04099644296326207
#island_id: 1
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0031366}
#standard deviation: 0.04697917432692916
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0087422}
#standard deviation: 0.04802963063734719
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] + interacting_spins[d][i][j][k]) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5363509999999999}
#standard deviation: 0.03944818929938357
#island_id: 2
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5370182}
#standard deviation: 0.04031558940112373
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
  return(priorities)




#score: {'data3D.txt': -0.5370182}
#standard deviation: 0.04031558940112373
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5363509999999999}
#standard deviation: 0.03944818929938357
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30674179999999984}
#standard deviation: 0.04594748581543934
#island_id: 2
#version_generated: 3
#generate time04:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])) - 2 * total_spin + h[i][j][k]
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])) + 2 * total_spin + h[i][j][k]
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * total_spin + h[i][j][k]
            priorities[i * N * N + j * N + k][1] -= 2 * total_spin + h[i][j][k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + 2 * total_spin + h[i][j][k]
            priorities[i * N * N + j * N + k][1] += 2 * total_spin + h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.47255220000000003}
#standard deviation: 0.03940733935652089
#island_id: 2
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        def objective(x):
          return np.sum((x - total_spin)**2)

        res = minimize(objective, [0.5], method="SLSQP")

        if res.success:
          priorities[i * N * N + j * N + k][0] += (res.x[0] - total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin)

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4733306}
#standard deviation: 0.0417872500128927
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5315702000000001}
#standard deviation: 0.03976015935531446
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) - abs(total_spin)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4882578}
#standard deviation: 0.039297269869037976
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5089962}
#standard deviation: 0.03964695430370409
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.5264994000000002}
#standard deviation: 0.04036025965773759
#island_id: 1
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin == h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin == h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2772834}
#standard deviation: 0.045719118587741824
#island_id: 3
#version_generated: 3
#generate time05:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.46073300000000006}
#standard deviation: 0.04336950577306595
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) + sum(J[d, i, (j + 1) % N, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] - sum(J[d, (i + 1) % N, j, k] for d in [0, 1, 2]) + sum(J[d, i, j, (k + 1) % N] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0796894}
#standard deviation: 0.05901077840225462
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = [0, 1, 2]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in site_nbr:
          priorities[i*N*N + j*N + k][0] += -J[d,i,j,k]*interacting_spins[d,i,j,k]
          priorities[i*N*N + j*N + k][1] -= J[d,i,j,k]

  return priorities




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5899646000000001}
#standard deviation: 0.039911688348652954
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4213066}
#standard deviation: 0.04089169838047816
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0])
        
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.47688700000000006}
#standard deviation: 0.04203900178405763
#island_id: 0
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time05:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': 0.15385380000000018}
#standard deviation: 0.04537649816325628
#island_id: 0
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] = np.sum([val for val in site_neighbors])
        else:
          priorities[i*N**2 + j*N + k][0] = np.sum([abs(val) for val in site_neighbors]) + sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] = -np.sum([val for val in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': -0.35904500000000006}
#standard deviation: 0.04127252954448031
#island_id: 0
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.5013766}
#standard deviation: 0.04042988761349702
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.4590006}
#standard deviation: 0.04072517893932451
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4882578}
#standard deviation: 0.039297269869037976
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4882578}
#standard deviation: 0.039297269869037976
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.20317179999999999}
#standard deviation: 0.04588224890695747
#island_id: 1
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the total energy of all neighboring sites
        total_neighbor_energy = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            total_neighbor_energy += np.exp(h[i + d, j, k])
          else:
            total_neighbor_energy += np.exp(h[i - d, j, k])
        priorities[i * N * N + j * N + k][0] += total_neighbor_energy
        priorities[i * N * N + j * N + k][1] -= total_neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Add your code here
  return(priorities)




#score: {'data3D.txt': -0.5709606}
#standard deviation: 0.0410495788972311
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        total_spin = sum(site_interacting_spins)

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        else:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N**2 + j*N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N**2 + j*N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N**2 + j*N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5289306}
#standard deviation: 0.041743397365811036
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin_product = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.43541660000000004}
#standard deviation: 0.0459931012700818
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate local energy
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate priority based on site neighbors
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.067413}
#standard deviation: 0.045173426159635044
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = sum(site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val < 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum([J[3+i, i, j, k] for i in range(3)])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val > 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum([J[3+i, i, j, k] for i in range(3)])
  
  return(priorities)




#score: {'data3D.txt': -0.48821380000000003}
#standard deviation: 0.04183023606866211
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors.sort()
        if len(set(site_neighbors)) == 1:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': 0.34785220000000006}
#standard deviation: 0.04908161891339771
#island_id: 0
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 - 2 * np.tanh(sum(J[d, i, j, k] for d in [3+i for i in range(3)])) - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] = np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * np.tanh(sum(J[d, i, j, k] for d in [3+i for i in range(3)])) - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.113077}
#standard deviation: 0.045198655190171314
#island_id: 0
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = sum(site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val < 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum([J[3+i, i, j, k] for i in range(3)])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val > 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum([J[3+i, i, j, k] for i in range(3)])
        
        # Add a new term based on the local energy
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i*N**2 + j*N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.067413}
#standard deviation: 0.045173426159635044
#island_id: 0
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = sum(site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val < 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum([J[3+i, i, j, k] for i in range(3)])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val > 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum([J[3+i, i, j, k] for i in range(3)])
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                 J[d, i, (j+1)%N, k] if d == 1 else
                 J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.5021118}
#standard deviation: 0.04143081100775123
#island_id: 3
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
              J[d, i, (j+1)%N, k] if d == 1 else
              J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.006419399999999991}
#standard deviation: 0.05058859855382436
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) - site_nbr
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
    
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction energy with the site and its neighbors
        interacting_energy = sum(J[d, i, j, k]*interacting_spins[d] for d in range(6))
        priorities[i * N * N + j * N + k][0] += -interacting_energy
        priorities[i * N * N + j * N + k][1] -= interacting_energy
        
  return(priorities)




#score: {'data3D.txt': -0.012618599999999966}
#standard deviation: 0.057221166835708624
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, site_nbr, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else 
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        interacting_spins = np.array(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4498818}
#standard deviation: 0.042026843668779124
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d - 3, j, k]
          else:
            neighbor_spin = J[1 - d, i - d + 3, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.47431619999999997}
#standard deviation: 0.0417211559950105
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42627780000000004}
#standard deviation: 0.04017968326355996
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the total spin of the site's neighbors with absolute value
        neighbor_spin_abs_sum = sum(abs(J[d, i, j, k]) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_abs_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_abs_sum > 0) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.46424580000000004}
#standard deviation: 0.042155284631467026
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the site's energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42627780000000004}
#standard deviation: 0.04017968326355996
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the number of neighbors with same spin
        neighbor_spin_same = sum((J[d, i, j, k] > 0) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_same > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_same > 0) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.08290180000000004}
#standard deviation: 0.046961126016738575
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the energy term
        energy_term = sum(site_interacting_spins) + h[i][j][k]
        if h[i][j][k] > 0:
          energy_term *= np.exp(-abs(sum(site_interacting_spins)))
        else:
          energy_term *= np.exp(abs(sum(site_interacting_spins)))
        
        # Calculate the term for flipping a spin
        flip_term = -2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += energy_term + flip_term
        priorities[i*N**2 + j*N + k][1] -= 2 * np.tanh(energy_term)
  
  return(priorities)




#score: {'data3D.txt': -0.47688700000000006}
#standard deviation: 0.04203900178405763
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.489725}
#standard deviation: 0.04309173859337774
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.47688700000000006}
#standard deviation: 0.04203900178405763
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.07124499999999999}
#standard deviation: 0.04861846742751154
#island_id: 3
#version_generated: 3
#generate time06:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.4213066}
#standard deviation: 0.04089169838047816
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2]) - local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2]) - local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0])
        
  return(priorities)




#score: {'data3D.txt': -0.4213066}
#standard deviation: 0.04089169838047816
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
 
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0])

  return(priorities)




#score: {'data3D.txt': -0.42473340000000004}
#standard deviation: 0.04162201345970663
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        if len([val for val in site_interacting_spins + site_neighbors if val < 0]) > len([val for val in site_interacting_spins + site_neighbors if val > 0]):
          priorities[i*N**2 + j*N + k][1] -= 2
        else:
          priorities[i*N**2 + j*N + k][0] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.379805}
#standard deviation: 0.041719137275356026
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] += -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] += -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] += -2 + 2 * sum(J[d, i, (j+1)%N, k] for d in [0])
  
  return(priorities)




#score: {'data3D.txt': -0.4898757999999999}
#standard deviation: 0.0401630822318208
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with different spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy

  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0177686}
#standard deviation: 0.0619550483337718
#island_id: 3
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.012618599999999966}
#standard deviation: 0.057221166835708624
#island_id: 3
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, site_nbr, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else 
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        interacting_spins = np.array(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.030805800000000005}
#standard deviation: 0.059029575691851285
#island_id: 3
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2896438}
#standard deviation: 0.04276954011396428
#island_id: 1
#version_generated: 3
#generate time06:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.07124499999999999}
#standard deviation: 0.04861846742751154
#island_id: 3
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
             J[d, i, (j+1)%N, k] if d == 1 else
             J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': 0.07076779999999999}
#standard deviation: 0.3075787213107565
#island_id: 3
#version_generated: 3
#generate time06:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(h[i1][j1][k1] for i1 in range(N) for j1 in range(N) for k1 in range(N))
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.3825982000000003}
#standard deviation: 0.047867997208573494
#island_id: 3
#version_generated: 3
#generate time06:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.3825982000000003}
#standard deviation: 0.047867997208573494
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.030805800000000005}
#standard deviation: 0.059029575691851285
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                    J[d, i, (j+1)%N, k] if d == 1 else
                    J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3679122000000002}
#standard deviation: 0.05070568342069753
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
             J[d, i, (j+1)%N, k] if d == 1 else
             J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.21929540000000003}
#standard deviation: 0.043601374047614605
#island_id: 1
#version_generated: 3
#generate time06:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.21929540000000003}
#standard deviation: 0.043601374047614605
#island_id: 1
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.21929540000000003}
#standard deviation: 0.043601374047614605
#island_id: 1
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5366709999999999}
#standard deviation: 0.04100808065491483
#island_id: 0
#version_generated: 2
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.094119}
#standard deviation: 0.04349325141904201
#island_id: 0
#version_generated: 2
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49049100000000023}
#standard deviation: 0.04471669396321691
#island_id: 0
#version_generated: 2
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  # Add a term based on the number of nearest neighbors with same spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])) / 3) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])) / 3) * -2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0036465999999999994}
#standard deviation: 0.04764309339704969
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  # Sort the priority based on site interaction and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k] = sorted(priorities[i * N * N + j * N + k])
        else:
          priorities[i * N * N + j * N + k] = sorted(reversed(priorities[i * N * N + j * N + k]))
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.41884940000000015}
#standard deviation: 0.041952467384410184
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]

        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2

        # Add a new term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the site interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.2837422}
#standard deviation: 0.04336838732487063
#island_id: 2
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.46148300000000014}
#standard deviation: 0.04251413918921563
#island_id: 3
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]

        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) - abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.030921799999999996}
#standard deviation: 0.04793613589725396
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add another term based on the site interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.030921799999999996}
#standard deviation: 0.04793613589725396
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the site interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.432109}
#standard deviation: 0.04216058727057772
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins)
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
  return priorities




#score: {'data3D.txt': -0.470543}
#standard deviation: 0.03928530095341004
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.2837422}
#standard deviation: 0.04336838732487063
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0022838000000000008}
#standard deviation: 0.04706886590475704
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.3193506000000001}
#standard deviation: 0.054880218655176664
#island_id: 3
#version_generated: 3
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d == 0 else i, j, k] if d % 3 == 0 else 
                   J[1, i, (j+1)%N if d == 1 else j, k] if d % 3 == 1 else
                   J[2, i, j, (k+1)%N if d == 2 else k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - local_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - local_energy
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.047739000000000004}
#standard deviation: 0.04509749615000815
#island_id: 3
#version_generated: 3
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the interaction with the nearest neighbors
        for d in range(6):
          if d < 3:
            site_nbr = (i + ((d-1) % 3 - 1)) % N
          else:
            site_nbr = (j + ((d-3) % 3 - 1)) % N
          
          priorities[i * N * N + j * N + k][0] -= J[d, site_nbr, i, k]
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.030805800000000005}
#standard deviation: 0.059029575691851285
#island_id: 3
#version_generated: 3
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins_val = [J[0, site_nbr, j, k], 
                     J[1, i, (j+1)%N, k], 
                     J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins_val if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins_val if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.094119}
#standard deviation: 0.04349325141904201
#island_id: 0
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5366709999999999}
#standard deviation: 0.04100808065491483
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5366709999999999}
#standard deviation: 0.04100808065491483
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0646022}
#standard deviation: 0.046722082521651366
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.42281420000000003}
#standard deviation: 0.047636163556273085
#island_id: 3
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site interaction, neighbor interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site interaction, neighbor spin and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.45927260000000014}
#standard deviation: 0.045598797892488344
#island_id: 3
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4397062000000001}
#standard deviation: 0.04051904492408478
#island_id: 3
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]

        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (np.mean([J[d, i, j, k] for d in range(6)]) if total_spin > 0 else -np.mean([J[d, i, j, k] for d in range(6)]))
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': 0.287167}
#standard deviation: 0.051822029205734504
#island_id: 2
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [(i + (j - 1) % N), (i + (k - 1) % N)]
        opposite_spins = len([val for val in interacting_spins if val < 0])
        same_spins = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) - 2
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.0400114}
#standard deviation: 0.04295280375062843
#island_id: 2
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = []
        for l in range(3):
          if h[i][j][k] > 0:
            site_nbrs.append(-np.sum([J[d, i, j, k] for d in range(6)]))
          else:
            site_nbrs.append(np.sum([J[d, i, j, k] for d in range(6)]))
        
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(site_nbrs)
        priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': -0.432109}
#standard deviation: 0.04216058727057772
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins)
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins

  return priorities




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4109818}
#standard deviation: 0.04014788697752349
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] += len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 2
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 3
#version_generated: 2
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.541861}
#standard deviation: 0.04066007770528728
#island_id: 3
#version_generated: 2
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
        if i > 0:
          neighbor_spin = J[0, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          neighbor_spin = J[0, i+1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.457529}
#standard deviation: 0.040548987151345715
#island_id: 2
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  def get_priority(site_nbrs):
    opposite_spins = len([val for val in site_nbrs if val < 0])
    same_spins = len([val for val in site_nbrs if val > 0])
    return np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))* (opposite_spins - same_spins)

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += get_priority(site_nbrs)
        priorities[i * N * N + j * N + k][1] -= get_priority(site_nbrs)

  return priorities




#score: {'data3D.txt': -0.4614706}
#standard deviation: 0.04171806342149645
#island_id: 2
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins)
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.2023046}
#standard deviation: 0.0517558914408785
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3057002}
#standard deviation: 0.03995163876438612
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1267970000000002}
#standard deviation: 0.045822538897359245
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.048049800000000004}
#standard deviation: 0.04603852343375057
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        site_center = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_center if val < 0]) - len([val for val in site_center if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_center if val < 0]) + 2 * len([val for val in site_center if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.209313}
#standard deviation: 0.04209181382406798
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2475682}
#standard deviation: 0.043539602992677826
#island_id: 0
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4109818}
#standard deviation: 0.04014788697752349
#island_id: 0
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] += len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.1472706}
#standard deviation: 0.04523971104726466
#island_id: 0
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_opposite = [J[d, i, j, k] for d in [3, 4, 5]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite if val > 0]) - len([val for val in site_opposite if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_opposite if val > 0]) + 2 * len([val for val in site_opposite if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.4661586}
#standard deviation: 0.04063200814678005
#island_id: 3
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          neighbor_spin = J[0, i+1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.44836980000000004}
#standard deviation: 0.04052035350240667
#island_id: 0
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add the effect of magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.21791939999999999}
#standard deviation: 0.042585295392189075
#island_id: 0
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) > 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.32735659999999994}
#standard deviation: 0.04178420654314259
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Further Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.3839162}
#standard deviation: 0.04356043316543121
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Further improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.3839162}
#standard deviation: 0.04356043316543121
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.17659179999999997}
#standard deviation: 0.04406719020722787
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += -h[i][j][k] * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3776106}
#standard deviation: 0.039765162738759165
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the magnetism at this site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0020426000000000003}
#standard deviation: 0.048969413160053286
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40687100000000004}
#standard deviation: 0.04053712815432292
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy

        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3821878}
#standard deviation: 0.04201939232259315
#island_id: 1
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of the current site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= np.exp(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += np.exp(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4874522000000001}
#standard deviation: 0.04174368880633335
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin < 0) + 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] = (total_neighbor_spin > 0) - 1

  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin) - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [(i-1)%N if i > 0 else (i+1)%N, (j-1)%N if j > 0 else (j+1)%N, (k-1)%N if k > 0 else (k+1)%N]
        
        for d in [0, 1, 2]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, site_neighbors[0], site_neighbors[1], site_neighbors[2]] * (h[site_neighbors[0]][site_neighbors[1]][site_neighbors[2]] > 0) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.20733179999999998}
#standard deviation: 0.04363528880115267
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + len([val for val in J[2, :, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + len([val for val in J[2, :, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
    
  return priorities




#score: {'data3D.txt': -0.4699998}
#standard deviation: 0.039280425149939506
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.10444500000000007}
#standard deviation: 0.04793810525041642
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i, j, k] + J[d, i-1 if i>0 else N-1, j, k] * interacting_spins[0][i-1 if i>0 else N-1, j, k] 
                + J[d, i, j-1 if j>0 else N-1, k] * interacting_spins[1][i, j-1 if j>0 else N-1, k] 
                + J[d, i, j, k-1 if k>0 else N-1] * interacting_spins[2][i, j, k-1 if k>0 else N-1] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0699494}
#standard deviation: 0.04967707519208433
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.006407}
#standard deviation: 0.04706728025922042
#island_id: 1
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2
        elif all(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] = -neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.018232999999999996}
#standard deviation: 0.046541244407514504
#island_id: 1
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.1705498000000001}
#standard deviation: 0.04619437108523072
#island_id: 1
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.46322820000000003}
#standard deviation: 0.041932213449327946
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbors = [J[d, i, j, k] for d in [0, 1]]
        neighbor_counts = [len([val for val in neighbors if val < 0]), len([val for val in neighbors if val > 0])]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_counts[0] - neighbor_counts[1])
        priorities[i * N * N + j * N + k][1] -= neighbor_counts[0] - neighbor_counts[1]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.44266820000000007}
#standard deviation: 0.041651289881106925
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = sum(J[d, i + d, :, k])
          else:
            neighbor_spin = sum(J[1 - d, i - d, :, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] -= neighbor_spin > 0
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4716798}
#standard deviation: 0.039806471734631296
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0083862}
#standard deviation: 0.04658829992133218
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[d, :, :, :], 1, axis=0) for d in range(6)]
  interacting_spins += [np.roll(np.roll(J[d, :, :, :], 1, axis=1), 1, axis=1) for d in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[d, (i+1)%N, j, k] for d in range(3)] + [J[d, i, (j+1)%N, k] for d in range(3)] + [J[d, i, j, (k+1)%N] for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.44836980000000004}
#standard deviation: 0.04052035350240667
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add the effect of magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3598574}
#standard deviation: 0.04163064382447142
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.1705498000000001}
#standard deviation: 0.04619437108523072
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.14780339999999997}
#standard deviation: 0.04636303558267081
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])

        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if i + (d - 1) % 2 == 0:
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])

          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy

  return priorities




#score: {'data3D.txt': 0.1705498000000001}
#standard deviation: 0.04619437108523072
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.1204422}
#standard deviation: 0.046401130365110725
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.4405638}
#standard deviation: 0.039134929788617226
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        priorities[i * N * N + j * N + k][0] += total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + (1 if neighbor_spin < 0 else -1)
        priorities[i * N * N + j * N + k][1] += -2 + 2 * total_spin
  return priorities




#score: {'data3D.txt': -0.002561}
#standard deviation: 0.048223091138996886
#island_id: 1
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, :, :, :] for d in range(6)]
  total_spin = sum(J[d, :, :, :] * h for d in range(6))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [interacting_spins[0][i, (j + 1) % N, k], interacting_spins[1][(i + 1) % N, j, k], interacting_spins[2][i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] = -same_spin_count
        priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': 0.287167}
#standard deviation: 0.051822029205734504
#island_id: 2
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [(i + (j - 1) % N), (i + (k - 1) % N)]
        opposite_spins = len([val for val in interacting_spins if val < 0])
        same_spins = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) - 2
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.287167}
#standard deviation: 0.051822029205734504
#island_id: 2
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [(i + (j - 1) % N), (i + (k - 1) % N)]
        opposite_spins = len([val for val in interacting_spins if val < 0])
        same_spins = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) - 2
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.179335}
#standard deviation: 0.05503390495867071
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        opposite_neighbors = sum([val for val in site_neighbors if val * total_spin < 0])

        priorities[i * N * N + j * N + k][0] += -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3598574}
#standard deviation: 0.04163064382447142
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.0907414}
#standard deviation: 0.04537411471356769
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_opposite = [J[d, i, j, k] for d in [3, 4, 5]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_opposite if val < 0]) - len([val for val in site_opposite if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_opposite if val < 0]) + 2 * len([val for val in site_opposite if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4336954}
#standard deviation: 0.043073326999896355
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.477437}
#standard deviation: 0.042744642132084815
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3341174}
#standard deviation: 0.04066163126634248
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2851426}
#standard deviation: 0.04055728029885633
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4497574000000001}
#standard deviation: 0.04689999216673709
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36847660000000004}
#standard deviation: 0.04318222796984889
#island_id: 2
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] -= 4
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] += 4
        
        # Add a new term based on the interaction with the site above
        if i > 0:
          above_neighbor = J[1, (i - 1) % N, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (above_neighbor < 0) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction with the site below
        if i < N - 1:
          below_neighbor = J[1, (i + 1) % N, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (below_neighbor > 0) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the interaction with the site to the left
        if j > 0:
          left_neighbor = J[0, i, (j - 1) % N, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (left_neighbor < 0) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction with the site to the right
        if j < N - 1:
          right_neighbor = J[0, i, (j + 1) % N, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (right_neighbor > 0) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the interaction with the site in front
        if k > 0:
          front_neighbor = J[2, i, j, (k - 1) % N]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (front_neighbor < 0) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction with the site behind
        if k < N - 1:
          back_neighbor = J[2, i, j, (k + 1) % N]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (back_neighbor > 0) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2671726}
#standard deviation: 0.04903206307346245
#island_id: 2
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1680934}
#standard deviation: 0.05701971480496899
#island_id: 2
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the interactions with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the interactions with the next nearest neighbors
        site_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.343681}
#standard deviation: 0.045560499986281984
#island_id: 2
#version_generated: 3
#generate time08:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.0686002}
#standard deviation: 0.05862008563589787
#island_id: 2
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the interactions with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the interactions with the next nearest neighbors
        site_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the magnetism term
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.02098699999999976}
#standard deviation: 0.04370820919461238
#island_id: 2
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.zeros((N,N,N)) for _ in range(6)]
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1680934}
#standard deviation: 0.05701971480496899
#island_id: 2
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the interactions with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the interactions with the next nearest neighbors
        site_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0420494}
#standard deviation: 0.046863598662928135
#island_id: 3
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i, j, k] if d == 0 else h[(i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N]) for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.06717180000000007}
#standard deviation: 0.0470229131887849
#island_id: 3
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: 3
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1, axis=i%3)
    interacting_spins = interacting_spins.reshape(N,N,N)
    priorities += -J[i].flatten() * interacting_spins.flatten()
  return np.array([priorities, np.zeros(N**3)]).T




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + len([val for val in J[2, i, j, :] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + len([val for val in J[2, i, j, :] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.11657380000000007}
#standard deviation: 0.045806539200860835
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + e) % N, (k + f) % N] for d, e, f in [(0, 1, 2), (1, 0, 2), (2, 0, 1)]]
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)

  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.2974446}
#standard deviation: 0.039320685279379354
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
        layer_neighbors = [J[3, i, j, (k + 1) % N], J[4, (i + 1) % N, j, k], J[5, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in layer_neighbors if val < 0]) + sum(val for val in layer_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in layer_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2831902}
#standard deviation: 0.04457670808796899
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0239514}
#standard deviation: 0.048036597694258075
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0239514}
#standard deviation: 0.048036597694258075
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.1394126}
#standard deviation: 0.047487514582677415
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          left_spin = J[2, i+1, j, k]
          if left_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if j < N-1:
          up_spin = J[2, i, j+1, k]
          if up_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N-1:
          front_spin = J[2, i, j, k+1]
          if front_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.45217460000000015}
#standard deviation: 0.04674166658175551
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23776380000000036}
#standard deviation: 0.04703389426318002
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.1173022}
#standard deviation: 0.04569395140672341
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # Add terms based on the site's neighbors and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val != 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4666742}
#standard deviation: 0.03938114033849198
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2360802}
#standard deviation: 0.04370633555858922
#island_id: 0
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          for spin in [-1, 1]:
            if sum([val for val in interacting_spins if val < 0]) == 0 and total_spin >= 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif sum([val for val in interacting_spins if val > 0]) == 0 and total_spin <= 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            
            if J[2, i, j, k - 1] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            
            for d in [0, 1]:
              if (i + (d - 1) % 2 == 0):
                neighbor_spin = J[d, i + d, j, k]
              else:
                neighbor_spin = J[1 - d, i - d, j, k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
            
            for d in [0, 1]:
              if (i + (d - 1) % 2 == 0):
                neighbor_spin = J[d, i + d, j, k]
              else:
                neighbor_spin = J[1 - d, i - d, j, k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5630806}
#standard deviation: 0.04328313601900861
#island_id: 0
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add a new term based on the number of nearest neighbors with the opposite spin
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46830259999999996}
#standard deviation: 0.03984016557746717
#island_id: 1
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34458939999999993}
#standard deviation: 0.04276586030515462
#island_id: 2
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        
  
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_neighbors = [val for val in site_neighbors if val < 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.458271}
#standard deviation: 0.0448929085602615
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.489885}
#standard deviation: 0.04085736965346644
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.46980700000000003}
#standard deviation: 0.03941427953166212
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4716798}
#standard deviation: 0.039806471734631296
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.18640140000000002}
#standard deviation: 0.05336849068542224
#island_id: 0
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])

        neighbor_spin = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.33159340000000004}
#standard deviation: 0.047892911338109315
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.36619100000000004}
#standard deviation: 0.04299328644102472
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1
        priorities[i * N * N + j * N + k][1] = total_spin_2
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45217460000000015}
#standard deviation: 0.04674166658175551
#island_id: 0
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0020365999999999995}
#standard deviation: 0.04676717545928982
#island_id: 3
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1, axis=i%3)
    interacting_spins = interacting_spins.flatten()
    
    site_nbr = (i + ((-1) % 2)) % N
    if h[0][0][0] > 0:
      priorities[:,0] += -np.exp(-abs(J[i].flatten())) * len([val for val in interacting_spins if val < 0]) + J[i].flatten()
      priorities[:,1] -= 2 - 2 * np.sum(J[i].flatten())
    else:
      priorities[:,0] -= -np.exp(-abs(J[i].flatten())) * len([val for val in interacting_spins if val < 0]) + J[i].flatten()
      priorities[:,1] += 2 - 2 * np.sum(J[i].flatten())

  return priorities




#score: {'data3D.txt': -0.3811922}
#standard deviation: 0.05064070516057216
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

  # calculate the priority based on the magnetism and interaction
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]] if val > 0]) + sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]] if val < 0]) + sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])

  return priorities




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.2215570000000002}
#standard deviation: 0.04492072696428677
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * priorities[i * N * N + j * N + k][0])
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * priorities[i * N * N + j * N + k][0])
          
  return(priorities)




#score: {'data3D.txt': -0.4173698}
#standard deviation: 0.04091351375719275
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34458939999999993}
#standard deviation: 0.04276586030515462
#island_id: 2
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.5037474000000001}
#standard deviation: 0.04185668875150064
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy and calculate the average
          avg_neighbor_spin = sum(site_neighbors) / len(site_neighbors)
          if spin == -1:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (avg_neighbor_spin + total_spin)
            priorities[i * N * N + j * N + k][1] += 2 - 2 * avg_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (avg_neighbor_spin + total_spin)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * avg_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45596380000000014}
#standard deviation: 0.045081479229945425
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])

        # Add the total energy of the neighboring sites
        neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.45217460000000015}
#standard deviation: 0.04674166658175551
#island_id: 0
#version_generated: 3
#generate time09:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.4532198000000002}
#standard deviation: 0.04710714136901113
#island_id: 0
#version_generated: 3
#generate time09:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Add the total spin energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        else:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2671726}
#standard deviation: 0.04903206307346245
#island_id: 2
#version_generated: 3
#generate time09:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0015853999999999998}
#standard deviation: 0.04598906377433661
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.zeros((N,N,N)) for _ in range(6)]
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = max(-2, min(2, 2 - 4 * total_spin))
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = max(-2, min(2, 2 + 4 * total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.2799926000000002}
#standard deviation: 0.04559333180674558
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0] * 6
        
        if i > 0:
          interacting_spins[0] = h[i-1][j][k]
        if i < N - 1:
          interacting_spins[1] = h[i+1][j][k]
        
        if j > 0:
          interacting_spins[2] = h[i][j-1][k]
        if j < N - 1:
          interacting_spins[3] = h[i][j+1][k]
        
        if k > 0:
          interacting_spins[4] = h[i][j][k-1]
        if k < N - 1:
          interacting_spins[5] = h[i][j][k+1]
        
        total_spin = sum(J[d, i, j, k] * s for d, s in enumerate(interacting_spins))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.07065860000000018}
#standard deviation: 0.04460407297590657
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] * (h[(i+1)%N][j][k] if d==0 else h[i][(j+1)%N][k] if d==1 else h[i][j][(k+1)%N]) for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4405638}
#standard deviation: 0.039134929788617226
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        priorities[i * N * N + j * N + k][0] += total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + (1 if neighbor_spin < 0 else -1)
        priorities[i * N * N + j * N + k][1] += -2 + 2 * total_spin
  return priorities




#score: {'data3D.txt': 0.11957900000000009}
#standard deviation: 0.0483857416911222
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += - sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0]) - (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0]) + (1 if neighbor_spin > 0 else -1)
        else:
          priorities[i * N * N + j * N + k][0] += sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val < 0]) + (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += -sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val > 0]) - (1 if neighbor_spin > 0 else -1)
  return priorities




#score: {'data3D.txt': -0.44001419999999997}
#standard deviation: 0.04539529401116376
#island_id: 0
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_energy = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbor_energy = sum([val for val in site_neighbors if val != 0])
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_energy)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin_energy
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_energy - site_neighbor_energy
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_energy)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin_energy
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_energy + site_neighbor_energy
  
  return(priorities)




#score: {'data3D.txt': -0.06622579999999995}
#standard deviation: 0.045927807854936865
#island_id: 0
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.046833400000000004}
#standard deviation: 0.04910445972047753
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0420494}
#standard deviation: 0.046863598662928135
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i, j, k] if d == 0 else h[(i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N]) for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.001157800000000001}
#standard deviation: 0.052556806021294714
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -2 * total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = 2 * total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4782342}
#standard deviation: 0.0396928425583253
#island_id: 1
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) + h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.41358140000000004}
#standard deviation: 0.04051226300813125
#island_id: 1
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins[2][i, j, :] if val < 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins[2][i, j, :] if val > 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': -0.29960659999999995}
#standard deviation: 0.04282805338139944
#island_id: 1
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.33378820000000003}
#standard deviation: 0.051632387323849366
#island_id: 2
#version_generated: 3
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum(site_neighbors[3:])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]*interacting_spins[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2*J[d, i, j, k]*interacting_spins[d, i, j, k]
  
  return priorities




#score: {'data3D.txt': -0.4699998}
#standard deviation: 0.039280425149939506
#island_id: 2
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0027434000000000013}
#standard deviation: 0.04639688735723551
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val < 0]) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val > 0]) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (interacting_spins[d, i, j, k] if d < 3 else -interacting_spins[2-d, i, j, k]) for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (interacting_spins[d, i, j, k] if d < 3 else -interacting_spins[2-d, i, j, k]) for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0658834}
#standard deviation: 0.047394539394744625
#island_id: 0
#version_generated: 3
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, -1])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin) * len([val for val in J[0, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * len([val for val in J[0, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1 + site_neighbors[0]
        priorities[i * N * N + j * N + k][1] = total_spin_2 + site_neighbors[0]
  
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1
        priorities[i * N * N + j * N + k][1] = total_spin_2
        
  return(priorities)




#score: {'data3D.txt': 0.08445820000000001}
#standard deviation: 0.047796862792028515
#island_id: 1
#version_generated: 3
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        interacting_spins = [J[2, i+1 if i < N-1 else i, j, k], 
                   J[2, i, j+1 if j < N-1 else j, k], 
                   J[2, i, j, k+1 if k < N-1 else k]]
        
        for spin in interacting_spins:
          if spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.0239514}
#standard deviation: 0.048036597694258075
#island_id: 1
#version_generated: 3
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0541174}
#standard deviation: 0.04602041739532574
#island_id: 1
#version_generated: 3
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0035381999999999996}
#standard deviation: 0.046008246008297254
#island_id: 1
#version_generated: 3
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * np.sign(h[i, j, k]) for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * h[i, j, k])
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if i > 0:
            left_spin = J[2, i-1, j, k]
            if left_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * h[i-1, j, k])
              priorities[i * N * N + j * N + k][1] -= 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * h[i-1, j, k])
              priorities[i * N * N + j * N + k][1] += 1
          
          if j > 0:
            up_spin = J[2, i, j-1, k]
            if up_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * h[i, j-1, k])
              priorities[i * N * N + j * N + k][1] -= 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * h[i, j-1, k])
              priorities[i * N * N + j * N + k][1] += 1
          
          if k > 0:
            front_spin = J[2, i, j, k-1]
            if front_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * h[i, j, k-1])
              priorities[i * N * N + j * N + k][1] -= 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * h[i, j, k-1])
              priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.08648620000000032}
#standard deviation: 0.04785006300476521
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j - 1) % N, k], J[2, site_nbr, j, k]] if val < 0]) + 1
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k], J[1, i, (j - 1) % N, k], J[2, site_nbr, j, k]] if val > 0]) + 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j - 1) % N, k], J[2, site_nbr, j, k]] if val > 0]) + 1
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[0, i, j, k], J[1, i, (j - 1) % N, k], J[2, site_nbr, j, k]] if val < 0]) + 1
  
  return(priorities)




#score: {'data3D.txt': -0.021200599999999997}
#standard deviation: 0.051604683117329575
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate neighboring spins along each axis
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  # Calculate total spin and energy of each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_energy = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))

        # Calculate priority based on energy and spin
        priorities[i*N*N + j*N + k, 0] = -site_energy * total_spin
        priorities[i*N*N + j*N + k, 1] = site_energy

  return priorities




#score: {'data3D.txt': 0.12462780000000016}
#standard deviation: 0.05045023119035235
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] < 0:
          priorities[i * N**2 + j * N + k, 0] = np.exp(-abs(total_spin))
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N**2 + j * N + k, 0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N**2 + j * N + k, 1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N**2 + j * N + k, 0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N**2 + j * N + k, 1] += 1
        
        else:
          priorities[i * N**2 + j * N + k, 1] = np.exp(abs(total_spin))
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N**2 + j * N + k, 1] -= np.exp(abs(total_spin)) * 1
            elif neighbor_spin > 0:
              priorities[i * N**2 + j * N + k, 1] += np.exp(abs(total_spin)) * 1
        
  return(priorities)




#score: {'data3D.txt': 0.0410282}
#standard deviation: 0.04743122731661073
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20122379999999998}
#standard deviation: 0.044961132031567
#island_id: 2
#version_generated: 3
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2943926}
#standard deviation: 0.05286859394044824
#island_id: 2
#version_generated: 3
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # add interactions with nearest neighbors along each axis
        interacting_spins = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0895926000000001}
#standard deviation: 0.04558124598165347
#island_id: 3
#version_generated: 3
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.344765}
#standard deviation: 0.04532931077128793
#island_id: 3
#version_generated: 3
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if j > 0:
         neighbor_spin = J[1, i, j-1, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
         neighbor_spin = J[1, i, j+1, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
         neighbor_spin = J[2, i, j, k+1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k-1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1267970000000002}
#standard deviation: 0.045822538897359245
#island_id: 3
#version_generated: 3
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3813114}
#standard deviation: 0.04468088125854279
#island_id: 2
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors.append(J[2, i, l, k])
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        site_neighbors = [J[3, i, j, k], J[4, i, (j+1)%N, k]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum([J[d, i, j, k] for d in [3, 4]]))) * len([val for val in [J[d, i, j, k] for d in [3, 4]] if val > 0]) + sum([J[d, i, j, k] for d in [3, 4]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([J[d, i, j, k] for d in [3, 4]])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum([J[d, i, j, k] for d in [3, 4]]))) * len([val for val in [J[d, i, j, k] for d in [3, 4]] if val < 0]) + sum([J[d, i, j, k] for d in [3, 4]])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([J[d, i, j, k] for d in [3, 4]])
        
  return priorities




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.18718220000000002}
#standard deviation: 0.059013190077812264
#island_id: 2
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [0] * 6
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins[0] = sum(J[d, i, (j+1)%N, k] for d in [0, 1])
        interacting_spins[1] = sum(J[d, (i+1)%N, j, k] for d in [2, 3])
        interacting_spins[2] = sum(J[d, i, j, (k+1)%N] for d in [4, 5])
        total_spin = sum(J[d, i, j, k] for d in range(6))
        priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return priorities




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 2
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]] if val < 0]) + sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])

  return priorities




#score: {'data3D.txt': -0.46830259999999996}
#standard deviation: 0.03984016557746717
#island_id: 1
#version_generated: 3
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.26457500000000006}
#standard deviation: 0.04859668522646376
#island_id: 1
#version_generated: 3
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        interacting_spins = [h[i-1][j][k] if i > 0 else 0, h[i][(j+1)%N][k] if j < N-1 else 0, 
                   h[i][j][k-1] if k > 0 else 0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 3 * np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 3 * np.exp(-abs(total_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.46830259999999996}
#standard deviation: 0.03984016557746717
#island_id: 1
#version_generated: 3
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41358140000000004}
#standard deviation: 0.04051226300813125
#island_id: 1
#version_generated: 3
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins[2][i, j, :] if val < 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins[2][i, j, :] if val > 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': -0.41358140000000004}
#standard deviation: 0.04051226300813125
#island_id: 1
#version_generated: 3
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins[2][i, j, :] if val < 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins[2][i, j, :] if val > 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': -0.4018386}
#standard deviation: 0.04726056950609038
#island_id: 1
#version_generated: 3
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  h_flat = h.flatten()
  J_flatten = J.reshape(-1, N**3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = J_flatten[:, i * N * N + j * N + k]
        total_site_neighbors_spin = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in interacting_spins[2][i, j, :] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in interacting_spins[2][i, j, :] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0699494}
#standard deviation: 0.04967707519208433
#island_id: 3
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0699494}
#standard deviation: 0.04967707519208433
#island_id: 3
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0699494}
#standard deviation: 0.04967707519208433
#island_id: 3
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.23776380000000036}
#standard deviation: 0.04703389426318002
#island_id: 0
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = J[[0, 1, 2], i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.39885860000000023}
#standard deviation: 0.044867806343078555
#island_id: 0
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1])
        
        # Add the site neighbors' spin energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in [J[2, i, j, k], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in [J[2, i, j, k], J[0, i, (j + 1) % N, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in [J[2, i, j, k], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] += sum([val for val in [J[2, i, j, k], J[0, i, (j + 1) % N, k]] if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.2307106}
#standard deviation: 0.048682277346484115
#island_id: 0
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum([val for val in site_neighbors if val < 0])
          site_neighbors_sum += spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.18406460000000002}
#standard deviation: 0.0425611384579877
#island_id: 1
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        x = i
        y = j
        z = k
        
        # Calculate priority for -1
        p1 = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        p2 = sum(1 for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += p1
        priorities[i * N * N + j * N + k][1] -= p2
        
        # Calculate priority for 1
        p3 = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
        p4 = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] -= p3
        priorities[i * N * N + j * N + k][1] += p4
        
  return(priorities)




#score: {'data3D.txt': -0.046833400000000004}
#standard deviation: 0.04910445972047753
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.046833400000000004}
#standard deviation: 0.04910445972047753
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # add a small random value to the priority of the same spin
        if site_spin == 1:
          priorities[i * N * N + j * N + k][0] += np.random.uniform(-1, 1)
        elif site_spin == -1:
          priorities[i * N * N + j * N + k][1] += np.random.uniform(-1, 1)

  return(priorities)




#score: {'data3D.txt': -0.29395659999999996}
#standard deviation: 0.0481678066392897
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)

  return(priorities)




#score: {'data3D.txt': -0.046833400000000004}
#standard deviation: 0.04910445972047753
#island_id: 3
#version_generated: 3
#generate time09:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0131838}
#standard deviation: 0.04514768496346186
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (2*h[i,j,k]*np.roll(h, -1, axis=d)[i,j,k]-1) if d < 3 else J[d-3, i, j, k] * (2*h[i,j,k]*np.roll(h, 1, axis=(d-3)%3)[i,j,k]-1) for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.005185800000000001}
#standard deviation: 0.04285170239745441
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xx = np.roll(interacting_spins_x, 1, axis=0)
  interacting_spins_yy = np.roll(interacting_spins_y, 1, axis=1)
  interacting_spins_zz = np.roll(interacting_spins_z, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = sum(J[0, i, j, k] * (2*h[i,j,k]*interacting_spins_x[i,j,k]-1) for d in range(3))
        total_spin_y = sum(J[1, i, j, k] * (2*h[i,j,k]*interacting_spins_y[i,j,k]-1) for d in range(3))
        total_spin_z = sum(J[2, i, j, k] * (2*h[i,j,k]*interacting_spins_z[i,j,k]-1) for d in range(3))
        total_spin_xx = sum(J[3, i, j, k] * (2*h[i,j,k]*interacting_spins_xx[i,j,k]-1) for d in range(3))
        total_spin_yy = sum(J[4, i, j, k] * (2*h[i,j,k]*interacting_spins_yy[i,j,k]-1) for d in range(3))
        total_spin_zz = sum(J[5, i, j, k] * (2*h[i,j,k]*interacting_spins_zz[i,j,k]-1) for d in range(3))
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin_x - total_spin_y - total_spin_z - total_spin_xx - total_spin_yy - total_spin_zz
          priorities[i*N*N + j*N + k][1] = -2 * (total_spin_x + total_spin_y + total_spin_z + total_spin_xx + total_spin_yy + total_spin_zz)
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin_x - total_spin_y - total_spin_z - total_spin_xx - total_spin_yy - total_spin_zz
          priorities[i*N*N + j*N + k][1] = 2 * (total_spin_x + total_spin_y + total_spin_z + total_spin_xx + total_spin_yy + total_spin_zz)
  
  return(priorities)




#score: {'data3D.txt': 0.010676600000000001}
#standard deviation: 0.04562680541567643
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[2*d%6][i,j,k]-1) for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1080762}
#standard deviation: 0.05026028485355012
#island_id: 1
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j-1, k], J[0, i, j, k-1], J[0, i-1, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[2, i, j, k-1], J[2, i, j-1, k], J[2, i-1, j, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j-1, k], J[0, i, j, k-1], J[0, i-1, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[2, i, j, k-1], J[2, i, j-1, k], J[2, i-1, j, k]] if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4018386}
#standard deviation: 0.04726056950609038
#island_id: 1
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  h_flat = h.flatten()
  J_flatten = J.reshape(-1, N**3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = J_flatten[:, i * N * N + j * N + k]
        total_site_neighbors_spin = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in interacting_spins[2][i, j, :] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in interacting_spins[2][i, j, :] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
  
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23287779999999997}
#standard deviation: 0.04912205520089728
#island_id: 2
#version_generated: 3
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.18640140000000002}
#standard deviation: 0.05336849068542224
#island_id: 0
#version_generated: 3
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])

  return priorities




#score: {'data3D.txt': -0.1304902}
#standard deviation: 0.055120245136973035
#island_id: 0
#version_generated: 3
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])
        
        diagonal_spin = [J[0, i, (j + 1) % N, (k + 1) % N], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in diagonal_spin if val < 0]) - len([val for val in diagonal_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in diagonal_spin if val < 0]) - len([val for val in diagonal_spin if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.045885}
#standard deviation: 0.051040213312642024
#island_id: 1
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * np.sign(h[i, j, k]) for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        if np.sum(interacting_spins) > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (1 - 2 * h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (1 + 2 * h[i, j, k])
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.13093860000000002}
#standard deviation: 0.047544457826754115
#island_id: 1
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * np.sign(site_spin) for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * site_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * site_spin)
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if i > 0:
            left_spin = h[i-1][j][k]
            if J[2, i-1, j, k] > 0 and np.sign(left_spin) == site_spin:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * left_spin)
              priorities[i * N * N + j * N + k][1] -= 1
            elif J[2, i-1, j, k] < 0 and np.sign(left_spin) != site_spin:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * left_spin)
              priorities[i * N * N + j * N + k][1] += 1
          
          if j > 0:
            up_spin = h[i][j-1][k]
            if J[2, i, j-1, k] > 0 and np.sign(up_spin) == site_spin:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * up_spin)
              priorities[i * N * N + j * N + k][1] -= 1
            elif J[2, i, j-1, k] < 0 and np.sign(up_spin) != site_spin:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * up_spin)
              priorities[i * N * N + j * N + k][1] += 1
          
          if k > 0:
            front_spin = h[i][j][k-1]
            if J[2, i, j, k-1] > 0 and np.sign(front_spin) == site_spin:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2 * front_spin)
              priorities[i * N * N + j * N + k][1] -= 1
            elif J[2, i, j, k-1] < 0 and np.sign(front_spin) != site_spin:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + 2 * front_spin)
              priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44001419999999997}
#standard deviation: 0.04539529401116376
#island_id: 0
#version_generated: 3
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_energy = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbor_energy = sum([val for val in site_neighbors if val != 0])
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_energy)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin_energy
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_energy - site_neighbor_energy
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_energy)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin_energy
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_energy + site_neighbor_energy
  
  return(priorities)




#score: {'data3D.txt': -0.3821082}
#standard deviation: 0.04058021701223393
#island_id: 2
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add a new term based on the number of nearest neighbors with different spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val != total_spin])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * len([val for val in site_neighbors if val != total_spin])
        
  return(priorities)




#score: {'data3D.txt': -0.2851426}
#standard deviation: 0.04055728029885633
#island_id: 2
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2851426}
#standard deviation: 0.04055728029885633
#island_id: 2
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2339682}
#standard deviation: 0.039103426816073296
#island_id: 2
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [3, 4]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43548700000000007}
#standard deviation: 0.042658802503117696
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
            priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
            priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
            priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
            priorities[i * N * N + j * N + site_nbr][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.41607260000000007}
#standard deviation: 0.04716700509084715
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1553914}
#standard deviation: 0.04618540338721748
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(site_neighbors_total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - abs(site_neighbors_total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42765900000000007}
#standard deviation: 0.04737138713400738
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2215570000000002}
#standard deviation: 0.04492072696428677
#island_id: 2
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * priorities[i * N * N + j * N + k][0])
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * priorities[i * N * N + j * N + k][0])

  return(priorities)




#score: {'data3D.txt': -0.28622660000000044}
#standard deviation: 0.047371660435749974
#island_id: 2
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * priorities[i * N * N + j * N + k][0])
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * priorities[i * N * N + j * N + k][0])
          
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
          
  return priorities




#score: {'data3D.txt': -0.2215570000000002}
#standard deviation: 0.04492072696428677
#island_id: 2
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2,3,4,5]]
        
        site_neighbors = []
        for l in [(i+1)%N,(j+1)%N,(k+1)%N]:
          if l == i: 
            site_neighbors += [J[0,l,j,k], J[1,i,l,k]]
          elif l == j:
            site_neighbors += [J[2,i,l,k]]
          else:
            site_neighbors.append(J[4,i,j,l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * priorities[i * N * N + j * N + k][0])
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * priorities[i * N * N + j * N + k][0])
          
  return(priorities)




#score: {'data3D.txt': 0.0011066000000000003}
#standard deviation: 0.0446744244108416
#island_id: 3
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xx = np.roll(interacting_spins_x, -1, axis=0)
  interacting_spins_xy = np.roll(interacting_spins_y, -1, axis=1)
  interacting_spins_xz = np.roll(interacting_spins_z, -1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (4*h[i,j,k]*interacting_spins_x[i,j,k]+
                                              2*h[i,j,k]*interacting_spins_y[i,j,k]+
                                              2*h[i,j,k]*interacting_spins_z[i,j,k]) 
                         for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3362726000000002}
#standard deviation: 0.05010025997178059
#island_id: 1
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3362726000000002}
#standard deviation: 0.05010025997178059
#island_id: 1
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4027518}
#standard deviation: 0.04757065352462587
#island_id: 1
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4290606}
#standard deviation: 0.03924850733008836
#island_id: 1
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.06033139999999976}
#standard deviation: 0.048017232469604085
#island_id: 0
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] += 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] -= 2
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.2418614}
#standard deviation: 0.04366209099482067
#island_id: 0
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          for spin in [-1, 1]:
            if sum([val for val in interacting_spins if val < 0]) == 0 and total_spin >= 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif sum([val for val in interacting_spins if val > 0]) == 0 and total_spin <= 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            
            if J[2, i, j, k - 1] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            
            for d in [0, 1]:
              if (i + (d - 1) % 2 == 0):
                neighbor_spin = J[d, i + d, j, k]
              else:
                neighbor_spin = J[1 - d, i - d, j, k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': 0.0007013999999999998}
#standard deviation: 0.04946962702547898
#island_id: 3
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[5-d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.00013340000000000018}
#standard deviation: 0.04718061386247534
#island_id: 3
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[:, i, j, k] * interacting_spins[0][i, j, k])
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.421233}
#standard deviation: 0.048483923840794904
#island_id: 2
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        if (i+j+k) % 2 == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34505179999999996}
#standard deviation: 0.03967748677474419
#island_id: 2
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38193780000000005}
#standard deviation: 0.04400033376191595
#island_id: 1
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        interacting_spins = [h[i-1][j][k] if i > 0 else 0, h[i][(j+1)%N][k] if j < N-1 else 0, 
                   h[i][j][k-1] if k > 0 else 0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 3 * np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 3 * np.exp(-abs(total_spin))
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.12095339999999999}
#standard deviation: 0.04595832316827933
#island_id: 1
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        interacting_spins = [h[i-1][j][k] if i > 0 else 0, h[i][(j+1)%N][k] if j < N-1 else 0, 
                  h[i][j][k-1] if k > 0 else 0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_neighbors_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 3 * np.exp(-abs(total_spin)) + J[2, i, j, k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_neighbors_spin + np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 3 * np.exp(-abs(total_spin)) - J[2, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.38193780000000005}
#standard deviation: 0.04400033376191595
#island_id: 1
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        interacting_spins = [h[i-1][j][k] if i > 0 else 0, h[i][(j+1)%N][k] if j < N-1 else 0, 
                   h[i][j][k-1] if k > 0 else 0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 3 * np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + 3 * np.exp(-abs(total_spin))
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2128018}
#standard deviation: 0.049098568174235
#island_id: 0
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in J[0, i, j, :k+1] if val < 0]) + len([val for val in J[0, i, j, :k+1] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in J[0, i, j, :k+1] if val < 0]) + len([val for val in J[0, i, j, :k+1] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0008470000000000004}
#standard deviation: 0.049529042702236833
#island_id: 0
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.27022100000000016}
#standard deviation: 0.049666675336688296
#island_id: 0
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - total_neighbor_spin + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.31225100000000006}
#standard deviation: 0.05192087363479164
#island_id: 0
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': 0.0634734}
#standard deviation: 0.04496941819103289
#island_id: 3
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if h[(i+d)%N, (j+d)%N, k] > 0:
            total_spin += J[5-d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.00018420000000000009}
#standard deviation: 0.04636546764953418
#island_id: 3
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.14110419999999999}
#standard deviation: 0.048204423680405104
#island_id: 3
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = 0
        for d in range(6):
          if site_spin * J[d, (i+d)%N, (j+d)%N, k] > 0:
            total_neighbor_spin += -J[d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k]
          else:
            total_neighbor_spin += J[5-d, i, j, k] * h[i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.041323399999999996}
#standard deviation: 0.044784296493748786
#island_id: 0
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1 + site_neighbors[0]
        priorities[i * N * N + j * N + k][1] = -total_spin_2 - site_neighbors[0]
  
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1 + site_neighbors[0]
        priorities[i * N * N + j * N + k][1] = total_spin_2 + site_neighbors[0]
  
  return(priorities)




#score: {'data3D.txt': -0.00401419999999994}
#standard deviation: 0.04580411071465093
#island_id: 0
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1
        priorities[i * N * N + j * N + k][1] = total_spin_2
        
        # Calculate the priority based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_1)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_1)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_1
        
        # Add the site neighbors' spin energy and calculate the average
        avg_neighbor_spin = sum(site_neighbors) / len(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_1)) * (avg_neighbor_spin + total_spin_1)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * avg_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_1)) * (avg_neighbor_spin + total_spin_1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * avg_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1 + site_neighbors[0]
        priorities[i * N * N + j * N + k][1] = total_spin_2 + site_neighbors[0]
  
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3431558}
#standard deviation: 0.04837621322881732
#island_id: 2
#version_generated: 3
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[3:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0158294}
#standard deviation: 0.04621101833589041
#island_id: 0
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([J[d, i, j, k] for d in [0, 1, 2]]) < 0)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([J[d, i, j, k] for d in [0, 1, 2]]) > 0)
          priorities[i * N * N + j * N + k][1] = -1
          
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        for spin in [-1, 1]:
          if sum([site_neighbor * spin for site_neighbor in site_neighbors]) > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1 * spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1 * spin
          
  return(priorities)




#score: {'data3D.txt': -0.0026129999999999994}
#standard deviation: 0.04690373493656982
#island_id: 0
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in J[[0, 1], i, j, k] if val < 0]) - np.sum([val for val in J[[2], i, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in J[[0, 1], i, j, k] if val > 0]) - np.sum([val for val in J[[2], i, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.23282860000000033}
#standard deviation: 0.04633649212057382
#island_id: 0
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.46151460000000005}
#standard deviation: 0.041210521312402736
#island_id: 0
#version_generated: 3
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4699998}
#standard deviation: 0.039280425149939506
#island_id: 2
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4699998}
#standard deviation: 0.039280425149939506
#island_id: 2
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4699998}
#standard deviation: 0.039280425149939506
#island_id: 2
#version_generated: 3
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.2339682}
#standard deviation: 0.039103426816073296
#island_id: 2
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [3, 4]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2339682}
#standard deviation: 0.039103426816073296
#island_id: 2
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [3, 4]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.00011299999999999982}
#standard deviation: 0.05202804465862618
#island_id: 3
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0634734}
#standard deviation: 0.04496941819103289
#island_id: 3
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if h[(i+d)%N,(j+d)%N,k] > 0:
            total_spin += J[d,i,j,k]
          else:
            total_spin -= J[5-d,i,j,k]
        if h[i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.0006586}
#standard deviation: 0.05529561832586738
#island_id: 3
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0011609999999999995}
#standard deviation: 0.047618991578990834
#island_id: 3
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  interacting_spins = [np.roll(h,-1,axis=i) for i in range(3)]
  interacting_spins += [np.roll(h,1,axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,(i+d)%N,(j+d)%N,k]*interacting_spins[d][i,j,k] if h[(i+d)%N,(j+d)%N,k]>0 else J[5-d,i,j,k]*interacting_spins[5-d][i,j,k] for d in range(6))
        total_spin -= 2*J[3,i,j,k]*(h[i,j,k]**2)
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0002541999999999997}
#standard deviation: 0.04690538031356318
#island_id: 3
#version_generated: 3
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[5-d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        total_spin += -J[3, i, (j+1)%N, k]*h[i,(j+1)%N,k]
        total_spin += -J[4, i, j, (k+1)%N]*h[i,j,(k+1)%N]
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.47109979999999996}
#standard deviation: 0.03958630268110423
#island_id: 2
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = np.array([sum(J[d, i, j, k] for d in [0, 1, 2]) for i in range(N)])
        
        priorities[i * N * N + j * N + k][0] += total_spin - len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.5247613999999998}
#standard deviation: 0.0410760181862848
#island_id: 2
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.47013059999999995}
#standard deviation: 0.03920687316836169
#island_id: 2
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
          site_neighbors = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                    J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
          site_neighbors = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                    J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.33851939999999997}
#standard deviation: 0.043784471489787334
#island_id: 2
#version_generated: 3
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  return priorities




#score: {'data3D.txt': -0.3294793999999997}
#standard deviation: 0.044244372022213166
#island_id: 3
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if j < N-1:
          site_neighbors.append(J[1, i, j+1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        if k < N-1:
          site_neighbors.append(J[2, i, j, k+1])
        
        neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0:
          site_neighbors = []
          for d in [0, 1, 2]:
            if J[d, i-1, j, k] < 0:
              site_neighbors.append(1)
            elif J[d, i-1, j, k] > 0:
              site_neighbors.append(-1)
          neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.021618199999999924}
#standard deviation: 0.04465056269253503
#island_id: 3
#version_generated: 3
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if i < N-1:
          neighbor_spin = J[0, (i+1), j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0:
          neighbor_spin = J[0, (i-1), j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, (j+1), k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j > 0:
          neighbor_spin = J[1, i, (j-1), k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, (k+1)]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, (k-1)]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.015820599999999997}
#standard deviation: 0.047279581381818515
#island_id: 3
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          if h[i,j,k] > 0:
            priorities[i*N*N + j*N + k][0] += -J[d,i,j,k]*interacting_spins[2*d%6][i,j,k]
            priorities[i*N*N + j*N + k][1] = -2 * J[d,i,j,k]*interacting_spins[2*d%6][i,j,k]
          else:
            priorities[i*N*N + j*N + k][0] -= J[d,i,j,k]*interacting_spins[2*d%6][i,j,k]
            priorities[i*N*N + j*N + k][1] = 2 * J[d,i,j,k]*interacting_spins[2*d%6][i,j,k]

  return(priorities)




#score: {'data3D.txt': 0.010676600000000001}
#standard deviation: 0.04562680541567643
#island_id: 3
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[2*d%6][i,j,k]-1) for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.057099000000000004}
#standard deviation: 0.046713400208077335
#island_id: 3
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d in [0,1,2,3,4,5]
                   for a,b,c in itertools.product([-1,0,1], [-1,0,1], [-1,0,1])]
        
        total_spin = sum(val * (2*h[i,j,k]*val-1) for val in interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.311807}
#standard deviation: 0.042957592006535934
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[0, (i + 1) % N, j, k],
          J[0, i, j, (k + 1) % N],
          J[1, i, (j + 1) % N, k],
          J[1, i, j, (k + 1) % N],
          J[2, (i + 1) % N, j, k]
        ]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45874260000000006}
#standard deviation: 0.0438521920232045
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0035565999999999996}
#standard deviation: 0.04692066662399416
#island_id: 2
#version_generated: 3
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                  J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          
        return priorities




#score: {'data3D.txt': -0.18406460000000002}
#standard deviation: 0.0425611384579877
#island_id: 1
#version_generated: 3
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        x = i
        y = j
        z = k
        
        # Calculate priority for -1
        p1 = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        p2 = sum(1 for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += p1
        priorities[i * N * N + j * N + k][1] -= p2
        
        # Calculate priority for 1
        p3 = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
        p4 = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] -= p3
        priorities[i * N * N + j * N + k][1] += p4
        
  return(priorities)




#score: {'data3D.txt': 0.027406599999999972}
#standard deviation: 0.04664166717046037
#island_id: 0
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        
        site_neighbors = np.sum([J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]], axis=0)
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.sum(interacting_spins)) * len([val for val in interacting_spins if val < 0]) - site_neighbors
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin * (site_neighbors - sum(interacting_spins))
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum(interacting_spins)) * len([val for val in interacting_spins if val > 0]) - site_neighbors
            priorities[i * N * N + j * N + k][1] = -2 + 2 * spin * (site_neighbors - sum(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.38648340000000014}
#standard deviation: 0.044166708326974065
#island_id: 0
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1])
        
        # Add the site neighbors' spin energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in [J[2, i, j, k], J[0, i, (j+1)%N, k]] if val < 0]) + sum([J[2, i, j, k], J[0, i, (j+1)%N, k]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([J[2, i, j, k], J[0, i, (j+1)%N, k]])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * len([val for val in [J[2, i, j, k], J[0, i, (j+1)%N, k]] if val > 0]) + sum([J[2, i, j, k], J[0, i, (j+1)%N, k]])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([J[2, i, j, k], J[0, i, (j+1)%N, k]])
  
  return(priorities)




#score: {'data3D.txt': -0.20738540000000008}
#standard deviation: 0.04619626637337698
#island_id: 0
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1]]
        
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum([val for val in site_neighbors if val < 0])
          site_neighbors_sum += spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, i, j, (k+1)%N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum([val for val in site_neighbors if val < 0])
          site_neighbors_sum += spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.0064482}
#standard deviation: 0.048052774704068865
#island_id: 3
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h,-1,axis=i) for i in range(3)]
  interacting_spins += [np.roll(h,1,axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if h[(i+d)%N,(j+d)%N,k]>0:
            total_spin += J[d,i,j,k]*interacting_spins[d][i,j,k]
          else:
            total_spin -= J[5-d,i,j,k]*interacting_spins[5-d][i,j,k]

        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = 2*total_spin if h[i,j,k]>0 else -2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022582}
#standard deviation: 0.04489675280863862
#island_id: 3
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  interacting_spins = [np.roll(h,-1,axis=i) for i in range(3)]
  interacting_spins += [np.roll(h,1,axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,(i+d)%N,(j+d)%N,k]*interacting_spins[5-d][i,j,k] if h[(i+d)%N,(j+d)%N,k]>0 else J[3-d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
        total_spin -= 2*J[3,i,j,k]*(h[i,j,k]**2)
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0028166}
#standard deviation: 0.047389365942582515
#island_id: 3
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] if h[i, j, k] > 0 else -1) for d in range(6))
        local_energy = (2*h[i, j, k]**2) + sum(J[d, i, j, k]*(-1)**h[(i+d)%N, (j+d)%N, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.04502659999999999}
#standard deviation: 0.048601362660320536
#island_id: 3
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0006586}
#standard deviation: 0.05529561832586738
#island_id: 3
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.004010199999999999}
#standard deviation: 0.04817181100975964
#island_id: 3
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(6):
    interacting_spins = [np.roll(h, d, axis=axi) for axi, d in zip([0,1,2], [-1,1,-1])]
    interacting_spins += [np.roll(h, -d, axis=axi) for axi, d in zip([0,1,2], [1,1,1])]
    
    for i in range(N):
      for j in range(N):
        for k in range(N):
          total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0006586}
#standard deviation: 0.05529561832586738
#island_id: 3
#version_generated: 3
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        priorities[i * N * N + j * N + k][0] = -2 * total_spin
        priorities[i * N * N + j * N + k][1] = 4 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4200382}
#standard deviation: 0.038591784886941934
#island_id: 1
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val < 0)
  
  return priorities




#score: {'data3D.txt': -0.3089645999999999}
#standard deviation: 0.043023326543167234
#island_id: 1
#version_generated: 3
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4684774000000003}
#standard deviation: 0.061232680565528094
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  # Add a new term based on the total spin of the site's neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0007638000000000005}
#standard deviation: 0.049302672641145934
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  # Normalize the priorities
  min_val = np.min(priorities)
  max_val = np.max(priorities)

  for i in range(N**3):
    priorities[i][0] = (priorities[i][0] - min_val) / (max_val - min_val)
    priorities[i][1] = (priorities[i][1] - min_val) / (max_val - min_val)

  return(priorities)




#score: {'data3D.txt': 0.0266738}
#standard deviation: 0.052757278488944064
#island_id: 3
#version_generated: 3
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i, j, k] + interacting_spins[d][i, j, k]) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.00011299999999999982}
#standard deviation: 0.05202804465862618
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.0042382}
#standard deviation: 0.05080384887742266
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.00011299999999999982}
#standard deviation: 0.05202804465862618
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.00011299999999999982}
#standard deviation: 0.05202804465862618
#island_id: 3
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': -0.1198578}
#standard deviation: 0.051582861292875176
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)

        if sum(J[d, i, j, k] for d in range(6)) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)

  return(priorities)




#score: {'data3D.txt': -0.29395659999999996}
#standard deviation: 0.0481678066392897
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)

  return(priorities)




#score: {'data3D.txt': -0.0025062}
#standard deviation: 0.04581086204777204
#island_id: 3
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)

        # add a term that favors the current spin direction
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.2928698}
#standard deviation: 0.04823683123879511
#island_id: 3
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        
        if np.prod([np.sign(val) == 1 for val in J[:, i, j, k]]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - np.prod([np.sign(val) == 1 for val in J[:, i, j, k]]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - np.prod([np.sign(val) == 1 for val in J[:, i, j, k]]))
  
  return(priorities)




#score: {'data3D.txt': -0.20118180000000038}
#standard deviation: 0.04820342175364732
#island_id: 1
#version_generated: 3
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 3
#version_generated: 3
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 3
#version_generated: 3
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2344530000000002}
#standard deviation: 0.045278899622230195
#island_id: 3
#version_generated: 3
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[2, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0028166}
#standard deviation: 0.047389365942582515
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] if h[i, j, k] > 0 else -1) for d in range(6))
        
        local_energy = (2*h[i, j, k]**2) + sum(J[d, i, j, k]*(-1)**h[(i+d)%N, (j+d)%N, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028206000000000004}
#standard deviation: 0.04739338198145391
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * (-1)**h[(i+d)%N, (j+d)%N, k] for d in range(6))
        local_energy = (2*h[i, j, k]**2) + sum(J[d, i, j, k]*(-1)**h[(i+d)%N, (j+d)%N, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0028166}
#standard deviation: 0.047389365942582515
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] if h[i, j, k] > 0 else -1) for d in range(6)]
        
        site_neighbors = sum(interacting_spins)
        
        total_spin = sum(J[d, i, j, k]*(-1)**h[(i+d)%N, (j+d)%N, k] for d in range(6))
        
        local_energy = (2*h[i, j, k]**2) + site_neighbors
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': 0.00018420000000000009}
#standard deviation: 0.04636546764953418
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.00018420000000000009}
#standard deviation: 0.04636546764953418
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0020362000000000006}
#standard deviation: 0.04651637227428639
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.00018420000000000009}
#standard deviation: 0.04636546764953418
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.37554540000000003}
#standard deviation: 0.04844607082973809
#island_id: 2
#version_generated: 3
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.246261}
#standard deviation: 0.047303292052456564
#island_id: 2
#version_generated: 3
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 2
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2619394000000002}
#standard deviation: 0.04339367842946712
#island_id: 2
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_neighbors_total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2896970000000001}
#standard deviation: 0.04351331739824028
#island_id: 2
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2896970000000001}
#standard deviation: 0.04351331739824028
#island_id: 2
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_total_spin = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_total_spin = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1698902}
#standard deviation: 0.05510475754379108
#island_id: 2
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * sum([J[d, i, j, k] for d in [0, 1, 2]]) - 2 + 2 * sum(site_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.2145978}
#standard deviation: 0.052965981867232476
#island_id: 2
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Calculate priority for -1 and 1 spin at each site
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.10092980000000006}
#standard deviation: 0.049783474285750695
#island_id: 3
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        interacting_spin_sum = sum(interacting_spins)
        total_spin = np.sign(h[i, j, k]) * abs(interacting_spin_sum)
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.038996199999999995}
#standard deviation: 0.04540850344990462
#island_id: 3
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] * (h[(i+d)%N, j, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(3)]
        interacting_spins += [J[d, i, (j+d)%N, k] * (h[i, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(3)]
        interacting_spins += [J[d, (i+d)%N, j, k] * (h[(i+d)%N, j, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(3)]
        total_spin = sum(interacting_spins)
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.29395659999999996}
#standard deviation: 0.0481678066392897
#island_id: 3
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d-1)%N, (j+d-1)%N, (k+d-1)%N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin + np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.03145219999999996}
#standard deviation: 0.046662994708441076
#island_id: 3
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        site_spin = h[i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.162137}
#standard deviation: 0.05497562724517111
#island_id: 0
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0732158}
#standard deviation: 0.045100299226945265
#island_id: 0
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 1
#version_generated: 3
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)

        # Add spin-dependent term
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.3089645999999999}
#standard deviation: 0.043023326543167234
#island_id: 1
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.060752600000000004}
#standard deviation: 0.04705437485760491
#island_id: 2
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = min(2 - 2 * total_spin, 2 - 2 * np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = max(-2 + 2 * total_spin, -2 + 2 * np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
        
  return priorities




#score: {'data3D.txt': -0.28457860000000035}
#standard deviation: 0.0469326536863195
#island_id: 2
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * priorities[i * N * N + j * N + k][0])
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * priorities[i * N * N + j * N + k][0])
          
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
          
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))))
          
  return priorities




#score: {'data3D.txt': -0.40055060000000003}
#standard deviation: 0.04184195788487914
#island_id: 1
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + np.exp(-abs(total_spin)) * (site_neighbors[0] - site_neighbors[-1])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + np.exp(-abs(total_spin)) * (site_neighbors[0] - site_neighbors[-1])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.4200382}
#standard deviation: 0.038591784886941934
#island_id: 1
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val < 0)
  
  return priorities




#score: {'data3D.txt': -0.4200382}
#standard deviation: 0.038591784886941934
#island_id: 1
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val < 0)
  
  return priorities




#score: {'data3D.txt': -0.1553914}
#standard deviation: 0.04618540338721748
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(site_neighbors_total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - abs(site_neighbors_total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1553914}
#standard deviation: 0.04618540338721748
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(site_neighbors_total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - abs(site_neighbors_total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1867922}
#standard deviation: 0.0481071593337208
#island_id: 2
#version_generated: 3
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        site_neighbors = J[[0, 1, 2], (i+1)%N if i < N-1 else 0, j, k] + J[[3, 4, 5], i, (j+1)%N if j < N-1 else 0, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors[0])) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors)) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_neighbors[0])) * len([val for val in site_neighbors if val > 0]) - abs(sum(site_neighbors)) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        
        # Add spin-dependent term
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(neighbor_spin) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)
        
        # Add term to favor the same spin as the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        # Add spin-dependent term
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)

        # Add spin-dependent term
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """
  Improved version of priority_v1.
  This function calculates the priority score for each site based on its own spin and the spins of its neighboring sites.
  It uses a combination of terms to determine the likelihood that a site will flip from one state (up or down) to another.
  """
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)

        # Add spin-dependent term
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)

  return priorities




#score: {'data3D.txt': 0.007811}
#standard deviation: 0.04632993761057746
#island_id: 3
#version_generated: 3
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  total_spin = sum(J[d].flatten() * interacting_spins[d].flatten() for d in range(6))
  
  if h.mean() > 0:
    priorities[:,0] -= np.exp(-abs(total_spin)) * len([val for val in J.flatten() if val < 0]) + total_spin
    priorities[:,1] = -2 + 2 * total_spin
  else:
    priorities[:,0] += np.exp(-abs(total_spin)) * len([val for val in J.flatten() if val > 0]) + total_spin
    priorities[:,1] = 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.32653739999999976}
#standard deviation: 0.043977144532586464
#island_id: 3
#version_generated: 3
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if j < N-1:
          site_neighbors.append(J[1, i, j+1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        if k < N-1:
          site_neighbors.append(J[2, i, j, k+1])
        
        neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0 and h[i-1][j][k] != h[i][j][k]:
          site_neighbors = []
          for d in [0, 1, 2]:
            if J[d, i-1, j, k] < 0:
              site_neighbors.append(1)
            elif J[d, i-1, j, k] > 0:
              site_neighbors.append(-1)
          neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3373453999999997}
#standard deviation: 0.044017541263001045
#island_id: 3
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * 2*h[i][j][k] - J[d, i, j, k]**2 for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if j < N-1:
          site_neighbors.append(J[1, i, j+1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        if k < N-1:
          site_neighbors.append(J[2, i, j, k+1])
        
        neighbor_spin = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0:
          site_neighbors = []
          for d in [0, 1, 2]:
            if J[d, i-1, j, k] < 0:
              site_neighbors.append(1)
            elif J[d, i-1, j, k] > 0:
              site_neighbors.append(-1)
          neighbor_spin = sum(site_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][1] -= 1
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3364573999999997}
#standard deviation: 0.0449962863494311
#island_id: 3
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if j < N-1:
          site_neighbors.append(J[1, i, j+1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        if k < N-1:
          site_neighbors.append(J[2, i, j, k+1])
        
        neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0:
          site_neighbors = []
          for d in [0, 1, 2]:
            if J[d, i-1, j, k] < 0:
              site_neighbors.append(1)
            elif J[d, i-1, j, k] > 0:
              site_neighbors.append(-1)
          neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          site_neighbors = []
          for d in [0, 1, 2]:
            if J[d, i+1, j, k] < 0:
              site_neighbors.append(1)
            elif J[d, i+1, j, k] > 0:
              site_neighbors.append(-1)
          neighbor_spin = sum(site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.25223060000000036}
#standard deviation: 0.04559039442294834
#island_id: 2
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.027475000000000013}
#standard deviation: 0.04655278998083789
#island_id: 2
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [3, 4, 5]:
          site_neighbors = [J[d, i, (j+1)%N, k], J[d, (i+1)%N, j, k], J[d, i, j, (k+1)%N]]
          site_neighbors_total_spin = sum(site_neighbors)
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + len([val for val in J[2, :, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + len([val for val in J[2, :, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors.append(J[2, i, j, l])
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.43881140000000013}
#standard deviation: 0.042826939069235376
#island_id: 2
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add the interaction with its own magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3880486}
#standard deviation: 0.03946659344356946
#island_id: 2
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add the interaction with the diagonal neighbors
        site_neighbors = [J[3, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0022226}
#standard deviation: 0.04705207507900157
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.10607700000000009}
#standard deviation: 0.04444119655229819
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] * site_nbrs[d] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3:, i, j, k] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0022226}
#standard deviation: 0.04705207507900157
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val < 0 for val in site_neighbors) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0022226}
#standard deviation: 0.04705207507900157
#island_id: 2
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N, j, k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  # Add a new term based on the total spin of the site's neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.004221}
#standard deviation: 0.04417744672341307
#island_id: 3
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.3089074000000004}
#standard deviation: 0.04672348387310175
#island_id: 3
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -2 * np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -2 * np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 4 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.13442219999999983}
#standard deviation: 0.048658739268090376
#island_id: 0
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        neighbor_corr = sum(val * (val < 0) for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(neighbor_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(neighbor_corr)
        
  return priorities




#score: {'data3D.txt': -0.41607260000000007}
#standard deviation: 0.04716700509084715
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4690898}
#standard deviation: 0.039234688426951984
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.42044780000000004}
#standard deviation: 0.04172551156259202
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - neighbor_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - neighbor_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1023314000000001}
#standard deviation: 0.0448924445095163
#island_id: 2
#version_generated: 3
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] = total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          neighbor_spin = sum([J[d, i, (j+1)%N, k] for d in [0, 1]]) if j < N-1 else 0
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.020520600000000007}
#standard deviation: 0.04731769706610836
#island_id: 1
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)

        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(J[d, i, j, k])
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(J[d, i, j, k])
            priorities[i * N * N + j * N + k][1] += J[d, i, j, k]

  return priorities




#score: {'data3D.txt': -0.2672098000000004}
#standard deviation: 0.049324624519199334
#island_id: 1
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -np.abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= np.abs(neighbor_spin)
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] += np.abs(neighbor_spin)

        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * np.abs(J[d, i, j, k])
            priorities[i * N * N + j * N + k][1] += np.abs(J[d, i, j, k])
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * -np.abs(J[d, i, j, k])
            priorities[i * N * N + j * N + k][1] -= np.abs(J[d, i, j, k])

  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)
        
  return priorities




#score: {'data3D.txt': 0.2580402}
#standard deviation: 0.046318056349117245
#island_id: 0
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.5462386}
#standard deviation: 0.03953929273570786
#island_id: 1
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37196140000000005}
#standard deviation: 0.04186167973266243
#island_id: 2
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.0129378}
#standard deviation: 0.04671769526806733
#island_id: 0
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
            
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0732158}
#standard deviation: 0.045100299226945265
#island_id: 0
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

  return(priorities)




#score: {'data3D.txt': -0.37565980000000004}
#standard deviation: 0.04684945489501452
#island_id: 0
#version_generated: 3
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.17980379999999996}
#standard deviation: 0.04667535222748727
#island_id: 2
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
  
  return priorities




#score: {'data3D.txt': -0.37196140000000005}
#standard deviation: 0.04186167973266243
#island_id: 2
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        opposite_spin = sum([val for val in interacting_spins if val == 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin)
        priorities[i * N * N + j * N + k][1] -= opposite_spin
        
  return priorities




#score: {'data3D.txt': -0.06224100000000001}
#standard deviation: 0.058196785813307596
#island_id: 2
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (same_spin - different_spin) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.12265340000000019}
#standard deviation: 0.04534532289486977
#island_id: 3
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k] - J[5-d, i, j, k] * h[i, j, (k+d)%N] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.1557502}
#standard deviation: 0.04731829709488709
#island_id: 3
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, (k+d)%N] * (h[i, j, k] > 0) - J[5-d, i, j, k] * (h[(i+d)%N, (j+d)%N, k] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.03542100000000001}
#standard deviation: 0.04524890008607945
#island_id: 3
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1037902}
#standard deviation: 0.045135806893862
#island_id: 3
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.3159586}
#standard deviation: 0.04596946645372337
#island_id: 3
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i,j,k] if h[(i+d)%N, (j+d)%N, k]>0 else J[5-d,i,j,k]*interacting_spins[5-d][i,j,k] for d in range(6))
        total_spin -= 2*J[3,i,j,k]*(h[i,j,k]**2)
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += sum(J[5-d,i,j,k]*h[(i+d)%N,(j+d)%N,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] = 2
        else:
          priorities[i*N*N+j*N+k][0] -= sum(J[5-d,i,j,k]*h[(i+d)%N,(j+d)%N,k] for d in range(6))
          priorities[i*N*N+j*N+k][1] = -2

  return(priorities)




#score: {'data3D.txt': 0.001365399999999999}
#standard deviation: 0.04534568339809204
#island_id: 3
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0011609999999999995}
#standard deviation: 0.047618991578990834
#island_id: 3
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[5-d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        total_spin -= 2*J[3, i, j, k]*(h[i, j, k]**2)
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.00013260000000000043}
#standard deviation: 0.04764199300239234
#island_id: 3
#version_generated: 3
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i,j,k] if h[(i+d)%N, (j+d)%N, k]>0 else J[5-d,i,j,k]*interacting_spins[5-d][i,j,k] for d in range(6))
        total_spin -= 2*J[3,i,j,k]*(h[i,j,k]**2)
        total_spin -= sum(J[d, (i+d)%N, k, (j+d)%N] * interacting_spins[d][i,j,k] if h[(i+d)%N, k,(j+d)%N]>0 else J[5-d,i,k,(j+d)%N]*interacting_spins[5-d][i,j,k] for d in range(6))
        total_spin -= sum(J[d, i, (j+d)%N, k] * interacting_spins[d][i,j,k] if h[i,(j+d)%N,k]>0 else J[5-d,i,(j+d)%N,k]*interacting_spins[5-d][i,j,k] for d in range(6))
        
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49035500000000004}
#standard deviation: 0.04583132394989261
#island_id: 1
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors]) - len([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4408786}
#standard deviation: 0.039336759678956786
#island_id: 1
#version_generated: 2
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.023549799999999805}
#standard deviation: 0.045687528275887276
#island_id: 3
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  interacting_spins = [np.roll(h,-1,axis=i) for i in range(3)]
  interacting_spins += [np.roll(h,1,axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
        site_spin = int(h[i,j,k])
        if site_spin > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2*total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2*sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2*sum(J[d,i,j,k]*interacting_spins[d][i,j,k] for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.2915222000000001}
#standard deviation: 0.04592893104743458
#island_id: 3
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = h[i, j, k]
        if site_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.046833400000000004}
#standard deviation: 0.04910445972047753
#island_id: 3
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i, j, k] for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.046833400000000004}
#standard deviation: 0.04910445972047753
#island_id: 3
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N] * interacting_spins[d][i,j,k] for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4532802000000001}
#standard deviation: 0.0449390583786532
#island_id: 2
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          for neighbor, spin in zip(site_neighbors, neighbor_spins):
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val > 0])
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val < 0])

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          for neighbor, spin in zip(site_neighbors, neighbor_spins):
            if spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val < 0])
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val > 0])

  return priorities




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3257622000000001}
#standard deviation: 0.04200266147710167
#island_id: 2
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.48269500000000015}
#standard deviation: 0.04525692670741132
#island_id: 2
#version_generated: 3
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0860674}
#standard deviation: 0.05594849968712298
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.162137}
#standard deviation: 0.05497562724517111
#island_id: 0
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.22396939999999996}
#standard deviation: 0.04993586750663295
#island_id: 1
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors]) - len([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -site_energy
          priorities[i * N * N + j * N + k][1] = -2 * site_energy
        else:
          priorities[i * N * N + j * N + k][0] -= -site_energy
          priorities[i * N * N + j * N + k][1] = 2 * site_energy
        
  return(priorities)




#score: {'data3D.txt': -0.20893260000000027}
#standard deviation: 0.046792510268631675
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  # Calculate the priority for each site based on its magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * (1 - abs(np.sum(J[:, i, j, k])))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * (1 - abs(np.sum(J[:, i, j, k])))
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.0018666000000000004}
#standard deviation: 0.04619543791804555
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*interacting_spins[d][i, j, k]-1) for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return priorities




#score: {'data3D.txt': 0.0021758}
#standard deviation: 0.04609875415192909
#island_id: 3
#version_generated: 3
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  # Calculate the priority for each spin based on its energy and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = sum(J[d, i, j, k] * h[i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += site_energy
          priorities[i * N * N + j * N + k][1] -= site_energy
        else:
          priorities[i * N * N + j * N + k][0] -= site_energy
          priorities[i * N * N + j * N + k][1] = -site_energy

  return(priorities)




#score: {'data3D.txt': -0.13442219999999983}
#standard deviation: 0.048658739268090376
#island_id: 0
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        neighbor_corr = sum(val * (val < 0) for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(neighbor_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(neighbor_corr)
        
  return priorities




#score: {'data3D.txt': -0.30939739999999993}
#standard deviation: 0.04525637052658994
#island_id: 0
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        
  return priorities




#score: {'data3D.txt': -0.19118700000000002}
#standard deviation: 0.04777792577121782
#island_id: 0
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        neighbor_corr = sum(val * (val < 0) for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(neighbor_corr)
        
  return priorities




#score: {'data3D.txt': -0.013955400000000001}
#standard deviation: 0.04764278466714556
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.06224100000000001}
#standard deviation: 0.058196785813307596
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (same_spin - different_spin) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.013999399999999983}
#standard deviation: 0.04511485741571174
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        site_neighbors_sum = sum(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - site_neighbors_sum
        priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.23649540000000002}
#standard deviation: 0.05445196763056409
#island_id: 2
#version_generated: 3
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (same_spin - different_spin) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0])
        site_neighbors_diff = sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum - site_neighbors_diff) + total_spin
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4958174}
#standard deviation: 0.042108595526804266
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.42236619999999997}
#standard deviation: 0.04148075141026257
#island_id: 1
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 - 1) >= N:
            continue
          neighbor = J[d, i + (d - 1) % 2 - 1, j, k]
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 1
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3790554}
#standard deviation: 0.041795800875686066
#island_id: 1
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.47537300000000005}
#standard deviation: 0.0398653547707781
#island_id: 1
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        site_nbr_mag = h[site_nbr, (j - 1) % N, (k - 1) % N]
        if site_nbr_mag > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_nbr_mag < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.38826499999999997}
#standard deviation: 0.04226946480616948
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_mag = h[i, (j - 1) % N, (k - 1) % N]
        if site_nbr_mag > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.47537300000000005}
#standard deviation: 0.0398653547707781
#island_id: 1
#version_generated: 3
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        site_nbr_mag = h[site_nbr, (j - 1) % N, (k - 1) % N]
        if site_nbr_mag > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_nbr_mag < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4481614}
#standard deviation: 0.03944309711521143
#island_id: 1
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 - 1) >= N:
            continue
          neighbor = J[d, i + (d - 1) % 2 - 1, j, k]
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2]:
          if (i + (d - 1) % 3 - 1) >= N:
            continue
          neighbor = J[d, i + (d - 1) % 3 - 1, j, k]
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.42236619999999997}
#standard deviation: 0.04148075141026257
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 - 1) >= N:
            continue
          neighbor = J[d, i + (d - 1) % 2 - 1, j, k]
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.36257100000000003}
#standard deviation: 0.040210406600779354
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, : , :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.3790554}
#standard deviation: 0.041795800875686066
#island_id: 1
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.011434999999999999}
#standard deviation: 0.044272831567452285
#island_id: 3
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, (j+1)%N, k], J[1, i, j, k], J[2, i, (j-1)%N, k],
                              J[3, (i+1)%N, j, k], J[4, (i-1)%N, j, k]]
        interacting_spins.sort()
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = sum([a for a in interacting_spins if a < 0])
          priorities[i * N * N + j * N + k][1] = -sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = -sum([a for a in interacting_spins if a > 0])
          priorities[i * N * N + j * N + k][1] = sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': 0.14110419999999999}
#standard deviation: 0.048204423680405104
#island_id: 3
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = 0
        for d in range(6):
          if site_spin * J[d, (i+d)%N, (j+d)%N, k] > 0:
            total_neighbor_spin += -J[d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k]
          else:
            total_neighbor_spin += J[5-d, i, j, k] * h[i, j, k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': 0.00018420000000000009}
#standard deviation: 0.04636546764953418
#island_id: 3
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = 0
        interacting_spins = [J[5-d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k] for d in range(6)]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= -sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 * sum(interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.1437078}
#standard deviation: 0.047025991315016426
#island_id: 3
#version_generated: 3
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = 0
        for d in range(6):
          if site_spin * J[d, (i+d)%N, (j+d)%N, k] > 0:
            total_neighbor_spin += -J[d, (i+d)%N, (j+d)%N, k] * h[(i+d)%N, (j+d)%N, k]
          else:
            total_neighbor_spin += J[5-d, i, j, k] * h[i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.48243020000000003}
#standard deviation: 0.04016253985942622
#island_id: 2
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.348601}
#standard deviation: 0.04278436582444573
#island_id: 2
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [2]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4958174}
#standard deviation: 0.042108595526804266
#island_id: 2
#version_generated: 3
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.030048599999999995}
#standard deviation: 0.04753496563625559
#island_id: 2
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
        
        # Add a new term based on the total spin of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(total_spin)
        priorities[i * N * N + j * N + k][1] -= abs(total_spin)
        
  return priorities




#score: {'data3D.txt': -0.002397}
#standard deviation: 0.04728801572280233
#island_id: 2
#version_generated: 3
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        opposite_spin = sum([val for val in interacting_spins if val != h[i][j][k]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin) / 2
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
  return priorities




#score: {'data3D.txt': -0.3678134}
#standard deviation: 0.04990118415869507
#island_id: 0
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.37565980000000004}
#standard deviation: 0.04684945489501452
#island_id: 0
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.37565980000000004}
#standard deviation: 0.04684945489501452
#island_id: 0
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4363525999999999}
#standard deviation: 0.047478255583372056
#island_id: 0
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for spin in interacting_spins if spin < 0)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - sum(1 for spin in interacting_spins if spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for spin in interacting_spins if spin > 0)
          priorities[i * N * N + j * N + k][1] = -len(interacting_spins) + sum(1 for spin in interacting_spins if spin < 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4374458}
#standard deviation: 0.03945588755002224
#island_id: 1
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's diagonals
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            diagonal_spin = J[d, i + d, j, k]
          else:
            diagonal_spin = J[1 - d, i - d, j, k]
          if diagonal_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif diagonal_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4317082}
#standard deviation: 0.03942971180163507
#island_id: 1
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's diagonals
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            diagonal_spin = J[d, i + d, j, k]
          else:
            diagonal_spin = J[1 - d, i - d, j, k]
          if diagonal_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif diagonal_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [3]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4374458}
#standard deviation: 0.03945588755002224
#island_id: 1
#version_generated: 3
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's diagonals
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            diagonal_spin = J[d, i + d, j, k]
          else:
            diagonal_spin = J[1 - d, i - d, j, k]
          if diagonal_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif diagonal_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2376666}
#standard deviation: 0.04962177429758029
#island_id: 0
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        neighbor_corr = sum(val * (val < 0) for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(neighbor_corr)
        
  return priorities




#score: {'data3D.txt': -0.22701380000000002}
#standard deviation: 0.04798491439567231
#island_id: 0
#version_generated: 3
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - sum(interacting_spins) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - sum(interacting_spins) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        neighbor_corr = sum(val * (val < 0) for val in interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * abs(neighbor_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(neighbor_corr)
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        site_corr = sum(val * (val < 0) for val in interacting_spins[1:])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * abs(site_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(sum(interacting_spins))) * abs(site_corr)
        
  return(priorities)




#score: {'data3D.txt': -0.2827698}
#standard deviation: 0.043731431350460044
#island_id: 0
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 / 2) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 / 2) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - (1 / 2) * total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - (1 / 2) * total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

  return(priorities)




#score: {'data3D.txt': -0.0732158}
#standard deviation: 0.045100299226945265
#island_id: 0
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

  return(priorities)




#score: {'data3D.txt': -0.0757418}
#standard deviation: 0.04464826640262755
#island_id: 0
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

  return(priorities)




#score: {'data3D.txt': -0.3354742}
#standard deviation: 0.05020031528148006
#island_id: 0
#version_generated: 3
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 + total_site_neighbors_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 + total_site_neighbors_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.21346099999999998}
#standard deviation: 0.04966663748433147
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2827698}
#standard deviation: 0.043731431350460044
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 / 2) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 / 2) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - (1 / 2) * total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - (1 / 2) * total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin

  return(priorities)




#score: {'data3D.txt': -0.2754738}
#standard deviation: 0.049729672767473546
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2739334}
#standard deviation: 0.04361877215649244
#island_id: 0
#version_generated: 3
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 / 2) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - (1 / 2) * total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 / 2) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - (1 / 2) * total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0028166}
#standard deviation: 0.047389365942582515
#island_id: 3
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = sum(J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] + h[i, j, k]) // 2) for d in range(6))
        
        total_spin = sum(J[d, i, j, k]*(-1)**h[(i+d)%N, (j+d)%N, k] for d in range(6))

        local_energy = (2*h[i, j, k]**2) + site_neighbors

        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': 0.026694600000000013}
#standard deviation: 0.044726794327785216
#island_id: 3
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = h[i, j, k]**2 + sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        site_energy -= np.sum([J[d, (i+d)%N, (j+d)%N, k]*h[(i+d)%N, (j+d)%N, k] for d in range(6)])

        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] = -2*site_energy
          priorities[i*N*N+j*N+k][1] = 4*site_energy
        else:
          priorities[i*N*N+j*N+k][0] = 2*site_energy
          priorities[i*N*N+j*N+k][1] = -4*site_energy

  return(priorities)




#score: {'data3D.txt': -0.0006586}
#standard deviation: 0.05529561832586738
#island_id: 3
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        priorities[i*N*N+j*N+k][0] = -2*total_spin
        priorities[i*N*N+j*N+k][1] = 4*total_spin

  return(priorities)




#score: {'data3D.txt': -0.07522740000000004}
#standard deviation: 0.04683560364978763
#island_id: 3
#version_generated: 3
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        site_neighbors = sum(J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] if h[i, j, k] > 0 else -1) for d in range(6))
        
        local_energy = (2*h[i, j, k]**2) + site_neighbors
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin + local_energy
          priorities[i*N*N+j*N+k][1] = 2*total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.4317082}
#standard deviation: 0.03942971180163507
#island_id: 1
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's diagonals
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            diagonal_spin = J[d, i + d, j, k]
          else:
            diagonal_spin = J[1 - d, i - d, j, k]
          if diagonal_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif diagonal_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's corners
        for d in [3]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4317082}
#standard deviation: 0.03942971180163507
#island_id: 1
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's diagonals
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            diagonal_spin = J[d, i + d, j, k]
          else:
            diagonal_spin = J[1 - d, i - d, j, k]
          if diagonal_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif diagonal_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's corners
        for d in [3]:
          if (i + (d - 1) % 2 == 0):
            corner_spin = J[d, i + d, j, k]
          else:
            corner_spin = J[1 - d, i - d, j, k]
          if corner_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif corner_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.23918179999999994}
#standard deviation: 0.04049032808906344
#island_id: 1
#version_generated: 3
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        corner_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in corner_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(corner_neighbors) - sum(1 for neighbor in corner_neighbors if neighbor > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3257622000000001}
#standard deviation: 0.04200266147710167
#island_id: 2
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
  
  return(priorities)




#score: {'data3D.txt': -0.3257622000000001}
#standard deviation: 0.04200266147710167
#island_id: 2
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.27313980000000004}
#standard deviation: 0.04506050172778815
#island_id: 2
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        
        for d in range(3):
          interacting_spins[d] += -J[d, i, j, k]*h[i][j][k]
          
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins]) - np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(val)) for val in interacting_spins]) + np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2
        
        for neighbor, spin in zip(site_neighbors, interacting_spins):
          if spin < 0:
            if h[neighbor][j][k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin)) - spin
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(spin)) - spin
          else:
            if h[neighbor][j][k] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(spin)) - spin
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin)) - spin
        
  return priorities




#score: {'data3D.txt': -0.4532802000000001}
#standard deviation: 0.0449390583786532
#island_id: 2
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          for neighbor, spin in zip(site_neighbors, neighbor_spins):
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val > 0])
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val < 0])

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          for neighbor, spin in zip(site_neighbors, neighbor_spins):
            if spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val < 0])
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - len([val for val in [J[0, neighbor, j, k], J[1, i, neighbor, k], J[2, i, j, neighbor]] if val > 0])

  return priorities




#score: {'data3D.txt': -0.019949}
#standard deviation: 0.04677022042924322
#island_id: 3
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] - J[5-d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k]
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - sum([val for val in interacting_spins if val < 0]) - 3 * (1 if neighbor_spin > 0 else -1)
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - sum([val for val in interacting_spins if val > 0]) + 3 * (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.060973000000000006}
#standard deviation: 0.04617596551237451
#island_id: 3
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j+d)%N, (k+d)%N] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.06061259999999995}
#standard deviation: 0.0438154936208643
#island_id: 3
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.06061259999999995}
#standard deviation: 0.0438154936208643
#island_id: 3
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0020473999999999996}
#standard deviation: 0.04652957718741918
#island_id: 3
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  interacting_spins = [np.roll(h,-1,axis=i) for i in range(3)]
  interacting_spins += [np.roll(h,1,axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,(i+d)%N,(j+d)%N,k]*(2*h[(i+d)%N,(j+d)%N,k]*interacting_spins[5-d][i,j,k]-1) for d in range(6))
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.005686599999999995}
#standard deviation: 0.046797192869230946
#island_id: 3
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * (2*h[(i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] - 1) for d in range(6))
        total_spin -= 2 * J[3, i, j, k] * (h[i, j, k]**2)
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, (i+d)%N, (j+d)%N, k] * (2*h[(i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] - 1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, (i+d)%N, (j+d)%N, k] * (2*h[(i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] - 1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i, j, k] * interacting_spins[5-d][i, j, k] - 1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i, j, k] * interacting_spins[5-d][i, j, k] - 1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.0104002}
#standard deviation: 0.04535559193704785
#island_id: 3
#version_generated: 3
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h,-1,axis=i) for i in range(3)]
  interacting_spins += [np.roll(h,1,axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,(i+d)%N,(j+d)%N,k]*(2*h[i,j,k]*interacting_spins[5-d][i,j,k]-1) for d in range(6))
        if h[i,j,k]>0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k]>0:
          total_spin = sum(J[d,(i+d)%N,(j+d)%N,k]*(2*h[(i+d)%N,(j+d)%N,k]*interacting_spins[5-d][i,j,k]-1) for d in range(6))
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin
        else:
          total_spin = sum(J[d,i,j,k]*(2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N+j*N+k][0] -= -total_spin
          priorities[i*N*N+j*N+k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.36257100000000003}
#standard deviation: 0.040210406600779354
#island_id: 1
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, : , :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.36257100000000003}
#standard deviation: 0.040210406600779354
#island_id: 1
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.36257100000000003}
#standard deviation: 0.040210406600779354
#island_id: 1
#version_generated: 3
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': -0.3918678}
#standard deviation: 0.041449094600003025
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_mag = h[i, (j - 1) % N, (k - 1) % N]
        if site_nbr_mag > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i, j, k]
          elif (j + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i, (j + 1) % N, k]
          elif (k + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i, j, (k + 1) % N]
          else:
            continue
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.5136594}
#standard deviation: 0.040191916993843425
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_mag = h[i, (j - 1) % N, (k - 1) % N]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum([val > 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum([val < 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3888962}
#standard deviation: 0.042998431431390614
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_mag = h[i, (j - 1) % N, (k - 1) % N]
        if site_nbr_mag > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i, j, k]
          elif (j + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i, (j + 1) % N, k]
          else:
            neighbor_spin = J[2, i, j, (k + 1) % N]
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.38826499999999997}
#standard deviation: 0.04226946480616948
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_mag = h[i, (j - 1) % N, (k - 1) % N]
        if site_nbr_mag > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.06147139999999999}
#standard deviation: 0.05256325924103261
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3142633999999999}
#standard deviation: 0.04462581338687285
#island_id: 0
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        
        # Calculate the priority for assigning a spin of 0
        if site_spin == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (1 + total_spin)
        
  return priorities




#score: {'data3D.txt': -0.1154502000000001}
#standard deviation: 0.04695497843637031
#island_id: 0
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        
        # Calculate the priority for assigning a spin of -1 or 1 based on magnetism at the site
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (2 - total_spin)
        priorities[i * N * N + j * N + k][1] -= np.exp(h[i][j][k]) * (2 - total_spin)
        
  return priorities




#score: {'data3D.txt': -0.2965702}
#standard deviation: 0.046985776059995016
#island_id: 0
#version_generated: 3
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': 0.025069400000000002}
#standard deviation: 0.04676278716714819
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*int(interacting_spins[d][i, j, k]) - 1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.15418459999999998}
#standard deviation: 0.04625874839249328
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i, j, k] if d % 2 == 0 else -h[i, j, k]) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.001365399999999999}
#standard deviation: 0.04534568339809204
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.14839340000000015}
#standard deviation: 0.04381634668066244
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[5-d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        total_spin += -J[3, i, (j+1)%N, k]*h[i,(j+1)%N,k]
        total_spin += -J[4, i, j, (k+1)%N]*h[i,j,(k+1)%N]

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2][i, j, :] if val < 0]) - 2*total_spin
          priorities[i * N * N + j * N + k][1] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2][i, j, :] if val > 0]) - 2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2][i, j, :] if val < 0]) + 2*total_spin
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2][i, j, :] if val > 0]) - 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.0002541999999999997}
#standard deviation: 0.04690538031356318
#island_id: 3
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] if h[(i+d)%N, (j+d)%N, k] > 0 else J[5-d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
        total_spin += -J[3, i, (j+1)%N, k]*h[i,(j+1)%N,k]
        total_spin += -J[4, i, j, (k+1)%N]*h[i,j,(k+1)%N]

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2*total_spin

  return(priorities)




#score: {'data3D.txt': -0.07047740000000015}
#standard deviation: 0.04454271533303735
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.07047740000000015}
#standard deviation: 0.04454271533303735
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(interacting_spins)
        site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': 0.058650199999999944}
#standard deviation: 0.0455169164153285
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.32624979999999976}
#standard deviation: 0.04518143468240024
#island_id: 3
#version_generated: 3
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 1
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 1
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 1
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.0860674}
#standard deviation: 0.05594849968712298
#island_id: 0
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0860674}
#standard deviation: 0.05594849968712298
#island_id: 0
#version_generated: 3
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0860674}
#standard deviation: 0.05594849968712298
#island_id: 0
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0860674}
#standard deviation: 0.05594849968712298
#island_id: 0
#version_generated: 3
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 2
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49269939999999995}
#standard deviation: 0.0410124303064327
#island_id: 2
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5289306}
#standard deviation: 0.041743397365811036
#island_id: 2
#version_generated: 3
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.49269939999999995}
#standard deviation: 0.0410124303064327
#island_id: 2
#version_generated: 3
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.13442219999999983}
#standard deviation: 0.048658739268090376
#island_id: 0
#version_generated: 3
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the correlation between the site's spin and its neighbors' spins
        neighbor_corr = sum(val * (val < 0) for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(neighbor_corr)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(neighbor_corr)
        
        # Add a new term based on the local field
        local_field = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(local_field)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * abs(local_field)
  
  return priorities




#score: {'data3D.txt': -0.2753454}
#standard deviation: 0.14751194588520622
#island_id: 1
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]
  
  site_interactions = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interaction = J[0, i, j, k] * h[i, j, k]
        if h[i, j, k] > 0:
          interaction += np.sum([J[d, i, j, k] for d in [1, 2]])
        else:
          interaction -= np.sum([J[d, i, j, k] for d in [1, 2]])
        site_interactions.append(interaction)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k]) - site_interactions[i * N * N + j * N + k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k]) - site_interactions[i * N * N + j * N + k]
  
  return(priorities)




#score: {'data3D.txt': -0.36257100000000003}
#standard deviation: 0.040210406600779354
#island_id: 1
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, : , :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.36257100000000003}
#standard deviation: 0.040210406600779354
#island_id: 1
#version_generated: 3
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in range(6)]
  interacting_spin_sums = [np.sum(spin) for spin in interacting_spins]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val < 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, k]))) * len([val for val in interacting_spin_sums if val > 0]) - (1 - h[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, k])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k]))) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*interacting_spins[d][i,j,k]-1) for d in range(6))
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i,j,k]*J[d, i-1 if i>0 else N-1, j, k]-1) for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, i, j, k] * (2*h[i,j,k]*J[d, i-1 if i>0 else N-1, j, k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, i, j, k] * (2*h[i,j,k]*J[d, i-1 if i>0 else N-1, j, k]-1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i,j,k]*J[d, i-1 if i>0 else N-1, j, k]-1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i,j,k]*J[d, i-1 if i>0 else N-1, j, k]-1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 0
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        # Calculate the priority based on the interactions
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.212909}
#standard deviation: 0.049116823176993035
#island_id: 0
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3186953999999998}
#standard deviation: 0.04657054754713539
#island_id: 0
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d,i,j,k] * site_spin for d in range(6))
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = sum(site_spin * J[d,i,j,k] for d in range(6) if i+(d-1)%2==0 or j+(d-3)//2==0 or k+(d-6)//3==0)
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        
        # Calculate the priority for assigning a spin of 0
        if site_spin == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = -np.exp(-abs(total_spin)) * (1 + total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.21346099999999998}
#standard deviation: 0.04966663748433147
#island_id: 0
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0009062000000000001}
#standard deviation: 0.04365226089860639
#island_id: 3
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  # Normalize the priorities
  min_val = np.min(priorities, axis=0)[0]
  max_val = np.max(priorities, axis=0)[0]

  for i in range(N**3):
    priorities[i][0] = (priorities[i][0] - min_val) / (max_val - min_val)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data3D.txt': -0.0810682}
#standard deviation: 0.044818426888501996
#island_id: 3
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        # Calculate priority values
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (np.exp(-total_spin) + np.exp(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (np.exp(-total_spin) + np.exp(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.3193705999999999}
#standard deviation: 0.04472220182012508
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * 2*h[i][j][k] - J[d, i, j, k]**2 for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          site_neighbors.append(np.exp(-abs(total_spin)) * (neighbor_spin < 0) - np.exp(-abs(total_spin)) * (neighbor_spin > 0))
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          site_neighbors.append(np.exp(-abs(total_spin)) * (neighbor_spin < 0) - np.exp(-abs(total_spin)) * (neighbor_spin > 0))
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          site_neighbors.append(np.exp(-abs(total_spin)) * (neighbor_spin < 0) - np.exp(-abs(total_spin)) * (neighbor_spin > 0))
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          site_neighbors.append(np.exp(-abs(total_spin)) * (neighbor_spin < 0) - np.exp(-abs(total_spin)) * (neighbor_spin > 0))

        priorities[i * N * N + j * N + k][0] += np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.16351659999999998}
#standard deviation: 0.04638337163725811
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * 2*h[i][j][k] - J[d, i, j, k]**2 for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.16351659999999998}
#standard deviation: 0.04638337163725811
#island_id: 3
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * 2*h[i][j][k] - J[d, i, j, k]**2 for d in [0, 1, 2])
        
        site_neighbors = []
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.47771220000000003}
#standard deviation: 0.04073562189484776
#island_id: 1
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a term based on the spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4408786}
#standard deviation: 0.039336759678956786
#island_id: 1
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in interacting_spins if neighbor < 0)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - sum(1 for neighbor in interacting_spins if neighbor > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for neighbor in interacting_spins if neighbor > 0)
          priorities[i * N * N + j * N + k][1] = -len(interacting_spins) + sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.348569}
#standard deviation: 0.03873814294722967
#island_id: 1
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in site_neighbors if neighbor < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for neighbor in site_neighbors if neighbor > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3142633999999999}
#standard deviation: 0.04462581338687285
#island_id: 0
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        
        # Calculate the priority for assigning a spin of 0
        if site_spin == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (1 + total_spin)
        
  return priorities




#score: {'data3D.txt': -0.2965702}
#standard deviation: 0.046985776059995016
#island_id: 0
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the priority for assigning a spin of 0
        if site_spin == 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (1 + total_spin)
        
  return priorities




#score: {'data3D.txt': -0.06637300000000036}
#standard deviation: 0.04851044455578614
#island_id: 0
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if site_spin * neighbor_spin > 0:
            neighbor_corr += 1
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr + np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr - np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.0005010000000000003}
#standard deviation: 0.04461905421453933
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  
  return np.array([priorities.flatten(), np.zeros(N**3)]).T




#score: {'data3D.txt': -0.162137}
#standard deviation: 0.05497562724517111
#island_id: 0
#version_generated: 3
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.17140099999999997}
#standard deviation: 0.053099312603836976
#island_id: 0
#version_generated: 3
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.162137}
#standard deviation: 0.05497562724517111
#island_id: 0
#version_generated: 3
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.06147139999999999}
#standard deviation: 0.05256325924103261
#island_id: 1
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.06147139999999999}
#standard deviation: 0.05256325924103261
#island_id: 1
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.06147139999999999}
#standard deviation: 0.05256325924103261
#island_id: 1
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.06611099999999988}
#standard deviation: 0.0559006114367276
#island_id: 1
#version_generated: 3
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(3):
    interacting_spins = [np.roll(h, -1, axis=i), np.roll(h, 1, axis=i)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        interacting_spin = sum([val < 0 for val in J[:, i, j, k]]) - len([val > 0 for val in J[:, i, j, k]])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * interacting_spin + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0301214}
#standard deviation: 0.04539228240615358
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :k+1] if val < 0]) + len([val for val in J[:3, i, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :k+1] if val > 0]) + len([val for val in J[:3, i, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.4045846}
#standard deviation: 0.04287671585884348
#island_id: 3
#version_generated: 3
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([spin for spin in site_neighbors if spin > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
        priorities[i * N * N + j * N + k][1] -= 1

        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.17980379999999996}
#standard deviation: 0.04667535222748727
#island_id: 2
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.004665400000000001}
#standard deviation: 0.047316991481285035
#island_id: 2
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
        
        # Add a new term based on the number of nearest neighbors with different spin
        diff_neighbors = len([val for val in site_neighbors if val != 0 and val != h[i][j][k]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * diff_neighbors
        priorities[i * N * N + j * N + k][1] -= diff_neighbors
        
  return priorities




#score: {'data3D.txt': -0.017372199999999994}
#standard deviation: 0.04749989207524582
#island_id: 2
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        opposite_spin = sum([val for val in interacting_spins if val * h[i][j][k] < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin - same_spin)
        priorities[i * N * N + j * N + k][1] -= opposite_spin - same_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin)
          priorities[i * N * N + j * N + k][1] -= same_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (same_spin)
          priorities[i * N * N + j * N + k][1] = -same_spin
        
  return priorities




#score: {'data3D.txt': -0.17980379999999996}
#standard deviation: 0.04667535222748727
#island_id: 2
#version_generated: 3
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 2
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.00013340000000000018}
#standard deviation: 0.04718061386247534
#island_id: 3
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[:, i, j, k] * interacting_spins[0][i, j, k])
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.14685900000000002}
#standard deviation: 0.0496244729846071
#island_id: 3
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[:, i, j, k] * (h[i, j, k] + interacting_spins[0][i, j, k]))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0005009999999999997}
#standard deviation: 0.04586100215869689
#island_id: 3
#version_generated: 3
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[:, i, (j + i) % N, k] * h[(i + j) % N, (k + 2) % N, 0])
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.16431620000000022}
#standard deviation: 0.04808498120577777
#island_id: 3
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': 0.34098259999999964}
#standard deviation: 0.04433836687610403
#island_id: 3
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if J[d, (i+d)%N, (j+d)%N, k] > 0:
            total_spin += J[d, (i+d)%N, (j+d)%N, k]
          else:
            total_spin -= J[d, (i+d)%N, (j+d)%N, k]

        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, (i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * interacting_spins[5-d][i, j, k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': -0.005686599999999995}
#standard deviation: 0.046797192869230946
#island_id: 3
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, k] * (2*h[(i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] - 1) for d in range(6))
        total_spin -= 2 * J[3, i, j, k] * (h[i, j, k]**2)
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -total_spin
          priorities[i*N*N + j*N + k][1] = 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += -sum(J[d, (i+d)%N, (j+d)%N, k] * (2*h[(i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] - 1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = -2 * sum(J[d, (i+d)%N, (j+d)%N, k] * (2*h[(i+d)%N, (j+d)%N, k] * interacting_spins[5-d][(i+d)%N, (j+d)%N, k] - 1) for d in range(6))
        else:
          priorities[i*N*N + j*N + k][0] -= -sum(J[d, i, j, k] * (2*h[i, j, k] * interacting_spins[5-d][i, j, k] - 1) for d in range(6))
          priorities[i*N*N + j*N + k][1] = 2 * sum(J[d, i, j, k] * (2*h[i, j, k] * interacting_spins[5-d][i, j, k] - 1) for d in range(6))

  return(priorities)




#score: {'data3D.txt': -0.4330342}
#standard deviation: 0.03937212809031282
#island_id: 1
#version_generated: 3
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 - 1) >= N:
            continue
          neighbor = J[d, i + (d - 1) % 2 - 1, j, k]
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2]:
          if (i + (d - 1) % 3 - 1) >= N:
            continue
          neighbor = J[d, i + (d - 1) % 3 - 1, j, k]
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors in the z-direction
        neighbor_z = J[2, i, j, (k + 1) % N]
        if neighbor_z > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif neighbor_z < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0) + sum(J[3+d, site_nbr, j, k] for d in [0, 1]) - len([val for val in interacting_spins[3:].reshape(-1) if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]])
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0) - sum(J[3+d, site_nbr, j, k] for d in [0, 1]) + len([val for val in interacting_spins[3:].reshape(-1) if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]])
  
  return priorities




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.10077619999999998}
#standard deviation: 0.051967916578981685
#island_id: 1
#version_generated: 3
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors]) - sum([val < 0 for val in site_neighbors])
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0020362000000000006}
#standard deviation: 0.04651637227428639
#island_id: 3
#version_generated: 3
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0003197999999999998}
#standard deviation: 0.0452403192734092
#island_id: 3
#version_generated: 3
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(sum(J[5-d, (i+d)%N, (j+d)%N, k] for d in range(6))))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        elif h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(sum(J[5-d, (i+d)%N, (j+d)%N, k] for d in range(6))))
          priorities[i * N * N + j * N + k][1] += 2 * total_spin
        
        if i > 0 and h[i-1, j, k] != h[i, j, k]:
          site_neighbors = []
          for d in [0, 1, 2]:
            if J[d, (i-1+d)%N, j, k] < 0:
              site_neighbors.append(1)
            elif J[d, (i-1+d)%N, j, k] > 0:
              site_neighbors.append(-1)
          neighbor_spin = sum(site_neighbors)
          
          if h[i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 2 * neighbor_spin
          elif h[i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0020362000000000006}
#standard deviation: 0.04651637227428639
#island_id: 3
#version_generated: 3
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[5-d, (i+d)%N, (j+d)%N, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.33285379999999976}
#standard deviation: 0.04436131406484708
#island_id: 3
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        
        if h[i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(np.exp(-abs(x)) * len([val for val in interacting_spins if val < 0]) + x for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2*sum(interacting_spins) 
        else:
          priorities[i*N*N+j*N+k][0] -= sum(np.exp(-abs(x)) * len([val for val in interacting_spins if val < 0]) + x for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = 2*sum(interacting_spins) 

  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5107202000000001}
#standard deviation: 0.04210475688042861
#island_id: 1
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0)
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin > 0
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5188258}
#standard deviation: 0.04092511911234957
#island_id: 1
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47367699999999996}
#standard deviation: 0.04116187302589619
#island_id: 1
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.030065800000000004}
#standard deviation: 0.046827644296505024
#island_id: 3
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        same_spin_neighbors = sum([(J[d, (i+d)%N, (j+d)%N, k] > 0) - 1 for d in range(6)])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * same_spin_neighbors
        priorities[i*N*N+j*N+k][1] += same_spin_neighbors
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        opposite_spin_neighbors = sum([(J[d, (i+d)%N, (j+d)%N, k] > 0) - 2 for d in range(6)])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * opposite_spin_neighbors
        priorities[i*N*N+j*N+k][1] -= opposite_spin_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5107202000000001}
#standard deviation: 0.04210475688042861
#island_id: 1
#version_generated: 3
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0)
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin > 0
        
  return(priorities)




#score: {'data3D.txt': 0.017791}
#standard deviation: 0.04575370890977036
#island_id: 1
#version_generated: 3
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1] if k > 0 else 0
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        neighbor_spin += sum(val for val in site_neighbors)
        
        # Calculate the local energy and add it to the priorities
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4741282}
#standard deviation: 0.041672467706628566
#island_id: 1
#version_generated: 3
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0)
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin > 0
        
        # Add another term based on the distance from the boundary
        if i < N // 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (j % 2 == 0)
          priorities[i * N * N + j * N + k][1] -= j % 2 == 0
        if i >= N // 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (j % 2 == 1)
          priorities[i * N * N + j * N + k][1] -= j % 2 == 1
        
  return(priorities)




#score: {'data3D.txt': -0.5107202000000001}
#standard deviation: 0.04210475688042861
#island_id: 1
#version_generated: 3
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0)
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin > 0
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34409019999999996}
#standard deviation: 0.04471351634528424
#island_id: 2
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [1, 2]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [1, 2]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48269500000000015}
#standard deviation: 0.04525692670741132
#island_id: 2
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.09984460000000024}
#standard deviation: 0.04677928570254147
#island_id: 1
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2914678}
#standard deviation: 0.047179462514530625
#island_id: 1
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 1 - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 1 - len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.39233500000000004}
#standard deviation: 0.040459007093600306
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if (d == 2 or d == 5) and J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif (d == 2 or d == 5) and J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.474731}
#standard deviation: 0.04092115930664721
#island_id: 2
#version_generated: 3
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.348601}
#standard deviation: 0.04278436582444573
#island_id: 2
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [2]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 1
#version_generated: 3
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3157793999999999}
#standard deviation: 0.04417790868341324
#island_id: 1
#version_generated: 3
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.15689139999999993}
#standard deviation: 0.046135679100236526
#island_id: 1
#version_generated: 3
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0757258}
#standard deviation: 0.04701509007074218
#island_id: 0
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        site_nbr2 = (i + ((k - 2) % 2 - 1)) % N
        
        if h[site_nbr2][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.1210594}
#standard deviation: 0.0546936942584792
#island_id: 0
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = h[(i + ((j - 1) % 2 - 1)) % N][k][((k - 1) % 2 - 1)] % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * len([val for val in [J[0, (i + ((j - 1) % 2 - 1)) % N, k, (k - 1) % 2], J[1, i, (j + 1) % N, (k - 1) % 2]] if val < 0]) - len([val for val in [J[0, (i + ((j - 1) % 2 - 1)) % N, k, (k - 1) % 2], J[1, i, (j + 1) % N, (k - 1) % 2]] if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, (i + ((j - 1) % 2 - 1)) % N, k, (k - 1) % 2], J[1, i, (j + 1) % N, (k - 1) % 2]] if val < 0]) - len([val for val in [J[0, (i + ((j - 1) % 2 - 1)) % N, k, (k - 1) % 2], J[1, i, (j + 1) % N, (k - 1) % 2]] if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.08398979999999978}
#standard deviation: 0.05022153498211698
#island_id: 0
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                 J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N]]
        
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) + np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val > 0]) - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
  
  return priorities




#score: {'data3D.txt': -0.035433000000000006}
#standard deviation: 0.04953725457673245
#island_id: 0
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(val for val in interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          neighbor_spin = J[3 - d, (i + d) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          neighbor_spin = J[3 - d, (i + d) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.06828419999999992}
#standard deviation: 0.05382890664280671
#island_id: 0
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.38191060000000004}
#standard deviation: 0.03947935115525583
#island_id: 2
#version_generated: 3
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3835902000000001}
#standard deviation: 0.04779940945200056
#island_id: 2
#version_generated: 3
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in range(6):
            if (d == 0 or d == 3) and J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
              priorities[i * N * N + j * N + k][1] -= 1
            elif (d == 0 or d == 3) and J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
              priorities[i * N * N + j * N + k][1] += 1
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          for d in range(6):
            if (d == 0 or d == 3) and J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
              priorities[i * N * N + j * N + k][1] += 1
            elif (d == 0 or d == 3) and J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
              priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.37196140000000005}
#standard deviation: 0.04186167973266243
#island_id: 2
#version_generated: 3
#generate time14:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        opp_spin = sum([val for val in interacting_spins if val == 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opp_spin)
        priorities[i * N * N + j * N + k][1] -= opp_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.448159}
#standard deviation: 0.04029999452853561
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3157793999999999}
#standard deviation: 0.04417790868341324
#island_id: 1
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3157793999999999}
#standard deviation: 0.04417790868341324
#island_id: 1
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.24676380000000003}
#standard deviation: 0.049496399157514484
#island_id: 1
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3157793999999999}
#standard deviation: 0.04417790868341324
#island_id: 1
#version_generated: 3
#generate time14:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin) / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin) / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.2819517999999999}
#standard deviation: 0.05152052054046039
#island_id: 1
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.10881780000000023}
#standard deviation: 0.0440284213112394
#island_id: 1
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site and its neighbors
        site_nbr_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_nbr_spin)) * site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_nbr_spin)) * site_nbr_spin
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.15689139999999993}
#standard deviation: 0.046135679100236526
#island_id: 1
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.15689139999999993}
#standard deviation: 0.046135679100236526
#island_id: 1
#version_generated: 3
#generate time14:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.23649540000000002}
#standard deviation: 0.05445196763056409
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (same_spin - different_spin) + total_spin
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        same_neighbors = sum([val for val in site_neighbors if val > 0])
        different_neighbors = sum([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_neighbors - different_neighbors) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.17725580000000024}
#standard deviation: 0.05118602354510457
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the total spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin - 2 + 2 * sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + total_spin - 2 + 2 * sum([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.127015}
#standard deviation: 0.045042315826342674
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          
          for neighbor, spin in zip(site_neighbors, neighbor_spins):
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - spin
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          for neighbor, spin in zip(site_neighbors, neighbor_spins):
            if spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - spin
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - spin
  
  return priorities




#score: {'data3D.txt': -0.03941020000000034}
#standard deviation: 0.04940679564553848
#island_id: 2
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          # Calculate the priority based on the total spin
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Calculate the priority based on the site neighbors
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= sum([val for val in neighbor_spins if val > 0])
        else:
          # Calculate the priority based on the total spin
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          # Calculate the priority based on the site neighbors
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= sum([val for val in neighbor_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4324434}
#standard deviation: 0.041199194123671894
#island_id: 1
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5063898}
#standard deviation: 0.04162835975582032
#island_id: 1
#version_generated: 3
#generate time14:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0) * (len([val for val in site_neighbors if val == total_spin]) - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.3286609999999997}
#standard deviation: 0.046353257479922576
#island_id: 0
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d,i,j,k] * site_spin for d in range(6))
        
        # Calculate the correlation with neighboring spins
        neighbor_corr = 0
        for d in range(6):
          if i+(d-1)%2==0 or j+(d-3)//2==0 or k+(d-6)//3==0:
            neighbor_corr += J[d,i,j,k] * site_spin
        
        # Calculate the priority for assigning a spin of -1 or 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] = -np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        
  return(priorities)




#score: {'data3D.txt': -0.0019186000000000003}
#standard deviation: 0.045771112877447055
#island_id: 0
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        
        total_spin = sum(J[d,i,j,k] * site_spin for d in range(6))
        neighbor_corr = sum(site_spin * J[d,i,j,k] for d in range(3) if i+(d-1)%2==0 or j+(d-1)%2==0 or k+(d-1)%2==0)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (2 - total_spin) + np.exp(-abs(total_spin)) * neighbor_corr
        priorities[i * N * N + j * N + k][1] = -np.exp(-abs(total_spin)) * (2 - total_spin) - np.exp(-abs(total_spin)) * neighbor_corr
        
  return(priorities)




#score: {'data3D.txt': -0.3539758}
#standard deviation: 0.04109817531667312
#island_id: 3
#version_generated: 3
#generate time14:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3539758}
#standard deviation: 0.04109817531667312
#island_id: 3
#version_generated: 3
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3467354}
#standard deviation: 0.04345855527787365
#island_id: 3
#version_generated: 3
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20642260000000032}
#standard deviation: 0.043854889000429595
#island_id: 3
#version_generated: 3
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5034638}
#standard deviation: 0.0402089836922049
#island_id: 3
#version_generated: 3
#generate time14:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) - len([val for val in J[1, i, j, :] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) - len([val for val in J[1, i, j, :] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.03941020000000034}
#standard deviation: 0.04940679564553848
#island_id: 2
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          # Calculate the priority based on the total spin
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Calculate the priority based on the site neighbors
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= sum([val for val in neighbor_spins if val > 0])
        else:
          # Calculate the priority based on the total spin
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          # Calculate the priority based on the site neighbors
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbor_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= sum([val for val in neighbor_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.1774369999999999}
#standard deviation: 0.04656731676830866
#island_id: 2
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        neighbor_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_neighbors_sum = sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
  
  return priorities




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19711699999999996}
#standard deviation: 0.05626492718381497
#island_id: 0
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
    
  return(priorities)




#score: {'data3D.txt': -0.22565100000000002}
#standard deviation: 0.05625794236372319
#island_id: 0
#version_generated: 3
#generate time14:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          
          # Add new terms based on interacting spins and site interactions
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
          
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          
          # Add new terms based on interacting spins and site interactions
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] += sum(1 for val in site_neighbors if val < 0)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time14:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3339026}
#standard deviation: 0.04349631608814706
#island_id: 3
#version_generated: 3
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          # Add a term based on the site's own spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.15442059999999985}
#standard deviation: 0.04833986859353262
#island_id: 3
#version_generated: 3
#generate time14:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = np.sum(J[:, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * spin * (1 - 2 * (neighbor_spin > 0))
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(J[0, i, j, k])) * spin * (1 + 2 * (neighbor_spin > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.35832220000000004}
#standard deviation: 0.043844911987139405
#island_id: 3
#version_generated: 3
#generate time14:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3752382}
#standard deviation: 0.049869082413455335
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.336625}
#standard deviation: 0.049972929221729634
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) * np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) * np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3678134}
#standard deviation: 0.04990118415869507
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678134}
#standard deviation: 0.04990118415869507
#island_id: 0
#version_generated: 3
#generate time14:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.051157799999999996}
#standard deviation: 0.05205653022589961
#island_id: 2
#version_generated: 3
#generate time15:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1352930000000003}
#standard deviation: 0.04594498047665272
#island_id: 3
#version_generated: 3
#generate time15:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+d)%N, k] * ((h[(i+d)%N, (j+d)%N, k] > 0) - 1) for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15442059999999985}
#standard deviation: 0.04833986859353262
#island_id: 3
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = np.sum(J[:, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * spin * (1 - 2 * (neighbor_spin > 0))
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(neighbor_spin)) * spin * (1 + 2 * (neighbor_spin > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.15442059999999985}
#standard deviation: 0.04833986859353262
#island_id: 3
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = np.sum(J[:, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * spin * (1 - 2 * (neighbor_spin > 0))
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(J[0, i, j, k])) * spin * (1 + 2 * (neighbor_spin > 0))
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = np.sum(J[:, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[2, i, j, k])) * spin * (1 - 2 * (neighbor_spin > 0))
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(J[2, i, j, k])) * spin * (1 + 2 * (neighbor_spin > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.0659214}
#standard deviation: 0.04814400920197652
#island_id: 3
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = np.sum(J[:, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * spin * (1 - 2 * (neighbor_spin > 0))
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(J[0, i, j, k])) * spin * (1 + 2 * (neighbor_spin > 0))
        
        # Add a term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.15442059999999985}
#standard deviation: 0.04833986859353262
#island_id: 3
#version_generated: 3
#generate time15:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          spin = 1
        else:
          spin = -1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = np.sum(J[:, i, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin * (1 - 2 * (neighbor_spin > 0))
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * spin * (1 + 2 * (neighbor_spin > 0))
        
  return(priorities)




#score: {'data3D.txt': -0.4693630000000001}
#standard deviation: 0.04333552204600748
#island_id: 1
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        # Additional improvement
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= len([val < 0 for val in interacting_spins])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] += len([val > 0 for val in interacting_spins])
        
  return(priorities)




#score: {'data3D.txt': -0.32232659999999996}
#standard deviation: 0.042614636129386346
#island_id: 1
#version_generated: 3
#generate time15:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        # Additional term to consider the spin of the neighboring sites
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i-1, j, k] > 0 for _ in range(3)])
        
  return(priorities)




#score: {'data3D.txt': -0.4324434}
#standard deviation: 0.041199194123671894
#island_id: 1
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4552486000000001}
#standard deviation: 0.04312569533398853
#island_id: 1
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.48420700000000005}
#standard deviation: 0.0411112985808038
#island_id: 1
#version_generated: 3
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin < 0)
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin < 0)
        
  return priorities




#score: {'data3D.txt': -0.2485362}
#standard deviation: 0.04853203611595129
#island_id: 1
#version_generated: 3
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with opposite spin
        opposite_neighbors = [val for val in site_neighbors if val < 0]
        same_neighbors = [val for val in site_neighbors if val > 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(opposite_neighbors) - len(same_neighbors))
        priorities[i * N * N + j * N + k][1] -= 2 * (len(opposite_neighbors) - len(same_neighbors))
  
  return priorities




#score: {'data3D.txt': -0.5511458}
#standard deviation: 0.04332468006067673
#island_id: 1
#version_generated: 3
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0027374}
#standard deviation: 0.04705676615790762
#island_id: 3
#version_generated: 2
#generate time15:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0861242000000002}
#standard deviation: 0.04823659911685318
#island_id: 3
#version_generated: 2
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr < i) - (site_nbr > i)
          priorities[i * N * N + j * N + k][1] -= (site_nbr < i) - (site_nbr > i)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr < i) - (site_nbr > i)
          priorities[i * N * N + j * N + k][1] += (site_nbr < i) - (site_nbr > i)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 2
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 2
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37196140000000005}
#standard deviation: 0.04186167973266243
#island_id: 2
#version_generated: 3
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        opposite_spin = sum([val for val in interacting_spins if val == 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin)
        priorities[i * N * N + j * N + k][1] -= opposite_spin
        
  return priorities




#score: {'data3D.txt': -0.3053838}
#standard deviation: 0.04314406677122592
#island_id: 2
#version_generated: 3
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 2
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 2 else J[2, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 2 else J[2, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0)).item()
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-3, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if i == 0 or i == N-1:
          # modify the priority for boundary sites
          pass
    
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 2 else J[2, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 2 else J[2, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38618979999999997}
#standard deviation: 0.04194142696618702
#island_id: 2
#version_generated: 3
#generate time15:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
  # Add a new term based on the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
          
  return(priorities)




#score: {'data3D.txt': -0.37196140000000005}
#standard deviation: 0.04186167973266243
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3251558}
#standard deviation: 0.04057741941474347
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin) + total_spin
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.37196140000000005}
#standard deviation: 0.04186167973266243
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38938700000000004}
#standard deviation: 0.045984677785105774
#island_id: 1
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2454982000000004}
#standard deviation: 0.044798312432054836
#island_id: 1
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30494140000000014}
#standard deviation: 0.047554226374108964
#island_id: 1
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.33282140000000027}
#standard deviation: 0.04941531404372536
#island_id: 1
#version_generated: 3
#generate time15:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N, (i + d-N) % N, (j + d-N) % N, k] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.19793100000000008}
#standard deviation: 0.045953761097433585
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N, i, j, (k + d - 6) % N] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(total_spin)) * (total_spin > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d) % N, (j+d) % N, k] if d < 3 else J[3+d-3, i, j, (k+d-3)%3] for d in range(6)]
        total_spin = sum(J[d, (i+d) % N, (j+d) % N, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N//2, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2056002}
#standard deviation: 0.04585351240592153
#island_id: 2
#version_generated: 3
#generate time15:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the total number of nearest neighbors
        total_nbr = len([val for val in interacting_spins if val != 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_nbr
        priorities[i * N * N + j * N + k][1] -= total_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.40510580000000007}
#standard deviation: 0.04153759991092408
#island_id: 2
#version_generated: 3
#generate time15:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetization of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.2720190000000004}
#standard deviation: 0.04702020756015438
#island_id: 3
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27444860000000004}
#standard deviation: 0.046760662078717416
#island_id: 3
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_distance = sum(abs(val) for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) * (site_neighbors_distance / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_distance = sum(abs(val) for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) * (site_neighbors_distance / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4055462}
#standard deviation: 0.04330501801823895
#island_id: 3
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
        # Add a term to prioritize spins aligned with the local field
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.17432460000000016}
#standard deviation: 0.04568145745091766
#island_id: 1
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin - total_neighbor_spin > 0
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin + total_neighbor_spin > 0
        
  return(priorities)




#score: {'data3D.txt': 0.13738419999999996}
#standard deviation: 0.047111195594677927
#island_id: 1
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1] if k > 0 else 0
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        neighbor_spin += sum(val for val in site_neighbors)
        
        # Calculate the local energy and add it to the priorities
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - (neighbor_spin > 0) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -(2 + (neighbor_spin > 0)) + (neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - (neighbor_spin < 0) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -(2 - (neighbor_spin < 0)) + (neighbor_spin < 0)
  
  return(priorities)




#score: {'data3D.txt': 0.0108746}
#standard deviation: 0.045395939849726646
#island_id: 1
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, -1]]
        interacting_spins += [J[3, i, (j+d)%N, k] for d in [0, 1, -1]]
        interacting_spins += [J[4, i, j, (k+d)%N] for d in [0, 1, -1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4])
        neighbor_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.19793100000000008}
#standard deviation: 0.045953761097433585
#island_id: 0
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N, i, j, (k + d - 6) % N] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(total_spin)) * (total_spin > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.19793100000000008}
#standard deviation: 0.045953761097433585
#island_id: 0
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N, i, j, (k + d - 6) % N] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(total_spin)) * (total_spin > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.19793100000000008}
#standard deviation: 0.045953761097433585
#island_id: 0
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N, i, j, (k + d - 6) % N] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum(np.exp(-np.abs(total_spin)) * (total_spin > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.19242620000000005}
#standard deviation: 0.04470510567664504
#island_id: 0
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-N, i, j, (k + d - 6) % N] for d in range(6)]
        
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4324434}
#standard deviation: 0.041199194123671894
#island_id: 1
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4324434}
#standard deviation: 0.041199194123671894
#island_id: 1
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4324434}
#standard deviation: 0.041199194123671894
#island_id: 1
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4324434}
#standard deviation: 0.041199194123671894
#island_id: 1
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time15:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        # Additional term to consider the spin of the neighboring sites
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i-1, j, k] > 0 for _ in range(3)])
        
        # Additional term to consider the spin of the neighboring sites
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i+1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i+1, j, k] > 0 for _ in range(3)])
        
        # Additional term to consider the spin of the neighboring sites
        if j > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j-1, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j-1, k] > 0 for _ in range(3)])
        
        # Additional term to consider the spin of the neighboring sites
        if j < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j+1, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j+1, k] > 0 for _ in range(3)])
        
        # Additional term to consider the spin of the neighboring sites
        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j, k-1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j, k-1] > 0 for _ in range(3)])
        
        # Additional term to consider the spin of the neighboring sites
        if k < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j, k+1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j, k+1] > 0 for _ in range(3)])
        
  return(priorities)




#score: {'data3D.txt': -0.14933339999999998}
#standard deviation: 0.04536977060158008
#island_id: 1
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        # Additional term to consider the spin of the neighboring sites
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i-1, j, k] > 0 for _ in range(3)])
        
        # Additional term to consider the spin of the sites diagonally above
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i+1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i+1, j, k] > 0 for _ in range(3)])
        
  return(priorities)




#score: {'data3D.txt': -0.0067206}
#standard deviation: 0.04707676513568026
#island_id: 1
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        # Additional term to consider the spin of the neighboring sites
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i-1, j, k] > 0 for _ in range(3)])
        
        # Consider the total spin of the neighboring sites
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i+1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i+1, j, k] > 0 for _ in range(3)])
        
        if j < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j+1, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j+1, k] > 0 for _ in range(3)])
        
        if k < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j, k+1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j, k+1] > 0 for _ in range(3)])
        
  return(priorities)




#score: {'data3D.txt': -0.3249286}
#standard deviation: 0.042592724989603564
#island_id: 2
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetization of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin)
        priorities[i * N * N + j * N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.40510580000000007}
#standard deviation: 0.04153759991092408
#island_id: 2
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetization of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.40510580000000007}
#standard deviation: 0.04153759991092408
#island_id: 2
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        magnetization = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (magnetization)
        priorities[i * N * N + j * N + k][1] -= magnetization
  
  return(priorities)




#score: {'data3D.txt': -0.028676199999999995}
#standard deviation: 0.046224140809321704
#island_id: 0
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        for d in range(6):
          if J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
          elif J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
            priorities[i * N * N + j * N + k][1] = len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.005905800000000001}
#standard deviation: 0.047487170966061976
#island_id: 0
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time15:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49542100000000006}
#standard deviation: 0.041271624138141214
#island_id: 0
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (interacting_spin_sum - site_neighbors_sum) / 2
        priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5101678000000001}
#standard deviation: 0.043783137886177145
#island_id: 0
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        if i > 0 and j > 0 and k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[0, i-1, j-1, k] - J[2, i, j, k-1])
          priorities[i * N * N + j * N + k][1] -= J[0, i-1, j-1, k] - J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time15:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10453300000000003}
#standard deviation: 0.04487196575814347
#island_id: 3
#version_generated: 3
#generate time15:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.013955400000000001}
#standard deviation: 0.04764278466714556
#island_id: 2
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Normalize the priorities to ensure they are comparable across different sites
        priorities[i * N * N + j * N + k] /= np.linalg.norm(priorities[i * N * N + j * N + k])
  
  return(priorities)




#score: {'data3D.txt': -0.013955400000000001}
#standard deviation: 0.04764278466714556
#island_id: 2
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.013955400000000001}
#standard deviation: 0.04764278466714556
#island_id: 2
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the total spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the priority based on the site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the priority based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5101678000000001}
#standard deviation: 0.043783137886177145
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        if i > 0 and j > 0 and k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[0, i-1, j-1, k] - J[2, i, j, k-1])
          priorities[i * N * N + j * N + k][1] -= J[0, i-1, j-1, k] - J[2, i, j, k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5101678000000001}
#standard deviation: 0.043783137886177145
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        if i > 0 and j > 0 and k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[0, i-1, j-1, k] - J[2, i, j, k-1])
          priorities[i * N * N + j * N + k][1] -= J[0, i-1, j-1, k] - J[2, i, j, k-1]
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3257622000000001}
#standard deviation: 0.04200266147710167
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
  
  return(priorities)




#score: {'data3D.txt': -0.018010199999999994}
#standard deviation: 0.045087988821414515
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
  
  return(priorities)




#score: {'data3D.txt': -0.3257622000000001}
#standard deviation: 0.04200266147710167
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3257622000000001}
#standard deviation: 0.04200266147710167
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.2502586}
#standard deviation: 0.051245008010927275
#island_id: 1
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0) * (len([val for val in site_neighbors if val == total_spin]) - 1)
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != total_spin])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (len([val for val in site_neighbors if val != total_spin]))
        
  return(priorities)




#score: {'data3D.txt': -0.5032934000000001}
#standard deviation: 0.04399367268642162
#island_id: 1
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0) * (len([val for val in site_neighbors if val == total_spin]) - 1)
        
        # Add a new term based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49800059999999996}
#standard deviation: 0.04382583119166139
#island_id: 1
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin]) - total_spin
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0) * (len([val for val in site_neighbors if val == total_spin]) - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.11257379999999999}
#standard deviation: 0.045812918631757134
#island_id: 0
#version_generated: 3
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-3, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.03547700000000004}
#standard deviation: 0.048177688103519474
#island_id: 0
#version_generated: 3
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-3, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        spin = h[i][j][k]
        if spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(np.exp(-np.abs(total_spin)) * (total_spin > 0))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_neighbors_sum = sum([J[0, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-3, i, j, (k + d - 3) % 3] for d in range(6)])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (site_neighbors_sum - sum([J[0, i, (j + d) % N, k] if d < 3 else J[3+d-3, i, j, (k + d - 3) % 3] for d in range(6)])) / 2
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + site_neighbors_sum / 2
  
  return(priorities)




#score: {'data3D.txt': -0.010926200000000002}
#standard deviation: 0.0469099242544688
#island_id: 0
#version_generated: 3
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-3, (i+d-3)%N, (j+d-3)%N, (k+d-3)%3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        interacting_spins.sort()
        median_spin = interacting_spins[len(interacting_spins)//2]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -median_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= median_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.12133580000000001}
#standard deviation: 0.04369671381648739
#island_id: 0
#version_generated: 3
#generate time15:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, k] if d < 3 else J[3+d-3, i, j, (k + d - 3) % 3] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, (j + d) % N, k] for d in range(6))
        
        interacting_spins.sort()
        
        priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(total_spin)) * (total_spin < 0)) + len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2836522}
#standard deviation: 0.04481454356746256
#island_id: 1
#version_generated: 3
#generate time15:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5101678000000001}
#standard deviation: 0.043783137886177145
#island_id: 0
#version_generated: 3
#generate time15:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        if i > 0 and j > 0 and k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[0,i-1,j-1,k] - J[2,i,j,k-1])
          priorities[i * N * N + j * N + k][1] -= J[0,i-1,j-1,k] - J[2,i,j,k-1]
        
  return(priorities)




#score: {'data3D.txt': -0.17980379999999996}
#standard deviation: 0.04667535222748727
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.17980379999999996}
#standard deviation: 0.04667535222748727
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin
        
        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.17980379999999996}
#standard deviation: 0.04667535222748727
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum([val for val in interacting_spins if val > 0])
        different_spin = sum([val for val in interacting_spins if val < 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin - different_spin)
        priorities[i * N * N + j * N + k][1] -= same_spin - different_spin

        # Add a new term based on the magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -abs(h[i][j][k])

  return priorities




#score: {'data3D.txt': -0.27444860000000004}
#standard deviation: 0.046760662078717416
#island_id: 3
#version_generated: 3
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors_distance = sum(abs(val) for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) * (site_neighbors_distance / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors_distance = sum(abs(val) for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) * (site_neighbors_distance / len(site_neighbors))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin

  return priorities




#score: {'data3D.txt': -0.09475499999999999}
#standard deviation: 0.04629099107817848
#island_id: 3
#version_generated: 3
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2720190000000004}
#standard deviation: 0.04702020756015438
#island_id: 3
#version_generated: 3
#generate time15:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.23162739999999998}
#standard deviation: 0.044471537068556555
#island_id: 1
#version_generated: 3
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2836522}
#standard deviation: 0.04481454356746256
#island_id: 1
#version_generated: 3
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2836522}
#standard deviation: 0.04481454356746256
#island_id: 1
#version_generated: 3
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0264942}
#standard deviation: 0.04409504514523146
#island_id: 1
#version_generated: 3
#generate time15:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0))
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49542100000000006}
#standard deviation: 0.041271624138141214
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (interacting_spin_sum - site_neighbors_sum) / 2
        priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.49542100000000006}
#standard deviation: 0.041271624138141214
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (interacting_spin_sum - site_neighbors_sum) / 2
        priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.49542100000000006}
#standard deviation: 0.041271624138141214
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + (interacting_spin_sum - site_neighbors_sum) / 2
        priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.36557940000000005}
#standard deviation: 0.043784708011359405
#island_id: 0
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] - J[0, i, j, k] for d in [1, 2]] + [J[3, i, (j+1)%N, k] - J[0, i, j, k], J[4, i, j, (k+1)%N] - J[0, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(interacting_spins) / len(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2637322}
#standard deviation: 0.0397490317260685
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.1253838}
#standard deviation: 0.04654687720524333
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10453300000000003}
#standard deviation: 0.04487196575814347
#island_id: 3
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.12923860000000031}
#standard deviation: 0.047974845805275924
#island_id: 3
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(site_neighbors)) * site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.058840199999999995}
#standard deviation: 0.04598720456779255
#island_id: 3
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(site_neighbors)) * site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time16:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.028676199999999995}
#standard deviation: 0.046224140809321704
#island_id: 0
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        for d in range(6):
          if J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
          elif J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
            priorities[i * N * N + j * N + k][1] = len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0458558}
#standard deviation: 0.05009537270407318
#island_id: 0
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Calculate the total spin of the neighboring sites
        for d in range(6):
          site_neighbors_spin = sum([J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors_spin, J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [site_neighbors_spin, J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.04364699999999999}
#standard deviation: 0.04501656396261269
#island_id: 0
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        for d in range(6):
          site_neighbor = [J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]]
          if sum(site_neighbor) < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbor if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbor if val > 0])
          elif sum(site_neighbor) > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbor if val > 0])
            priorities[i * N * N + j * N + k][1] = len([val for val in site_neighbor if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.028676199999999995}
#standard deviation: 0.046224140809321704
#island_id: 0
#version_generated: 3
#generate time16:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        for d in range(6):
          if J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
          elif J[d, i, (j+1)%N, k]+J[d, i, j, (k+1)%N] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val > 0])
            priorities[i * N * N + j * N + k][1] = len([val for val in [J[d, i, j, k], J[d, i, (j+1)%N, k], J[d, i, j, (k+1)%N]] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3371586}
#standard deviation: 0.05073827121650875
#island_id: 3
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 3
#version_generated: 3
#generate time16:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.26656739999999995}
#standard deviation: 0.04703335260472081
#island_id: 2
#version_generated: 2
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 2
#version_generated: 2
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.46667260000000005}
#standard deviation: 0.04154593276411062
#island_id: 2
#version_generated: 3
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        site_neighbor_sum = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 2
#version_generated: 3
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 2
#version_generated: 3
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10453300000000003}
#standard deviation: 0.04487196575814347
#island_id: 3
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.10453300000000003}
#standard deviation: 0.04487196575814347
#island_id: 3
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.13260300000000003}
#standard deviation: 0.054742609647330485
#island_id: 3
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.28200260000000027}
#standard deviation: 0.04276729162853313
#island_id: 1
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction) - (total_spin < 0)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction) - (total_spin > 0)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.07665900000000005}
#standard deviation: 0.04729023830559538
#island_id: 1
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        # Calculate the interaction energy with neighboring spins
        for d in [3, 4, 5]:
          interacting_spins.append(J[d, i, j, k])
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        total_neighbor_interaction += sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2454982000000004}
#standard deviation: 0.044798312432054836
#island_id: 1
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0070494000000000685}
#standard deviation: 0.046348675058085535
#island_id: 1
#version_generated: 3
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  # Add a term to the priority that depends on the magnetism at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k]))
        
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.11267060000000001}
#standard deviation: 0.04510944397396182
#island_id: 3
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        
  return(priorities)




#score: {'data3D.txt': -0.4300926}
#standard deviation: 0.04312177762152205
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': 0.018489399999999993}
#standard deviation: 0.047993209182549984
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.46667260000000005}
#standard deviation: 0.04154593276411062
#island_id: 2
#version_generated: 3
#generate time16:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        site_neighbor_sum = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.46667260000000005}
#standard deviation: 0.04154593276411062
#island_id: 2
#version_generated: 3
#generate time16:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        site_neighbor_sum = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.26656739999999995}
#standard deviation: 0.04703335260472081
#island_id: 2
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum

          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum

          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum

  return(priorities)




#score: {'data3D.txt': 0.008221399999999785}
#standard deviation: 0.05553471762816483
#island_id: 2
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.26656739999999995}
#standard deviation: 0.04703335260472081
#island_id: 2
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
  return(priorities)




#score: {'data3D.txt': -0.26656739999999995}
#standard deviation: 0.04703335260472081
#island_id: 2
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
  return(priorities)




#score: {'data3D.txt': -0.058840199999999995}
#standard deviation: 0.04598720456779255
#island_id: 3
#version_generated: 3
#generate time16:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(site_neighbors)) * site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.058840199999999995}
#standard deviation: 0.04598720456779255
#island_id: 3
#version_generated: 3
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(site_neighbors)) * site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.038225400000000104}
#standard deviation: 0.04558958866715075
#island_id: 3
#version_generated: 3
#generate time16:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09574780000000024}
#standard deviation: 0.04752736680229613
#island_id: 1
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1.5
          priorities[i * N * N + j * N + k][1] += 2.5
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1.5
          priorities[i * N * N + j * N + k][1] -= 2.5
        
  return(priorities)




#score: {'data3D.txt': 0.27739179999999997}
#standard deviation: 0.04640933669812573
#island_id: 1
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[2, i, j, (k - 1) % N], J[2, (i - 1) % N, j, k], J[0, i, (j - 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.08474300000000011}
#standard deviation: 0.046695045465231115
#island_id: 1
#version_generated: 3
#generate time16:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Additional term based on the site's total spin
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 * abs(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.36419979999999996}
#standard deviation: 0.043806319634956785
#island_id: 0
#version_generated: 3
#generate time16:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(J[2, i, j, k])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.2569374000000001}
#standard deviation: 0.047151722357088914
#island_id: 2
#version_generated: 3
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
          
  return(priorities)




#score: {'data3D.txt': -0.1593926000000004}
#standard deviation: 0.04879321085192078
#island_id: 2
#version_generated: 3
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        # Add a term to account for the magnetism
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.26656739999999995}
#standard deviation: 0.04703335260472081
#island_id: 2
#version_generated: 3
#generate time16:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          if site_neighbors_sum > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_sum
            priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbors_sum
            
  return(priorities)




#score: {'data3D.txt': -0.1446422}
#standard deviation: 0.04363972157518881
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
        
        site_neighbors_distance_x = sum(abs(val) for val in interacting_spins_x)
        site_neighbors_distance_y = sum(abs(val) for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) * (site_neighbors_distance_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) * (site_neighbors_distance_y / len(interacting_spins_y))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
        
  return(priorities)




#score: {'data3D.txt': -0.0359738}
#standard deviation: 0.044486160472218775
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.09848259999999999}
#standard deviation: 0.05276439725079781
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin_x = sum(val for val in interacting_spins_x)
        
        total_spin_y = sum(J[d, i, j, k] for d in [3, 4, 5])
        total_neighbor_spin_y = sum(val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_neighbor_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y)) - 2 * (total_neighbor_spin_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_neighbor_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y)) - 2 * (total_neighbor_spin_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.08333539999999999}
#standard deviation: 0.04335047712355656
#island_id: 3
#version_generated: 3
#generate time16:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46667260000000005}
#standard deviation: 0.04154593276411062
#island_id: 2
#version_generated: 3
#generate time16:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])

        site_neighbor_sum = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(site_neighbor_sum) - site_neighbor_sum

  return(priorities)




#score: {'data3D.txt': 0.018489399999999993}
#standard deviation: 0.047993209182549984
#island_id: 2
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.018489399999999993}
#standard deviation: 0.047993209182549984
#island_id: 2
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.018489399999999993}
#standard deviation: 0.047993209182549984
#island_id: 2
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48435860000000003}
#standard deviation: 0.040739812543014974
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0) * (len([val for val in site_neighbors if val == total_spin]) - 1)
        
        # Add another term based on the distance from the boundary
        if i < N // 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (j % 2 == 0) * min(i, N - i - 1)
          priorities[i * N * N + j * N + k][1] -= j % 2 == 0 * min(i, N - i - 1)
        if i >= N // 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (j % 2 == 1) * min(N - i - 1, i + 1)
          priorities[i * N * N + j * N + k][1] -= j % 2 == 1 * min(N - i - 1, i + 1)
  
  return priorities




#score: {'data3D.txt': -0.4955778}
#standard deviation: 0.041763198478564835
#island_id: 1
#version_generated: 3
#generate time16:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0) * (len([val for val in site_neighbors if val == total_neighbor_spin]) - 1)
        
        # Add another term based on the distance from the boundary
        if i < N // 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (j % 2 == 0 and k % 2 == 0)
          priorities[i * N * N + j * N + k][1] -= j % 2 == 0 and k % 2 == 0
        if i >= N // 2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (j % 2 == 1 and k % 2 == 1)
          priorities[i * N * N + j * N + k][1] -= j % 2 == 1 and k % 2 == 1
        
  return priorities




#score: {'data3D.txt': -0.08075500000000002}
#standard deviation: 0.05111761198452056
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - sum(val > 0 for val in site_neighbors) / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - sum(val > 0 for val in site_neighbors) / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.17279820000000023}
#standard deviation: 0.04650539707130776
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        # Calculate the interaction energy with neighboring spins
        interacting_spins += [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, (i + 1) % N, k]]
        site_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, (i + 1) % N, k]]
        
        total_neighbor_interaction += sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.07665900000000005}
#standard deviation: 0.04729023830559538
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        for d in [3, 4, 5]:
          interacting_spins.append(J[d, i, j, k])
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        total_neighbor_interaction += sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0006473999999999998}
#standard deviation: 0.04704752356118226
#island_id: 1
#version_generated: 3
#generate time16:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.roll(h, -1, axis=0) + np.roll(h, 1, axis=0) + np.roll(h, -1, axis=1) + np.roll(h, 1, axis=1) + np.roll(h, -1, axis=2) + np.roll(h, 1, axis=2)
  interacting_spins -= h
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] == J[d, i, j, k]) for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction) - (total_spin < 0)
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.39117900000000005}
#standard deviation: 0.0453547051473163
#island_id: 2
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors = J[0, i, (j + 1) % N, k] + J[1, (i + 1) % N, j, k] + J[2, i, j, (k + 1) % N]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum([J[d, i, j, k] for d in [0, 1, 2]]))) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - site_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum([J[d, i, j, k] for d in [0, 1, 2]]))) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - site_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.150409}
#standard deviation: 0.05118987281679844
#island_id: 0
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k - 1], J[1, i, j, k - 1]] if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k - 1], J[1, i, j, k - 1]] if val > 0]) - 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k - 1], J[1, i, j, k - 1]] if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k - 1], J[1, i, j, k - 1]] if val < 0]) - 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k - 1], J[1, i, j, k - 1]] if val == 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k - 1], J[1, i, j, k - 1]] if val == 0]) - 2
  
  return priorities




#score: {'data3D.txt': -0.39960500000000004}
#standard deviation: 0.04454581029681692
#island_id: 3
#version_generated: 3
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = J[0, i, j, k] + J[1, i, (j + 1) % N, k] + J[2, i, j, (k + 1) % N]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.22634300000000024}
#standard deviation: 0.04739021408476648
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(np.exp(-np.abs(val)) * val for val in interacting_spins_x)
        total_spin_y = sum(np.exp(np.abs(val)) * val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_x - total_spin_y
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = total_spin_x - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x / len(interacting_spins_x)) + 2 * (total_spin_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.0359738}
#standard deviation: 0.044486160472218775
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.09372260000000009}
#standard deviation: 0.047710033842369055
#island_id: 3
#version_generated: 3
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins_x = [J[0, :, :, :], J[1, :, :, :], J[2, :, :, :]]
  interacting_spins_y = [J[3, :, :, :], J[4, :, :, :], J[5, :, :, :]]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x[0].T[i, j, k])) * interacting_spins_x[0].T[i, j, k]) - np.sum(np.exp(np.abs(interacting_spins_y[0].T[i, j, k])) * interacting_spins_y[0].T[i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 * (np.mean(interacting_spins_x[0].T[i, j, k]) if np.mean(interacting_spins_x[0].T[i, j, k]) > 0 else np.mean(interacting_spins_y[0].T[i, j, k])) - 2 * (np.mean(interacting_spins_y[0].T[i, j, k]) if np.mean(interacting_spins_y[0].T[i, j, k]) > 0 else np.mean(interacting_spins_x[0].T[i, j, k]))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x[0].T[i, j, k])) * interacting_spins_x[0].T[i, j, k]) - np.sum(np.exp(-np.abs(interacting_spins_y[0].T[i, j, k])) * interacting_spins_y[0].T[i, j, k])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (np.mean(interacting_spins_x[0].T[i, j, k]) if np.mean(interacting_spins_x[0].T[i, j, k]) > 0 else np.mean(interacting_spins_y[0].T[i, j, k])) - 2 * (np.mean(interacting_spins_y[0].T[i, j, k]) if np.mean(interacting_spins_y[0].T[i, j, k]) > 0 else np.mean(interacting_spins_x[0].T[i, j, k]))

  return(priorities)




#score: {'data3D.txt': -0.08333539999999999}
#standard deviation: 0.04335047712355656
#island_id: 3
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.08333539999999999}
#standard deviation: 0.04335047712355656
#island_id: 3
#version_generated: 3
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': 0.007217}
#standard deviation: 0.04615888377116587
#island_id: 3
#version_generated: 3
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.08333539999999999}
#standard deviation: 0.04335047712355656
#island_id: 3
#version_generated: 3
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.31630020000000003}
#standard deviation: 0.04291556454201669
#island_id: 0
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.31630020000000003}
#standard deviation: 0.04291556454201669
#island_id: 0
#version_generated: 3
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.16201459999999998}
#standard deviation: 0.04456409032887354
#island_id: 0
#version_generated: 3
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in interacting_spins])
        
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[d, i-1, j, k] > 0 for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= len([J[d, i-1, j, k] > 0 for d in [0, 1, 2]])
        
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[d, i+1, j, k] > 0 for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= len([J[d, i+1, j, k] > 0 for d in [0, 1, 2]])
        
        if j > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[0, i, j-1, k], J[1, i, (j-1) % N, k], J[2, i, j-1, k]])
          priorities[i * N * N + j * N + k][1] -= len([J[0, i, j-1, k], J[1, i, (j-1) % N, k], J[2, i, j-1, k]])
        
        if j < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[0, i, j+1, k], J[1, i, (j+1) % N, k], J[2, i, j+1, k]])
          priorities[i * N * N + j * N + k][1] -= len([J[0, i, j+1, k], J[1, i, (j+1) % N, k], J[2, i, j+1, k]])
        
        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[0, i, j, k-1], J[1, i, j, (k-1) % N], J[2, i, j, k-1]])
          priorities[i * N * N + j * N + k][1] -= len([J[0, i, j, k-1], J[1, i, j, (k-1) % N], J[2, i, j, k-1]])
        
        if k < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[0, i, j, k+1], J[1, i, j, (k+1) % N], J[2, i, j, k+1]])
          priorities[i * N * N + j * N + k][1] -= len([J[0, i, j, k+1], J[1, i, j, (k+1) % N], J[2, i, j, k+1]])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in interacting_spins])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i-1, j, k] > 0 for _ in range(3)])
        
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i+1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i+1, j, k] > 0 for _ in range(3)])
        
        if j < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j+1, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j+1, k] > 0 for _ in range(3)])
        
        if k < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j, k+1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([h[i, j, k+1] > 0 for _ in range(3)])
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[0, i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([J[0, i-1, j, k] > 0 for _ in range(3)])
        
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[0, i+1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([J[0, i+1, j, k] > 0 for _ in range(3)])
        
        if j > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[1, i, (j-1) % N, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([J[1, i, (j-1) % N, k] > 0 for _ in range(3)])
        
        if j < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[1, i, (j+1) % N, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([J[1, i, (j+1) % N, k] > 0 for _ in range(3)])
        
        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[2, i, j, k-1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([J[2, i, j, k-1] > 0 for _ in range(3)])
        
        if k < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([J[2, i, j, k+1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([J[2, i, j, k+1] > 0 for _ in range(3)])
  
  return priorities




#score: {'data3D.txt': -0.266635}
#standard deviation: 0.04344759343162749
#island_id: 1
#version_generated: 3
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i-1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [h[i-1, j, k] > 0 for _ in range(3)] if val])
        
        if i < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i+1, j, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [h[i+1, j, k] > 0 for _ in range(3)] if val])
        
        if j < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j+1, k] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [h[i, j+1, k] > 0 for _ in range(3)] if val])
        
        if k < N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([h[i, j, k+1] > 0 for _ in range(3)])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [h[i, j, k+1] > 0 for _ in range(3)] if val])
  
  return(priorities)




#score: {'data3D.txt': 0.14337140000000012}
#standard deviation: 0.047279597524090666
#island_id: 1
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        # Calculate the interaction energy with neighboring spins
        for d in range(3):
          interacting_spins.append(J[d, (i + 1) % N, j, k])
          interacting_spins.append(J[d, i, (j + 1) % N, k])
          interacting_spins.append(J[d, i, j, (k + 1) % N])
        
        total_neighbor_interaction += sum([val * abs(val - total_spin) for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.1626770000000002}
#standard deviation: 0.04599171089446446
#island_id: 1
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        # Calculate the interaction energy with neighboring spins
        for d in [3, 4, 5]:
          interacting_spins.append(J[d, i, j, k])
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        total_neighbor_interaction += sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': 0.030272599999999997}
#standard deviation: 0.04504697336381213
#island_id: 1
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        # Calculate the interaction energy with neighboring spins
        for d in [3, 4, 5]:
          interacting_spins.append(J[d, i, j, k])
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        # Calculate the priority based on interaction energy
        for s in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][s] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - sum([val * abs(val - total_spin) for val in site_neighbors]))
          else:
            priorities[i * N * N + j * N + k][s] -= np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - sum([val * abs(val - total_spin) for val in site_neighbors]))
  
  return(priorities)




#score: {'data3D.txt': -0.05595860000000001}
#standard deviation: 0.04900730074223636
#island_id: 1
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        total_neighbor_interaction = sum([val * abs(val - total_spin) for val in site_neighbors])
        
        # Calculate the interaction energy with neighboring spins
        for d in [3, 4, 5]:
          interacting_spins.append(J[d, i, j, k])
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, (i + 1) % N, j, k])
          site_neighbors.append(J[d, i, (j + 1) % N, k])
          site_neighbors.append(J[d, i, j, (k + 1) % N])
        
        total_neighbor_interaction += sum([val * abs(val - total_spin) for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - neighbor_spin / len(site_neighbors) - total_neighbor_interaction)
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add the interaction energy with the spin itself
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin / len(interacting_spins))
        priorities[i * N * N + j * N + k][1] -= total_spin / len(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.4461082}
#standard deviation: 0.04079479884446055
#island_id: 2
#version_generated: 3
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([J[d, i, j, k] < 0 for d in [0, 1, 2]]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([J[d, i, j, k] > 0 for d in [0, 1, 2]]) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.09705780000000006}
#standard deviation: 0.04446979625723509
#island_id: 2
#version_generated: 3
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * interacting_spins[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= J[d, i, j, k] * interacting_spins[d, i, j, k]
  
  return priorities




#score: {'data3D.txt': -0.2266458000000001}
#standard deviation: 0.055997927304142256
#island_id: 1
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.sum(J[:, i, j, k], axis=0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -abs(total_spin) + len([val for val in interacting_spins if val < 0]) - site_neighbors.sum()
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += abs(total_spin) - len([val for val in interacting_spins if val > 0]) - site_neighbors.sum()
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.0461618}
#standard deviation: 0.04695882133060838
#island_id: 1
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin > 0)
        
        site_neighbors = [J[2, i, j, (k - 1) % N], J[2, (i - 1) % N, j, k], J[0, i, (j - 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        site_neighbors = [J[3, i, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.221737}
#standard deviation: 0.04464431241490902
#island_id: 1
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[2, i, j, (k - 1) % N], J[2, (i - 1) % N, j, k], J[0, i, (j - 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0) * len([val for val in interacting_spins if val == total_spin])
        priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin > 0)
        
  return priorities




#score: {'data3D.txt': 0.27739179999999997}
#standard deviation: 0.04640933669812573
#island_id: 1
#version_generated: 3
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[2, i, j, (k - 1) % N], J[2, (i - 1) % N, j, k], J[0, i, (j - 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.08333539999999999}
#standard deviation: 0.04335047712355656
#island_id: 3
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return priorities




#score: {'data3D.txt': -0.11348460000000017}
#standard deviation: 0.045250079368328186
#island_id: 3
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(np.exp(-np.abs(val)) * val for val in interacting_spins_x)
        total_spin_y = sum(np.exp(np.abs(val)) * val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_x - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = total_spin_x - total_spin_y
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
  
  return priorities




#score: {'data3D.txt': -0.08333539999999999}
#standard deviation: 0.04335047712355656
#island_id: 3
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': 0.024081000000000196}
#standard deviation: 0.04930728910617579
#island_id: 3
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x)
        total_spin_y = np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = total_spin_y
        else:
          priorities[i * N * N + j * N + k][0] = 2 - 2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = -total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.3974534}
#standard deviation: 0.04230575455467022
#island_id: 2
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3759402}
#standard deviation: 0.044280967287989546
#island_id: 2
#version_generated: 3
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3429266}
#standard deviation: 0.04907093245945098
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4894734000000001}
#standard deviation: 0.04261554191184245
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2428634}
#standard deviation: 0.04681082204405302
#island_id: 0
#version_generated: 2
#generate time17:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.3664514}
#standard deviation: 0.043064227823566045
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - 3
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0]) + 3
        
  return(priorities)




#score: {'data3D.txt': -0.428981}
#standard deviation: 0.04173860945216072
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2183822000000004}
#standard deviation: 0.047676294771720674
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [total_spin] + site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in [total_spin] + site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in [total_spin] + site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [total_spin] + site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.11682459999999997}
#standard deviation: 0.044968963461925616
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, i, (j + 1) % N, k], J[0, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[3, i, (j + 1) % N, k], J[3, i, j, (k + 1) % N]]
        interacting_spins_z = [J[4, i, j, k], J[4, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        site_neighbors_z = sum([val for val in interacting_spins_z if val > 0]) - len(interacting_spins_z)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y) + np.sum(np.exp(-np.abs(interacting_spins_z)) * interacting_spins_z)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y)) - 2 * (site_neighbors_z / len(interacting_spins_z))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y) + np.sum(np.exp(np.abs(interacting_spins_z)) * interacting_spins_z)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y)) - 2 * (site_neighbors_z / len(interacting_spins_z))
        
  return(priorities)




#score: {'data3D.txt': -0.04332419999999998}
#standard deviation: 0.04727059354778615
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N]]
        interacting_spins_y = [J[3, i, j, k], J[3, (i+1)%N, j, k], J[3, i, (j+1)%N, k], J[3, i, j, (k+1)%N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.16005020000000003}
#standard deviation: 0.04568383696626193
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1642846}
#standard deviation: 0.04541653534606091
#island_id: 3
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': 0.0331342}
#standard deviation: 0.045863496054705646
#island_id: 3
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add interaction with neighboring spins
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0])
          else:
            priorities[i * N * N + j * N + k][1] -= np.exp(abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.19862739999999993}
#standard deviation: 0.04550508816868726
#island_id: 3
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1642846}
#standard deviation: 0.04541653534606091
#island_id: 3
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.430441}
#standard deviation: 0.04466996887171514
#island_id: 2
#version_generated: 3
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
        # additional calculation based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4300926}
#standard deviation: 0.04312177762152205
#island_id: 2
#version_generated: 3
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.001559}
#standard deviation: 0.04340599266230413
#island_id: 2
#version_generated: 3
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_product = 0
        for d in range(6):
          if J[d, i, j, k] > 0:
            spin_product -= interacting_spins[d][i, j, k]
          else:
            spin_product += interacting_spins[d][i, j, k]

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(spin_product)) - abs(priorities[i * N * N + j * N + k][1])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_product

  return(priorities)




#score: {'data3D.txt': -0.3759402}
#standard deviation: 0.044280967287989546
#island_id: 2
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3759402}
#standard deviation: 0.044280967287989546
#island_id: 2
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.0074722}
#standard deviation: 0.04480389209834342
#island_id: 2
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+di)%N, (j+dj)%N, (k+dk)%N] 
                   for d,(di,dj,dk) in enumerate([(0,0,1), (0,1,0), (0,-1,0), 
                                   (-1,0,0), (1,0,0), (0,0,0)])]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - abs(sum(site_neighbors)) 
          priorities[i*N**2 + j*N + k][1] -= 2 - 2*sum(interacting_spins) + sum(site_neighbors)
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - abs(sum(site_neighbors))
          priorities[i*N**2 + j*N + k][1] = -2 + 2*sum(interacting_spins) - sum(site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': 0.3664514}
#standard deviation: 0.043064227823566045
#island_id: 1
#version_generated: 3
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - 3
        priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0]) + 3
        
  return(priorities)




#score: {'data3D.txt': -0.1598050000000002}
#standard deviation: 0.053093222307560126
#island_id: 1
#version_generated: 3
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val > 0) + sum(1 for val in J[:, i, j, k] if val < 0) - sum(1 for val in J[0, :, j, k] if val > 0))
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[2, i, j, :] if val > 0]) + len([val for val in J[:, i, j, k] if val < 0]) - len([val for val in J[0, :, j, k] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val < 0) + sum(1 for val in J[:, i, j, k] if val > 0) - sum(1 for val in J[0, :, j, k] if val < 0))
          priorities[i * N * N + j * N + k][1] = len([val for val in J[2, i, j, :] if val < 0]) + len([val for val in J[:, i, j, k] if val > 0]) - len([val for val in J[0, :, j, k] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1598050000000002}
#standard deviation: 0.053093222307560126
#island_id: 1
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val > 0) + sum(1 for val in J[:, i, j, k] if val < 0) - sum(1 for val in J[0, :, j, k] if val > 0))
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[2, i, j, :] if val > 0]) + len([val for val in J[:, i, j, k] if val < 0]) - len([val for val in J[0, :, j, k] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val < 0) + sum(1 for val in J[:, i, j, k] if val > 0) - sum(1 for val in J[0, :, j, k] if val < 0))
          priorities[i * N * N + j * N + k][1] = len([val for val in J[2, i, j, :] if val < 0]) + len([val for val in J[:, i, j, k] if val > 0]) - len([val for val in J[0, :, j, k] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.1598050000000002}
#standard deviation: 0.053093222307560126
#island_id: 1
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val > 0) + sum(1 for val in J[:, i, j, k] if val < 0) - sum(1 for val in J[0, :, j, k] if val > 0))
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[2, i, j, :] if val > 0]) + len([val for val in J[:, i, j, k] if val < 0]) - len([val for val in J[0, :, j, k] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val < 0) + sum(1 for val in J[:, i, j, k] if val > 0) - sum(1 for val in J[0, :, j, k] if val < 0))
          priorities[i * N * N + j * N + k][1] = len([val for val in J[2, i, j, :] if val < 0]) + len([val for val in J[:, i, j, k] if val > 0]) - len([val for val in J[0, :, j, k] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1598050000000002}
#standard deviation: 0.053093222307560126
#island_id: 1
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val > 0) + sum(1 for val in J[:, i, j, k] if val < 0) - sum(1 for val in J[0, :, j, k] if val > 0))
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[2, i, j, :] if val > 0]) + len([val for val in J[:, i, j, k] if val < 0]) - len([val for val in J[0, :, j, k] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, k:] if val < 0) + sum(1 for val in J[:, i, j, k] if val > 0) - sum(1 for val in J[0, :, j, k] if val < 0))
          priorities[i * N * N + j * N + k][1] = len([val for val in J[2, i, j, :] if val < 0]) + len([val for val in J[:, i, j, k] if val > 0]) - len([val for val in J[0, :, j, k] if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3968962}
#standard deviation: 0.04797585044123762
#island_id: 3
#version_generated: 3
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3371586}
#standard deviation: 0.05073827121650875
#island_id: 3
#version_generated: 3
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.496691}
#standard deviation: 0.04428527790361036
#island_id: 3
#version_generated: 3
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :k+1] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :k+1] if val < 0]) - len([val for val in J[2, i, j, :k+1] if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47570180000000006}
#standard deviation: 0.039577019553776405
#island_id: 3
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - sum([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.2083522}
#standard deviation: 0.04894418939118311
#island_id: 3
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))

        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.038225400000000104}
#standard deviation: 0.04558958866715075
#island_id: 3
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.08223540000000006}
#standard deviation: 0.046151183590889634
#island_id: 3
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1]) if i % 2 == 0 else sum(J[d, i - 1, j, k] for d in [0, 1])
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(sum(interacting_spins))) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

  return(priorities)




#score: {'data3D.txt': 0.08324019999999999}
#standard deviation: 0.049002701394514986
#island_id: 3
#version_generated: 3
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 * (total_spin + sum(val for val in interacting_spins if val > 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins) + 2 * total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * (total_spin + sum(val for val in interacting_spins if val > 0))

  return(priorities)




#score: {'data3D.txt': -0.2183822000000004}
#standard deviation: 0.047676294771720674
#island_id: 1
#version_generated: 3
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [total_spin] + site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in [total_spin] + site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in [total_spin] + site_neighbors if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [total_spin] + site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.2265402000000003}
#standard deviation: 0.047747852558622995
#island_id: 1
#version_generated: 3
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in [total_spin] + site_neighbors + interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the number of nearest neighbors with the same spin
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [total_spin] + site_neighbors + interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3996282}
#standard deviation: 0.04537695940408524
#island_id: 1
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:3, i, j, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0:3, i, j, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] += sum(1 for val in site_neighbors if val > 0)
  
  return priorities




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5543994}
#standard deviation: 0.04414996941833595
#island_id: 1
#version_generated: 3
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3759402}
#standard deviation: 0.044280967287989546
#island_id: 2
#version_generated: 3
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_neighbor_sum
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(site_neighbor_sum) 
          priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin + site_neighbor_sum
        else:
          priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(site_neighbor_sum)
          priorities[i * N * N + j * N + site_nbr][1] = -2 + 2 * total_spin - site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3063402}
#standard deviation: 0.04361029309646978
#island_id: 1
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 0
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0823638}
#standard deviation: 0.05205007521185729
#island_id: 0
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4894734000000001}
#standard deviation: 0.04261554191184245
#island_id: 0
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3316073999999998}
#standard deviation: 0.04558037368473408
#island_id: 0
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.13358740000000016}
#standard deviation: 0.04697821411292686
#island_id: 1
#version_generated: 3
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': 0.1066774}
#standard deviation: 0.048260607219967715
#island_id: 3
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(abs(val) for val in [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(abs(val) for val in interacting_spins)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(abs(val) for val in [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]) + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3371586}
#standard deviation: 0.05073827121650875
#island_id: 3
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3371586}
#standard deviation: 0.05073827121650875
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2769202}
#standard deviation: 0.05380744699351568
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.2510046}
#standard deviation: 0.04295816219113662
#island_id: 3
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 * sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum(val for val in interacting_spins)
        
        # Add interaction with neighboring spins
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors + interacting_spins if val < 0])
          else:
            priorities[i * N * N + j * N + k][1] -= np.exp(abs(J[d, i, j, k])) * len([val for val in site_neighbors + interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.09160219999999998}
#standard deviation: 0.0474543531739713
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          if i < N - 1:
            priorities[i * N * N + j * N + k][0] += J[2, i, j, (k + 1) % N]
          if j < N - 1:
            priorities[i * N * N + j * N + k][0] += J[1, i, (j + 1) % N, k]
          if k < N - 1:
            priorities[i * N * N + j * N + k][0] += J[2, i, j, (k + 1) % N]
          
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          if i < N - 1:
            priorities[i * N * N + j * N + k][0] -= J[2, i, j, (k + 1) % N]
          if j < N - 1:
            priorities[i * N * N + j * N + k][0] -= J[1, i, (j + 1) % N, k]
          if k < N - 1:
            priorities[i * N * N + j * N + k][0] -= J[2, i, j, (k + 1) % N]
          
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.4308574}
#standard deviation: 0.047533550522131214
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              energy -= J[d, i, j, k]
            elif interacting_spins[d] > 0:
              energy += J[d, i, j, k]
            else:
              pass
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4334662}
#standard deviation: 0.03948966621231433
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 2
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4894770000000001}
#standard deviation: 0.04271266452704631
#island_id: 0
#version_generated: 3
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [interacting_spins[0, i, (j + 1) % N, k], 
                  interacting_spins[1, (i + 1) % N, j, k], 
                  interacting_spins[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.22836940000000036}
#standard deviation: 0.046117607739777654
#island_id: 0
#version_generated: 3
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
  
  return(priorities)




#score: {'data3D.txt': -0.37654580000000004}
#standard deviation: 0.04452569036365411
#island_id: 0
#version_generated: 3
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + sum(val for val in site_neighbors))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 1
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4765314}
#standard deviation: 0.03977670039156089
#island_id: 1
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin

  return(priorities)




#score: {'data3D.txt': -0.2800186}
#standard deviation: 0.04361884654641844
#island_id: 1
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46001980000000015}
#standard deviation: 0.044016864585747134
#island_id: 1
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add more terms based on the neighbors' spins...
  return(priorities)




#score: {'data3D.txt': -0.4308574}
#standard deviation: 0.047533550522131214
#island_id: 2
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.28942579999999996}
#standard deviation: 0.05326125809967316
#island_id: 2
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if site_nbr == i:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
        if site_nbr == j:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
        if site_nbr == k:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.028801399999999998}
#standard deviation: 0.04763537129108999
#island_id: 2
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = -J[0, i, j, k] * (h[i][j][k] + J[1, i, j, k]) - J[2, i, j, k] * (h[i][j][k] + h[(i+1)%N][j][k])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        priorities[i*N*N + j*N + k][0] = -np.exp(-abs(site_energy)) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N + j*N + k][1] = 2 - 2 * site_energy
  
  return(priorities)




#score: {'data3D.txt': -0.4155414000000001}
#standard deviation: 0.04719734109078604
#island_id: 2
#version_generated: 3
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the priority of site neighbors
        for d in [0, 1, 2]:
          if h[(i + ((d - 1) % 3 - 1)) % N][(j + ((d - 1) % 3 - 1)) % N][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i + ((d - 1) % 3 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, k]
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i + ((d - 1) % 3 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, k]
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.2242442}
#standard deviation: 0.04392704140230708
#island_id: 0
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] - 2*sum(int(interacting_spins[d, i, j, k]) for d in [0, 1, 2])) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 + total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin - 2
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.08128860000000036}
#standard deviation: 0.05257298574401116
#island_id: 0
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.37419140000000006}
#standard deviation: 0.04655306612931097
#island_id: 2
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+j+k)%3, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              energy -= J[d, i, j, k]
            elif interacting_spins[d] > 0:
              energy += J[d, i, j, k]
          
          site_neighbor_energy = sum([spin * s for s in site_neighbors])
          energy += site_neighbor_energy
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (energy)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in [0, 1, 2]]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if interacting_spins[d][i, j, k] < 0:
              energy -= J[d, i, j, k]
            elif interacting_spins[d][i, j, k] > 0:
              energy += J[d, i, j, k]
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 3
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              energy -= J[d, i, j, k]
            elif interacting_spins[d] > 0:
              energy += J[d, i, j, k]
            else:
              pass
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = np.exp(abs(total_spin)) * (2 - 2 * total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              energy -= J[d, i, j, k]
            elif interacting_spins[d] > 0:
              energy += J[d, i, j, k]
            else:
              pass
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1, 2]:
          interacting_spins[d] += J[d, i, j, k]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if interacting_spins[d] < 0:
              energy -= J[d, i, j, k]
            elif interacting_spins[d] > 0:
              energy += J[d, i, j, k]
            else:
              pass
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2836522}
#standard deviation: 0.04481454356746256
#island_id: 2
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3300730000000001}
#standard deviation: 0.04412803089873828
#island_id: 2
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum([1 if val < 0 else -1 for val in interacting_spins]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if sum([1 if val < 0 else -1 for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4308574}
#standard deviation: 0.047533550522131214
#island_id: 2
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2416354000000001}
#standard deviation: 0.052127907178784766
#island_id: 2
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4029362000000002}
#standard deviation: 0.046825725937352
#island_id: 2
#version_generated: 3
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the priority of site neighbors
        for d in [0, 1, 2]:
          if h[(i + ((d - 1) % 3 - 1)) % N][(j + ((d - 1) % 3 - 1)) % N][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i + ((d - 1) % 3 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, k]
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i + ((d - 1) % 3 - 1)) % N, (j + ((d - 1) % 3 - 1)) % N, k]
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the priority of site neighbors in the z-direction
        for d in [0, 1]:
          if h[(i + ((d - 1) % 2 - 1)) % N][(j + ((d - 1) % 2 - 1)) % N][((k + (d - 1) % 2 - 1)) % N] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i + ((d - 1) % 2 - 1)) % N, (j + ((d - 1) % 2 - 1)) % N, ((k + (d - 1) % 2 - 1)) % N]
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, (i + ((d - 1) % 2 - 1)) % N, (j + ((d - 1) % 2 - 1)) % N, ((k + (d - 1) % 2 - 1)) % N]
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.3681794}
#standard deviation: 0.04606246645198236
#island_id: 3
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total spin
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3579126}
#standard deviation: 0.04959035068680196
#island_id: 3
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of neighbors with the same spin as the current site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val == h[i][j][k]])
  
  return(priorities)




#score: {'data3D.txt': -0.4296186}
#standard deviation: 0.04284924006373975
#island_id: 3
#version_generated: 3
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.024081000000000196}
#standard deviation: 0.04930728910617579
#island_id: 3
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x)
        total_spin_y = np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = total_spin_y
        else:
          priorities[i * N * N + j * N + k][0] = 2 - 2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = -total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.005928199999999852}
#standard deviation: 0.04936403148811897
#island_id: 3
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x)
        total_spin_y = np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -2 * (total_spin_x / len(interacting_spins_x) + total_spin_y / len(interacting_spins_y))
          priorities[i * N * N + j * N + k][1] = total_spin_x + total_spin_y
        else:
          priorities[i * N * N + j * N + k][0] = 2 - 2 * (total_spin_x / len(interacting_spins_x) + total_spin_y / len(interacting_spins_y))
          priorities[i * N * N + j * N + k][1] = -total_spin_x - total_spin_y
  
  return(priorities)




#score: {'data3D.txt': 0.024081000000000196}
#standard deviation: 0.04930728910617579
#island_id: 3
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x)
        total_spin_y = np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = total_spin_y
        else:
          priorities[i * N * N + j * N + k][0] = 2 - 2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = -total_spin_y
  
  return(priorities)




#score: {'data3D.txt': 0.024081000000000196}
#standard deviation: 0.04930728910617579
#island_id: 3
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x)
        total_spin_y = np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = total_spin_y
        else:
          priorities[i * N * N + j * N + k][0] = 2 - 2 * (total_spin_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] = -total_spin_y
  
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        for spin in [-1,1]:
          energy = h[i][j][k] * spin
          for d in [0,1,2]:
            if interacting_spins[d] < 0:
              energy -= J[d,i,j,k]
            elif interacting_spins[d] > 0:
              energy += J[d,i,j,k]
            else:
              pass
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i*N*N+j*N+k][1] = np.exp(abs(total_spin)) * (2-2*total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              energy -= J[d, i, j, k]
            elif J[d, i, j, k] > 0:
              energy += J[d, i, j, k]
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = np.exp(abs(total_spin)) * (2 - 2 * total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.4334662}
#standard deviation: 0.03948966621231433
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44980939999999997}
#standard deviation: 0.040349843514442534
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          energy = h[i][j][k] * spin
          for d in [0, 1, 2]:
            if J[d, i, j, k] < 0:
              energy -= J[d, i, j, k]
            elif J[d, i, j, k] > 0:
              energy += J[d, i, j, k]
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * (energy)
          priorities[i * N * N + j * N + k][1] = np.exp(abs(total_spin)) * (2 - 2 * total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.056955399999999996}
#standard deviation: 0.045272806527097476
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.25846339999999995}
#standard deviation: 0.0440811644632943
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1601866}
#standard deviation: 0.045977224148919645
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.11659739999999999}
#standard deviation: 0.04555767019108857
#island_id: 2
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 + abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3371586}
#standard deviation: 0.05073827121650875
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3968962}
#standard deviation: 0.04797585044123762
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3371586}
#standard deviation: 0.05073827121650875
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.10957460000000001}
#standard deviation: 0.04419971170539464
#island_id: 3
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - sum([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2428634}
#standard deviation: 0.04681082204405302
#island_id: 0
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.346627}
#standard deviation: 0.04559193383702867
#island_id: 0
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.005339000000000006}
#standard deviation: 0.04700100423395229
#island_id: 0
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.40251780000000004}
#standard deviation: 0.0477358984744186
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = []
        for d in range(3):
          site_neighbors.append(J[0+d, i, (j+1)%N, k])
          site_neighbors.append(J[3+d, (i+1)%N, j, k])
        site_neighbors.extend([J[d,i,(j+1)%N,k] for d in [0,1,2]] + [J[d,i,j,(k+1)%N] for d in [0,1,2]])
        
        priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2416354000000001}
#standard deviation: 0.052127907178784766
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0826114}
#standard deviation: 0.0505929804423499
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        for spin in [-1,1]:
          energy = h[i][j][k] * spin
          for d in [0,1,2]:
            if interacting_spins[d] < 0:
              energy -= J[d,i,j,k]
            elif interacting_spins[d] > 0:
              energy += J[d,i,j,k]
            else:
              pass
          for neighbor_spin in site_neighbors:
            if neighbor_spin == spin:
              energy -= 1
            else:
              energy += 1
          
          probabilities = [np.exp(-energy) / (np.exp(-energy) + np.exp(energy)), np.exp(energy) / (np.exp(-energy) + np.exp(energy))]
          priorities[i*N*N+j*N+k] = probabilities
          
  return(priorities)




#score: {'data3D.txt': -0.3300730000000001}
#standard deviation: 0.04412803089873828
#island_id: 2
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum([1 if val < 0 else -1 for val in interacting_spins]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if sum([1 if val < 0 else -1 for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.171069}
#standard deviation: 0.051510131809188765
#island_id: 2
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum([1 if val < 0 else -1 for val in interacting_spins]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors.sort(key=lambda x: -x)
        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * 1
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(1)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(1)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1769414}
#standard deviation: 0.04992250760969445
#island_id: 2
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum([1 if val < 0 else -1 for val in interacting_spins]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 1
        
        if sum([1 if val < 0 else -1 for val in site_neighbors]) > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1119734}
#standard deviation: 0.06219759908903237
#island_id: 3
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[3, i, (j+d)%N, k] for d in [-1, 0, 1]]
        interacting_spins_z = [J[4, i, j, (k+d)%N] for d in [-1, 0, 1]]

        total_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        total_spin_y = sum(J[3+d, i, j, k] for d in [0, 1])
        total_spin_z = sum(J[4+d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y) + np.sum(np.exp(-np.abs(interacting_spins_z)) * interacting_spins_z)
          priorities[i * N * N + j * N + k][1] = -2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y)) - 2 * (total_spin_z / len(interacting_spins_z))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y) + np.sum(np.exp(np.abs(interacting_spins_z)) * interacting_spins_z)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y)) - 2 * (total_spin_z / len(interacting_spins_z))

  return(priorities)




#score: {'data3D.txt': -0.3075077999999999}
#standard deviation: 0.04597591477241099
#island_id: 3
#version_generated: 3
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N]]
        interacting_spins_y = [J[3, i, j, k], J[3, (i+1)%N, j, k], J[3, i, (j+1)%N, k], J[3, i, j, (k+1)%N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))

        site_neighbors_total = site_neighbors_x + site_neighbors_y
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(-np.abs([J[0, i, j, k], J[3, i, j, k]])) * [J[0, i, j, k], J[3, i, j, k]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total
        else:
          priorities[i * N * N + j * N + k][0] += np.sum(np.exp(np.abs([J[0, i, j, k], J[3, i, j, k]])) * [J[0, i, j, k], J[3, i, j, k]])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbors_total

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2]]) - sum(1 for val in site_neighbors if val < 0) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2]]) + sum(1 for val in site_neighbors if val > 0) - np.sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.1642846}
#standard deviation: 0.04541653534606091
#island_id: 3
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': 0.2767561999999999}
#standard deviation: 0.045119648508825966
#island_id: 3
#version_generated: 3
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (sum(interacting_spins) + sum(site_neighbors)) / 4
          priorities[i * N * N + j * N + k][1] -= 2 - (sum(interacting_spins) + sum(site_neighbors)) / 4
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (sum(interacting_spins) + sum(site_neighbors)) / 4
          priorities[i * N * N + j * N + k][1] -= 2 - (sum(interacting_spins) + sum(site_neighbors)) / 4
        
  return(priorities)




#score: {'data3D.txt': 0.10389579999999993}
#standard deviation: 0.051905221147395195
#island_id: 0
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*interacting_spins[d, i, j, k] - 1) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.071599}
#standard deviation: 0.04967515232991239
#island_id: 0
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0823638}
#standard deviation: 0.05205007521185729
#island_id: 0
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0157034}
#standard deviation: 0.047741973026258565
#island_id: 0
#version_generated: 3
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.13260300000000003}
#standard deviation: 0.054742609647330485
#island_id: 3
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': -0.1120538}
#standard deviation: 0.046926505362747825
#island_id: 3
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins)) * interacting_spins) - np.sum(np.exp(-np.abs(J[3:,i,j,k])) * J[3:,i,j,k])
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins)) * interacting_spins) - np.sum(np.exp(np.abs(J[3:,i,j,k])) * J[3:,i,j,k])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins) / len(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 1
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23481860000000007}
#standard deviation: 0.05777404481287425
#island_id: 1
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.383139}
#standard deviation: 0.04912836491274669
#island_id: 1
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39634940000000013}
#standard deviation: 0.0436854332660213
#island_id: 1
#version_generated: 3
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])

        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin

  return(priorities)




#score: {'data3D.txt': -0.02873300000000007}
#standard deviation: 0.04787457060904046
#island_id: 3
#version_generated: 3
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(np.exp(-np.abs(val)) * val for val in interacting_spins_x)
        total_spin_y = sum(np.exp(np.abs(val)) * val for val in interacting_spins_y)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N], J[2, i, (j + 1) % N, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_x - total_spin_y + len([val for val in interacting_spins_x if val < 0]) - sum([np.exp(-np.abs(val)) for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = total_spin_x - total_spin_y + len([val for val in interacting_spins_x if val > 0]) - sum([np.exp(np.abs(val)) for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
  
  return priorities




#score: {'data3D.txt': -0.0333598}
#standard deviation: 0.05020171813752992
#island_id: 1
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0333598}
#standard deviation: 0.05020171813752992
#island_id: 1
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.21588460000000007}
#standard deviation: 0.05580496969661396
#island_id: 1
#version_generated: 3
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in range(6) if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0333598}
#standard deviation: 0.05020171813752992
#island_id: 1
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 1
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3167818}
#standard deviation: 0.050958019866945384
#island_id: 1
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 1
#version_generated: 3
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0323994}
#standard deviation: 0.04595989164086443
#island_id: 3
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
  
  return(priorities)




#score: {'data3D.txt': 0.1642846}
#standard deviation: 0.04541653534606091
#island_id: 3
#version_generated: 3
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': 0.1642846}
#standard deviation: 0.04541653534606091
#island_id: 3
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
        # Additional improvement: Consider the magnetism at each site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': 0.2957137999999999}
#standard deviation: 0.04639108674691725
#island_id: 3
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - total_neighbor_spin / 3
          priorities[i * N * N + j * N + k][1] -= 2 - (total_neighbor_spin / 3)
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - total_neighbor_spin / 3
          priorities[i * N * N + j * N + k][1] -= 2 - (total_neighbor_spin / 3)
  
  return(priorities)




#score: {'data3D.txt': 0.0126958}
#standard deviation: 0.045788822897733464
#island_id: 1
#version_generated: 3
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46001980000000015}
#standard deviation: 0.044016864585747134
#island_id: 1
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add more terms based on the neighbors' spins...
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = h[i, j, k] + J[3, i, j, k] - J[4, i, j, k] - J[5, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [interacting_spins] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [interacting_spins] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.36216139999999997}
#standard deviation: 0.039069746736317607
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [interacting_spins[0][i, (j + 1) % N, k], interacting_spins[1][(i + 1) % N, j, k], interacting_spins[2][i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - (total_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - (total_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin) / 2
  
  return(priorities)




#score: {'data3D.txt': -0.048114199999999996}
#standard deviation: 0.0450886863676466
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * sum([val for val in interacting_spins if val < 0]) - (sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)) / 4
          priorities[i * N * N + j * N + k][1] -= 2 - (sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)) / 4
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * sum([val for val in interacting_spins if val > 0]) - (sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)) / 4
          priorities[i * N * N + j * N + k][1] -= 2 - (sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)) / 4
  
  return(priorities)




#score: {'data3D.txt': -0.2637322}
#standard deviation: 0.0397490317260685
#island_id: 3
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - (total_spin + total_neighbor_spin) / 2
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2]]) - sum(1 for val in site_neighbors if val < 0) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2]]) + sum(1 for val in site_neighbors if val > 0) - np.sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2]]) - sum(1 for val in site_neighbors if val < 0) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2]]) + sum(1 for val in site_neighbors if val > 0) - np.sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0])
        
        # Add the spin at this site to both priorities
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2]]) - sum(1 for val in site_neighbors if val < 0) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2]]) + sum(1 for val in site_neighbors if val > 0) - np.sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.17621619999999982}
#standard deviation: 0.04477533894411075
#island_id: 0
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': 0.17621619999999982}
#standard deviation: 0.04477533894411075
#island_id: 0
#version_generated: 3
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
        
        # Calculate the local energy and add it to the priority list
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.15824700000000025}
#standard deviation: 0.04755232981673979
#island_id: 0
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.1551254000000003}
#standard deviation: 0.04936911579965755
#island_id: 0
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          # Add a new term based on the number of nearest neighbors with the same spin
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] += 2

          # Add a new term based on the number of nearest neighbors with the opposite spin
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] += 2

        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          # Add a new term based on the number of nearest neighbors with the same spin
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] -= 2

          # Add a new term based on the number of nearest neighbors with the opposite spin
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.48000139999999997}
#standard deviation: 0.04483831528993926
#island_id: 0
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.4744382}
#standard deviation: 0.04776037458772701
#island_id: 0
#version_generated: 3
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 4

  return(priorities)




#score: {'data3D.txt': 0.0126958}
#standard deviation: 0.045788822897733464
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more terms based on the neighbors' spins...
  return(priorities)




#score: {'data3D.txt': 0.0126958}
#standard deviation: 0.045788822897733464
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0126958}
#standard deviation: 0.045788822897733464
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more terms based on the neighbors' spins...
        
  return(priorities)




#score: {'data3D.txt': 0.0126958}
#standard deviation: 0.045788822897733464
#island_id: 1
#version_generated: 3
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(np.roll(h, -1, axis=0), -1, axis=1), 
             np.roll(np.roll(h, 1, axis=0), 1, axis=1), 
             np.roll(np.roll(h, -1, axis=1), 1, axis=0), 
             np.roll(np.roll(h, 1, axis=1), -1, axis=0), 
             h, np.roll(h, -1, axis=2)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0][i][j][k:] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more terms based on the neighbors' spins...
  return(priorities)




#score: {'data3D.txt': -0.4240462}
#standard deviation: 0.039979425528138844
#island_id: 2
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val < 0]) - len([val for val in J[0, i, j, k:3+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val > 0]) - len([val for val in J[0, i, j, k:3+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5067754}
#standard deviation: 0.04264138640851163
#island_id: 2
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N]]
        interacting_spins_y = [J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        interacting_spins_z = [J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (total_spin_x - total_spin_y) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (total_spin_x - total_spin_y) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': -0.06275900000000004}
#standard deviation: 0.04566096668928507
#island_id: 1
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.32582620000000007}
#standard deviation: 0.04666723040378549
#island_id: 1
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 1
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.529605}
#standard deviation: 0.039379788915127514
#island_id: 1
#version_generated: 3
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.3090726}
#standard deviation: 0.051198214512226885
#island_id: 2
#version_generated: 3
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_energy = h[i][j][k]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) - np.exp(-total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(-total_spin) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add the local energy term
        priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * site_energy
        priorities[i * N * N + j * N + k][1] -= 1
    
  return(priorities)




#score: {'data3D.txt': -0.3670222}
#standard deviation: 0.04315665264081542
#island_id: 2
#version_generated: 3
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[3, i, j, k]] if val < 0]) - len([val for val in site_neighbors + [J[3, i, j, k]] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[3, i, j, k]] if val > 0]) - len([val for val in site_neighbors + [J[3, i, j, k]] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j + 1) % N, k], J[3, (i + 1) % N, j, k], J[3, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4308574}
#standard deviation: 0.047533550522131214
#island_id: 2
#version_generated: 3
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if h[i][j][k] > 0:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.22948540000000003}
#standard deviation: 0.04311394886623122
#island_id: 0
#version_generated: 3
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors_same = [spin for spin in site_neighbors if spin < 0]
        site_neighbors_opposite = [spin for spin in site_neighbors if spin > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(site_neighbors_same)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(site_neighbors_opposite)
  
  return priorities




#score: {'data3D.txt': -0.28968940000000015}
#standard deviation: 0.05449985805155827
#island_id: 1
#version_generated: 3
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in range(6) if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin
        
  # Add a term based on the magnetism at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.004529}
#standard deviation: 0.04757221162611635
#island_id: 1
#version_generated: 3
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in range(6) if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin
        
        # Add a new term based on the number of nearest neighbors with different spin
        diff_spin = sum(1 for d in range(6) if J[d, i, j, k] != h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * diff_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * diff_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in range(6) if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        opposite_spin = sum(1 for d in range(6) if J[d, i, j, k] != h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * opposite_spin
        priorities[i * N * N + j * N + k][1] -= 2 * opposite_spin
        
  return(priorities)




#score: {'data3D.txt': 0.004380199999999999}
#standard deviation: 0.04856684185697069
#island_id: 1
#version_generated: 3
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in range(6) if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] -= same_spin
        
        # Add a new term based on the number of nearest neighbors with different spin
        diff_spin = sum(1 for d in range(6) if J[d, i, j, k] != h[i][j][k])
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * diff_spin
        priorities[i * N * N + j * N + k][1] += diff_spin
        
  return(priorities)




#score: {'data3D.txt': -0.30895619999999996}
#standard deviation: 0.0434261695474054
#island_id: 3
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of neighbors with the same spin as the current site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val == h[i][j][k]])
        
        # Add a new term based on the total spin of the site's neighbors
        total_neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] = -3 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3157994}
#standard deviation: 0.05210947591024113
#island_id: 3
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum(1 for d in [0, 1, 2] if J[d, i, j, k] > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - sum(1 for d in [0, 1, 2] if J[d, i, j, k] < 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of neighbors with the same spin as the current site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val == h[i][j][k]])
  
  return(priorities)




#score: {'data3D.txt': -0.3579126}
#standard deviation: 0.04959035068680196
#island_id: 3
#version_generated: 3
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of neighbors with the same spin as the current site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val == h[i][j][k]])
  
  return(priorities)




#score: {'data3D.txt': -0.27204940000000033}
#standard deviation: 0.044990302062111104
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(site_neighbors) / len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) / len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': 0.08200340000000003}
#standard deviation: 0.047684646883876594
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val < 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val > 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
  
  return(priorities)




#score: {'data3D.txt': -0.22836940000000036}
#standard deviation: 0.046117607739777654
#island_id: 0
#version_generated: 3
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
  
  return(priorities)




#score: {'data3D.txt': -0.22836940000000036}
#standard deviation: 0.046117607739777654
#island_id: 0
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
  
  return(priorities)




#score: {'data3D.txt': -0.06192819999999995}
#standard deviation: 0.04673292891270566
#island_id: 3
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins_x) + np.array(interacting_spins_y))) * (np.array(interacting_spins_x) + np.array(interacting_spins_y)))
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(np.array(interacting_spins_x) + np.array(interacting_spins_y))) * (np.array(interacting_spins_x) + np.array(interacting_spins_y)))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.11267060000000001}
#standard deviation: 0.04510944397396182
#island_id: 3
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        
  return(priorities)




#score: {'data3D.txt': -0.09792259999999998}
#standard deviation: 0.045890250481338636
#island_id: 3
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        site_magnetism = h[i][j][k]
        
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y)) + site_magnetism
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y)) - site_magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.06192819999999995}
#standard deviation: 0.04673292891270566
#island_id: 3
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(np.array(interacting_spins_x) + np.array(interacting_spins_y))) * (np.array(interacting_spins_x) + np.array(interacting_spins_y)))
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(np.array(interacting_spins_x) + np.array(interacting_spins_y))) * (np.array(interacting_spins_x) + np.array(interacting_spins_y)))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val < 0]) - len([val for val in J[0, i, j, k:3+1] if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[0, i, j, k:3+1] if val < 0]) + len([val for val in J[0, i, j, k:3+1] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:3+1] if val < 0]) - len([val for val in J[0, i, j, k:3+1] if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[0, i, j, k:3+1] if val < 0]) + len([val for val in J[0, i, j, k:3+1] if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[2, i, j, k - 1]] if val < 0]) - len([val for val in [J[2, i, j, k - 1]] if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[2, i, j, k - 1]] if val < 0]) + len([val for val in [J[2, i, j, k - 1]] if val > 0])
        
        return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.03342060000000001}
#standard deviation: 0.04798890971505813
#island_id: 3
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          if len([val for val in interacting_spins_x if val > 0]) > len([val for val in interacting_spins_x if val < 0]):
            priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
          elif len([val for val in interacting_spins_x if val < 0]) > len([val for val in interacting_spins_x if val > 0]):
            priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
          else:
            if sum(val for val in interacting_spins_x) > 0:
              priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
            else:
              priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
          
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          if len([val for val in interacting_spins_x if val > 0]) > len([val for val in interacting_spins_x if val < 0]):
            priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
          elif len([val for val in interacting_spins_x if val < 0]) > len([val for val in interacting_spins_x if val > 0]):
            priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
          else:
            if sum(val for val in interacting_spins_x) > 0:
              priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
            else:
              priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.07936340000000001}
#standard deviation: 0.04792868348327545
#island_id: 3
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]

        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = -2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))

        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41400139999999996}
#standard deviation: 0.048353238133965755
#island_id: 1
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.21080540000000036}
#standard deviation: 0.04746100136785989
#island_id: 1
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in interacting_spins if val < 0])
        interacting_spin_sum = sum(val for val in interacting_spins)
        
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        site_neighbor_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - interacting_spin_product) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbor_product) + site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_sum
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_product + site_neighbor_sum
          priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbor_sum
  
  return(priorities)




#score: {'data3D.txt': -0.0018278000000000005}
#standard deviation: 0.04697626025089694
#island_id: 2
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        neighbor_spins = [J[0, site_neighbors[0], site_neighbors[1], site_neighbors[2]], J[1, i, j, k], J[2, i, j, k]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.048435}
#standard deviation: 0.04523796298464377
#island_id: 2
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.06676820000000001}
#standard deviation: 0.04473671142093482
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          site_neighbors_distance_x = sum(abs(val) for val in interacting_spins_x)
          site_neighbors_distance_y = sum(abs(val) for val in interacting_spins_y)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) * (site_neighbors_distance_x / len(interacting_spins_x))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          site_neighbors_distance_x = sum(abs(val) for val in interacting_spins_x)
          site_neighbors_distance_y = sum(abs(val) for val in interacting_spins_y)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) * (site_neighbors_distance_y / len(interacting_spins_y))
        
  return(priorities)




#score: {'data3D.txt': -0.14509700000000003}
#standard deviation: 0.041562868897611
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)
        
        site_neighbors_distance_x = sum(abs(val) for val in interacting_spins_x)
        site_neighbors_distance_y = sum(abs(val) for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) * (site_neighbors_distance_y / len(interacting_spins_y))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) * (site_neighbors_distance_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
        
  return(priorities)




#score: {'data3D.txt': -0.1446422}
#standard deviation: 0.04363972157518881
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          site_neighbors_distance_x = sum(abs(val) for val in interacting_spins_x)
          site_neighbors_distance_y = sum(abs(val) for val in interacting_spins_y)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) * (site_neighbors_distance_x / len(interacting_spins_x))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          site_neighbors_distance_x = sum(abs(val) for val in interacting_spins_x)
          site_neighbors_distance_y = sum(abs(val) for val in interacting_spins_y)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) * (site_neighbors_distance_y / len(interacting_spins_y))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
        
  return(priorities)




#score: {'data3D.txt': -0.06676820000000001}
#standard deviation: 0.04473671142093482
#island_id: 3
#version_generated: 3
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = sum(val for val in interacting_spins_x)
        total_spin_y = sum(val for val in interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
        
        # Symmetry trick: use the same weights for both x and y directions
        site_neighbors_distance = sum(abs(val) for val in interacting_spins_x)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) * (site_neighbors_distance / len(interacting_spins_x))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) * (site_neighbors_distance / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.17833859999999999}
#standard deviation: 0.05019993814777065
#island_id: 1
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - len([val for val in interacting_spins if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0079758}
#standard deviation: 0.047073483133925835
#island_id: 1
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[d], -1, axis=0) for d in range(6)]
  interacting_spins += [np.roll(np.roll(J[d], -1, axis=1), -1, axis=1) for d in range(6)]
  interacting_spins += [np.roll(np.roll(np.roll(J[d], -1, axis=2), -1, axis=0), -1, axis=1) for d in range(6)]
  
  total_spin = np.sum(h, axis=(0, 1, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [interacting_spins[d][i, j, k] 
                  for d in [0, 1, 2, 3, 4, 5]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        site_neighbors = sum([val for val in interacting_spins if val < 0], [])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.048435}
#standard deviation: 0.04523796298464377
#island_id: 2
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.009851400000000001}
#standard deviation: 0.046031162901234636
#island_id: 2
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
        
        # Add interaction with the next layer of spins
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          total_site_neighbors = sum(val for val in site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
            
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.048435}
#standard deviation: 0.04523796298464377
#island_id: 2
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.175679}
#standard deviation: 0.04465259812149793
#island_id: 0
#version_generated: 3
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.44083659999999997}
#standard deviation: 0.04524062489002555
#island_id: 1
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1792814}
#standard deviation: 0.04189256991448483
#island_id: 1
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in interacting_spins if val < 0])
        interacting_spin_sum = sum(val for val in interacting_spins)
        
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        site_neighbor_sum = sum(val for val in site_neighbors)
        
        spin_magnetism = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (1 - interacting_spin_product) + total_spin + spin_magnetism
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (1 - site_neighbor_product) + site_neighbor_sum + spin_magnetism
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.21080540000000036}
#standard deviation: 0.04746100136785989
#island_id: 1
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in interacting_spins if val < 0])
        interacting_spin_sum = sum(val for val in interacting_spins)
        
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        site_neighbor_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - interacting_spin_product) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - site_neighbor_product) + site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_sum
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_product + site_neighbor_sum
          priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbor_sum
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        interacting_spin_sum = sum(val for val in interacting_spins)
        interacting_spin_product = np.prod([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(interacting_spin_sum)) * abs(interacting_spin_sum) - 2 * site_neighbor_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(interacting_spin_sum)) * interacting_spin_product + site_neighbor_product
        
  return(priorities)




#score: {'data3D.txt': -0.44083659999999997}
#standard deviation: 0.04524062489002555
#island_id: 1
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43011940000000004}
#standard deviation: 0.045468101605851116
#island_id: 1
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[d, (i + d) % N, j, k])
          site_neighbors.append(J[d, i, (j + d) % N, k])
          site_neighbors.append(J[d, i, j, (k + d) % N])
        
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0107042}
#standard deviation: 0.04479156418746727
#island_id: 1
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.sum(np.abs(J[:, i, j, k])) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= np.sum(J[:, i, j, k]) * interacting_spin_product
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.2304578}
#standard deviation: 0.044826795325563926
#island_id: 0
#version_generated: 3
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the site's spin
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4188146}
#standard deviation: 0.046892922140126865
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44083659999999997}
#standard deviation: 0.04524062489002555
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44083659999999997}
#standard deviation: 0.04524062489002555
#island_id: 1
#version_generated: 3
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.28106420000000004}
#standard deviation: 0.04531835387963687
#island_id: 0
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                 J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val < 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val > 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2 * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.03368060000000001}
#standard deviation: 0.04902350154405539
#island_id: 0
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                 J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N]]
        
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val < 0 for val in site_neighbors]) - interacting_spin_sum
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-total_spin)) - np.exp(-total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val > 0 for val in site_neighbors]) - interacting_spin_sum
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-total_spin)) - np.exp(-total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.3974174}
#standard deviation: 0.047850676664390024
#island_id: 0
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                 J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val < 0 for val in site_neighbors]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]]))) + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val > 0 for val in site_neighbors]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]]))) + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.12470699999999998}
#standard deviation: 0.047089108199242856
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.12470699999999998}
#standard deviation: 0.047089108199242856
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.15061860000000002}
#standard deviation: 0.04491365242373415
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_signs = [1 if val > 0 else -1 for val in site_neighbors]
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * sum(site_neighbor_signs) / len(site_neighbor_signs)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_signs = [1 if val > 0 else -1 for val in site_neighbors]
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * sum(site_neighbor_signs) / len(site_neighbor_signs)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.024706600000000002}
#standard deviation: 0.04554269421586738
#island_id: 3
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Improved priority calculation for site with positive magnetism
          spin_diff = sum(1 if val < 0 else -1 for val in interacting_spins)
          neighbor_spin_diff = sum(1 if val < 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_diff - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(abs(J[d, i, j, k])) * J[d, i, j, k] for d in [0, 1, 2]]) - (total_spin + total_neighbor_spin) / 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Improved priority calculation for site with negative magnetism
          spin_diff = sum(1 if val > 0 else -1 for val in interacting_spins)
          neighbor_spin_diff = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * spin_diff - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18347019999999997}
#standard deviation: 0.04526297462562531
#island_id: 3
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_weights = [0.5, 0.3, 0.2]
          priorities[i * N * N + j * N + k][0] += sum(val * weight for val, weight in zip(site_neighbors, neighbor_weights))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_weights = [0.5, 0.3, 0.2]
          priorities[i * N * N + j * N + k][0] += sum(val * weight for val, weight in zip(site_neighbors, neighbor_weights))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1253838}
#standard deviation: 0.04654687720524333
#island_id: 3
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(np.abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2]]) - sum(1 for val in site_neighbors if val < 0) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2]]) + sum(1 for val in site_neighbors if val > 0) - np.sum([J[d, i, j, k] for d in [0, 1, 2]])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.23858020000000002}
#standard deviation: 0.04586263803969415
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(sum([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4234794000000002}
#standard deviation: 0.04280508913248517
#island_id: 2
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = J[0, i, j, k]
        interacting_spins_y = J[1, i, j, k]
        interacting_spins_z = J[2, i, j, k]

        total_spin_x = sum(J[d, i, j, k] for d in [0])
        total_spin_y = sum(J[d, i, j, k] for d in [1])
        total_spin_z = sum(J[d, i, j, k] for d in [2])

        site_nbr_x = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_y = (j + ((i - 1) % 2 - 1)) % N
        site_nbr_z = (k + ((j - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val < 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val > 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val > 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val > 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z

  return(priorities)




#score: {'data3D.txt': -0.009851400000000001}
#standard deviation: 0.046031162901234636
#island_id: 2
#version_generated: 3
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors

        # Add interaction with the next layer of spins
        for d in [3, 4, 5]:
          site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          total_site_neighbors = sum(val for val in site_neighbors)

          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors

          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors

  return priorities




#score: {'data3D.txt': 0.08128860000000036}
#standard deviation: 0.05257298574401116
#island_id: 0
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': 0.15805780000000003}
#standard deviation: 0.04754863425125899
#island_id: 0
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (2 - 2 * total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = np.exp(-abs(total_spin)) * (2 - 2 * total_spin)

  return(priorities)




#score: {'data3D.txt': -0.29885820000000013}
#standard deviation: 0.04457873677842385
#island_id: 0
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_energy = h[i][j][k]
        neighbor_energy = -sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy) * (1 - total_spin/2) + neighbor_energy
          priorities[i * N * N + j * N + k][1] = -2 - site_energy + neighbor_energy
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-site_energy) * (1 + total_spin/2) - neighbor_energy
          priorities[i * N * N + j * N + k][1] = 2 + site_energy - neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0775198}
#standard deviation: 0.04388137381577747
#island_id: 0
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors_same = [spin for spin in site_neighbors if spin < 0]
        site_neighbors_opposite = [spin for spin in site_neighbors if spin > 0]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(site_neighbors_same)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(site_neighbors_opposite)

        # Add a new term based on the number of diagonal neighbors with the same spin
        diagonal_neighbors_same = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        diagonal_neighbors_opposite = [spin for spin in diagonal_neighbors_same if spin > 0]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(diagonal_neighbors_same)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(diagonal_neighbors_opposite)

  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0359738}
#standard deviation: 0.044486160472218775
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.0359738}
#standard deviation: 0.044486160472218775
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.0359738}
#standard deviation: 0.044486160472218775
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.0359738}
#standard deviation: 0.044486160472218775
#island_id: 3
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) - np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (sum(val for val in interacting_spins_x) / len(interacting_spins_x)) - 2 * (sum(val for val in interacting_spins_y) / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.28429780000000004}
#standard deviation: 0.043977280442974186
#island_id: 2
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d,f,g in [(0,1,0), (1,0,1), (2,-1,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) 
        priorities[i * N * N + j * N + k][1] -= sum([2*val for val in site_neighbors])
        
  return priorities




#score: {'data3D.txt': -0.0067866}
#standard deviation: 0.045963562312336066
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the total spin at the current site
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the product of all neighboring spins
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        # Calculate the priority for assigning a spin to -1 or 1 based on the total spin and neighboring spins
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + np.sum([J[d, i, j, k]*val for d,val in enumerate([1,-1]) if val*total_spin<0]))
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.076637}
#standard deviation: 0.04578640268682396
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(site_spin)) * abs(site_spin) - 2 * site_neighbor_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(site_spin)) * site_neighbor_product + site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(val for val in interacting_spins)
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        interacting_spin_sum = sum(val for val in interacting_spins)
        interacting_spin_product = np.prod([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(total_spin) - 2 * site_neighbor_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * interacting_spin_product + site_neighbor_product
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = sum(J[0, (i+d)%N, (j+f)%N, (k+g)%N] 
                     for d,f,g in [(0,1,0), (1,0,1), (2,-1,1)])
        interacting_spins_y = sum(J[1, (i+d)%N, (j+f)%N, (k+g)%N] 
                     for d,f,g in [(0,1,0), (1,0,1), (2,-1,1)])
        interacting_spins_z = sum(J[2, (i+d)%N, (j+f)%N, (k+g)%N] 
                     for d,f,g in [(0,1,0), (1,0,1), (2,-1,1)])

        total_spin_x = sum(J[d, i, j, k] for d in [0])
        total_spin_y = sum(J[d, i, j, k] for d in [1])
        total_spin_z = sum(J[d, i, j, k] for d in [2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z

  return priorities




#score: {'data3D.txt': -0.4553774000000001}
#standard deviation: 0.04141648378653118
#island_id: 2
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d,f,g in [(0,1,0), (1,0,1), (2,-1,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) 
        priorities[i * N * N + j * N + k][1] -= sum([2*val for val in site_neighbors])
        
        # additional improvement here
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.28429780000000004}
#standard deviation: 0.043977280442974186
#island_id: 2
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d,f,g in [(0,1,0), (1,0,1), (2,-1,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) 
        priorities[i * N * N + j * N + k][1] -= sum([2*val for val in site_neighbors])
        
  return priorities




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v2`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_spin = h[i, j, k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.507693}
#standard deviation: 0.043581602896176276
#island_id: 1
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_spin = h[i, j, k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.prod([val for val in [site_spin] + site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.prod([val for val in [site_spin] + site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 1
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the site's spin
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44083659999999997}
#standard deviation: 0.04524062489002555
#island_id: 1
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4234794000000002}
#standard deviation: 0.04280508913248517
#island_id: 2
#version_generated: 3
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = J[0, i, j, k]
        interacting_spins_y = J[1, i, j, k]
        interacting_spins_z = J[2, i, j, k]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0])
        total_spin_y = sum(J[d, i, j, k] for d in [1])
        total_spin_z = sum(J[d, i, j, k] for d in [2])
        
        site_nbr_x = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_y = (j + ((i - 1) % 2 - 1)) % N
        site_nbr_z = (k + ((j - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val < 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val < 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val > 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val > 0]) + total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in [interacting_spins_x, interacting_spins_y, interacting_spins_z] if val > 0]) + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-sum(abs(val) for val in interacting_spins)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-sum(abs(val) for val in interacting_spins)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in interacting_spins)
  
  return(priorities)




#score: {'data3D.txt': -0.10076660000000007}
#standard deviation: 0.04628983262488644
#island_id: 0
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + 1) % N, j, k] if d == 0 else J[d, i, (j + 1) % N, k] if d == 1 else J[d, i, j, (k + 1) % N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [spin for spin in interacting_spins if spin < 0], [spin for spin in interacting_spins if spin > 0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors[0]) - len(site_neighbors[1])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len(site_neighbors[1]) - len(site_neighbors[0])) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
  
  return(priorities)




#score: {'data3D.txt': 0.03849179999999996}
#standard deviation: 0.1215264791424485
#island_id: 3
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = [J[0, i, j, k] for i in range(3) for j in range(N) for k in range(N)]
  interacting_spins_y = [J[1, i, j, k] for i in range(N) for j in range(3) for k in range(N)]
  interacting_spins_z = [J[2, i, j, k] for i in range(N) for j in range(N) for k in range(3)]
  
  site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
  site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
  site_neighbors_z = sum([val for val in interacting_spins_z if val > 0]) - len(interacting_spins_z)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y) + np.sum(np.exp(-np.abs(interacting_spins_z)) * interacting_spins_z)
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y)) - 2 * (site_neighbors_z / len(interacting_spins_z))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y) + np.sum(np.exp(np.abs(interacting_spins_z)) * interacting_spins_z)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y)) - 2 * (site_neighbors_z / len(interacting_spins_z))
  
  return(priorities)




#score: {'data3D.txt': -0.1920394}
#standard deviation: 0.04563046534542465
#island_id: 3
#version_generated: 3
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        site_neighbors_x = sum([val for val in interacting_spins_x if val > 0]) - len(interacting_spins_x)
        site_neighbors_y = sum([val for val in interacting_spins_y if val > 0]) - len(interacting_spins_y)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(-np.abs(interacting_spins_y)) * interacting_spins_y) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(np.abs(interacting_spins_x)) * interacting_spins_x) + np.sum(np.exp(np.abs(interacting_spins_y)) * interacting_spins_y) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (site_neighbors_x / len(interacting_spins_x)) - 2 * (site_neighbors_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': 0.22650100000000037}
#standard deviation: 0.044187801020191084
#island_id: 3
#version_generated: 3
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins_y = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_x = np.sum(interacting_spins_x)
        total_spin_y = np.sum(interacting_spins_y)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-total_spin_x) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
          
          priorities[i * N * N + j * N + k][0] += -np.exp(-total_spin_y) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin_x) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
          
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin_y) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x / len(interacting_spins_x)) - 2 * (total_spin_y / len(interacting_spins_y))
  
  return(priorities)




#score: {'data3D.txt': 0.115357}
#standard deviation: 0.05344618780605404
#island_id: 1
#version_generated: 3
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - 2) + np.exp(-abs(total_spin)) * site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3887242}
#standard deviation: 0.04238535377179245
#island_id: 1
#version_generated: 3
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * site_nbr
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i, j, k]
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i, j, k])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.488377}
#standard deviation: 0.045646794312415855
#island_id: 1
#version_generated: 3
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= abs(neighbor_spin)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += abs(neighbor_spin)
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(site_spin))
          priorities[i * N * N + j * N + k][1] -= abs(site_spin)
        elif site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + abs(site_spin))
          priorities[i * N * N + j * N + k][1] += abs(site_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.41400139999999996}
#standard deviation: 0.048353238133965755
#island_id: 1
#version_generated: 3
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_nbr
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2521878}
#standard deviation: 0.046833414259052235
#island_id: 0
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(site_neighbors) / len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) / len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.27204940000000033}
#standard deviation: 0.044990302062111104
#island_id: 0
#version_generated: 3
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-abs(total_spin)))
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(site_neighbors) / len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][1] -= sum(site_neighbors) / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.5215186}
#standard deviation: 0.04238941441020388
#island_id: 2
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin) * (total_spin > 0)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (total_neighbor_spin) * (total_spin < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 2
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.22793420000000006}
#standard deviation: 0.0450232840912344
#island_id: 2
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1

  return(priorities)




#score: {'data3D.txt': -0.42835540000000005}
#standard deviation: 0.04321519606388475
#island_id: 1
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[3+d%3, (i + d) % N, j, k])
          site_neighbors.append(J[d, i, (j + d) % N, k])
          site_neighbors.append(J[d, i, j, (k + d) % N])
        
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4312542}
#standard deviation: 0.04449650303518244
#island_id: 1
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[3-d, (i + d) % N, j, k])
          site_neighbors.append(J[3-d, i, (j + d) % N, k])
          site_neighbors.append(J[3-d, i, j, (k + d) % N])
        
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4290638}
#standard deviation: 0.044462399053132526
#island_id: 1
#version_generated: 3
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[d, (i + d) % N, j, k])
          site_neighbors.append(J[d, i, (j + d) % N, k])
          site_neighbors.append(J[d, i, j, (k + d) % N])
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[d, (i + d) % N, j, k])
          site_neighbors.append(J[d, i, (j + d) % N, k])
          site_neighbors.append(J[d, i, j, (k + d) % N])
        interacting_spin_product = np.prod([val for val in [sum(J[d, i, j, k] for d in [0, 1, 2])] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * interacting_spin_product
  return(priorities)




#score: {'data3D.txt': -0.3302662}
#standard deviation: 0.04893616063362552
#island_id: 1
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_sum = sum([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - len([val for val in interacting_spins if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors_sum = sum([val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum - interacting_spin_sum)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.35744139999999996}
#standard deviation: 0.045367852120637146
#island_id: 1
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_sum = sum([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - len([val for val in interacting_spins if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1419694000000002}
#standard deviation: 0.04767919948614909
#island_id: 0
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.1419694000000002}
#standard deviation: 0.04767919948614909
#island_id: 0
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.1419694000000002}
#standard deviation: 0.04767919948614909
#island_id: 0
#version_generated: 3
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-abs(total_spin)))
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.4180754}
#standard deviation: 0.04084541436734362
#island_id: 2
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(J[d][i][j][k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * h[i,j,k]
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2874633999999999}
#standard deviation: 0.047057066849092936
#island_id: 0
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * interacting_spins
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.05923140000000003}
#standard deviation: 0.047310321221061276
#island_id: 3
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add terms based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add terms based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.423499}
#standard deviation: 0.04015362896426673
#island_id: 3
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, (k - 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.006567000000000001}
#standard deviation: 0.04605117578303511
#island_id: 1
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the total spin at the current site
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the product of all neighboring spins
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        # Calculate the priority for assigning a spin to -1 or 1 based on the total spin and neighboring spins
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + np.sum([J[d, i, j, k]*val for d,val in enumerate([-1,1]) if val*total_spin<0]))
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0055246}
#standard deviation: 0.046153689720757965
#island_id: 1
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the total spin at the current site
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the product of all neighboring spins
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        # Calculate the priority for assigning a spin to -1 or 1 based on the total spin and neighboring spins
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + np.sum([J[d, i, j, k]*val for d,val in enumerate([-1,1]) if val*total_spin<0]))
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
        
  # Calculate the interaction with the next layer
  interacting_spins = [np.roll(h, -1, axis=d) for d in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the total spin at the current site
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the product of all neighboring spins
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        # Calculate the priority for assigning a spin to -1 or 1 based on the total spin and neighboring spins
        priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * (neighbor_product + np.sum([J[d, i, j, k]*val for d,val in enumerate([-1,1]) if val*total_spin<0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0067866}
#standard deviation: 0.045963562312336066
#island_id: 1
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + np.sum([J[d, i, j, k]*val for d,val in enumerate([1,-1]) if val*total_spin<0]))
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0035734}
#standard deviation: 0.0475810825059708
#island_id: 1
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the total spin at the current site
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the product of all neighboring spins
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        # Calculate the priority for assigning a spin to -1 or 1 based on the total spin and neighboring spins
        priorities[i*N*N+k][0] += (np.exp(-abs(total_spin)) * (neighbor_product + 2*np.sum([J[d, i, j, k]*val for d,val in enumerate([1,-1]) if val*total_spin<0])) - np.exp(abs(total_spin)) * (2-2*total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.1199718}
#standard deviation: 0.046119040371195935
#island_id: 2
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
          
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[site_nbr][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0019986000000001354}
#standard deviation: 0.049893959133746855
#island_id: 2
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = -1
        
        site_neighbors.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0031122}
#standard deviation: 0.046932123872247676
#island_id: 2
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
          
        return(priorities)




#score: {'data3D.txt': -0.16985380000000033}
#standard deviation: 0.04711972353017364
#island_id: 2
#version_generated: 3
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
          
          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.28106420000000004}
#standard deviation: 0.04531835387963687
#island_id: 0
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val < 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val > 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.28309180000000006}
#standard deviation: 0.04498587792585578
#island_id: 0
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in interacting_spins]) - np.prod([val < 0 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in interacting_spins]) - np.prod([val > 0 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.28106420000000004}
#standard deviation: 0.04531835387963687
#island_id: 0
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                 J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val < 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - np.prod([val > 0 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 * (1 - np.exp(-np.sum([abs(J[d, i, j, k]) for d in [0, 1, 2]])))
        
        # Add a new term based on the local energy and interaction with nearest neighbors
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1012554}
#standard deviation: 0.04673494892304901
#island_id: 3
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          for spin in interacting_spins:
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 1
            elif spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          for spin in interacting_spins:
            if spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 1
            elif spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, (k - 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.025697799999999903}
#standard deviation: 0.0457923416649553
#island_id: 3
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        for d in [0, 1]:
          if i + d == site_nbr:
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2095138}
#standard deviation: 0.04607249645460945
#island_id: 3
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, (k - 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, (j - 1) % N, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.14372980000000024}
#standard deviation: 0.04506950268152512
#island_id: 3
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.39588020000000007}
#standard deviation: 0.044972444985346305
#island_id: 1
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for a,b,c in [(1,0,0), (0,1,0), (0,0,1)]]
        
        site_neighbors = sum(val for val in interacting_spins if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42385500000000004}
#standard deviation: 0.04459043008314676
#island_id: 1
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0667554}
#standard deviation: 0.05154293327741447
#island_id: 1
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        # Add a term to account for the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - len([val for val in interacting_spins if val < 0])) - h[i, j, k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46492420000000007}
#standard deviation: 0.04081632485121609
#island_id: 0
#version_generated: 3
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [interacting_spins[0, i, (j + 1) % N, k], 
                  interacting_spins[1, (i + 1) % N, j, k], 
                  interacting_spins[2, i, j, (k + 1) % N]]
        site_neighbor_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - site_neighbor_sum
        else:
          priorities[i*N*N + j*N + k][0] -= -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N*N + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - site_neighbor_sum
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3476354}
#standard deviation: 0.04470254922082185
#island_id: 3
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        for d in range(3):
          site_neighbor = J[d, i, (j+1) % N, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * site_neighbor
          priorities[i * N * N + j * N + k][1] -= 2 * site_neighbor
        
  return(priorities)




#score: {'data3D.txt': -0.2095138}
#standard deviation: 0.04607249645460945
#island_id: 3
#version_generated: 3
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, (k - 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, (j - 1) % N, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.2095138}
#standard deviation: 0.04607249645460945
#island_id: 3
#version_generated: 3
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, (k - 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, (j - 1) % N, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+d)%N, j, k])
          interacting_spins.append(J[d, i, (j+d)%N, k])
          interacting_spins.append(J[d, i, j, (k+d)%N])
        site_neighbors = sum([val for val in interacting_spins if val < 0], [])
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  return(priorities)




#score: {'data3D.txt': -0.44672540000000005}
#standard deviation: 0.04181994733186545
#island_id: 1
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in [0, 1, 2]:
          site_neighbors.append(J[d, (i + d) % N, j, k])
          site_neighbors.append(J[d, i, (j + d) % N, k])
          site_neighbors.append(J[d, i, j, (k + d) % N])
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = []
        for d in [3, 4, 5]:
          site_neighbors.append(J[d, (i + d) % N, j, k])
          site_neighbors.append(J[d, i, (j + d) % N, k])
          site_neighbors.append(J[d, i, j, (k + d) % N])
        interacting_spin_product = np.prod([val for val in [sum(J[d, i, j, k] for d in [3, 4, 5])] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [3, 4, 5]))) * interacting_spin_product
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 1
#version_generated: 3
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                  for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        site_neighbors = sum([val for val in interacting_spins if val < 0], [])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  min_val = minimize(lambda x: np.sum(x), x0=np.zeros(2)).x
  priorities[:, 0] += (priorities[:, 1] - 2) / 2
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N * N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        # your code here
  return priorities




#score: {'data3D.txt': 0.22047980000000006}
#standard deviation: 0.04853614397498013
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        total_spin_product = np.prod([val for val in site_neighbors if val < 0])
        total_spin_sum = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(site_spin)) * abs(site_spin) - 2 * total_spin_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(site_spin)) * total_spin_product + total_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3350889999999997}
#standard deviation: 0.04561945154207796
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        total_energy = -site_spin * (site_neighbor_sum + site_neighbor_product) + h[i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(total_energy)
        priorities[i * N * N + j * N + k][1] -= 2 * total_energy
        
  return(priorities)




#score: {'data3D.txt': -0.0205942}
#standard deviation: 0.04704148133679466
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        total_spin = site_spin + site_neighbor_sum
        interacting_spin_product = site_spin * site_neighbor_product
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(total_spin) - np.exp(-abs(site_spin)) * (1 - interacting_spin_product)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * site_neighbor_product + site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.005099000000000001}
#standard deviation: 0.046204543488708984
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        interacting_spins_sum = sum([-J[d, i, j, k]*val for d,val in enumerate([1,-1]) if val*total_spin<0])
        
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + interacting_spins_sum)
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.35744139999999996}
#standard deviation: 0.045367852120637146
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_sum = sum([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - len([val for val in interacting_spins if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0071146000000000004}
#standard deviation: 0.04596481466121668
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        interacting_spin_sum = sum([J[l,i,j,k] for l in range(6) if J[l,i,j,k]*total_spin<0])
        
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + interacting_spin_sum)
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.006204600000000001}
#standard deviation: 0.0464063256339047
#island_id: 1
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        interacting_spins = [J[3+i, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for i,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_interacting_spin = sum([val for val in interacting_spins])
        
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (neighbor_product + total_interacting_spin)
        priorities[i*N*N+k][1] -= 2 - 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.18015820000000018}
#standard deviation: 0.05167646478581909
#island_id: 2
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1
        
        if i > 0 and h[i-1][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
        if i < N-1 and h[i+1][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if j > 0 and h[i][j-1][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
        if j < N-1 and h[i][j+1][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0 and h[i][j][k-1] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 1
        
        if k < N-1 and h[i][j][k+1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.034010600000000134}
#standard deviation: 0.04622234100129504
#island_id: 2
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1

        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.22793420000000006}
#standard deviation: 0.0450232840912344
#island_id: 2
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1
  
  return priorities




#score: {'data3D.txt': -0.20700260000000026}
#standard deviation: 0.047106363404958364
#island_id: 1
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        total_energy = -np.sum([site_spin * val for val in site_neighbors]) + h[i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(total_energy)
        priorities[i * N * N + j * N + k][1] -= 2 * total_energy
  
  return(priorities)




#score: {'data3D.txt': -0.3350889999999997}
#standard deviation: 0.04561945154207796
#island_id: 1
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        total_energy = -site_spin * (site_neighbor_sum + site_neighbor_product) + h[i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(total_energy)
        priorities[i * N * N + j * N + k][1] -= 2 * total_energy
        
  return(priorities)




#score: {'data3D.txt': -0.2896178}
#standard deviation: 0.0461438251899428
#island_id: 1
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        total_energy = -site_spin * sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][0] += np.exp(total_energy)
        priorities[i * N * N + j * N + k][1] -= 2 * total_energy
        
  return(priorities)




#score: {'data3D.txt': -0.09325100000000003}
#standard deviation: 0.05044369136968469
#island_id: 1
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [h]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        site_neighbors = [site_spin] + [interacting_spins[d][i, j, k] for d in range(6)]
        
        neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        neighbor_sum = sum([1 if val < 0 else -1 for val in site_neighbors])

        total_energy = -site_spin * (neighbor_sum + neighbor_product) + h[i, j, k]

        priorities[i * N * N + j * N + k][0] += np.exp(total_energy)
        priorities[i * N * N + j * N + k][1] -= 2 * total_energy

  return priorities




#score: {'data3D.txt': -0.14372980000000024}
#standard deviation: 0.04506950268152512
#island_id: 3
#version_generated: 3
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.2622134000000004}
#standard deviation: 0.04678739510209987
#island_id: 3
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2

          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2

  return priorities




#score: {'data3D.txt': -0.07585020000000031}
#standard deviation: 0.04723192903068856
#island_id: 3
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 2
#version_generated: 3
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        priority_ones = np.exp(-abs(total_spin)) * interacting_spin_product
        priority_minus_ones = 2 - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= priority_minus_ones
        priorities[i * N * N + j * N + k][0] += np.max([priority_ones, priority_minus_ones])
  return(priorities)




#score: {'data3D.txt': -0.5168854000000002}
#standard deviation: 0.04169723476251153
#island_id: 1
#version_generated: 3
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_spin = h[i, j, k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.prod([val for val in [site_spin] + site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.prod([val for val in [site_spin] + site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.507693}
#standard deviation: 0.043581602896176276
#island_id: 1
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_spin = h[i, j, k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.prod([val for val in [site_spin] + site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.prod([val for val in [site_spin] + site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.09456620000000016}
#standard deviation: 0.0489281793812114
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                    for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        interacting_spin_sum = sum(val for val in interacting_spins)
        interacting_spin_product = np.prod([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(total_spin) - 2 * site_neighbor_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * interacting_spin_product + site_neighbor_product
        
  return(priorities)




#score: {'data3D.txt': -0.116247}
#standard deviation: 0.04602312887016701
#island_id: 1
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_sum = sum(val for val in interacting_spins)
        total_spin_product = np.prod([val for val in interacting_spins])
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin_sum)) * abs(total_spin_sum) + 2 * total_spin_product
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin_sum)) * total_spin_sum + site_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        interacting_spin_sum = sum(val for val in interacting_spins)
        interacting_spin_product = np.prod([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(interacting_spin_sum)) * abs(interacting_spin_sum) - 2 * site_neighbor_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(interacting_spin_sum)) * interacting_spin_product + site_neighbor_product
        
  return(priorities)




#score: {'data3D.txt': 0.0002366000000000006}
#standard deviation: 0.04847857238450819
#island_id: 1
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = np.array([J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                        for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        
        site_neighbor_sum = np.sum(site_neighbors < 0)
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        interacting_spin_sum = np.sum(interacting_spins)
        interacting_spin_product = np.prod([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(interacting_spin_sum)) * abs(interacting_spin_sum) - 2 * site_neighbor_sum
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(interacting_spin_sum)) * interacting_spin_product + site_neighbor_product
    
  return(priorities)




#score: {'data3D.txt': -0.2937306}
#standard deviation: 0.05052774627509127
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                   for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_sum = sum([val for val in interacting_spins])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - len([val for val in interacting_spins if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors_sum = sum([val for val in site_neighbors])
        
        site_neighbor_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (site_neighbor_product)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4017626}
#standard deviation: 0.04536882190712031
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                  for d,a,b,c in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)

        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])

        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors_sum = sum([val for val in site_neighbors])

        interacting_spins_sum = sum([val for val in interacting_spins])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-total_spin) * (site_neighbors_sum - interacting_spins_sum)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin) * (site_neighbors_sum - interacting_spins_sum)

  return(priorities)




#score: {'data3D.txt': -0.42385500000000004}
#standard deviation: 0.04459043008314676
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,(i+a)%N,(j+b)%N,(k+c)%N] 
                   for d,a,b,c in [(0,1,0,0),(1,0,1,0),(2,0,0,1)]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2842394000000002}
#standard deviation: 0.047936195172750204
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add the contribution from the three neighboring sites
        for d in [0, 1, 2]:
          for neighbor in [(i-1, j, k) if d == 0 else (i, j-1, k) if d == 1 else (i, j, k-1)]:
            if 0 <= neighbor[0] < N and 0 <= neighbor[1] < N and 0 <= neighbor[2] < N:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, neighbor[0], neighbor[1], neighbor[2]])) * (len([val for val in [J[d_, neighbor[0], neighbor[1], neighbor[2]] for d_ in [0, 1, 2]] if val < 0]) + len([val for val in [J[d_, neighbor[0], neighbor[1], neighbor[2]] for d_ in [0, 1, 2]] if val > 0])) + J[d, neighbor[0], neighbor[1], neighbor[2]]
              priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.07585020000000031}
#standard deviation: 0.04723192903068856
#island_id: 3
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[0, (i - 1) % N, j, k], J[1, i, (j - 1) % N, k], J[2, i, j, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors + diagonal_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors + diagonal_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.24588619999999997}
#standard deviation: 0.044230260790097085
#island_id: 0
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors_same = [spin for spin in site_neighbors if spin < 0]
        site_neighbors_opposite = [spin for spin in site_neighbors if spin > 0]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(site_neighbors_same)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(site_neighbors_opposite)

        # Add a new term based on the number of diagonal neighbors with the same spin
        diagonal_neighbors_same = [spin for spin in diagonal_neighbors if spin < 0]
        diagonal_neighbors_opposite = [spin for spin in diagonal_neighbors if spin > 0]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(diagonal_neighbors_same)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(diagonal_neighbors_opposite)

  return priorities




#score: {'data3D.txt': -0.0775198}
#standard deviation: 0.04388137381577747
#island_id: 0
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_same = [spin for spin in site_neighbors if spin < 0]
        site_neighbors_opposite = [spin for spin in site_neighbors if spin > 0]
        
        diagonal_neighbors_same = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        diagonal_neighbors_opposite = [spin for spin in diagonal_neighbors_same if spin > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(site_neighbors_same)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(site_neighbors_opposite)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(diagonal_neighbors_same)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(diagonal_neighbors_opposite)
        
  return priorities




#score: {'data3D.txt': -0.24588619999999997}
#standard deviation: 0.044230260790097085
#island_id: 0
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        diagonal_neighbors = [J[0,i,(j-1)%N,k], J[1,(i-1)%N,j,k], J[2,i,j,(k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors_same = [spin for spin in site_neighbors if spin < 0]
        site_neighbors_opposite = [spin for spin in site_neighbors if spin > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(site_neighbors_same)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(site_neighbors_opposite)
        
        # Add a new term based on the number of diagonal neighbors with the same spin
        diagonal_neighbors_same = [spin for spin in diagonal_neighbors if spin < 0]
        diagonal_neighbors_opposite = [spin for spin in diagonal_neighbors if spin > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_same)
        priorities[i * N * N + j * N + k][1] -= 2 * len(diagonal_neighbors_same)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(diagonal_neighbors_opposite)
        priorities[i * N * N + j * N + k][1] += 2 * len(diagonal_neighbors_opposite)
  
  return priorities




#score: {'data3D.txt': 0.2164158}
#standard deviation: 0.04758822071017154
#island_id: 2
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if site_neighbors[d-3] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if site_neighbors[d-3] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1
        
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if h[site_nbr][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -1
  
  return(priorities)




#score: {'data3D.txt': -0.20277860000000003}
#standard deviation: 0.04969691803361654
#island_id: 2
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
  
  return(priorities)




#score: {'data3D.txt': -0.1765182000000003}
#standard deviation: 0.04688625116982589
#island_id: 2
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = -1

  return(priorities)




#score: {'data3D.txt': -0.22647620000000018}
#standard deviation: 0.04722920699694204
#island_id: 2
#version_generated: 3
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.20277860000000003}
#standard deviation: 0.04969691803361654
#island_id: 2
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4541590000000001}
#standard deviation: 0.043956155871504504
#island_id: 2
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin) * (total_spin > 0)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (total_neighbor_spin) * (total_spin < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.20277860000000003}
#standard deviation: 0.04969691803361654
#island_id: 2
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2842394000000002}
#standard deviation: 0.047936195172750204
#island_id: 3
#version_generated: 3
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add the contribution from the three neighboring sites
        for d in [0, 1, 2]:
          for neighbor in [(i-1, j, k) if d == 0 else (i, j-1, k) if d == 1 else (i, j, k-1)]:
            if 0 <= neighbor[0] < N and 0 <= neighbor[1] < N and 0 <= neighbor[2] < N:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, neighbor[0], neighbor[1], neighbor[2]])) * (len([val for val in [J[d_, neighbor[0], neighbor[1], neighbor[2]] for d_ in [0, 1, 2]] if val < 0]) + len([val for val in [J[d_, neighbor[0], neighbor[1], neighbor[2]] for d_ in [0, 1, 2]] if val > 0])) + J[d, neighbor[0], neighbor[1], neighbor[2]]
              priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.034010600000000134}
#standard deviation: 0.04622234100129504
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1

        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.09163380000000017}
#standard deviation: 0.04552366524742928
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1

        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in range(3):
          if J[d, i, (j + 1) % N, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif J[d, i, (j + 1) % N, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.18820299999999987}
#standard deviation: 0.044820345726020464
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1

        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in range(3):
          if J[d, i, j, k] > 0:
            site_neighbors.append(J[d, (i+1)%N, j, k])
          elif J[d, i, j, k] < 0:
            site_neighbors.append(J[d, (i-1)%N, j, k])

        site_neighbors.sort()

        for val in interacting_spins:
          if val > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif val < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.034010600000000134}
#standard deviation: 0.04622234100129504
#island_id: 2
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1

        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4569922000000001}
#standard deviation: 0.043292737256496044
#island_id: 2
#version_generated: 3
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_neighbor_spin * (total_spin > 0)
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * total_neighbor_spin * (total_spin < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0823638}
#standard deviation: 0.05205007521185729
#island_id: 0
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0823638}
#standard deviation: 0.05205007521185729
#island_id: 0
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0823638}
#standard deviation: 0.05205007521185729
#island_id: 0
#version_generated: 3
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4188146}
#standard deviation: 0.046892922140126865
#island_id: 1
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        site_nbr = sum(J[3, i, j, k] for k in [0, 1])
        total_spin_product = np.prod([val for val in [total_spin] + site_nbr + [J[4, i, (j + 1) % N, k]] if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.037541}
#standard deviation: 0.04690007760121512
#island_id: 1
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,(i+a)%N,(j+b)%N,(k+c)%N] 
                   for d,a,b,c in [(0,1,0,0),(1,0,1,0),(2,0,0,1)]]
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        
        interacting_spin_product = np.prod([val for val in interacting_spins if val < 0])
        site_neighbor_product = np.prod([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(J[:, i, j, k]) / 2)) * interacting_spin_product * site_neighbor_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[:, i, j, k]) * interacting_spin_product * site_neighbor_product
        
  return(priorities)




#score: {'data3D.txt': -0.42385500000000004}
#standard deviation: 0.04459043008314676
#island_id: 1
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors if val < 0])
        
        neighboring_spins = [J[d, (i+a)%N, (j+b)%N, (k+c)%N] 
                    for d,a,b,c in [(0,1,0,0),(1,0,1,0),(2,0,0,1)]]
        
        site_spin_product = np.prod([val for val in [total_spin] + neighboring_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product * site_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.42385500000000004}
#standard deviation: 0.04459043008314676
#island_id: 1
#version_generated: 3
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,(i+a)%N,(j+b)%N,(k+c)%N] 
                   for d,a,b,c in [(0,1,0,0),(1,0,1,0),(2,0,0,1)]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors if val < 0)
        
        interacting_spin_product = np.prod([val for val in [total_spin] + site_neighbors + interacting_spins if val < 0])
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * interacting_spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.5090854}
#standard deviation: 0.0441552056595822
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.175679}
#standard deviation: 0.04465259812149793
#island_id: 0
#version_generated: 3
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.1632042}
#standard deviation: 0.045896305105748984
#island_id: 0
#version_generated: 3
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
  return priorities




#score: {'data3D.txt': -0.004897799999999999}
#standard deviation: 0.04727534828174194
#island_id: 2
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.2043054}
#standard deviation: 0.04836266463750731
#island_id: 2
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if site_neighbors[d-3] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if site_neighbors[d-3] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1
        
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if h[site_nbr][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -1
  
  return(priorities)




#score: {'data3D.txt': 0.2043054}
#standard deviation: 0.04836266463750731
#island_id: 2
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(6):
          if site_neighbors[d-3] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if site_neighbors[d-3] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] = 1
        
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if h[site_nbr][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -1
  
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 1
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1678314}
#standard deviation: 0.045138838421474696
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 2
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(-np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 1
#version_generated: 3
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -len(interacting_spins) + sum(1 for val in interacting_spins if val < 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d==0 else 
                    J[0, i, (j+1)%N, k] if d==1 else 
                    J[0, i, j, (k+1)%N] for d in range(6)]
        
        site_nbr = sum(-1 if val < 0 else 1 for val in interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * site_nbr
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.2622134000000004}
#standard deviation: 0.04678739510209987
#island_id: 3
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.2622134000000004}
#standard deviation: 0.04678739510209987
#island_id: 3
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2

          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2

  return priorities




#score: {'data3D.txt': -0.2622134000000004}
#standard deviation: 0.04678739510209987
#island_id: 3
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0]))
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.21033780000000032}
#standard deviation: 0.047254887695983364
#island_id: 3
#version_generated: 3
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[:, i, j, k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.roll(h[i], -1, axis=0)[j] + np.roll(h[:, j], -1, axis=1)[k] + h[i][j]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (interacting_spins < 0).sum() + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * ((interacting_spins < 0) | (interacting_spins == 0)).sum()
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-np.abs(total_spin)) * ((interacting_spins > 0) | (interacting_spins == 0)).sum()
            priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (interacting_spins > 0).sum() + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-np.abs(total_spin)) * ((interacting_spins > 0) | (interacting_spins == 0)).sum()
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * ((interacting_spins > 0) | (interacting_spins == 0)).sum()
            priorities[i * N * N + j * N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.120239}
#standard deviation: 0.04490443495914407
#island_id: 3
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          for spin in interacting_spins:
            if spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 1
            elif spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] < 0:
          for spin in interacting_spins:
            if spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 1
            elif spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, (k - 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a term based on the total spin of all neighbors
        neighbor_spins = [J[2, i, (j - 1) % N, k], J[0, i, j, (k - 1) % N]]
        if sum(neighbor_spin for neighbor_spin in neighbor_spins) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.28791220000000006}
#standard deviation: 0.04356662680492948
#island_id: 1
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.4376826}
#standard deviation: 0.03953300819871921
#island_id: 1
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # added
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2261582}
#standard deviation: 0.04580431652977697
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] = -total_spin
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([1 if val < 0 else -1 for val in site_neighbors])
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.28330700000000014}
#standard deviation: 0.046840025950035495
#island_id: 3
#version_generated: 3
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= 2
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2
          
  return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.13531900000000002}
#standard deviation: 0.04532178503766153
#island_id: 0
#version_generated: 3
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30801459999999997}
#standard deviation: 0.045638743922680435
#island_id: 1
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28791220000000006}
#standard deviation: 0.04356662680492948
#island_id: 1
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.2053634}
#standard deviation: 0.04378183710672726
#island_id: 1
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.18739700000000037}
#standard deviation: 0.04830502614635458
#island_id: 2
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
  
  return(priorities)




#score: {'data3D.txt': -0.226829}
#standard deviation: 0.05040938721111377
#island_id: 2
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
  
  return(priorities)




#score: {'data3D.txt': -0.1914478000000002}
#standard deviation: 0.046081657903769044
#island_id: 2
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors.count(-1) - site_neighbors.count(1))
          priorities[i * N * N + j * N + k][1] -= 2 * (site_neighbors.count(-1) - site_neighbors.count(1))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (site_neighbors.count(1) - site_neighbors.count(-1))
          priorities[i * N * N + j * N + k][1] = 2 * (site_neighbors.count(1) - site_neighbors.count(-1))

  return(priorities)




#score: {'data3D.txt': -0.21851299999999999}
#standard deviation: 0.051490869006067475
#island_id: 2
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbors_spin_sum = sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbors_spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 * neighbors_spin_sum

  return(priorities)




#score: {'data3D.txt': -0.0024546000000000004}
#standard deviation: 0.04698644931083855
#island_id: 0
#version_generated: 3
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 2
        
        return priorities




#score: {'data3D.txt': -0.09456620000000016}
#standard deviation: 0.0489281793812114
#island_id: 3
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          site_spin = sum(val for val in site_neighbors)
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          site_spin = sum(val for val in site_neighbors)
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
  
  return(priorities)




#score: {'data3D.txt': -0.08941700000000018}
#standard deviation: 0.049559970046399345
#island_id: 3
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          elif site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          elif site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
  
  return priorities




#score: {'data3D.txt': -0.09456620000000016}
#standard deviation: 0.0489281793812114
#island_id: 3
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          if site_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.28791220000000006}
#standard deviation: 0.04356662680492948
#island_id: 1
#version_generated: 3
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.2873570000000001}
#standard deviation: 0.04450027180815866
#island_id: 1
#version_generated: 3
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.28791220000000006}
#standard deviation: 0.04356662680492948
#island_id: 1
#version_generated: 3
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.28791220000000006}
#standard deviation: 0.04356662680492948
#island_id: 1
#version_generated: 3
#generate time22:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.5129914}
#standard deviation: 0.04280518807387722
#island_id: 2
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49569979999999997}
#standard deviation: 0.04020414207466688
#island_id: 2
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.237821}
#standard deviation: 0.05074981063018857
#island_id: 2
#version_generated: 2
#generate time22:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 3
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbor_spin < 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3573898}
#standard deviation: 0.04283428832092346
#island_id: 3
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for neighbor in site_neighbors if neighbor == J[2, i, j, k])
        opposite_spin_count = len(site_neighbors) - same_spin_count
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] += 2 * (same_spin_count - opposite_spin_count)
        
  return(priorities)




#score: {'data3D.txt': -0.0027930000000000003}
#standard deviation: 0.04703714522587441
#island_id: 3
#version_generated: 2
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.137299}
#standard deviation: 0.04083173176587053
#island_id: 2
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.19422059999999985}
#standard deviation: 0.04596462221796238
#island_id: 2
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(h[i][j][k])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.exp(-abs(h[i][j][k])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.237821}
#standard deviation: 0.05074981063018857
#island_id: 2
#version_generated: 3
#generate time22:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.137299}
#standard deviation: 0.04083173176587053
#island_id: 2
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.137299}
#standard deviation: 0.04083173176587053
#island_id: 2
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.137299}
#standard deviation: 0.04083173176587053
#island_id: 2
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3510906}
#standard deviation: 0.052007330172197844
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + site_nbr][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + site_nbr][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3573898}
#standard deviation: 0.04283428832092346
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for neighbor in site_neighbors if neighbor == J[2, i, j, k])
        opposite_spin_count = len(site_neighbors) - same_spin_count
        
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] += 2 * (same_spin_count - opposite_spin_count)
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 3
#version_generated: 3
#generate time22:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3636210000000001}
#standard deviation: 0.04452324515351504
#island_id: 2
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_spin = h[i][j][k]
        
        # Calculate interactions with all 6 neighboring sites
        for d in [0, 1, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          interacting_spins.append(neighbor_spin)
          
        total_spin = sum(interacting_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.275175}
#standard deviation: 0.044871157495656386
#island_id: 1
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.4673326000000001}
#standard deviation: 0.043683836567316295
#island_id: 1
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.2544254000000001}
#standard deviation: 0.044684387819908654
#island_id: 1
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_nbr_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(site_nbr_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.24327420000000005}
#standard deviation: 0.04549455939296478
#island_id: 1
#version_generated: 3
#generate time22:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.07911900000000015}
#standard deviation: 0.04764361320261091
#island_id: 0
#version_generated: 3
#generate time22:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.43456100000000003}
#standard deviation: 0.04088751935493275
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4713506000000002}
#standard deviation: 0.04555460020283352
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.007335800000000001}
#standard deviation: 0.04655337494059909
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -len(interacting_spins) + sum(1 for val in interacting_spins if val < 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3318446}
#standard deviation: 0.045668704063505025
#island_id: 1
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.30965780000000004}
#standard deviation: 0.043749907190301564
#island_id: 1
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.46814700000000004}
#standard deviation: 0.04383690444134942
#island_id: 1
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[3, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[3, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.4037822}
#standard deviation: 0.043254053719391436
#island_id: 1
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_neighbors.index(min(site_neighbors)) * N + k][0] += np.exp(-abs(total_spin)) * (1 if min(site_neighbors) < 0 else 0)
          priorities[i * N * N + site_neighbors.index(min(site_neighbors)) * N + k][1] -= 2 - 2 * min(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_neighbors.index(max(site_neighbors)) * N + k][0] -= np.exp(-abs(total_spin)) * (1 if max(site_neighbors) > 0 else 0)
          priorities[i * N * N + site_neighbors.index(max(site_neighbors)) * N + k][1] = -2 + 2 * max(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.4646082000000001}
#standard deviation: 0.04409634693214394
#island_id: 1
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) + total_spin
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
          
  return(priorities)




#score: {'data3D.txt': -0.4801182}
#standard deviation: 0.040857967506472956
#island_id: 1
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45799739999999994}
#standard deviation: 0.041636936885894954
#island_id: 0
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i, j, k] for d in [0, 1]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.4673326000000001}
#standard deviation: 0.043683836567316295
#island_id: 1
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        
  return priorities




#score: {'data3D.txt': -0.3677634000000001}
#standard deviation: 0.04548313424160652
#island_id: 1
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, (i + 1) % N, j, k]] if val < 0])
        priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum([J[0, i, j, k], J[1, (i + 1) % N, j, k]])
        
  return(priorities)




#score: {'data3D.txt': -0.23347340000000005}
#standard deviation: 0.042248962264652135
#island_id: 1
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return priorities




#score: {'data3D.txt': -0.3108738}
#standard deviation: 0.048520385340184595
#island_id: 1
#version_generated: 3
#generate time22:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 3
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val < 0]) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val > 0]) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2760882}
#standard deviation: 0.04259251038339957
#island_id: 3
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

        for d in [0, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.2713542000000002}
#standard deviation: 0.04658040813861551
#island_id: 3
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + site_nbr][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + site_nbr][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.0027321999999999997}
#standard deviation: 0.048278473910843535
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] += 2
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 2
  
  return priorities




#score: {'data3D.txt': -0.1396402000000001}
#standard deviation: 0.04462227721620671
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.480615}
#standard deviation: 0.03978356212055426
#island_id: 2
#version_generated: 3
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        spin_energy = -h[i][j][k] * total_spin
        
        for d in [0, 1, 2]:
          if interacting_spins[d] < 0:
            spin_energy -= np.exp(-abs(total_spin)) * J[d, i, j, k]
          else:
            spin_energy += np.exp(-abs(total_spin)) * J[d, i, j, k]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [3, 4, 5]:
          if site_neighbors[d - 3] < 0:
            spin_energy -= np.exp(-abs(total_spin)) * J[d, i, j, k]
          else:
            spin_energy += np.exp(-abs(total_spin)) * J[d, i, j, k]
        
        priorities[i * N * N + j * N + k][0] = -spin_energy
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.030712199999999995}
#standard deviation: 0.05195593913269204
#island_id: 2
#version_generated: 3
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the interaction with neighboring spins
        for d in [3, 4, 5]:
          site_nbr = (i + ((d - 3) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * J[d, site_nbr, j, k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * J[d, site_nbr, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.46977820000000003}
#standard deviation: 0.039245215310404404
#island_id: 2
#version_generated: 3
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the interaction with the nearest neighbors
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[site_nbr, j, k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.237821}
#standard deviation: 0.05074981063018857
#island_id: 2
#version_generated: 3
#generate time23:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and magnetism
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.43456100000000003}
#standard deviation: 0.04088751935493275
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4104206}
#standard deviation: 0.04670172947161593
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43456100000000003}
#standard deviation: 0.04088751935493275
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.43456100000000003}
#standard deviation: 0.04088751935493275
#island_id: 1
#version_generated: 3
#generate time23:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.1655794000000001}
#standard deviation: 0.04469744171247389
#island_id: 0
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0 or i == N - 1 or j == N - 1 or k == N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 4 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.11693740000000007}
#standard deviation: 0.0473894819684706
#island_id: 0
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the number of next nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          for m in range(N):
            if ((m + (d - 1) % 2 == 0)):
              next_neighbor_spin = J[d, m + d, j, k]
            else:
              next_neighbor_spin = J[1 - d, m - d, j, k]
            if neighbor_spin < 0 and next_neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0 and next_neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.12013940000000009}
#standard deviation: 0.0438387778985683
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(interacting_spins)
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.13443740000000012}
#standard deviation: 0.04509445200066191
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy and nearest neighbors' spins
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.34222139999999956}
#standard deviation: 0.04501484268594082
#island_id: 0
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] += 2

  return priorities




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 0
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
  
  return priorities




#score: {'data3D.txt': -0.0691418}
#standard deviation: 0.04555846104468412
#island_id: 0
#version_generated: 3
#generate time23:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] += 2
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[d, i+1, j, k] for d in [0, 1]) if (i+1) < N else 0
        priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] += neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.294255}
#standard deviation: 0.05143871747040355
#island_id: 1
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.3108738}
#standard deviation: 0.048520385340184595
#island_id: 1
#version_generated: 3
#generate time23:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.3108738}
#standard deviation: 0.048520385340184595
#island_id: 1
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        
  return priorities




#score: {'data3D.txt': -0.4142238000000001}
#standard deviation: 0.049988009297830614
#island_id: 2
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i+d)%N, j, k])
          else:
            interacting_spins.append(J[d, i, (j+d)%N, k])
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4501478000000001}
#standard deviation: 0.04215282333557268
#island_id: 2
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5129914}
#standard deviation: 0.04280518807387722
#island_id: 2
#version_generated: 3
#generate time23:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add more logic here to make it better
  return(priorities)




#score: {'data3D.txt': -0.497391}
#standard deviation: 0.0396872145533042
#island_id: 2
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.47391300000000003}
#standard deviation: 0.04511331589453385
#island_id: 2
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = sum(J[d, i, j, k] for i in range(N) for j in range(N))
          else:
            neighbor_spin = sum(J[d, i, j, k] for i in range(N) for j in range(N) if (i + (d - 1) % 2 == 0 and j < k))
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
          
  return(priorities)




#score: {'data3D.txt': -0.487781}
#standard deviation: 0.03901394211048148
#island_id: 2
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time23:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4761278}
#standard deviation: 0.04318849230014866
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [(site_neighbors[0] if d == 0 else (site_neighbors[1] if d == 1 else site_neighbors[2])) for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0818794}
#standard deviation: 0.04557601974328167
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_neighbors.index(min(site_neighbors)) * N + k][0] += np.exp(-abs(total_spin)) * (1 if min(site_neighbors) < 0 else 0)
          priorities[i * N * N + site_neighbors.index(min(site_neighbors)) * N + k][1] -= 2 - 2 * min(site_neighbors)

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_neighbors.index(max(site_neighbors)) * N + k][0] += np.exp(-abs(total_spin)) * (1 if max(site_neighbors) > 0 else 0)
          priorities[i * N * N + site_neighbors.index(max(site_neighbors)) * N + k][1] = -2 + 2 * max(site_neighbors)

  return(priorities)




#score: {'data3D.txt': 0.08391180000000002}
#standard deviation: 0.0462675871508338
#island_id: 3
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - 1)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.1290642}
#standard deviation: 0.050313792128600286
#island_id: 3
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.2760882}
#standard deviation: 0.04259251038339957
#island_id: 3
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

        for d in [0, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.2760882}
#standard deviation: 0.04259251038339957
#island_id: 3
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

        for d in [0, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.1792322}
#standard deviation: 0.043714675375210094
#island_id: 3
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.17666500000000002}
#standard deviation: 0.04384042307049511
#island_id: 3
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [0, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [1, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26180780000000003}
#standard deviation: 0.04781549517844608
#island_id: 0
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 1
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 1
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
              priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.16333859999999997}
#standard deviation: 0.043926217570375896
#island_id: 0
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i, j, k] for d in [0, 1]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 for val in [J[d, i, j, k] for d in [0, 1]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
          
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i+d, j, k]
            else:
              neighbor_spin = J[1-d, i-d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i+d, j, k]
            else:
              neighbor_spin = J[1-d, i-d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * (sum([1 for val in [J[d, i, j, k] for d in [0, 1]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
          
          site_nbr = (i + ((k-1) % 2 - 1)) % N
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i+d, j, k]
            else:
              neighbor_spin = J[1-d, i-d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (2 - 2 * ((k+1) % 2))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (2 - 2 * ((k+1) % 2))
              priorities[i * N * N + j * N + k][1] -= 2
  
  return priorities




#score: {'data3D.txt': -0.12309619999999993}
#standard deviation: 0.04457720746704532
#island_id: 2
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(h[i][j][k])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.exp(-abs(h[i][j][k])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.25681419999999994}
#standard deviation: 0.0442071025782057
#island_id: 2
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(h[i][j][k])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.exp(-abs(h[i][j][k])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + h[i][j][k]

        site_neighbors.append(J[3, i, j, k])
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors[0] < 0) - np.exp(-abs(total_spin)) * (site_neighbors[-1] > 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.2575598}
#standard deviation: 0.04543966487508464
#island_id: 2
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(h[i][j][k])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + np.exp(-abs(h[i][j][k])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]

          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][1] -= np.exp(-abs(h[i][j][k]))
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] += np.exp(-abs(h[i][j][k]))

  return(priorities)




#score: {'data3D.txt': -0.125939}
#standard deviation: 0.04383429250027882
#island_id: 0
#version_generated: 3
#generate time23:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate the interaction between each site and its nearest neighbors
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  # Calculate the total interaction between each site and its nearest neighbors
  total_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_interaction = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_interaction)) * (len([val for val in J[:, i, j, k] if val < 0]) - len([val for val in J[:, i, j, k] if val > 0])) + total_interaction
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_interaction

  # Add a new term based on the local energy
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_interaction)) * h[i, j, k]
        priorities[i*N*N + j*N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.1308510000000001}
#standard deviation: 0.0453964077763869
#island_id: 0
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0 or i == N - 1 or j == N - 1 or k == N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 4 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.1308510000000001}
#standard deviation: 0.0453964077763869
#island_id: 0
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2

        # Add a new term based on the distance to the boundary
        if i == 0 or j == 0 or k == 0 or i == N - 1 or j == N - 1 or k == N - 1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 4 * ((k + 1) % 2))
          priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.1171474000000001}
#standard deviation: 0.045002050544836296
#island_id: 0
#version_generated: 3
#generate time23:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.29407819999999996}
#standard deviation: 0.05312276729200014
#island_id: 2
#version_generated: 2
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -2 * total_spin
        priorities[i * N * N + j * N + k][1] = 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.294255}
#standard deviation: 0.05143871747040355
#island_id: 1
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.294255}
#standard deviation: 0.05143871747040355
#island_id: 1
#version_generated: 3
#generate time23:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.2475482}
#standard deviation: 0.047720935413715436
#island_id: 1
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
        
        site_neighbors_lower_left = [J[0, i-1, (j+1)%N, k], J[1, (i-1)%N, j, k-1]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_lower_left if val < 0]) - abs(total_spin) - sum(site_neighbors_lower_left)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - sum(site_neighbors_lower_left)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_lower_left if val > 0]) - abs(total_spin) - sum(site_neighbors_lower_left)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + sum(site_neighbors_lower_left)
        
  return(priorities)




#score: {'data3D.txt': -0.30801459999999997}
#standard deviation: 0.045638743922680435
#island_id: 1
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.30801459999999997}
#standard deviation: 0.045638743922680435
#island_id: 1
#version_generated: 3
#generate time23:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19957699999999995}
#standard deviation: 0.0477334607063012
#island_id: 1
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) - abs(total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) - abs(total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.495141}
#standard deviation: 0.04395448189889173
#island_id: 3
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          same_spin_count = sum(1 for neighbor in site_neighbors if neighbor == J[2, i, j, k])
          different_spin_count = len(site_neighbors) - same_spin_count
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1)
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) * different_spin_count

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2641106000000001}
#standard deviation: 0.04708613604491242
#island_id: 3
#version_generated: 3
#generate time23:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin
            
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time23:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.001332999999999999}
#standard deviation: 0.04641366039217334
#island_id: 2
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5278618}
#standard deviation: 0.04172157500334809
#island_id: 2
#version_generated: 3
#generate time23:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in site_neighbors if neighbor < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in site_neighbors if neighbor > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.07983459999999999}
#standard deviation: 0.05025005913270152
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22302580000000014}
#standard deviation: 0.04688656624620746
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
              priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
              priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2641106000000001}
#standard deviation: 0.04708613604491242
#island_id: 3
#version_generated: 3
#generate time23:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[i][j][site_nbr] > 0:
            priorities[i * N * N + j * N + site_nbr][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + site_nbr][1] -= 2 - 2 * total_spin
            
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4034073999999999}
#standard deviation: 0.04137134642769075
#island_id: 0
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] + J[1, i, :, k] + J[2, :, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] + J[1, i, :, k] + J[2, :, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.048362999999999996}
#standard deviation: 0.04533285288838548
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        for d in [0, 1]:
          neighbor_spin = J[d, (i + d) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val > 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += -2 + 2 * neighbor_spin
        
        for d in [2]:
          neighbor_spin = J[d, i, (j + 1) % N, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[2, i, j, k]] if val > 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[2, i, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += -2 + 2 * neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.18011220000000003}
#standard deviation: 0.042727915127700765
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1, 2]:
          if i + (d-1)%3 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[2-(d+1)%3, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23843219999999998}
#standard deviation: 0.03925090627183021
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0389398}
#standard deviation: 0.04396071992085662
#island_id: 3
#version_generated: 3
#generate time23:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in range(6):
          if i + (d-3)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[5-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2727934}
#standard deviation: 0.044151891425396494
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.2752934}
#standard deviation: 0.044550207591435534
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.2873570000000001}
#standard deviation: 0.04450027180815866
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.1988138}
#standard deviation: 0.04431322431915783
#island_id: 1
#version_generated: 3
#generate time23:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        if h[i][site_nbr][k] > 0:
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.28991300000000003}
#standard deviation: 0.04697770610619468
#island_id: 1
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[3, i, (j + 1) % N, k]] if val < 0]) - abs(total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[3, i, (j + 1) % N, k]] if val > 0]) - abs(total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.19957699999999995}
#standard deviation: 0.0477334607063012
#island_id: 1
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) - abs(total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin

          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) - abs(total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.19957699999999995}
#standard deviation: 0.0477334607063012
#island_id: 1
#version_generated: 3
#generate time23:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) - abs(total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) - abs(total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': 0.104541}
#standard deviation: 0.05823453476245861
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = -2 * total_spin
        priorities[i * N * N + j * N + k][1] = 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.29407819999999996}
#standard deviation: 0.05312276729200014
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -2 * total_spin
        priorities[i * N * N + j * N + k][1] = 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and spin-flip probabilities
        priorities[i * N * N + j * N + k][0] += h[i][j][k] + np.log(1 + np.exp(-h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] - np.log(1 + np.exp(h[i][j][k]))
        
  return(priorities)




#score: {'data3D.txt': -0.29407819999999996}
#standard deviation: 0.05312276729200014
#island_id: 2
#version_generated: 3
#generate time23:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -2 * total_spin
        priorities[i * N * N + j * N + k][1] = 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.39034019999999997}
#standard deviation: 0.04201213234245556
#island_id: 1
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.19957699999999995}
#standard deviation: 0.0477334607063012
#island_id: 1
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) - abs(total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) - abs(total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.19957699999999995}
#standard deviation: 0.0477334607063012
#island_id: 1
#version_generated: 3
#generate time23:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin

          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) - abs(total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin

          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0]) - abs(total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
        priorities[i*N*N+k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.326153}
#standard deviation: 0.04276389401118658
#island_id: 3
#version_generated: 3
#generate time23:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [0, 2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
  
  return priorities




