#score: {'data3D.txt': -0.3749574}
#standard deviation: 0.051588973872718186
#island_id: 2
#version_generated: 3
#generate time00:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_0 = [J[0, i, j, k] for j in range(N)]
        site_neighbors_1 = [J[1, i, j, k] for j in range(N)]
        site_neighbors_2 = [J[2, i, j, k] for j in range(N)]
        
        site_neighbors = [val for sublist in [site_neighbors_0, site_neighbors_1, site_neighbors_2] for val in sublist]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.1314685999999998}
#standard deviation: 0.044289424178239216
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.4701862}
#standard deviation: 0.04759571923566236
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the priority based on the magnetism and interaction
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 1
#version_generated: 3
#generate time00:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        # Calculate the priority based on the magnetism and interaction
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0706290000000003}
#standard deviation: 0.0488853581249028
#island_id: 3
#version_generated: 3
#generate time00:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(interacting_spins)
        
        site_nbr_spin = J[2, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * (site_nbr_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (site_nbr_spin < 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * (site_nbr_spin > 0)
          priorities[i * N * N + j * N + k][1] += (site_nbr_spin > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        # Calculate the priority based on the local energy and the interaction with neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0012073999999999993}
#standard deviation: 0.04716164103633376
#island_id: 0
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i * N * N + j * N + k][0] > 0:
          priorities[i * N * N + j * N + k][1] = np.sign(priorities[i * N * N + j * N + k][0])
        elif priorities[i * N * N + j * N + k][0] < 0:
          priorities[i * N * N + j * N + k][1] = -np.sign(priorities[i * N * N + j * N + k][0])

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i * N * N + j * N + k][0] > 0:
          priorities[i * N * N + j * N + k][1] = np.tanh(priorities[i * N * N + j * N + k][0])
        elif priorities[i * N * N + j * N + k][0] < 0:
          priorities[i * N * N + j * N + k][1] = -np.tanh(-priorities[i * N * N + j * N + k][0])

  return(priorities)




#score: {'data3D.txt': -0.20687339999999999}
#standard deviation: 0.06260658377870494
#island_id: 0
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 if total_spin > 0 else -2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 if total_spin < 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': 0.0013369999999999996}
#standard deviation: 0.048927208698228426
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] * interacting_spins[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [0, 1, 2, 4, 5])
    
    if h[(i//N**(2))%N][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = np.tanh(total_spin)
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    if h[(i//N**(2))%N][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.002245}
#standard deviation: 0.049341832302823935
#island_id: 0
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] * interacting_spins[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [0, 1, 2, 4, 5])
    
    if h[(i//N**(2))%N][(i//N**(1))%N][(i%N)] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2))%N, (i//N**(1))%N, (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5247178000000001}
#standard deviation: 0.042473051257944726
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 3
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 2
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.062881}
#standard deviation: 0.044281961553210354
#island_id: 2
#version_generated: 2
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5496554}
#standard deviation: 0.04128540772282624
#island_id: 2
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5189649999999999}
#standard deviation: 0.045262791065068
#island_id: 2
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    
  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])

  return(priorities)




#score: {'data3D.txt': -0.0032482000000000006}
#standard deviation: 0.04640112107223273
#island_id: 0
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] * d for d in [0, 1, 2, 4, 5])
    
    site_nbr = (i // N**3 - 1) % N
    
    if h[(i//N**(2)) % N][(i//N**(1))%N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin + sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] = 2 * total_spin - sum(J[d, (i//N**(2)) % N, ((i//N**(1))%N), (i%N)] for d in [3])
  
  return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0153366}
#standard deviation: 0.047071787096306425
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [3, 4, 5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [3, 4, 5])

  return(priorities)




#score: {'data3D.txt': 0.0064118}
#standard deviation: 0.05048127713083337
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin) * (h[i][j][k] - sum(J[d, i, j, k] for d in range(6)))
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin) * (h[i][j][k] + sum(J[d, i, j, k] for d in range(6)))
        
  return(priorities)




#score: {'data3D.txt': 0.0002906000000000004}
#standard deviation: 0.04368430555290996
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2]) - sum(J[d, i, j, k] * (d-1) for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.0010045999999999992}
#standard deviation: 0.04612708378859431
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  interacting_spins_sum = np.zeros((6, N, N, N))
  for i in range(6):
    interacting_spins_sum[i] = np.sum(interacting_spins[i], axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins_sum[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.5295082}
#standard deviation: 0.040842448662635304
#island_id: 1
#version_generated: 2
#generate time00:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_neighbors = list(set([site_nbr, i, (i + 1) % N]))
        for d in [0, 1]:
          if site_neighbors[d] == i:
            neighbor_spin = J[1 - d, site_neighbors[1], j, k]
          elif site_neighbors[d] == i - 1:
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, site_neighbors[0], j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.129493}
#standard deviation: 0.046868944419519415
#island_id: 1
#version_generated: 2
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 2
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 1
#version_generated: 2
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.0006077999999999999}
#standard deviation: 0.04719900485349241
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, (j-1)%N, k] * d + J[d, i, j, (k-1)%N] * h[i][j][k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i-((i//N)**2)%N, (j+i//N)%N, (k+(k//N)**2)%N] * interacting_spins[d, i, j, k] 
                    for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4150462}
#standard deviation: 0.04090896412230454
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(1 for val in site_neighbors if val < 0) - sum(1 for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins - len([val for val in J[2, i, j, :k+1] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (interacting_spins - len([val for val in J[2, i, j, :k+1] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, site_nbr, j, k]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4140146}
#standard deviation: 0.04240176678913273
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + ((k - 1) % 2 - 1)) % N, (j + ((k - 1) % 2 - 1)) % N]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [(i + (k + 1) % N), (j + (k + 1) % N)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5295082}
#standard deviation: 0.040842448662635304
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_neighbors = list(set([site_nbr, i, (i + 1) % N]))
        for d in [0, 1]:
          if site_neighbors[d] == i:
            neighbor_spin = J[1 - d, site_neighbors[1], j, k]
          elif site_neighbors[d] == i - 1:
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, site_neighbors[0], j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5295082}
#standard deviation: 0.040842448662635304
#island_id: 1
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_neighbors = list(set([site_nbr, i, (i + 1) % N]))
        for d in [0, 1]:
          if site_neighbors[d] == i:
            neighbor_spin = J[1 - d, site_neighbors[1], j, k]
          elif site_neighbors[d] == i - 1:
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, site_neighbors[0], j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time00:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.17260019999999998}
#standard deviation: 0.054044328841794304
#island_id: 3
#version_generated: 3
#generate time00:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) - total_spin
        
        # Add a new term based on the interaction with other sites
        site_interactions = [J[0, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0]) - len([val for val in site_interactions if val > 0])
        
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.37802299999999994}
#standard deviation: 0.0460607363271583
#island_id: 1
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37802299999999994}
#standard deviation: 0.0460607363271583
#island_id: 1
#version_generated: 3
#generate time00:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1280838}
#standard deviation: 0.04640639759300435
#island_id: 1
#version_generated: 3
#generate time00:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5272650000000001}
#standard deviation: 0.041248348997262915
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in range(3):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.31657899999999994}
#standard deviation: 0.04467301734828307
#island_id: 3
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == -J[d, (i + 1) % N, j, k]])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == J[d, (i + 1) % N, j, k]])
        
        # Add a new term based on the local energy and interactions with neighboring sites
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.31657899999999994}
#standard deviation: 0.04467301734828307
#island_id: 3
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and interactions with neighboring sites
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == -J[d, (i + 1) % N, j, k]])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[d, i, j, k])) * len([val for val in site_neighbors if val == J[d, (i + 1) % N, j, k]])
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors_z = [J[3, i, j, (k + 1) % N], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        interacting_spins_z = [-val for val in site_neighbors_z if val < 0] + [val for val in site_neighbors_z if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins_z)
        priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins_z if val < 0]) > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.010423400000000001}
#standard deviation: 0.04703512105267722
#island_id: 2
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with same spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[0, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[0, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

      return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': 0.025069400000000002}
#standard deviation: 0.04676278716714819
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  # Calculate total spin for each site
  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N)

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          # Calculate priority for spin up
          priority_up = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][0] = -priority_up
          priorities[i * N * N + j * N + k][1] = np.tanh(-priority_up)
        else:
          # Calculate priority for spin down
          priority_down = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][0] = -priority_down
          priorities[i * N * N + j * N + k][1] = np.tanh(priority_down)

  return(priorities)




#score: {'data3D.txt': -0.007081799999999999}
#standard deviation: 0.04867893085062572
#island_id: 0
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_sum = np.zeros((N, N, N))
  for d in range(6):
    total_spin_sum += J[d].reshape(N, N, N) * interacting_spins[d]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = np.tanh(total_spin_sum[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin_sum[i][j][k]
          priorities[i * N * N + j * N + k][1] = -np.tanh(-total_spin_sum[i][j][k])

  return(priorities)




#score: {'data3D.txt': -0.5330114000000001}
#standard deviation: 0.040887107870819145
#island_id: 3
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4855742}
#standard deviation: 0.04055491603196831
#island_id: 3
#version_generated: 3
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in J[0, i, j, :k+1] + J[1, i, j, :k+1] if val < 0])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the interaction with the current spin
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in J[2, i, j, :k+1] if val < 0])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.023756199999999998}
#standard deviation: 0.04580084062066983
#island_id: 0
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0045526}
#standard deviation: 0.04540434024672091
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 4
  
  return(priorities)




#score: {'data3D.txt': 0.011507}
#standard deviation: 0.04567926740874902
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i) 
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 2 * abs(neighbor_spin)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 2 * abs(neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.024069}
#standard deviation: 0.047023646806686525
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] -= 2 * neighbor_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
            priorities[i * N * N + j * N + k][1] += 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.191995}
#standard deviation: 0.04930154495550824
#island_id: 0
#version_generated: 3
#generate time00:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * d for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        
        for d in [3, 4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 * J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.129493}
#standard deviation: 0.046868944419519415
#island_id: 1
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.129493}
#standard deviation: 0.046868944419519415
#island_id: 1
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          for x in range(N):
            for y in range(N):
              if (i == x and j == y):
                continue
              neighbor_spin = J[d, min(i+x, N-1), min(j+y, N-1), k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0442494}
#standard deviation: 0.058184927254745285
#island_id: 3
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  priorities = h.flatten() + (J.sum(axis=0).flatten())
  
  return np.array([priorities, np.zeros(N**3)]).T




#score: {'data3D.txt': 0.17260019999999998}
#standard deviation: 0.054044328841794304
#island_id: 3
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) - total_spin
        
        # Add a new term based on the interaction with other sites
        site_interactions = [J[0, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0]) - len([val for val in site_interactions if val > 0])
        
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return priorities




#score: {'data3D.txt': -0.0029317999999999996}
#standard deviation: 0.0477089579508922
#island_id: 3
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins = [-val for val in site_neighbors if val < 0] + [val for val in site_neighbors if val > 0]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of -1 neighbors
        priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) - total_spin
        
        # Add a new term based on the interaction with other sites
        site_interactions = [J[0, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[0, i, j, k] != 0] + [J[1, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[1, i, j, k] != 0] + [J[2, i, j, k] for n in [(i+1)%N, (j+1)%N, (k+1)%N] if J[2, i, j, k] != 0]
        priorities[i * N * N + j * N + k][0] += len([val for val in site_interactions if val < 0]) - len([val for val in site_interactions if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] = np.exp(h[i][j][k]) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return priorities




#score: {'data3D.txt': 0.16299419999999998}
#standard deviation: 0.05337573986709692
#island_id: 3
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Your logic goes here...
  return(priorities)




#score: {'data3D.txt': -0.5038737999999999}
#standard deviation: 0.04469331620678869
#island_id: 3
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.18839499999999998}
#standard deviation: 0.05758404583736714
#island_id: 3
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.05318899999999999}
#standard deviation: 0.047731312982150415
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, ii, jj, kk] for (ii, jj, kk) in [(i, j, l) for l in range(N)] if d == 0 or d == 1) for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0032834}
#standard deviation: 0.04696570881441054
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        return(priorities)




#score: {'data3D.txt': -0.3504334}
#standard deviation: 0.04192085262062307
#island_id: 1
#version_generated: 3
#generate time01:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.164363}
#standard deviation: 0.04979444176813312
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4291986}
#standard deviation: 0.039209747232544105
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2257922000000004}
#standard deviation: 0.047048094320174115
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2304026}
#standard deviation: 0.038962432588841266
#island_id: 1
#version_generated: 3
#generate time01:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.555909}
#standard deviation: 0.03988630640959376
#island_id: 0
#version_generated: 2
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 2
#generate time01:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)

        for d in [0, 1]:
          if d == 0:
            site_neighbors = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
          else:
            site_neighbors = [J[1 - d, (i - 1) % N, j, k], J[1 - d, i, (j - 1) % N, k], J[1 - d, i, j, (k - 1) % N]]
          interacting_spins.extend(site_neighbors)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4984578}
#standard deviation: 0.041926684333011596
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4273810000000002}
#standard deviation: 0.049854737778871124
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0020558000000000004}
#standard deviation: 0.047048668061487144
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.47650740000000014}
#standard deviation: 0.04487500980768696
#island_id: 1
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.37315060000000017}
#standard deviation: 0.054157368470412234
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i*N*N + j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i*N*N + j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N + j*N+k][0] += np.exp(h[i][j][k])
        priorities[i*N*N + j*N+k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.1309526000000002}
#standard deviation: 0.040558639440198184
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(h[i, j, k]) - abs(total_spin)
        priorities[i * N * N + j * N + k][1] = -h[i, j, k] - total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5038737999999999}
#standard deviation: 0.04469331620678869
#island_id: 3
#version_generated: 3
#generate time01:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.37802299999999994}
#standard deviation: 0.0460607363271583
#island_id: 2
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time01:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2498762000000002}
#standard deviation: 0.04480571384946344
#island_id: 1
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_sum
          
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_sum
          
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.08994219999999999}
#standard deviation: 0.052366251528632446
#island_id: 1
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0025018}
#standard deviation: 0.047245268088561
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        
        if total_spin < 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k]*interacting_spins[d][i][j][k] for d in range(6)] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin

        elif total_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k]*interacting_spins[d][i][j][k] for d in range(6)] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4291986}
#standard deviation: 0.039209747232544105
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Check neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47002059999999996}
#standard deviation: 0.038901265990196256
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5189649999999999}
#standard deviation: 0.045262791065068
#island_id: 2
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.14646019999999996}
#standard deviation: 0.04835199453962578
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        if sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif sum(site_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.29731779999999997}
#standard deviation: 0.0445126463284312
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * (1 if d == 0 and i > 0 else -1 if d == 0 and i < N-1 
                           else 1 if d == 1 and j > 0 else -1 if d == 1 and j < N-1 
                           else 1 if d == 2 and k > 0 else -1 if d == 2 and k < N-1 
                           else 0) for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if site_spin * val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin

  return(priorities)




#score: {'data3D.txt': 0.002269}
#standard deviation: 0.04546280852521102
#island_id: 0
#version_generated: 3
#generate time01:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.33942859999999964}
#standard deviation: 0.04452487688966696
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
        else:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.459885}
#standard deviation: 0.044070465563685615
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4181542}
#standard deviation: 0.03989438885808379
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.21624259999999998}
#standard deviation: 0.04163337489610949
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Check neighbors
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, i, j, k], J[5, i, (j - 1) % N, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2

        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.4984578}
#standard deviation: 0.041926684333011596
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if any([val < 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif any([val > 0 for val in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.539453}
#standard deviation: 0.042087715440494035
#island_id: 2
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2697534}
#standard deviation: 0.04653369476454669
#island_id: 2
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0 and i < N - 1:
          neighbor_spin = J[2, i + 1, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1 and i > 0:
          neighbor_spin = J[2, i - 1, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i > 0 and j < N - 1:
          neighbor_spin = J[1, i - 1, j + 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N - 1 and j > 0:
          neighbor_spin = J[1, i + 1, j - 1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.33186140000000003}
#standard deviation: 0.049819321051575965
#island_id: 2
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * (total_spin > 0)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin < 0)
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a term based on the interaction with neighboring spins
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and total_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and total_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.33766740000000006}
#standard deviation: 0.04233088396478392
#island_id: 2
#version_generated: 3
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5277785999999999}
#standard deviation: 0.04174621877535736
#island_id: 2
#version_generated: 3
#generate time02:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with negative spin
        if J[0, i, (j + 1) % N, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[1, (i + 1) % N, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[2, i, j, (k + 1) % N] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with positive spin
        if J[0, i, (j + 1) % N, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, (i + 1) % N, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, (k + 1) % N] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.41892019999999996}
#standard deviation: 0.043728709927918066
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2569974000000003}
#standard deviation: 0.046015759400883524
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.0024438000000000003}
#standard deviation: 0.06583570795214402
#island_id: 3
#version_generated: 3
#generate time02:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 1] = -priorities[i*N**2 + j*N + k, 0]
        else:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 1] += J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 0] = -priorities[i*N**2 + j*N + k, 1]
  
  return(priorities)




#score: {'data3D.txt': -0.5370182}
#standard deviation: 0.04031558940112373
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3315474}
#standard deviation: 0.04115066844220152
#island_id: 2
#version_generated: 2
#generate time02:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4143258}
#standard deviation: 0.04351607397686515
#island_id: 3
#version_generated: 3
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4175242}
#standard deviation: 0.0443628941161417
#island_id: 3
#version_generated: 3
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          if (j + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i, j + d, k]
          else:
            neighbor_spin = J[2, i, j - d, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4, 5]:
          if (k + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i, j, k + d]
          else:
            neighbor_spin = J[2, i, j, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4815618}
#standard deviation: 0.041449642950935055
#island_id: 3
#version_generated: 3
#generate time02:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4145078}
#standard deviation: 0.039836222952985896
#island_id: 1
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  # Add a new term based on the local energy
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  # Add a new term based on the sum of neighboring spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

  return priorities




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4920458}
#standard deviation: 0.041459288251970754
#island_id: 1
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0018601999999999998}
#standard deviation: 0.046995432288255416
#island_id: 0
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4920458}
#standard deviation: 0.041459288251970754
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4920458}
#standard deviation: 0.041459288251970754
#island_id: 1
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0142502}
#standard deviation: 0.057800760548283446
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k]) + 2 * total_spin
          priorities[i * N * N + j * N + k][1] = h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3086761999999999}
#standard deviation: 0.045019119422307664
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        for d in range(3):
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= h[i][j][k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
            priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5616446}
#standard deviation: 0.0405200026016781
#island_id: 2
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46650140000000007}
#standard deviation: 0.04404627655137266
#island_id: 0
#version_generated: 3
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41999620000000004}
#standard deviation: 0.039255659790150006
#island_id: 0
#version_generated: 3
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.33842179999999994}
#standard deviation: 0.04408835452542997
#island_id: 0
#version_generated: 3
#generate time02:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_energy_change = sum(J[d, i, j, k] * (h[i][j][k] + 1) if d == 0 or d == 1 or d == 2 else h[i][j][k] - 1 for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_energy_change))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_energy_change
  
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2569974000000003}
#standard deviation: 0.046015759400883524
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.3472118}
#standard deviation: 0.046303604835476915
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5051434}
#standard deviation: 0.04078953537906506
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2569974000000003}
#standard deviation: 0.046015759400883524
#island_id: 1
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.31353819999999977}
#standard deviation: 0.045771082363868114
#island_id: 3
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.45911740000000006}
#standard deviation: 0.04176899923675453
#island_id: 3
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in site_neighbors]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if J[3, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        elif J[3, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[d], 1, axis=i) for d in range(6) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[3, i, j, k] > 0 or J[4, i, j, k] > 0 or J[5, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[3, i, j, k] < 0 or J[4, i, j, k] < 0 or J[5, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48133820000000005}
#standard deviation: 0.04635424533696995
#island_id: 3
#version_generated: 3
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.04698020000000001}
#standard deviation: 0.04710278429095248
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [3, 4, 5]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.0012194000000000003}
#standard deviation: 0.0455892310051398
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(J[0, i, (j + 1) % N, k], J[0, i, j, (k + 1) % N]),
                  (J[1, (i + 1) % N, j, k], J[1, i, j, (k + 1) % N]),
                  (J[2, i, j, (k + 1) % N]),]
        for d in range(3):
          if all(J[d, i, j, k] > 0 for d in [0, 1, 2]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 3
          elif all(J[d, i, j, k] < 0 for d in [0, 1, 2]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.0012194000000000003}
#standard deviation: 0.0455892310051398
#island_id: 0
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.274149}
#standard deviation: 0.0433891414872431
#island_id: 0
#version_generated: 3
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in [3, 4]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2592402}
#standard deviation: 0.04645117979082986
#island_id: 0
#version_generated: 3
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        for d in [0,1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d,i+d,j,k]
          else:
            neighbor_spin = J[1-d,i-d,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] += 3
          elif neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] -= 3
        
        site_neighbors = [J[0,i,j,(k+1)%N], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        for d in [0,1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d,i+d,j,k]
          else:
            neighbor_spin = J[1-d,i-d,j,k]
          if neighbor_spin > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] += 3
          elif neighbor_spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i*N*N+j*N+k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[3, i, j, (k + 1) % N], J[4, (i + 1) % N, j, k], J[5, i, (j + 1) % N, k]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.480461}
#standard deviation: 0.04502232600610502
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.48764620000000003}
#standard deviation: 0.044667230780069636
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if k < N - 1:
         neighbor_spin = J[2, i, j, k + 1]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
         neighbor_spin = J[2, i, j, k - 1]
         if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
         if (i + (d - 1) % 2 == 0):
          neighbor_spin = J[d, i + d, j, k]
         else:
          neighbor_spin = J[1 - d, i - d, j, k]
         if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
         elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3560706}
#standard deviation: 0.046127852926838034
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.344897}
#standard deviation: 0.04807033504147854
#island_id: 0
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if sum(J[d, i, j, k] for d in [0, 1]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        if sum(J[d, i, j, k] for d in [0, 1]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        if site_neighbors[2] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        if site_neighbors[2] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.33942859999999964}
#standard deviation: 0.04452487688966696
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
        else:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.36530260000000025}
#standard deviation: 0.048522295012086956
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[0], -1, axis=1), 
             np.roll(J[1], -1, axis=0), 
             np.roll(J[2], -1, axis=2)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d][i,j,k] for d in [0, 1, 2]])
        
        site_neighbors = [J[0][i,(j+1)%N,k], J[1][i,j,(k+1)%N], J[2][(i+1)%N,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins[0][i,j,k] + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins[0][i,j,k] + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.37031980000000025}
#standard deviation: 0.04763544654939219
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in [J[0, i, j, k]] + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in [J[0, i, j, k]] + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.33942859999999964}
#standard deviation: 0.04452487688966696
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin + np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([-np.exp(-abs(val)) for val in interacting_spins + site_neighbors]) + total_spin - np.exp(-h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
        else:
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] += 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(J[0, i, j, k]))
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.371261}
#standard deviation: 0.046690339032823484
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.5023486}
#standard deviation: 0.04013805224521987
#island_id: 0
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * 1
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.1481286000000002}
#standard deviation: 0.04866889830312579
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.252671}
#standard deviation: 0.05532557129393243
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.331057}
#standard deviation: 0.04750782494494986
#island_id: 0
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(val for val in interacting_spins if val < 0) - sum(val for val in site_neighbors if val > 0))
        priorities[i * N * N + j * N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37170180000000025}
#standard deviation: 0.045093367990869784
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.30875860000000027}
#standard deviation: 0.04706785406240654
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.37170180000000025}
#standard deviation: 0.045093367990869784
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2177398}
#standard deviation: 0.054361956697308096
#island_id: 0
#version_generated: 3
#generate time02:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the site itself and its neighbors
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2607154}
#standard deviation: 0.05457226404355971
#island_id: 0
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Calculate the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] > 0) * len([val for val in interacting_spins if val < 0]) - (h[i, j, k] > 0) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2390918}
#standard deviation: 0.05268946396349084
#island_id: 0
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N],
          J[3, i, (j - 1) % N, k], 
          J[4, (i - 1) % N, j, k], 
          J[5, i, j, (k - 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0024438000000000003}
#standard deviation: 0.06583570795214402
#island_id: 3
#version_generated: 3
#generate time02:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 1] = -priorities[i*N**2 + j*N + k, 0]
        else:
          for l in range(6):
            priorities[i*N**2 + j*N + k, 1] += J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N**2 + j*N + k, 0] = -priorities[i*N**2 + j*N + k, 1]

  return(priorities)




#score: {'data3D.txt': -0.05214979999999999}
#standard deviation: 0.0516512605844233
#island_id: 3
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[i*N**2 + j*N + k, 0] += -J[0,i,j,k]*interacting_spins[0,i,j,k]
          priorities[i*N**2 + j*N + k, 1] = -priorities[i*N**2 + j*N + k, 0]
          for d in [1, 2]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[3 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i*N**2 + j*N + k, 0] += np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 1] -= 1
            elif neighbor_spin > 0:
              priorities[i*N**2 + j*N + k, 0] += np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 1] += 1
        else:
          priorities[i*N**2 + j*N + k, 1] += J[0,i,j,k]*interacting_spins[0,i,j,k]
          priorities[i*N**2 + j*N + k, 0] = -priorities[i*N**2 + j*N + k, 1]
          for d in [1, 2]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[3 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i*N**2 + j*N + k, 1] += np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 0] -= 1
            elif neighbor_spin < 0:
              priorities[i*N**2 + j*N + k, 1] -= np.exp(-abs(sum(J[:3,i,j,k]))) * 1
              priorities[i*N**2 + j*N + k, 0] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34071900000000005}
#standard deviation: 0.04818165749535813
#island_id: 0
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(val for val in interacting_spins if val < 0) - sum(val for val in site_neighbors if val > 0))
        priorities[i * N * N + j * N + k][1] -= total_spin

  return(priorities)




#score: {'data3D.txt': -0.12758619999999998}
#standard deviation: 0.05612372982580541
#island_id: 0
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': -0.36605540000000014}
#standard deviation: 0.0442857061684693
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = 2

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5176778000000001}
#standard deviation: 0.04171888190208362
#island_id: 1
#version_generated: 3
#generate time03:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3352354000000001}
#standard deviation: 0.046499033826951724
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[d, i, (j + 1) % N, k] if d == 0 else 
                  J[d, (i + 1) % N, j, k] if d == 1 else 
                  J[d, i, j, (k + 1) % N] for d in range(3)]
        total_spin = sum(interacting_spins) + sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.353573}
#standard deviation: 0.04640796861531433
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2086342}
#standard deviation: 0.044992187659192565
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(interacting_spins)
        site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(site_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(site_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.07225460000000002}
#standard deviation: 0.04803328948593881
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + i1) % N, (j + j1) % N, (k + k1) % N] 
                   for d, i1, j1, k1 in [(0, -1, 0, 0), (0, 0, -1, 0), (0, 0, 0, -1),
                               (1, 1, 0, 0), (1, 0, 1, 0), (1, 0, 0, 1),
                               (2, 0, 1, 0), (2, 0, 0, 1), (2, -1, 0, 0)]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, (i + i1) % N, (j + j1) % N, (k + k1) % N] 
                  for i1, j1, k1 in [(1, 0, 0), (-1, 0, 0), (0, -1, 0), (0, 0, -1)]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46611060000000004}
#standard deviation: 0.04327603364034186
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1473346}
#standard deviation: 0.047343084002206694
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [1, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2410634}
#standard deviation: 0.04580157923521852
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31666700000000003}
#standard deviation: 0.043397150494012854
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3315474}
#standard deviation: 0.04115066844220152
#island_id: 2
#version_generated: 3
#generate time03:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if i > 0:
          neighbor_spin = J[1, (i - 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if i < N - 1:
          neighbor_spin = J[1, (i + 1) % N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4442194}
#standard deviation: 0.04191382186868671
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+di) % N, (j+dj) % N, (k+dk) % N] 
                   for d,(di,dj,dk) in enumerate([(0,0,1),(1,0,-1),(2,-1,0)])]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_energy = -h[i][j][k]*J[0, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) + site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4938485999999999}
#standard deviation: 0.04413561009026612
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors_sum = sum(site_neighbors)
        neighbor_opposite_count = len([val for val in site_neighbors if val < 0])
        neighbor_same_count = len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_opposite_count - neighbor_same_count) + site_neighbors_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.3471754}
#standard deviation: 0.045531984305979906
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(1 if val < 0 else -1 for val in site_neighbors)
        local_energy = h[i][j][k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins) + neighbor_spin_sum + local_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.4619774}
#standard deviation: 0.0418215878373837
#island_id: 0
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
        
        priorities[i*N**2 + j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbor_sum
        priorities[i*N**2 + j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.555909}
#standard deviation: 0.03988630640959376
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.0021934000000000003}
#standard deviation: 0.0639015417375825
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3110498}
#standard deviation: 0.0468049206810566
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2451578}
#standard deviation: 0.04492373202617966
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4308514}
#standard deviation: 0.044412400498509426
#island_id: 0
#version_generated: 3
#generate time03:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.020932199999999998}
#standard deviation: 0.04594296554598974
#island_id: 0
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.sort()
        if len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]):
          priorities[i * N * N + j * N + k][0] = -1
        elif len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]):
          priorities[i * N * N + j * N + k][0] = 1
        else:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] = 1
          elif total_spin < 0:
            priorities[i * N * N + j * N + k][0] = -1
          else:
            priorities[i * N * N + j * N + k][0] = 0
        
        if site_neighbors.count(-1) > site_neighbors.count(1):
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_neighbors.count(1) > site_neighbors.count(-1):
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.43024219999999996}
#standard deviation: 0.04690970580977886
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          if d < 3:
            site_neighbors[d] += np.roll(h, -1, axis = d)[i,j,k]
          else:
            site_neighbors[d-3] += np.roll(h, 1, axis = (d-3)%3)[i,j,k]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(s)) for s in interacting_spins])
        priorities[i * N * N + j * N + k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.33090579999999997}
#standard deviation: 0.047956041187320705
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in [3, 4, 5]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022858000000000006}
#standard deviation: 0.047019193084952025
#island_id: 0
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        return(priorities)




#score: {'data3D.txt': -0.16766419999999999}
#standard deviation: 0.044233201990812286
#island_id: 0
#version_generated: 3
#generate time03:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 1
        
        edge_neighbors = [J[5, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        for d in [5]:
          if (i + (d - 4) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.5582694}
#standard deviation: 0.040148867277172345
#island_id: 3
#version_generated: 2
#generate time03:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and (i + (d - 1) % 2 == 0 or k > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and (i + (d - 1) % 2 == 0 or k < N - 1):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2177398}
#standard deviation: 0.054361956697308096
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))

        # Calculate the priority based on the site neighbors and magnetism
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the site itself and its neighbors
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.25694259999999997}
#standard deviation: 0.04310125503091528
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3900738}
#standard deviation: 0.047098165925649374
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4964970000000001}
#standard deviation: 0.04324651004416426
#island_id: 2
#version_generated: 3
#generate time03:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        local_energy = h[i][j][k] - total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + local_energy
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + local_energy
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 2
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5604026}
#standard deviation: 0.04042338671165493
#island_id: 1
#version_generated: 2
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5328622000000001}
#standard deviation: 0.03925982897517512
#island_id: 1
#version_generated: 2
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5582694}
#standard deviation: 0.040148867277172345
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and (i + (d - 1) % 2 == 0 or k > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and (i + (d - 1) % 2 == 0 or k < N - 1):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5582694}
#standard deviation: 0.040148867277172345
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and (i + (d - 1) % 2 == 0 or k > 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and (i + (d - 1) % 2 == 0 or k < N - 1):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.36506819999999995}
#standard deviation: 0.044656970214738044
#island_id: 2
#version_generated: 3
#generate time03:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])) - h[i][j][k]
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])) + h[i][j][k]
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.5405582000000001}
#standard deviation: 0.04032161966935356
#island_id: 3
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5322462}
#standard deviation: 0.04140017567064179
#island_id: 3
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 8.460000000000046e-05}
#standard deviation: 0.04685864533722673
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        edge_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in range(3):
          if edge_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif edge_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.10656940000000001}
#standard deviation: 0.046402914387352875
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.07465540000000001}
#standard deviation: 0.044649891498636365
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for d in range(6):
          if site_neighbors[d-3] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif site_neighbors[d-3] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3738678000000001}
#standard deviation: 0.04561675748187283
#island_id: 2
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.5019669999999999}
#standard deviation: 0.04357444011114773
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d - 3, j, k]
          else:
            neighbor_spin = J[1 - d, i - d + 3, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4602366}
#standard deviation: 0.04166057873385822
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.5535793999999999}
#standard deviation: 0.04099644296326207
#island_id: 1
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3390794}
#standard deviation: 0.05004735652999067
#island_id: 0
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Calculate the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] > 0) * len([val for val in interacting_spins if val < 0]) - (h[i, j, k] > 0) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a bias to the priority based on the interaction energy
        priorities[i * N * N + j * N + k][0] += np.sum([abs(val) for val in interacting_spins]) / len(interacting_spins)
        priorities[i * N * N + j * N + k][1] -= np.sum([abs(val) for val in site_neighbors]) / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': 0.14111900000000008}
#standard deviation: 0.045772767001788305
#island_id: 0
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_priority = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        magnetism_priority = h[i, j, k]
        
        priorities[i * N * N + j * N + k][0] += site_priority
        priorities[i * N * N + j * N + k][1] += magnetism_priority
        
  return(priorities)




#score: {'data3D.txt': -0.2607154}
#standard deviation: 0.05457226404355971
#island_id: 0
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k], 
          J[1, (i + 1) % N, j, k], 
          J[2, i, j, (k + 1) % N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] > 0) * len([val for val in interacting_spins if val < 0]) - (h[i, j, k] > 0) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.2568342}
#standard deviation: 0.05512986913062646
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [
         J[0, i, (j + 1) % N, k], 
         J[1, (i + 1) % N, j, k], 
         J[2, i, j, (k + 1) % N]
        ]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Calculate the priority based on the magnetism and interactions
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the interactions
        for d in range(6):
          if interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[d, i, j, k] > 0) * len([val for val in [J[e, i, j, k] for e in range(6)] if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (J[d, i, j, k] < 0) * len([val for val in [J[e, i, j, k] for e in range(6)] if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2790666000000002}
#standard deviation: 0.0449435904711673
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5322462}
#standard deviation: 0.04140017567064179
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5535793999999999}
#standard deviation: 0.04099644296326207
#island_id: 1
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time04:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0031366}
#standard deviation: 0.04697917432692916
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0087422}
#standard deviation: 0.04802963063734719
#island_id: 3
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] + interacting_spins[d][i][j][k]) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5363509999999999}
#standard deviation: 0.03944818929938357
#island_id: 2
#version_generated: 3
#generate time04:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5370182}
#standard deviation: 0.04031558940112373
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
  return(priorities)




#score: {'data3D.txt': -0.5370182}
#standard deviation: 0.04031558940112373
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5363509999999999}
#standard deviation: 0.03944818929938357
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30674179999999984}
#standard deviation: 0.04594748581543934
#island_id: 2
#version_generated: 3
#generate time04:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0])) - 2 * total_spin + h[i][j][k]
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0])) + 2 * total_spin + h[i][j][k]
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * total_spin + h[i][j][k]
            priorities[i * N * N + j * N + k][1] -= 2 * total_spin + h[i][j][k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + 2 * total_spin + h[i][j][k]
            priorities[i * N * N + j * N + k][1] += 2 * total_spin + h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.47255220000000003}
#standard deviation: 0.03940733935652089
#island_id: 2
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        def objective(x):
          return np.sum((x - total_spin)**2)

        res = minimize(objective, [0.5], method="SLSQP")

        if res.success:
          priorities[i * N * N + j * N + k][0] += (res.x[0] - total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin)

        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.4851698}
#standard deviation: 0.03818586764707593
#island_id: 2
#version_generated: 3
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Define the objective function to minimize
        def objective(x):
          if x[0] > 0:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val < 0]))
          else:
            return np.sum(np.exp(-np.abs(total_spin)) * len([val for val in interacting_spins if val > 0]))
        
        # Use the minimize function to find the optimal value of x
        res = minimize(objective, [1], method="SLSQP")
        
        # Update the priorities based on the result
        if res.success:
          if res.x[0] > 0.5:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.4733306}
#standard deviation: 0.0417872500128927
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5315702000000001}
#standard deviation: 0.03976015935531446
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) - abs(total_spin)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.49926339999999997}
#standard deviation: 0.04037632301782816
#island_id: 3
#version_generated: 3
#generate time04:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4882578}
#standard deviation: 0.039297269869037976
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5089962}
#standard deviation: 0.03964695430370409
#island_id: 1
#version_generated: 3
#generate time04:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.5264994000000002}
#standard deviation: 0.04036025965773759
#island_id: 1
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin == h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin == h[i][j][k])
            priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2772834}
#standard deviation: 0.045719118587741824
#island_id: 3
#version_generated: 3
#generate time05:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if k < N - 1:
          neighbor_spin = J[2, i, j, k + 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.46073300000000006}
#standard deviation: 0.04336950577306595
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and site neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k]) + sum(J[d, i, (j + 1) % N, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] - sum(J[d, (i + 1) % N, j, k] for d in [0, 1, 2]) + sum(J[d, i, j, (k + 1) % N] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.0796894}
#standard deviation: 0.05901077840225462
#island_id: 0
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = [0, 1, 2]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in site_nbr:
          priorities[i*N*N + j*N + k][0] += -J[d,i,j,k]*interacting_spins[d,i,j,k]
          priorities[i*N*N + j*N + k][1] -= J[d,i,j,k]

  return priorities




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5202594000000001}
#standard deviation: 0.0416261863691595
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5899646000000001}
#standard deviation: 0.039911688348652954
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 2
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4213066}
#standard deviation: 0.04089169838047816
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0])
        
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.47688700000000006}
#standard deviation: 0.04203900178405763
#island_id: 0
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 3
#generate time05:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time05:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': 0.15385380000000018}
#standard deviation: 0.04537649816325628
#island_id: 0
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -np.sum([abs(val) for val in site_neighbors]) - sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] = np.sum([val for val in site_neighbors])
        else:
          priorities[i*N**2 + j*N + k][0] = np.sum([abs(val) for val in site_neighbors]) + sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] = -np.sum([val for val in site_neighbors])
  
  return(priorities)




#score: {'data3D.txt': -0.35904500000000006}
#standard deviation: 0.04127252954448031
#island_id: 0
#version_generated: 3
#generate time05:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.5013766}
#standard deviation: 0.04042988761349702
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.4590006}
#standard deviation: 0.04072517893932451
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4882578}
#standard deviation: 0.039297269869037976
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4882578}
#standard deviation: 0.039297269869037976
#island_id: 1
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with opposite spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.20317179999999999}
#standard deviation: 0.04588224890695747
#island_id: 1
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the total energy of all neighboring sites
        total_neighbor_energy = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            total_neighbor_energy += np.exp(h[i + d, j, k])
          else:
            total_neighbor_energy += np.exp(h[i - d, j, k])
        priorities[i * N * N + j * N + k][0] += total_neighbor_energy
        priorities[i * N * N + j * N + k][1] -= total_neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 3
#version_generated: 2
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Add your code here
  return(priorities)




#score: {'data3D.txt': -0.5709606}
#standard deviation: 0.0410495788972311
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        total_spin = sum(site_interacting_spins)

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        else:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N**2 + j*N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N**2 + j*N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N**2 + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N**2 + j*N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5289306}
#standard deviation: 0.041743397365811036
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin_product = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.43541660000000004}
#standard deviation: 0.0459931012700818
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate local energy
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate priority based on site neighbors
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0]) + sum(site_neighbors)
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5135006}
#standard deviation: 0.04167518781769315
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.067413}
#standard deviation: 0.045173426159635044
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = sum(site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val < 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum([J[3+i, i, j, k] for i in range(3)])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val > 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum([J[3+i, i, j, k] for i in range(3)])
  
  return(priorities)




#score: {'data3D.txt': -0.48821380000000003}
#standard deviation: 0.04183023606866211
#island_id: 0
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors.sort()
        if len(set(site_neighbors)) == 1:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': 0.34785220000000006}
#standard deviation: 0.04908161891339771
#island_id: 0
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 - 2 * np.tanh(sum(J[d, i, j, k] for d in [3+i for i in range(3)])) - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] = np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * np.tanh(sum(J[d, i, j, k] for d in [3+i for i in range(3)])) - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.113077}
#standard deviation: 0.045198655190171314
#island_id: 0
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = sum(site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val < 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum([J[3+i, i, j, k] for i in range(3)])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val > 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum([J[3+i, i, j, k] for i in range(3)])
        
        # Add a new term based on the local energy
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * h[i][j][k]
        priorities[i*N**2 + j*N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.067413}
#standard deviation: 0.045173426159635044
#island_id: 0
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + h[i][j][k]
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = sum(site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val < 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum([J[3+i, i, j, k] for i in range(3)])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum([J[3+i, i, j, k] for i in range(3)]))) * len([val for val in [J[3+i, i, j, k] for i in range(3)] if val > 0]) + site_neighbors_sum
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum([J[3+i, i, j, k] for i in range(3)])
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                 J[d, i, (j+1)%N, k] if d == 1 else
                 J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.5021118}
#standard deviation: 0.04143081100775123
#island_id: 3
#version_generated: 3
#generate time06:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.5178222000000001}
#standard deviation: 0.04096623618493649
#island_id: 0
#version_generated: 3
#generate time06:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_spin_product = h[i][j][k]
        for d in range(6):
          if J[d, i, j, k] < 0:
            site_spin_product *= -1
          elif J[d, i, j, k] > 0:
            site_spin_product *= 1
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors) + site_spin_product
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
              J[d, i, (j+1)%N, k] if d == 1 else
              J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.006419399999999991}
#standard deviation: 0.05058859855382436
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) - site_nbr
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
    
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction energy with the site and its neighbors
        interacting_energy = sum(J[d, i, j, k]*interacting_spins[d] for d in range(6))
        priorities[i * N * N + j * N + k][0] += -interacting_energy
        priorities[i * N * N + j * N + k][1] -= interacting_energy
        
  return(priorities)




#score: {'data3D.txt': -0.012618599999999966}
#standard deviation: 0.057221166835708624
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, site_nbr, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else 
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        interacting_spins = np.array(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4498818}
#standard deviation: 0.042026843668779124
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d - 3, j, k]
          else:
            neighbor_spin = J[1 - d, i - d + 3, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.47431619999999997}
#standard deviation: 0.0417211559950105
#island_id: 1
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42627780000000004}
#standard deviation: 0.04017968326355996
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the total spin of the site's neighbors with absolute value
        neighbor_spin_abs_sum = sum(abs(J[d, i, j, k]) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_abs_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_abs_sum > 0) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.46424580000000004}
#standard deviation: 0.042155284631467026
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the site's energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.42627780000000004}
#standard deviation: 0.04017968326355996
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_sum > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_sum > 0) * 1
        
        # Add a new term based on the number of neighbors with same spin
        neighbor_spin_same = sum((J[d, i, j, k] > 0) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin_same > 0) * 1
        priorities[i * N * N + j * N + k][1] -= (neighbor_spin_same > 0) * 1
        
  return(priorities)




#score: {'data3D.txt': -0.5404314}
#standard deviation: 0.03995126148246136
#island_id: 1
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.08290180000000004}
#standard deviation: 0.046961126016738575
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        # Calculate the energy term
        energy_term = sum(site_interacting_spins) + h[i][j][k]
        if h[i][j][k] > 0:
          energy_term *= np.exp(-abs(sum(site_interacting_spins)))
        else:
          energy_term *= np.exp(abs(sum(site_interacting_spins)))
        
        # Calculate the term for flipping a spin
        flip_term = -2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += energy_term + flip_term
        priorities[i*N**2 + j*N + k][1] -= 2 * np.tanh(energy_term)
  
  return(priorities)




#score: {'data3D.txt': -0.47688700000000006}
#standard deviation: 0.04203900178405763
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.489725}
#standard deviation: 0.04309173859337774
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.47688700000000006}
#standard deviation: 0.04203900178405763
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(site_interacting_spins) + local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbor_spin = J[1, (i+1)%N, j, k]
        if site_neighbor_spin < 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] -= 1
        elif site_neighbor_spin > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.07124499999999999}
#standard deviation: 0.04861846742751154
#island_id: 3
#version_generated: 3
#generate time06:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.4213066}
#standard deviation: 0.04089169838047816
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2]) - local_energy
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2]) - local_energy
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0])
        
  return(priorities)




#score: {'data3D.txt': -0.4213066}
#standard deviation: 0.04089169838047816
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
 
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, (j+1)%N, k] for d in [0])

  return(priorities)




#score: {'data3D.txt': -0.42473340000000004}
#standard deviation: 0.04162201345970663
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        if len([val for val in site_interacting_spins + site_neighbors if val < 0]) > len([val for val in site_interacting_spins + site_neighbors if val > 0]):
          priorities[i*N**2 + j*N + k][1] -= 2
        else:
          priorities[i*N**2 + j*N + k][0] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.379805}
#standard deviation: 0.041719137275356026
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += -np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] += -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        else:
          priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_interacting_spins))) * len([val for val in site_interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i*N**2 + j*N + k][1] += -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - h[i][j][k]
        
        priorities[i*N**2 + j*N + k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) + sum(J[d, i, (j+1)%N, k] for d in [0])
        priorities[i*N**2 + j*N + k][1] += -2 + 2 * sum(J[d, i, (j+1)%N, k] for d in [0])
  
  return(priorities)




#score: {'data3D.txt': -0.4898757999999999}
#standard deviation: 0.0401630822318208
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with different spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0 or neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy

  return(priorities)




#score: {'data3D.txt': -0.372201}
#standard deviation: 0.04255917150274427
#island_id: 1
#version_generated: 3
#generate time06:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 2
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0177686}
#standard deviation: 0.0619550483337718
#island_id: 3
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.012618599999999966}
#standard deviation: 0.057221166835708624
#island_id: 3
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, site_nbr, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else 
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        interacting_spins = np.array(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.030805800000000005}
#standard deviation: 0.059029575691851285
#island_id: 3
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2896438}
#standard deviation: 0.04276954011396428
#island_id: 1
#version_generated: 3
#generate time06:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.12068620000000006}
#standard deviation: 0.04868601246312949
#island_id: 3
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.07124499999999999}
#standard deviation: 0.04861846742751154
#island_id: 3
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
             J[d, i, (j+1)%N, k] if d == 1 else
             J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.4406338000000001}
#standard deviation: 0.04068121553690352
#island_id: 3
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': 0.07076779999999999}
#standard deviation: 0.3075787213107565
#island_id: 3
#version_generated: 3
#generate time06:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(h[i1][j1][k1] for i1 in range(N) for j1 in range(N) for k1 in range(N))
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.3825982000000003}
#standard deviation: 0.047867997208573494
#island_id: 3
#version_generated: 3
#generate time06:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.3825982000000003}
#standard deviation: 0.047867997208573494
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.030805800000000005}
#standard deviation: 0.059029575691851285
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                    J[d, i, (j+1)%N, k] if d == 1 else
                    J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3679122000000002}
#standard deviation: 0.05070568342069753
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4402718000000001}
#standard deviation: 0.040786462518340574
#island_id: 3
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
             J[d, i, (j+1)%N, k] if d == 1 else
             J[d, i, j, (k+1)%N] for d in range(6)]
        interacting_spins = np.array(interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.44975540000000014}
#standard deviation: 0.04601658625800049
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.21929540000000003}
#standard deviation: 0.043601374047614605
#island_id: 1
#version_generated: 3
#generate time06:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.21929540000000003}
#standard deviation: 0.043601374047614605
#island_id: 1
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.21929540000000003}
#standard deviation: 0.043601374047614605
#island_id: 1
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5366709999999999}
#standard deviation: 0.04100808065491483
#island_id: 0
#version_generated: 2
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.094119}
#standard deviation: 0.04349325141904201
#island_id: 0
#version_generated: 2
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5875937999999999}
#standard deviation: 0.03957982215169745
#island_id: 0
#version_generated: 2
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.49049100000000023}
#standard deviation: 0.04471669396321691
#island_id: 0
#version_generated: 2
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  # Add a term based on the number of nearest neighbors with same spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])) / 3) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])) / 3) * -2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0036465999999999994}
#standard deviation: 0.04764309339704969
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  # Sort the priority based on site interaction and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k] = sorted(priorities[i * N * N + j * N + k])
        else:
          priorities[i * N * N + j * N + k] = sorted(reversed(priorities[i * N * N + j * N + k]))
  
  return(priorities)




#score: {'data3D.txt': -0.35103059999999997}
#standard deviation: 0.037907796343760215
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.41884940000000015}
#standard deviation: 0.041952467384410184
#island_id: 3
#version_generated: 3
#generate time07:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]

        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2

        # Add a new term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the site interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.2837422}
#standard deviation: 0.04336838732487063
#island_id: 2
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.46148300000000014}
#standard deviation: 0.04251413918921563
#island_id: 3
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]

        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) - abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.030921799999999996}
#standard deviation: 0.04793613589725396
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add another term based on the site interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.030921799999999996}
#standard deviation: 0.04793613589725396
#island_id: 3
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                  J[d, i, (j+1)%N, k] if d == 1 else
                  J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] + np.mean([J[d, i, j, k] for d in range(6)]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add another term based on the site interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the site interaction and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.432109}
#standard deviation: 0.04216058727057772
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins)
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
  return priorities




#score: {'data3D.txt': -0.470543}
#standard deviation: 0.03928530095341004
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.2837422}
#standard deviation: 0.04336838732487063
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0022838000000000008}
#standard deviation: 0.04706886590475704
#island_id: 2
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.3193506000000001}
#standard deviation: 0.054880218655176664
#island_id: 3
#version_generated: 3
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d == 0 else i, j, k] if d % 3 == 0 else 
                   J[1, i, (j+1)%N if d == 1 else j, k] if d % 3 == 1 else
                   J[2, i, j, (k+1)%N if d == 2 else k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        local_energy = h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - local_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - local_energy
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.047739000000000004}
#standard deviation: 0.04509749615000815
#island_id: 3
#version_generated: 3
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[0, site_nbr, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the interaction with the nearest neighbors
        for d in range(6):
          if d < 3:
            site_nbr = (i + ((d-1) % 3 - 1)) % N
          else:
            site_nbr = (j + ((d-3) % 3 - 1)) % N
          
          priorities[i * N * N + j * N + k][0] -= J[d, site_nbr, i, k]
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.030805800000000005}
#standard deviation: 0.059029575691851285
#island_id: 3
#version_generated: 3
#generate time07:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins_val = [J[0, site_nbr, j, k], 
                     J[1, i, (j+1)%N, k], 
                     J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins_val if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins_val if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and magnetism
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 0
#version_generated: 3
#generate time07:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.094119}
#standard deviation: 0.04349325141904201
#island_id: 0
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5366709999999999}
#standard deviation: 0.04100808065491483
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5366709999999999}
#standard deviation: 0.04100808065491483
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0646022}
#standard deviation: 0.046722082521651366
#island_id: 0
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          site_neighbors = [J[d, i, j, (k - 1) % N], J[2 - d, (i - 1) % N, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
    
    return(priorities)




#score: {'data3D.txt': -0.42281420000000003}
#standard deviation: 0.047636163556273085
#island_id: 3
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site interaction, neighbor interaction and magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site interaction, neighbor spin and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * np.mean([J[d, i, j, k] for d in range(6)])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.45927260000000014}
#standard deviation: 0.045598797892488344
#island_id: 3
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy, neighbor interaction and neighbor spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site interaction and magnetism
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4397062000000001}
#standard deviation: 0.04051904492408478
#island_id: 3
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d == 0 else 
                   J[d, i, (j+1)%N, k] if d == 1 else
                   J[d, i, j, (k+1)%N] for d in range(6)]

        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k] * (np.mean([J[d, i, j, k] for d in range(6)]) if total_spin > 0 else -np.mean([J[d, i, j, k] for d in range(6)]))
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': 0.287167}
#standard deviation: 0.051822029205734504
#island_id: 2
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [(i + (j - 1) % N), (i + (k - 1) % N)]
        opposite_spins = len([val for val in interacting_spins if val < 0])
        same_spins = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) - 2
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.0400114}
#standard deviation: 0.04295280375062843
#island_id: 2
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = []
        for l in range(3):
          if h[i][j][k] > 0:
            site_nbrs.append(-np.sum([J[d, i, j, k] for d in range(6)]))
          else:
            site_nbrs.append(np.sum([J[d, i, j, k] for d in range(6)]))
        
        priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * np.sum(site_nbrs)
        priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': -0.432109}
#standard deviation: 0.04216058727057772
#island_id: 2
#version_generated: 3
#generate time07:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins)
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins

  return priorities




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4109818}
#standard deviation: 0.04014788697752349
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] += len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 2
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 3
#version_generated: 2
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.541861}
#standard deviation: 0.04066007770528728
#island_id: 3
#version_generated: 2
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
        if i > 0:
          neighbor_spin = J[0, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          neighbor_spin = J[0, i+1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.457529}
#standard deviation: 0.040548987151345715
#island_id: 2
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  def get_priority(site_nbrs):
    opposite_spins = len([val for val in site_nbrs if val < 0])
    same_spins = len([val for val in site_nbrs if val > 0])
    return np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))* (opposite_spins - same_spins)

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += get_priority(site_nbrs)
        priorities[i * N * N + j * N + k][1] -= get_priority(site_nbrs)

  return priorities




#score: {'data3D.txt': -0.4614706}
#standard deviation: 0.04171806342149645
#island_id: 2
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbrs = [J[0, i, j, k], J[1, i, j, k]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins)
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
  return priorities




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




#score: {'data3D.txt': -0.2023046}
#standard deviation: 0.0517558914408785
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.49179900000000004}
#standard deviation: 0.044346386087256315
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]])
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3057002}
#standard deviation: 0.03995163876438612
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        opposite_spins = len([val for val in site_nbrs if val < 0])
        same_spins = len([val for val in site_nbrs if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1267970000000002}
#standard deviation: 0.045822538897359245
#island_id: 3
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.048049800000000004}
#standard deviation: 0.04603852343375057
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        site_center = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_center if val < 0]) - len([val for val in site_center if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_center if val < 0]) + 2 * len([val for val in site_center if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.209313}
#standard deviation: 0.04209181382406798
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2475682}
#standard deviation: 0.043539602992677826
#island_id: 0
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4109818}
#standard deviation: 0.04014788697752349
#island_id: 0
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] += len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.1472706}
#standard deviation: 0.04523971104726466
#island_id: 0
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_opposite = [J[d, i, j, k] for d in [3, 4, 5]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite if val > 0]) - len([val for val in site_opposite if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_opposite if val > 0]) + 2 * len([val for val in site_opposite if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.4661586}
#standard deviation: 0.04063200814678005
#island_id: 3
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          neighbor_spin = J[0, i+1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j > 0:
          neighbor_spin = J[1, i, j-1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if j < N-1:
          neighbor_spin = J[1, i, j+1, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k < N-1:
          neighbor_spin = J[2, i, j, k+1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.44836980000000004}
#standard deviation: 0.04052035350240667
#island_id: 0
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add the effect of magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.21791939999999999}
#standard deviation: 0.042585295392189075
#island_id: 0
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(interacting_spins) > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(interacting_spins) > 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.32735659999999994}
#standard deviation: 0.04178420654314259
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Further Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.3839162}
#standard deviation: 0.04356043316543121
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Further improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.3839162}
#standard deviation: 0.04356043316543121
#island_id: 2
#version_generated: 3
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.17659179999999997}
#standard deviation: 0.04406719020722787
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += -h[i][j][k] * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3776106}
#standard deviation: 0.039765162738759165
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the magnetism at this site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0020426000000000003}
#standard deviation: 0.048969413160053286
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40687100000000004}
#standard deviation: 0.04053712815432292
#island_id: 1
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        # Add a new term based on the number of nearest neighbors with different sign
        opposite_spin_count = sum(1 for val in site_neighbors if (val > 0 and h[i][j][k] < 0) or (val < 0 and h[i][j][k] > 0))
        
        # Add a new term based on the number of nearest neighbors with same spin
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        same_spin_count_interacting = sum(1 for val in interacting_spins if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - same_spin_count_interacting) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_up = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_up if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy

        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3405202}
#standard deviation: 0.04363963602002198
#island_id: 1
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3821878}
#standard deviation: 0.04201939232259315
#island_id: 1
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] += neighbor_energy
          priorities[i * N * N + j * N + k][1] -= neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the local energy of the current site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= np.exp(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += np.exp(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4874522000000001}
#standard deviation: 0.04174368880633335
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (total_neighbor_spin < 0) + 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] = (total_neighbor_spin > 0) - 1

  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4965694}
#standard deviation: 0.04017140953016212
#island_id: 3
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4192174}
#standard deviation: 0.039697433383532495
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin) - sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [(i-1)%N if i > 0 else (i+1)%N, (j-1)%N if j > 0 else (j+1)%N, (k-1)%N if k > 0 else (k+1)%N]
        
        for d in [0, 1, 2]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, site_neighbors[0], site_neighbors[1], site_neighbors[2]] * (h[site_neighbors[0]][site_neighbors[1]][site_neighbors[2]] > 0) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.20733179999999998}
#standard deviation: 0.04363528880115267
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + len([val for val in J[2, :, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + len([val for val in J[2, :, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2
    
  return priorities




#score: {'data3D.txt': -0.4699998}
#standard deviation: 0.039280425149939506
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3, i, j, :] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.10444500000000007}
#standard deviation: 0.04793810525041642
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i, j, k] + J[d, i-1 if i>0 else N-1, j, k] * interacting_spins[0][i-1 if i>0 else N-1, j, k] 
                + J[d, i, j-1 if j>0 else N-1, k] * interacting_spins[1][i, j-1 if j>0 else N-1, k] 
                + J[d, i, j, k-1 if k>0 else N-1] * interacting_spins[2][i, j, k-1 if k>0 else N-1] for d in range(6))
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0699494}
#standard deviation: 0.04967707519208433
#island_id: 3
#version_generated: 3
#generate time08:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.006407}
#standard deviation: 0.04706728025922042
#island_id: 1
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if all(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2
        elif all(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] = -neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.018232999999999996}
#standard deviation: 0.046541244407514504
#island_id: 1
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
  return(priorities)




#score: {'data3D.txt': 0.1705498000000001}
#standard deviation: 0.04619437108523072
#island_id: 1
#version_generated: 3
#generate time08:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.46322820000000003}
#standard deviation: 0.041932213449327946
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + total_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbors = [J[d, i, j, k] for d in [0, 1]]
        neighbor_counts = [len([val for val in neighbors if val < 0]), len([val for val in neighbors if val > 0])]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_counts[0] - neighbor_counts[1])
        priorities[i * N * N + j * N + k][1] -= neighbor_counts[0] - neighbor_counts[1]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.44266820000000007}
#standard deviation: 0.041651289881106925
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = sum(J[d, i + d, :, k])
          else:
            neighbor_spin = sum(J[1 - d, i - d, :, k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] -= neighbor_spin > 0
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4716798}
#standard deviation: 0.039806471734631296
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0083862}
#standard deviation: 0.04658829992133218
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(J[d, :, :, :], 1, axis=0) for d in range(6)]
  interacting_spins += [np.roll(np.roll(J[d, :, :, :], 1, axis=1), 1, axis=1) for d in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[d, (i+1)%N, j, k] for d in range(3)] + [J[d, i, (j+1)%N, k] for d in range(3)] + [J[d, i, j, (k+1)%N] for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.44836980000000004}
#standard deviation: 0.04052035350240667
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add the effect of magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3598574}
#standard deviation: 0.04163064382447142
#island_id: 0
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.1705498000000001}
#standard deviation: 0.04619437108523072
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.14780339999999997}
#standard deviation: 0.04636303558267081
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])

        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if i + (d - 1) % 2 == 0:
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])

          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy

  return priorities




#score: {'data3D.txt': 0.1705498000000001}
#standard deviation: 0.04619437108523072
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.1204422}
#standard deviation: 0.046401130365110725
#island_id: 1
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_sign_neighbors = len([val for val in site_neighbors if val * h[i][j][k] > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) - total_spin
        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * same_sign_neighbors
          priorities[i * N * N + j * N + k][1] += same_sign_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (3 - same_sign_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy of neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_energy = np.exp(h[i + d, j, k])
          else:
            neighbor_energy = np.exp(h[i - d, j, k])
          priorities[i * N * N + j * N + k][0] -= neighbor_energy
          priorities[i * N * N + j * N + k][1] += neighbor_energy
        
        # Add a new term based on the number of nearest neighbors with same spin and different sign
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] < 0 or neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.4405638}
#standard deviation: 0.039134929788617226
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        priorities[i * N * N + j * N + k][0] += total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + (1 if neighbor_spin < 0 else -1)
        priorities[i * N * N + j * N + k][1] += -2 + 2 * total_spin
  return priorities




#score: {'data3D.txt': -0.002561}
#standard deviation: 0.048223091138996886
#island_id: 1
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, :, :, :] for d in range(6)]
  total_spin = sum(J[d, :, :, :] * h for d in range(6))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [interacting_spins[0][i, (j + 1) % N, k], interacting_spins[1][(i + 1) % N, j, k], interacting_spins[2][i, j, (k + 1) % N]]
        same_spin_count = sum(1 for val in site_neighbors if val > 0 and h[i][j][k] > 0 or val < 0 and h[i][j][k] < 0)
        
        priorities[i * N * N + j * N + k][0] = -same_spin_count
        priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': 0.287167}
#standard deviation: 0.051822029205734504
#island_id: 2
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [(i + (j - 1) % N), (i + (k - 1) % N)]
        opposite_spins = len([val for val in interacting_spins if val < 0])
        same_spins = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) - 2
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.287167}
#standard deviation: 0.051822029205734504
#island_id: 2
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbrs = [(i + (j - 1) % N), (i + (k - 1) % N)]
        opposite_spins = len([val for val in interacting_spins if val < 0])
        same_spins = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spins - same_spins) - 2
        priorities[i * N * N + j * N + k][1] -= opposite_spins - same_spins
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.179335}
#standard deviation: 0.05503390495867071
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        opposite_neighbors = sum([val for val in site_neighbors if val * total_spin < 0])

        priorities[i * N * N + j * N + k][0] += -np.sum([np.exp(-abs(val)) for val in interacting_spins]) - opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3598574}
#standard deviation: 0.04163064382447142
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.0907414}
#standard deviation: 0.04537411471356769
#island_id: 0
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([np.exp(-abs(val)) for val in interacting_spins]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_opposite = [J[d, i, j, k] for d in [3, 4, 5]]
        priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_opposite if val < 0]) - len([val for val in site_opposite if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_opposite if val < 0]) + 2 * len([val for val in site_opposite if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4336954}
#standard deviation: 0.043073326999896355
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.477437}
#standard deviation: 0.042744642132084815
#island_id: 2
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3341174}
#standard deviation: 0.04066163126634248
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] += neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2851426}
#standard deviation: 0.04055728029885633
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([J[d, i, (j + 1) % N, k] for d in [0, 1]]) if j < N-1 else 0
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4497574000000001}
#standard deviation: 0.04689999216673709
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36847660000000004}
#standard deviation: 0.04318222796984889
#island_id: 2
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] -= 4
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] += 4
        
        # Add a new term based on the interaction with the site above
        if i > 0:
          above_neighbor = J[1, (i - 1) % N, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (above_neighbor < 0) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction with the site below
        if i < N - 1:
          below_neighbor = J[1, (i + 1) % N, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (below_neighbor > 0) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the interaction with the site to the left
        if j > 0:
          left_neighbor = J[0, i, (j - 1) % N, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (left_neighbor < 0) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction with the site to the right
        if j < N - 1:
          right_neighbor = J[0, i, (j + 1) % N, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (right_neighbor > 0) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the interaction with the site in front
        if k > 0:
          front_neighbor = J[2, i, j, (k - 1) % N]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (front_neighbor < 0) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the interaction with the site behind
        if k < N - 1:
          back_neighbor = J[2, i, j, (k + 1) % N]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (back_neighbor > 0) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2671726}
#standard deviation: 0.04903206307346245
#island_id: 2
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.1680934}
#standard deviation: 0.05701971480496899
#island_id: 2
#version_generated: 3
#generate time08:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the interactions with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the interactions with the next nearest neighbors
        site_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.44777380000000006}
#standard deviation: 0.0424420017619339
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4619698}
#standard deviation: 0.04101120051839497
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.343681}
#standard deviation: 0.045560499986281984
#island_id: 2
#version_generated: 3
#generate time08:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = 0
        opposite_spin_count = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            opposite_spin_count += 1
          elif neighbor_spin > 0:
            same_spin_count += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= same_spin_count - opposite_spin_count
  
  return priorities




#score: {'data3D.txt': -0.0686002}
#standard deviation: 0.05862008563589787
#island_id: 2
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the interactions with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the interactions with the next nearest neighbors
        site_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the magnetism term
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.02098699999999976}
#standard deviation: 0.04370820919461238
#island_id: 2
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.zeros((N,N,N)) for _ in range(6)]
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1680934}
#standard deviation: 0.05701971480496899
#island_id: 2
#version_generated: 3
#generate time08:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the interactions with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add the interactions with the next nearest neighbors
        site_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 2) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 3
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0420494}
#standard deviation: 0.046863598662928135
#island_id: 3
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i, j, k] if d == 0 else h[(i + d - 1) % N, (j + d - 1) % N, (k + d - 1) % N]) for d in range(6))
        site_spin = int(h[i, j, k])
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.06717180000000007}
#standard deviation: 0.0470229131887849
#island_id: 3
#version_generated: 3
#generate time08:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (h[(i+d)%N, (j+d)%N, k] > 0) - J[5-d, i, j, k] * (h[i, j, (k+d)%N] > 0) for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: 3
#version_generated: 3
#generate time08:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h.flatten()
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1, axis=i%3)
    interacting_spins = interacting_spins.reshape(N,N,N)
    priorities += -J[i].flatten() * interacting_spins.flatten()
  return np.array([priorities, np.zeros(N**3)]).T




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.43254180000000003}
#standard deviation: 0.04294916079226694
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(site_neighbors[:3])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 2
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors_total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbors_total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbors_total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time08:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0]) + len([val for val in J[2, i, j, :] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0]) + len([val for val in J[2, i, j, :] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.11657380000000007}
#standard deviation: 0.045806539200860835
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + e) % N, (k + f) % N] for d, e, f in [(0, 1, 2), (1, 0, 2), (2, 0, 1)]]
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)

  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.2974446}
#standard deviation: 0.039320685279379354
#island_id: 2
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in site_neighbors)
        
        layer_neighbors = [J[3, i, j, (k + 1) % N], J[4, (i + 1) % N, j, k], J[5, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in layer_neighbors if val < 0]) + sum(val for val in layer_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(val for val in layer_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2831902}
#standard deviation: 0.04457670808796899
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0239514}
#standard deviation: 0.048036597694258075
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0239514}
#standard deviation: 0.048036597694258075
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.1394126}
#standard deviation: 0.047487514582677415
#island_id: 1
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if i < N-1:
          left_spin = J[2, i+1, j, k]
          if left_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if j < N-1:
          up_spin = J[2, i, j+1, k]
          if up_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        if k < N-1:
          front_spin = J[2, i, j, k+1]
          if front_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.45217460000000015}
#standard deviation: 0.04674166658175551
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23776380000000036}
#standard deviation: 0.04703389426318002
#island_id: 0
#version_generated: 2
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.1173022}
#standard deviation: 0.04569395140672341
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # Add terms based on the site's neighbors and local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val != 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4666742}
#standard deviation: 0.03938114033849198
#island_id: 1
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2360802}
#standard deviation: 0.04370633555858922
#island_id: 0
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          for spin in [-1, 1]:
            if sum([val for val in interacting_spins if val < 0]) == 0 and total_spin >= 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif sum([val for val in interacting_spins if val > 0]) == 0 and total_spin <= 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            
            if J[2, i, j, k - 1] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            
            for d in [0, 1]:
              if (i + (d - 1) % 2 == 0):
                neighbor_spin = J[d, i + d, j, k]
              else:
                neighbor_spin = J[1 - d, i - d, j, k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
            
            for d in [0, 1]:
              if (i + (d - 1) % 2 == 0):
                neighbor_spin = J[d, i + d, j, k]
              else:
                neighbor_spin = J[1 - d, i - d, j, k]
              if neighbor_spin < 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] -= 1
              elif neighbor_spin > 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
                priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.5630806}
#standard deviation: 0.04328313601900861
#island_id: 0
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add a new term based on the number of nearest neighbors with the opposite spin
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46830259999999996}
#standard deviation: 0.03984016557746717
#island_id: 1
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) - h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
        # New term based on the sum of neighboring spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(interacting_spins[2, i, j, :]) + total_site_neighbors_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.34458939999999993}
#standard deviation: 0.04276586030515462
#island_id: 2
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        
  
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_neighbors = [val for val in site_neighbors if val < 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32740020000000003}
#standard deviation: 0.04951543314927175
#island_id: 2
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.001211}
#standard deviation: 0.04945945894366415
#island_id: 3
#version_generated: 3
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.458271}
#standard deviation: 0.0448929085602615
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.489885}
#standard deviation: 0.04085736965346644
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.46980700000000003}
#standard deviation: 0.03941427953166212
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4716798}
#standard deviation: 0.039806471734631296
#island_id: 2
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, :, k] if val < 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, :, k] if val > 0])) - 2
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.30675339999999995}
#standard deviation: 0.04295753657322542
#island_id: 1
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add new terms based on the site's neighbors and local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin) - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.18640140000000002}
#standard deviation: 0.05336849068542224
#island_id: 0
#version_generated: 3
#generate time08:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])

        neighbor_spin = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_spin if val < 0]) - len([val for val in neighbor_spin if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.33159340000000004}
#standard deviation: 0.047892911338109315
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.36619100000000004}
#standard deviation: 0.04299328644102472
#island_id: 0
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 4.660000000000025e-05}
#standard deviation: 0.04560419310151206
#island_id: 0
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_1 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] > 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_2 = sum(J[d, i, j, k] for d in [0, 1, 2]) if h[i][j][k] < 0 else -sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] = total_spin_1
        priorities[i * N * N + j * N + k][1] = total_spin_2
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45217460000000015}
#standard deviation: 0.04674166658175551
#island_id: 0
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0020365999999999995}
#standard deviation: 0.04676717545928982
#island_id: 3
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1, axis=i%3)
    interacting_spins = interacting_spins.flatten()
    
    site_nbr = (i + ((-1) % 2)) % N
    if h[0][0][0] > 0:
      priorities[:,0] += -np.exp(-abs(J[i].flatten())) * len([val for val in interacting_spins if val < 0]) + J[i].flatten()
      priorities[:,1] -= 2 - 2 * np.sum(J[i].flatten())
    else:
      priorities[:,0] -= -np.exp(-abs(J[i].flatten())) * len([val for val in interacting_spins if val < 0]) + J[i].flatten()
      priorities[:,1] += 2 - 2 * np.sum(J[i].flatten())

  return priorities




#score: {'data3D.txt': -0.3811922}
#standard deviation: 0.05064070516057216
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

  # calculate the priority based on the magnetism and interaction
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]] if val > 0]) + sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]))) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]] if val < 0]) + sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]])

  return priorities




#score: {'data3D.txt': -0.4223194}
#standard deviation: 0.04245150296090823
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.2215570000000002}
#standard deviation: 0.04492072696428677
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  # This part is new
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], 2 - 2 * priorities[i * N * N + j * N + k][0])
        else:
          priorities[i * N * N + j * N + k][1] = max(priorities[i * N * N + j * N + k][1], -2 + 2 * priorities[i * N * N + j * N + k][0])
          
  return(priorities)




#score: {'data3D.txt': -0.4173698}
#standard deviation: 0.04091351375719275
#island_id: 2
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        site_neighbors = []
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if l == i: 
            site_neighbors += [J[0, l, j, k], J[1, i, l, k]]
          elif l == j:
            site_neighbors += [J[2, i, l, k]]
          else:
            site_neighbors.append(J[4, i, j, l])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34458939999999993}
#standard deviation: 0.04276586030515462
#island_id: 2
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.005885}
#standard deviation: 0.04739812163999751
#island_id: 3
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i, j, k]
        total_neighbor_spin = sum(J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] + J[d, (i+1)%N, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.5037474000000001}
#standard deviation: 0.04185668875150064
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy and calculate the average
          avg_neighbor_spin = sum(site_neighbors) / len(site_neighbors)
          if spin == -1:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (avg_neighbor_spin + total_spin)
            priorities[i * N * N + j * N + k][1] += 2 - 2 * avg_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (avg_neighbor_spin + total_spin)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * avg_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45596380000000014}
#standard deviation: 0.045081479229945425
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])

        # Add the total energy of the neighboring sites
        neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.45217460000000015}
#standard deviation: 0.04674166658175551
#island_id: 0
#version_generated: 3
#generate time09:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.4532198000000002}
#standard deviation: 0.04710714136901113
#island_id: 0
#version_generated: 3
#generate time09:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total energy for both -1 and 1
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add the site neighbors' spin energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        # Add the total spin energy
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        else:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2671726}
#standard deviation: 0.04903206307346245
#island_id: 2
#version_generated: 3
#generate time09:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] += 2 * total_spin - 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if (i > 0 and J[2, i - 1, j, k] < 0) or (i < N - 1 and J[2, i + 1, j, k] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        if (i > 0 and J[2, i - 1, j, k] > 0) or (i < N - 1 and J[2, i + 1, j, k] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the magnetism
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0015853999999999998}
#standard deviation: 0.04598906377433661
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.zeros((N,N,N)) for _ in range(6)]
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] = max(-2, min(2, 2 - 4 * total_spin))
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = max(-2, min(2, 2 + 4 * total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.2799926000000002}
#standard deviation: 0.04559333180674558
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0] * 6
        
        if i > 0:
          interacting_spins[0] = h[i-1][j][k]
        if i < N - 1:
          interacting_spins[1] = h[i+1][j][k]
        
        if j > 0:
          interacting_spins[2] = h[i][j-1][k]
        if j < N - 1:
          interacting_spins[3] = h[i][j+1][k]
        
        if k > 0:
          interacting_spins[4] = h[i][j][k-1]
        if k < N - 1:
          interacting_spins[5] = h[i][j][k+1]
        
        total_spin = sum(J[d, i, j, k] * s for d, s in enumerate(interacting_spins))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.07065860000000018}
#standard deviation: 0.04460407297590657
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] * (h[(i+1)%N][j][k] if d==0 else h[i][(j+1)%N][k] if d==1 else h[i][j][(k+1)%N]) for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4405638}
#standard deviation: 0.039134929788617226
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        priorities[i * N * N + j * N + k][0] += total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + (1 if neighbor_spin < 0 else -1)
        priorities[i * N * N + j * N + k][1] += -2 + 2 * total_spin
  return priorities




#score: {'data3D.txt': 0.11957900000000009}
#standard deviation: 0.0483857416911222
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, k - 1]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += - sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val < 0]) - (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val > 0]) + (1 if neighbor_spin > 0 else -1)
        else:
          priorities[i * N * N + j * N + k][0] += sum([J[d, i, j, k] for d in [0, 1, 2]]) + len([val for val in site_neighbors if val < 0]) + (1 if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += -sum([J[d, i, j, k] for d in [0, 1, 2]]) - len([val for val in site_neighbors if val > 0]) - (1 if neighbor_spin > 0 else -1)
  return priorities




#score: {'data3D.txt': -0.44001419999999997}
#standard deviation: 0.04539529401116376
#island_id: 0
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin_energy = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbor_energy = sum([val for val in site_neighbors if val != 0])
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_energy)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin_energy
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_energy - site_neighbor_energy
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_energy)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin_energy
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_energy + site_neighbor_energy
  
  return(priorities)




#score: {'data3D.txt': -0.06622579999999995}
#standard deviation: 0.045927807854936865
#island_id: 0
#version_generated: 3
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for spin in [-1, 1]:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
          
  return(priorities)




