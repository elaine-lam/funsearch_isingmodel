#score: {'data3D.txt': 0.08978540000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[(i + ((m % 3) - 1)) % N][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0006594000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0010730000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= sum(J[d][i][j][k] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        else:
          priorities[i*N*j+k][1] += sum(J[d][i][j][k] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
  return(priorities)


#score: {'data3D.txt': -0.002955}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) + total_spin)
        else:
          priorities[i*N*j+k][1] += (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) - total_spin)
  return(priorities)


#score: {'data3D.txt': 0.0448086}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.06430659999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] -= J[m,i,j,k]
          else:
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0009593999999999936}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0448086}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.029593400000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
        if total_spin_1[0] > total_spin_minus_1[0]:
          priorities[i][j][k] = [total_spin_1[0], total_spin_1[1]]
        else:
          priorities[i][j][k] = [total_spin_minus_1[0], total_spin_minus_1[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.38087820000000006}
program:
def priority(N, h, J):
  priorities = h.flatten()
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (interacting_spins - h).flatten()
    priorities += priority_change
  return np.array([priorities, np.zeros(N**3)]).T.reshape(-1,2)


#score: {'data3D.txt': 0.0011365999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin/abs(total_spin)
        else:
          priorities[i*N*j+k][1] = total_spin/abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -1.1400000000000077e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[(d-1)%3], site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 1
        else:
          priorities[i*N*j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.2638766}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[1] += 2*J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.05766619999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.10325419999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(2):
          priorities[i][j][k][m] = np.sum([J[n,i,j,k]*h[x][j][k] if h[x][j][k] == ((-1)**((n+m)%2))-1 else -J[n,i,j,k]*((-1)**((n+m)%2))+1 for n,x in enumerate(site_nbrs)])
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0847274}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(3):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if site_nbrs[l] == site_nbr])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if site_nbrs[l] == site_nbr])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.10351900000000011}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        total_spin[1] += 2*h[i][j][k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0010077999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0016337999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([h[i][j][k]*(-1)**(d==0) for d in range(6)])
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin + spin_product/abs(spin_product)
        else:
          priorities[i*N*j+k][1] = total_spin - spin_product/abs(spin_product)
  return(priorities)


#score: {'data3D.txt': 0.0001881999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (interacting_spins.flatten() - h.flatten())
    priorities += np.array([priority_change, -priority_change]).T.reshape(-1, 2)
  return priorities


#score: {'data3D.txt': 0.05732220000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.05732220000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0788418}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum(J[m,i,j,k] for m in range(6) if h[i][j][k] == h[site_nbrs[m]][j][k])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0010402}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= max(1, abs(total_spin))
        else:
          priorities[i*N*j+k][1] = -max(1, abs(total_spin))
  return(priorities)


#score: {'data3D.txt': -0.0003534000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += total_spin
          priorities[i*N*j+k][1] -= total_spin
        else:
          priorities[i*N*j+k][0] -= total_spin
          priorities[i*N*j+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0006290000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([h[i][j][k]*(-1)**(d==0) for d in range(6)])
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= total_spin + spin_product/abs(spin_product)
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin)
          priorities[i*N*j+k][1] = total_spin - spin_product/abs(spin_product)
  return(priorities)


#score: {'data3D.txt': -0.0008465999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([(-1)**d*h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6)])
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin + spin_product/abs(spin_product)
        else:
          priorities[i*N*j+k][1] = total_spin - spin_product/abs(spin_product)
  return(priorities)


#score: {'data3D.txt': -0.0027918}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0019562}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[m,i,j,k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]])
          else:
            total_spin[0] -= sum([J[m,i,j,k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.2885234000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + 1*h[i,j,k]
        priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]

  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.0233874}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N**3):
    site_nbr = (i // N**2 + ((i//N**2-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    
    if J[0, i//N**2, i%N].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
    
  return priorities.reshape(-1,2)


#score: {'data3D.txt': 0.08978540000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[site_nbrs[m]][j][k]])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0012654000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N**3):
    site_nbr = (i // N**2 + ((i//N**2-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i//N**2, i%N].flatten()[0] > 0:
      priorities[i//N**2*N+N-1+i%N][0] += 1
      priorities[i//N**2*N+N-1+i%N][1] -= 1
    else:
      priorities[i//N**2*N+N-1+i%N][0] -= 1
  return priorities


#score: {'data3D.txt': -0.0012226}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, i%N, (i // N) % N)
    total_spin = h[site_nbr[0]][site_nbr[1]] + h[site_nbr[0]][site_nbr[2]]
    
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
  
  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.0015158}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= abs(total_spin)
        else:
          priorities[i*N*j+k][0] -= total_spin
          priorities[i*N*j+k][1] = -abs(total_spin)
  return(priorities)


#score: {'data3D.txt': 0.015800599999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] > 0:
            total_spin[0] += J[m,i,j,k]
            total_spin[1] -= J[m,i,j,k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m,i,j,k]
            total_spin[1] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0017517999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0012226}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, i%N, (i // N) % N)
    
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
      
  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.0023878}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, (i // N) % N, i%N)
    interacting_spins = h[site_nbr[0]][(site_nbr[1]-1)%N] + h[site_nbr[0]][(site_nbr[1]+1)%N] + h[site_nbr[0]][(site_nbr[2]-1)%N] + h[site_nbr[0]][(site_nbr[2]+1)%N]
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
    
  return priorities.reshape(-1,2)


#score: {'data3D.txt': 0.17591340000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1 += J[m,i,j,k]
          else:
            total_spin_0 += J[m,i,j,k]
        priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.1692022000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        priorities[i][j][k] = [total_spin_zeros, total_spin_ones]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0026205999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        if all([h[s][j][k] > 0 for s in site_nbrs]):
          total_spin[1] -= sum([J[m,i,j,k] for m in range(6)])
        elif all([h[s][j][k] < 0 for s in site_nbrs]):
          total_spin[1] += sum([J[m,i,j,k] for m in range(6)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0056258}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  for i in range(N**3):
    site_nbr = ((i//N**2 + ((i//N**2-1)%2 - 1)) % N, (i // N) % N, i%N)
    interacting_spins = h[site_nbr[0]][(site_nbr[1]-1)%N] + h[site_nbr[0]][(site_nbr[1]+1)%N] + h[site_nbr[0]][(site_nbr[2]-1)%N] + h[site_nbr[0]][(site_nbr[2]+1)%N]
    if J[0, site_nbr[0], site_nbr[1]].flatten()[0] > 0:
      priorities[i//N**2, i%N, (i // N) % N][0] += 1
      priorities[i//N**2, i%N, (i // N) % N][1] -= 1
    else:
      priorities[i//N**2, i%N, (i // N) % N][0] -= 1
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = ((k-1)%2 - 1) % N
        interacting_spins = h[i][j]
        if J[k, i, j].flatten()[0] > 0:
          priorities[i,j,k][0] += 1
          priorities[i,j,k][1] -= 1
        else:
          priorities[i,j,k][0] -= 1
  
  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.002197}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr = ((i//N + ((i//N-1)%2 - 1)) % N, (i // N) % N, i%N)
    interacting_spins = h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    total_spin = interacting_spins
    for k in range(3):
      site = ((i//N + ((k-1)%2 - 1)) % N, (i // N) % N, i%N)
      if h[site[0]][site[1]][site[2]] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if J[0, site_nbr[0], site_nbr[1], site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return priorities


#score: {'data3D.txt': -0.002955}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) + total_spin)
        else:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] += (sum(J[d][i,j,k] * (h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N]-h[i][j][k]) for d in range(6)) - total_spin)
  return(priorities)


#score: {'data3D.txt': 0.00046899999999999964}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for _ in range(3)]
          total_spin += J[d][site_nbrs[0], site_nbrs[1], site_nbrs[2]] * h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
        priorities[i*N*j+k][0] = -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= total_spin
        else:
          priorities[i*N*j+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.17591340000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            if J[m, i, j, k] > 0:
              total_spin_0 += J[m, i, j, k]
            else:
              total_spin_1 += J[m, i, j, k]
          else:
            if J[m, i, j, k] < 0:
              total_spin_0 += J[m, i, j, k]
            else:
              total_spin_1 += J[m, i, j, k]
        priorities[i*N**2+j*N+k][0] = total_spin_0
        priorities[i*N**2+j*N+k][1] = -total_spin_1
  return(priorities.astype(int))


#score: {'data3D.txt': 0.2748426}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_1 += J[m,i,j,k]
          else:
            total_spin_0 += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] == h[i][j][k]:
            total_spin_0 += J[m,i,j,k]
          else:
            total_spin_1 -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            if J[m,i,j,k] > 0:
              total_spin_0 += J[m,i,j,k]
              total_spin_1 -= J[m,i,j,k]
            else:
              total_spin_0 -= J[m,i,j,k]
              total_spin_1 += J[m,i,j,k]
          priorities[i][j][k] = [total_spin_0, -total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0028334}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N, j, k]
          if h[tuple(site_nbrs)] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N, j, k]
          if h[tuple(site_nbrs)] == h[i, j, k]:
            total_spin[0] += J[m, i, j, k]
          else:
            total_spin[0] -= J[m, i, j, k]
        priorities[i*N + j + k] = [total_spin[0], -total_spin[1]]
  return(priorities.astype(int))


#score: {'data3D.txt': -0.0005510000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(h[site_nbrs[d]][site_nbrs[(d-1)%3], site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + 1)
        else:
          priorities[i*N*j+k][1] = total_spin - 1
  return(priorities)


#score: {'data3D.txt': -0.0010550000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[site_nbr][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
            total_spin_minus_1[1] += J[m, i, j, k]
          else:
            total_spin_1[1] += J[m, i, j, k]
            total_spin_minus_1[1] -= J[m, i, j, k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin_1[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
            total_spin_minus_1[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
          else:
            total_spin_1[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
            total_spin_minus_1[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
        if total_spin_1[0] > total_spin_minus_1[0]:
          priorities[i*N+j+k, 0] = -total_spin_1[1]
          priorities[i*N+j+k, 1] = 1
        else:
          priorities[i*N+j+k, 0] = -total_spin_minus_1[1]
          priorities[i*N+j+k, 1] = -1
  return(priorities)


#score: {'data3D.txt': -0.0018622}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
            total_spin_minus_1[1] += J[m, i, j, k]
          else:
            total_spin_1[1] += J[m, i, j, k]
            total_spin_minus_1[1] -= J[m, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k, 0] = total_spin_1[0] + sum([J[l, i, j, k] for l in range(6) if h[site_nbrs[l]][j][k] > 0])
          priorities[i*N+j+k, 1] = -total_spin_1[1]
        else:
          priorities[i*N+j+k, 0] = total_spin_minus_1[0] + sum([J[l, i, j, k] for l in range(6) if h[site_nbrs[l]][j][k] < 0])
          priorities[i*N+j+k, 1] = -total_spin_minus_1[1]
  return(priorities.astype(int))


#score: {'data3D.txt': -0.0011466000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbr][l][k]])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbr][l][k]])
        priorities[i*N+j+k, 0] = -total_spin[1]
        priorities[i*N+j+k, 1] = total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0021342000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][l][k] == h[site_nbrs[m]][l][k]])
          else:
            total_spin[0] -= sum([J[l, i, j, k] for l in range(6) if h[i][l][k] != h[site_nbrs[m]][l][k]])
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0023478}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] * h[site_nbr][j][k] > 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] * h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        if np.abs(h[i][j][k]) > 0.5:
          priorities[i*N+j+k, 0] = total_spin[0] + h[i][j][k] * (N**2)
          priorities[i*N+j+k, 1] = -total_spin[1] - h[i][j][k] * (N**2)
        else:
          priorities[i*N+j+k, 0] = total_spin[0]
          priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities.astype(int))


#score: {'data3D.txt': -0.0025702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m, i, j, k]
          else:
            total_spin[0] -= J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] > 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] < 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = (i + ((m-1)%3 - 1)) % N
          if h[i][j][k] > 0 and h[site_nbr][j][k] < 0:
            total_spin[0] += J[m, i, j, k]
            total_spin[1] -= J[m, i, j, k]
          elif h[i][j][k] < 0 and h[site_nbr][j][k] > 0:
            total_spin[0] -= J[m, i, j, k]
            total_spin[1] += J[m, i, j, k]
        priorities[i*N+j+k, 0] = total_spin[0]
        priorities[i*N+j+k, 1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0021038000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N**3):
    site_nbr = (i // N**2 + ((i//N**2-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i//N**2, i%N].flatten()[0] > 0:
      priorities[i//N**2*N+N-1+i%N][0] += 1
      priorities[i//N**2*N+N-1+i%N][1] -= 1
    else:
      priorities[i//N**2*N+N-1+i%N][0] -= 1
  for i in range(N):
    if h[0,i].sum() > 0:
      priorities[i*N:N*(i+1),0] = np.cumsum(priorities[i*N:N*(i+1),0])
    else:
      priorities[i*N:N*(i+1),1] = -np.cumsum(priorities[i*N:N*(i+1),0])
  return priorities


#score: {'data3D.txt': -0.1852278000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = site_nbrs[m]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.11333740000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0,i,j,k] > 0:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
        else:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]

  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.2885234000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
        priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]

  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.046829}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[p,i,j,k] for p in range(6)])
          else:
            total_spin[0] -= sum([J[p,i,j,k] for p in range(6)])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.4288834000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_0 += J[m,i,j,k]
            total_spin_1 -= J[m,i,j,k]
          else:
            total_spin_0 -= J[m,i,j,k]
            total_spin_1 += J[m,i,j,k]
        if h[i][j][k] > 0:
          priorities[i][j][k] = [total_spin_0+sum(J[m,i,j,k] for m in range(6)), -total_spin_1]
        else:
          priorities[i][j][k] = [-total_spin_0, total_spin_1]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.102013}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[l, i, j, k] for l in range(6) if h[i][j][k] == h[(i + ((l % 3) - 1)) % N][j][k]])
          priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0009470000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += total_spin + sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N)) 
          priorities[i*N*j+k][1] -= total_spin - sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N))
        else:
          priorities[i*N*j+k][0] -= total_spin - sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N)) 
          priorities[i*N*j+k][1] = -total_spin + sum(h[s][j][k] * (J[3][i,s,k] + J[4][i,j,s]) for s in range(N))
  return(priorities)


#score: {'data3D.txt': -0.0009598000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += total_spin + abs(total_spin)
          priorities[i*N*j+k][1] -= total_spin - abs(total_spin)
        else:
          priorities[i*N*j+k][0] -= total_spin + abs(total_spin)
          priorities[i*N*j+k][1] = -total_spin - abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.002787800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[3]][site_nbrs[(d-1)%3]][site_nbrs[(d-2)%3]] * h[site_nbrs[d]][site_nbrs[(d-1)%3]][site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + abs(total_spin))
        else:
          priorities[i*N*j+k][1] = total_spin - abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.0021846000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[(d-2)%3]] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[(d-2)%3]] for d in range(6))
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + 1)
        else:
          priorities[i*N*j+k][1] = total_spin - 1
  return(priorities)


#score: {'data3D.txt': 0.080145}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0788418}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_spin[0] = sum([J[m,i,j,k] for m in range(6) if h[i][j][k] == h[site_nbrs[m]][j][k]])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0009593999999999936}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (h[i][j][k] == h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0025702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.00038260000000000057}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= total_spin + h[i][j][k]
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin)
          priorities[i*N*j+k][1] = total_spin - h[i][j][k]
  return(priorities)


#score: {'data3D.txt': 5.0200000000000576e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        spin_product = np.prod([h[i][j][k]*(-1)**(d==0) for d in range(6)])
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin + (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
          priorities[i*N*j+k][1] -= total_spin - (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin) + (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
          priorities[i*N*j+k][1] = total_spin - (spin_product/abs(spin_product)) * (h[i][j][k] > 0)
  return(priorities)


#score: {'data3D.txt': -0.002045}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i for d in range(6)]
        total_spin = sum(J[d][site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] * h[site_nbrs[d]][site_nbrs[d-1]%N, site_nbrs[d-2]%N] for d in range(6))
        if total_spin > 0:
          priorities[i*N*j+k][0] += -total_spin
          priorities[i*N*j+k][1] -= 2
        elif total_spin < 0:
          priorities[i*N*j+k][0] -= abs(total_spin)
          priorities[i*N*j+k][1] = -2
  return(priorities)


#score: {'data3D.txt': 0.038330199999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i < 3 else 1 if i == 5 else 0, axis=i % 3)
    interacting_spins += h
    priority_change = -J[i].flatten() * (np.where(interacting_spins.flatten() > h.flatten(), 1, -1) - 0.5*np.ones(len(h.flatten())))
    priorities += np.array([priority_change, -priority_change]).T.reshape(-1, 2)
  return priorities


#score: {'data3D.txt': 2.740000000000009e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = h.copy()
  
  for i in range(6):
    if i < 3:
      interacting_spins += np.roll(h, -1, axis=i % 3)
    else:
      interacting_spins += np.roll(h, 1, axis=(i-3) % 3)
      
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
        else:
          priorities[i,j,k][0] = -J[0,i,j,k]*interacting_spins[i,j,k] - h[i,j,k]
          priorities[i,j,k][1] = -J[5,i,j,k]*interacting_spins[i,j,k] + h[i,j,k]
          
  return priorities.reshape(-1,2)


#score: {'data3D.txt': -0.0263994}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0023117999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[(i*N+j)*N+k] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': 0.005466200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbrs.sort()
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0022966000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for site_nbr in site_nbrs:
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum(J[:,i,j,k])
          else:
            total_spin[0] -= sum(J[:,i,j,k])
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0009582}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            J_val = J[m,i,j,k]
          else:
            J_val = -J[m,i,j,k]
          total_spin[1] += J_val
        for m in range(3):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.001583000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m, i, j, k] for l in range(N)])
          else:
            total_spin[0] += sum([J[m, i, j, k] for l in range(N)])
        priorities[i*N+j*N+k] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': 0.005433399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priorities[(i*N+j)*N+k, 0] = -total_spin[1]
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 1] = total_spin[0] + total_spin[1]
        else:
          priorities[(i*N+j)*N+k, 1] = -(total_spin[0] + total_spin[1])
  return(priorities)


#score: {'data3D.txt': 0.0402838}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr_sum = sum([J[l,i,j,k] for l in range(6) if h[i][l][k] == h[site_nbrs[0]][l][k]])
        priorities[(i*N+j)*N+k] = [total_spin[1] + site_nbr_sum, -total_spin[0]]
  return(priorities)


#score: {'data3D.txt': 0.05210419999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m,i,j,k] for k in range(N)])
          else:
            total_spin[0] += sum([J[m,i,j,k] for k in range(N)])
        priority_total = np.zeros((N*N,2))
        if h[i][j][k] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] = -1
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[site_nbr][j][k] > 0:
            priority_total[i*N+j][0] += 1 + total_spin[1]
            priority_total[i*N+j][1] -= 1 - total_spin[1]
          else:
            priority_total[i*N+j][0] -= 1 + total_spin[1]
            priority_total[i*N+j][1] = -1 + total_spin[1]
        priorities[(i*N+j)*N+k] = [priority_total[i*N+j][0], -priority_total[i*N+j][1]]
  return(priorities)


#score: {'data3D.txt': -0.0228986}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.013903800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            priorities[i*N+j*N+k][0] += 1
            priorities[i*N+j*N+k][1] -= 1
          else:
            priorities[i*N+j*N+k][0] -= 1
            priorities[i*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.006854600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = site_nbrs[m]
          if np.all(h[i][j][:] == h[site_nbr][j][:]):
            total_spin[0] -= sum([J[m, i, j, k] for l in range(N)])
          else:
            total_spin[0] += sum([J[m, i, j, k] for l in range(N)])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0174594}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0223118}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0120214}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
        total_energy = np.sum(h)
        if total_energy > 0:
          for l in range(6):
            site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
        else:
          for l in range(6):
            site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
  return(priorities)


#score: {'data3D.txt': -0.0174594}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0174594}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N**2 + j*N+k][0] += 1
            priorities[i*N**2 + j*N+k][1] -= 1
          else:
            priorities[i*N**2 + j*N+k][0] -= 1
            priorities[i*N**2 + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N**2+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N**2+j*N+k][1] -= 2
          else:
            priorities[i*N**2+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N**2+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.11155740000000003}
program:
def priority(N, h, J):
  priorities = h.copy()
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l < 3:  # x-axis
            priorities[i,j,k] += -J[l,i,j,k]*(2*h[(i+1)%N,j,k]-h[(i-1)%N,j,k])
          elif l < 6:  # y-axis and z-axis
            priorities[i,j,k] += -J[l,i,j,k]*(2*h[i,(j+1)%N,k]-h[i,j,k]+2*h[i,j,(k+1)%N]-h[i,j,k])
  return np.array([priorities.flatten(), np.zeros(N**3)]).T


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(6):
    interacting_spins = np.roll(h, -1 if i<3 else 1, axis = i//3)
    interacting_spins = interacting_spins + h
    for j in range(N):
      for k in range(N):
        for l in range(N):
          priorities[j,k,l] += -J[i,j,k,l]*(2*interacting_spins[j,k,l]-1)
  return(priorities.reshape((N**3, 2)))


#score: {'data3D.txt': 0.09253659999999994}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities.append([-1 * sum(J[0:3, i, j, k]) + 1, -sum(J[3:, i, j, k]) - 1])
        else:
          priorities.append([sum(J[0:3, i, j, k]) + 1, -sum(J[3:, i, j, k]) + 1])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i * N * N + j * N + k
        total_spin = [0, 0]
        
        for l in range(6):
          if l < 3:
            total_spin[0] += h[i][j][k]
            total_spin[1] -= h[i][j][k]
          else:
            total_spin[0] -= h[i][j][k]
            total_spin[1] += h[i][j][k]

        for l in range(6):
          if l < 3:
            priorities[site_nbr][0] = -total_spin[0]
            priorities[site_nbr][1] = -total_spin[1]
          else:
            if J[l, i, j, k] > 0:
              priorities[site_nbr][0] = total_spin[0]
              priorities[site_nbr][1] = -total_spin[1]
            else:
              priorities[site_nbr][0] = -total_spin[0]
              priorities[site_nbr][1] = total_spin[1]

  return priorities


#score: {'data3D.txt': -0.07541339999999999}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities.append([-1*sum(J[l,i,j,k]*h[(i+n)%N][(j+m)%N][(k+p)%N] for l,n,m,p in [(0,1,0,0), (1,0,1,0), (2,0,0,1), (3,-1,0,0), (4,0,-1,0), (5,0,0,-1)]), 1])
        else:
          priorities.append([float('-inf'), -1*sum(J[l,i,j,k]*h[(i+n)%N][(j+m)%N][(k+p)%N] for l,n,m,p in [(0,1,0,0), (1,0,1,0), (2,0,0,1), (3,-1,0,0), (4,0,-1,0), (5,0,0,-1)])])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)    
  for i in range(N**3):
    site_nbrs = [(i // (N**2)) % N, (i % (N**2)) // N, i % N]
    total_spin = [0, 0]
    for m in range(6):
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[1] -= J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[1] += J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] -= J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[0] += J[m, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
    priorities[i] = [total_spin[0], total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0025702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        total_spin.sort()
        priorities[i*N+j+k%N] = [total_spin[1], -total_spin[0]]
  return(priorities)


#score: {'data3D.txt': -0.0017517999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0451562}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][1] += 2
        
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2
      
  return(priorities)


#score: {'data3D.txt': -0.0451562}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0048722}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  # Compute priorities for each site with magnetism > 0
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  # Compute priorities for each site with magnetism < 0
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] < 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0016166000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j].sum()
      if h[i][j].mean() > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= 3*total_spin
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += 3*total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] * (h[i][j] > 0) - (1-h[i][j]) * (h[i][j] <= 0)
        priorities[i*N+j*N+k][0] += (total_spin >= 0).sum() * 2
        priorities[i*N+j*N+k][1] -= (total_spin < 0).sum() * 2
  return(priorities)


#score: {'data3D.txt': -0.0095574}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.13726819999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        if all([h[site_nbrs[m]][j][k] > 0 for m in range(6)]):
          total_spin[1] -= sum([J[m,i,j,k] for m in range(6)])
        elif all([h[site_nbrs[m]][j][k] < 0 for m in range(6)]):
          total_spin[1] += sum([J[m,i,j,k] for m in range(6)])
        if h[i][j][k] > 0:
          priority_total = [total_spin[0], -total_spin[1]]
        else:
          priority_total = [-total_spin[0], total_spin[1]]
        priorities[i][j][k] = priority_total
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0263994}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        if all([h[s][j][k] > 0 for s in site_nbrs]):
          total_spin[1] -= sum([J[m,i,j,k] for m in range(6)])
        elif all([h[s][j][k] < 0 for s in site_nbrs]):
          total_spin[1] += sum([J[m,i,j,k] for m in range(6)])
        else:
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m,i,j,k]
            else:
              total_spin[1] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.019725799999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            if h[i][j][k] > 0:
              total_spin[0] += J[m,i,j,k]
            else:
              total_spin[0] -= J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.034100200000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0] - np.sum(J[:,i,j,k]), -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.28522020000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i * N * N + j * N + k
        total_spin = [0, 0]
        for l in range(6):
          if l < 3:
            total_spin[0] += h[i][j][k]
            total_spin[1] -= h[i][j][k]
          else:
            site_nbr2 = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr2][j][k] > 0:
              total_spin[0] += 1
              total_spin[1] -= 1
            else:
              total_spin[0] -= 1
              total_spin[1] += 1
        priorities[site_nbr][0] = -total_spin[0]
        priorities[site_nbr][1] = -total_spin[1]
  return priorities


#score: {'data3D.txt': -0.11626380000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i * N * N + j * N + k
        total_spin = [0, 0]
        
        for l in range(6):
          if l < 3:
            total_spin[0] += h[i][j][k]
            total_spin[1] -= h[i][j][k]
          else:
            site_nbr_l = i * N * N + (j+((l-1)%2 - 1)) % N + k
            if l < 3:
              total_spin[0] += h[int(site_nbr_l // N)][site_nbr_l % N][k]
              total_spin[1] -= h[int(site_nbr_l // N)][site_nbr_l % N][k]
            else:
              site_nbr_l = i * N * N + (j+((l-3)%2 - 1)) % N + k
              if l < 3:
                total_spin[0] -= h[int(site_nbr_l // N)][site_nbr_l % N][k]
                total_spin[1] += h[int(site_nbr_l // N)][site_nbr_l % N][k]
              else:
                site_nbr_l = i * N * N + j + (k+((l-4)%2 - 1)) % N
                if l < 3:
                  total_spin[0] -= h[i][j][int(site_nbr_l // N)]
                  total_spin[1] += h[i][j][int(site_nbr_l // N)]
                else:
                  site_nbr_l = i * N * N + j + (k+((l-5)%2 - 1)) % N
                  if l < 3:
                    total_spin[0] += h[i][j][int(site_nbr_l // N)]
                    total_spin[1] -= h[i][j][int(site_nbr_l // N)]

        for l in range(6):
          if J[l, i, j, k] > 0:
            priorities[site_nbr][0] = -total_spin[0]
            priorities[site_nbr][1] = -total_spin[1]
          else:
            priorities[site_nbr][0] = total_spin[0]
            priorities[site_nbr][1] = total_spin[1]

  return priorities


#score: {'data3D.txt': -0.0021538000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.0031962}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][0] > 0:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][0]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][0]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0014782000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        elif h[i][j][k] < 0:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[i][site_nbr][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        elif h[i][site_nbr][k] < 0:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        elif h[site_nbr][j][k] < 0:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.004089}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.005573000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.003985799999999941}
program:
def priority(N, h, J):
  total_spin = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1
  return(total_spin.flatten().reshape(N**3,2))


#score: {'data3D.txt': 0.011732199999999998}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbr[0],site_nbr[1],site_nbr[2]])
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          priorities.append([-total_spin + 1, -1])
        else:
          priorities.append([total_spin + 1, -1])
  return(np.array(priorities))


#score: {'data3D.txt': -0.0013662000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(3):
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.003733}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0012638}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(3):
          if h[site_nbr][j][l] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*k+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][1] -= 2*total_spin
        else:
          priorities[i*N+j*k+k][1] += 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.004180199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        total_spin[1] -= h[site_nbr][j][k]
      if np.mean(h[i].flatten()) > 0:
        priorities[i*N*N:i*N*N+N**2, 0] += total_spin[0]
        priorities[i*N*N:i*N*N+N**2, 1] -= 3*total_spin[1]
      else:
        priorities[i*N*N:i*N*N+N**2, 0] -= total_spin[0]
        priorities[i*N*N:i*N*N+N**2, 1] += 3*total_spin[1]
  return priorities


#score: {'data3D.txt': -0.0016166000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j].sum()
      
      if h[i][j].mean() > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= 3*total_spin
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += 3*total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0036366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin
          priorities[i*N+j*k+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin
          priorities[i*N+j*k+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0036366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin
          priorities[i*N+j*k+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin
          priorities[i*N+j*k+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0026610000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin[i*N+j*k+k][0]
          priorities[i*N+j*k+k][1] -= 1 - total_spin[i*N+j*k+k][0]
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin[i*N+j*k+k][0]
          priorities[i*N+j*k+k][1] = -1 + total_spin[i*N+j*k+k][0]

  return(priorities)


#score: {'data3D.txt': -0.0012394}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        for spin in [1, -1]:
          if h[i][j][k] * spin > 0:
            priorities[i][j][k][0] += total_spin_zeros
            priorities[i][j][k][1] -= total_spin_ones
          else:
            priorities[i][j][k][0] -= total_spin_zeros
            priorities[i][j][k][1] += total_spin_ones
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.16672620000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        priority_total = [total_spin_zeros, total_spin_ones]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[i][j][k] = [priority_total[0], priority_total[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0520462}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr][j][k] > 0 for site_nbr in site_nbrs])
        total_spin_zeros = 5 - total_spin_ones
        if h[i][j][k] > 0:
          priorities[i][j][k] = [total_spin_zeros, total_spin_ones]
        else:
          priorities[i][j][k] = [total_spin_ones, total_spin_zeros]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.004028600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Compute total spin for each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
  
  # Compute interaction sum for each site
  interaction_sum = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if J[l][site_nbr][j][k] > 0:
            interaction_sum[i*N+j*k+k][0] += J[l][site_nbr][j][k]
            interaction_sum[i*N+j*k+k][1] -= J[l][site_nbr][j][k]
          else:
            interaction_sum[i*N+j*k+k][0] -= J[l][site_nbr][j][k]
            interaction_sum[i*N+j*k+k][1] += J[l][site_nbr][j][k]
  
  # Combine total spin and interaction sum to get final priorities
  for i in range(N**3):
    if total_spin[i][0] > 0:
      priorities[i][0] += -total_spin[i][1] + interaction_sum[i][0]
      priorities[i][1] -= -total_spin[i][1] + interaction_sum[i][0]
    elif total_spin[i][0] < 0:
      priorities[i][0] -= -total_spin[i][1] + interaction_sum[i][0]
      priorities[i][1] += -total_spin[i][1] + interaction_sum[i][0]
  
  return(priorities)


#score: {'data3D.txt': -0.002058199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[0, i, j, k] == 1 and h[site_nbr_l][j][k]:
            total_spin += 1
          elif J[0, i, j, k] == -1 and not h[site_nbr_l][j][k]:
            total_spin -= 1
          
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[3, i, j, k] == 1 and h[i][site_nbr_l][k]:
            total_spin += 1
          elif J[3, i, j, k] == -1 and not h[i][site_nbr_l][k]:
            total_spin -= 1
          
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[4, i, j, k] == 1 and h[i][j][site_nbr_l]:
            total_spin += 1
          elif J[4, i, j, k] == -1 and not h[i][j][site_nbr_l]:
            total_spin -= 1
          
        for l in range(3):
          site_nbr_l = (i + ((l-1)%2 - 1)) % N
          if J[5, i, j, k] == 1 and h[i][j][site_nbr_l]:
            total_spin += 1
          elif J[5, i, j, k] == -1 and not h[i][j][site_nbr_l]:
            total_spin -= 1
          
        priorities[i*N+j*k+k][0] = total_spin
        priorities[i*N+j*k+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.004089}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.004089}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1
        else:
          total_spin[i*N+j*k+k][0] += h[site_nbr][j][k]
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j][k] > 0:
        total_spin[i*N+j*k+k][1] -= 1
      else:
        total_spin[i*N+j*k+k][1] += 1

  for i in range(N):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[i][j][k] > 0:
      total_spin[i*N+j*k+k][0] -= 1
    else:
      total_spin[i*N+j*k+k][0] += 1

  return(priorities)


#score: {'data3D.txt': 0.011732199999999998}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([-total_spin + 1, -1])
        else:
          priorities.append([total_spin + 1, -1])
  return(np.array(priorities))


#score: {'data3D.txt': -0.0016438}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.0016438}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j].sum() > 0:
        total_spin[i*N+j][0] += 1
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] -= 1
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][1] += 1
        else:
          total_spin[i*N+j*k+k][0] -= 1
          priorities[i*N+j*k+k][0] += 1
          priorities[i*N+j*k+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.0027994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [0, 1, 2]]
      total_spin = [h[s][j].sum() if s == i else 0 for s in site_nbrs]
      
      spin_counts = {1: sum(1 for t in total_spin if t > 0), -1: sum(1 for t in total_spin if t < 0)}
      priority_total = np.array([spin_counts.get(1, 0), spin_counts.get(-1, 0)])
      
      priorities[i*N+j][0] -= priority_total[1]
      priorities[i*N+j][1] += priority_total[0]
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] -= np.count_nonzero(h[site_nbr][j][k] < 0)
        else:
          priorities[i*N+j*N+k][0] -= np.count_nonzero(h[site_nbr][j][k] > 0)
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
  return(priorities)


#score: {'data3D.txt': 0.003175}
program:
def priority(N, h, J):
  total_spin = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1
  return(np.concatenate([np.sum(total_spin,axis=3),-np.sum(total_spin,axis=3)],axis=1).reshape(N**3,2))


#score: {'data3D.txt': 0.0013173999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0014245999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        if h[i][j][k] > 0:
          total_spin[1] += 1
        else:
          total_spin[1] -= 1
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin[0] += sum(J[:,i,j,k])
          else:
            total_spin[0] -= sum(J[:,i,j,k])
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[1] += sum(J[:,i,j,k])
          else:
            total_spin[1] -= sum(J[:,i,j,k])
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities.astype(int))


#score: {'data3D.txt': -0.0028362}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum(J[m,:,j,k])
          else:
            total_spin[0] -= sum(J[m,:,j,k])
        priorities[i*N+j+k%N] = [total_spin[0], total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0022966000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_0 = [0, 0]
        total_spin_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
          if h[i][j][k] == h[site_nbrs[m]][j][k]:
            if h[site_nbrs[m]][j][k] > 0:
              total_spin_0[1] -= J[m,i,j,k]
            else:
              total_spin_0[1] += J[m,i,j,k]
          elif h[i][j][k] > 0 and h[site_nbrs[m]][j][k] < 0:
            total_spin_0[1] -= J[m,i,j,k]
          elif h[i][j][k] < 0 and h[site_nbrs[m]][j][k] > 0:
            total_spin_0[1] += J[m,i,j,k]
        for site_nbr in site_nbrs:
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin_0[0] += sum(J[:,i,j,k])
          else:
            total_spin_0[0] -= sum(J[:,i,j,k])
        priorities[i*N+j+k%N] = [total_spin_0[0], total_spin_1[1]]
  return(priorities)


#score: {'data3D.txt': 0.0448086}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // (N ** 2)) % N, (i % (N ** 2)) // N, i % N]
    total_spin = [0, 0]
    for k in range(6):
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] == h[(site_nbrs[0] + ((k % 3) - 1)) % N][site_nbrs[1]][site_nbrs[2]]:
        total_spin[0] += J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[0] -= J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      if h[(site_nbrs[0] + ((k % 3) - 1)) % N][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[1] -= J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
      else:
        total_spin[1] += J[k, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
    priorities[i] = [total_spin[0], total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.013435800000000001}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + 1, -1])
        else:
          priorities.append([-total_spin + 1, -1])
  return(np.array(priorities))


#score: {'data3D.txt': -0.03930020000000002}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + 2, -3])
        else:
          priorities.append([-total_spin - 2, 3])
  return(np.array(priorities))


#score: {'data3D.txt': 0.0278966}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for _ in range(3)]
          total_spin[0] += np.sum([J[m,i,j,k] if h[n][j][k] == h[i][j][k] else -J[m,i,j,k] for n in site_nbrs])
          total_spin[1] += np.sum([J[m,i,j,k] if h[n][j][k] != h[i][j][k] else -J[m,i,j,k] for n in site_nbrs])
        priorities[i][j][k] = [total_spin[0], total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.034100200000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin[0] += J[m,i,j,k]
        priority = [total_spin[0] - np.sum(J[:,i,j,k]), -total_spin[1]]
        priorities[i][j][k] = priority
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.029593400000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        spin_count = sum([int(h[i][j][k]) for i in range(N) for j in range(N) for k in range(N)])
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] -= J[m,i,j,k]
          else:
            total_spin[0] += J[m,i,j,k]
        priorities[i][j][k] = [total_spin[0] - spin_count, -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0034062000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][jj][kk] for jj in range(N) for kk in range(N))
        if h[i][j][k] > 0:
          priorities[i*N+j*k+k][0] += 1 + total_spin
          priorities[i*N+j*k+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k+k][0] -= 1 + total_spin
          priorities[i*N+j*k+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0198606}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] += 2
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1
      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][0] -= J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.017322200000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          interacting_spin_counts += [np.sum(h[site_nbrs])]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += 1
            priorities[i*N*N + j*N+k][1] -= 1
          else:
            priorities[i*N*N + j*N+k][0] -= 1
            priorities[i*N*N + j*N+k][1] += 1
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (j-1)%N]
      interacting_spin_counts = [0]*6
      for l in range(2):
        if np.sum(h[site_nbrs[l]]) > 0:
          interacting_spin_counts[2*l] += 1
          interacting_spin_counts[2*l+1] -= 1
        else:
          interacting_spin_counts[2*l] -= 1
          interacting_spin_counts[2*l+1] += 1

      for l in range(6):
        site_nbrs = [(i+((l-1)%2 - 1))%N, j]
        if np.sum(h[site_nbrs]) > 0:
          priorities[i*N*N+j][0] += J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] -= 2
        else:
          priorities[i*N*N+j][0] -= J[l,i,j,k]*interacting_spin_counts[l]
          priorities[i*N*N+j][1] += 2

  return(priorities)


#score: {'data3D.txt': 0.1158998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, (j-1)%N, (k-1)%N]
        interacting_spin_counts = [0]*6
        for l in range(3):
          if np.sum(h[site_nbrs[l]]) > 0:
            interacting_spin_counts[2*l] += 1
            interacting_spin_counts[2*l+1] -= 1
          else:
            interacting_spin_counts[2*l] -= 1
            interacting_spin_counts[2*l+1] += 1
        for l in range(3):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j, k]
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N + j*N+k][0] += J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] -= 2
          else:
            priorities[i*N*N + j*N+k][0] -= J[l,i,j,k]*interacting_spin_counts[l]
            priorities[i*N*N + j*N+k][1] += 2
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1))%N, j,k]
          interacting_spin_counts = [0]*2
          for m in range(3):
            if np.sum(h[site_nbrs[m]]) > 0:
              interacting_spin_counts[0] += 1
              interacting_spin_counts[1] -= 1
            else:
              interacting_spin_counts[0] -= 1
              interacting_spin_counts[1] += 1
          if np.sum(h[site_nbrs]) > 0:
            priorities[i*N*N+j*N+k][0] += J[l,i,j,k]*np.dot(interacting_spin_counts, [1, -2])
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= J[l,i,j,k]*np.dot(interacting_spin_counts, [-1, 2])
            priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0051066}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0122874}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,(j+((i-1)%2 - 1)) % N,(k+((j-1)%2 - 1)) % N])
        if h[(i + ((k-1)%2 - 1)) % N][j][k] > 0:
          priorities.append([total_spin + 1, -1])
        else:
          priorities.append([-total_spin + 1, -1])
  return(np.array(priorities))


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + N**2, -1])
        else:
          priorities.append([-total_spin + N**2, -1])
  return(np.array(priorities))


#score: {'data3D.txt': 0.001118599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[max(0,i-1):min(i+2,N),max(0,j-1):min(j+2,N),max(0,k-1):min(k+2,N)]))
          priorities[i*N+j*N+k][1] -= 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[max(0,i-1):min(i+2,N),max(0,j-1):min(j+2,N),max(0,k-1):min(k+2,N)]))
          priorities[i*N+j*N+k][1] += 4
  
  return(priorities)


#score: {'data3D.txt': 0.0006769999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[max(i-1,0):i+3, max(j-1,0):j+3, k]))
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[max(i-1,0):i+3, max(j-1,0):j+3, k]))
          priorities[i*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.008434200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k])
        
        # Calculate the priority based on the magnetism and interactions
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) + total_spin
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - total_spin
          priorities[i*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.4195346000000001}
program:
def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins = np.array([interacting_spins_x, interacting_spins_y, interacting_spins_z])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 3 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[0][i,j,k]
          elif l % 3 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[1][i,j,k]
          else:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[2][i,j,k]
  
  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)


#score: {'data3D.txt': -0.4195346000000001}
program:
def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 3 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_x[i,j,k]
          elif l % 3 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_y[i,j,k]
          else:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_z[i,j,k]
  
  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)


#score: {'data3D.txt': -0.41692540000000006}
program:
def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xy = np.roll(np.roll(h, -1, axis=0), -1, axis=1)
  interacting_spins_xz = np.roll(np.roll(h, -1, axis=0), 1, axis=2)
  interacting_spins_yz = np.roll(np.roll(h, -1, axis=1), -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 4 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_x[i,j,k]
          elif l % 4 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_y[i,j,k]
          elif l % 4 == 2:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_z[i,j,k]
          else:
            if l % 4 == 3:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xy[i,j,k]
            elif l % 4 == 4:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xz[i,j,k]
            else:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_yz[i,j,k]

  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)


#score: {'data3D.txt': 0.034988199999999935}
program:
def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 3 == 0:
            priorities[i,j,k] += J[l,i,j,k]*(interacting_spins_x[i,j,k] - h[i,j,k])
          elif l % 3 == 1:
            priorities[i,j,k] += J[l,i,j,k]*(interacting_spins_y[i,j,k] - h[i,j,k])
          else:
            priorities[i,j,k] += J[l,i,j,k]*(interacting_spins_z[i,j,k] - h[i,j,k])

  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)


#score: {'data3D.txt': -0.04052860000000001}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = sum(J[:,site_nbrs[0],site_nbrs[1],site_nbrs[2]])
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities.append([total_spin + 4, -5])
        else:
          priorities.append([-total_spin - 4, 5])
  return(np.array(priorities))


#score: {'data3D.txt': -0.3383045999999997}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
          total_spin += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities.append([total_spin + 2, -3])
        else:
          priorities.append([-total_spin - 2, 3])
  return(np.array(priorities))


#score: {'data3D.txt': 0.0428734}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
          if (i == site_nbrs[m] or j == site_nbrs[m] or k == site_nbrs[m]):
            total_spin_1[0] += J[m,i,j,k]
            total_spin_minus_1[0] -= J[m,i,j,k]
        priority = [total_spin_1[0], -total_spin_1[1]]
        if np.prod(total_spin_1) > 0:
          priorities[i][j][k] = priority
        else:
          priorities[i][j][k] = [-priority[0], -priority[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.2712526000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for _ in range(3)]
          if np.all([h[site_nbr][j][k] > 0 for site_nbr in site_nbrs]):
            total_spin_1[1] -= J[m,i,j,k]
          elif np.any([h[site_nbr][j][k] < 0 for site_nbr in site_nbrs]):
            total_spin_minus_1[1] += J[m,i,j,k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i][j][k] = priority
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0229374}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
        priority = [total_spin_1[0] - np.sum(J[:,i,j,k]), -total_spin_1[1]] if h[i][j][k] > 0 else [-total_spin_minus_1[0], total_spin_minus_1[1]]
        priorities[i][j][k] = priority
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m,i,j,k]
            total_spin_minus_1[1] += J[m,i,j,k]
          else:
            total_spin_1[1] += J[m,i,j,k]
            total_spin_minus_1[1] -= J[m,i,j,k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = [total_spin_1[0] + total_spin_1[1], total_spin_minus_1[0] - total_spin_minus_1[1]]
        else:
          priority_total = [-total_spin_1[0] - total_spin_1[1], -total_spin_minus_1[0] + total_spin_minus_1[1]]
        priorities[i][j][k] = priority_total
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.125719}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1)%3) - 1) % N
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = sum([J[m,i,j,k] for m in range(6)]) + total_spin[1]
          priorities[(i*N+j)*N+k, 1] = -total_spin[0]
        else:
          priorities[(i*N+j)*N+k, 0] = -sum([J[m,i,j,k] for m in range(6)]) - total_spin[1]
          priorities[(i*N+j)*N+k, 1] = total_spin[0]
  return(priorities)


#score: {'data3D.txt': 0.0636342}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        total_energy = sum([J[m,i,j,k] for m in range(6)])
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = -total_spin[1]
          priorities[(i*N+j)*N+k, 1] = total_energy
        else:
          priorities[(i*N+j)*N+k, 0] = -(-total_spin[1])
          priorities[(i*N+j)*N+k, 1] = -total_energy
  return(priorities)


#score: {'data3D.txt': 0.00017540000000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        priorities[i*N+j*N+k, 0] = -total_spin[1]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k, 1] = total_spin[0] + total_spin[1]
        else:
          priorities[i*N+j*N+k, 1] = -(total_spin[0] + total_spin[1])
  return(priorities)


#score: {'data3D.txt': -0.005784200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[0] += 2
          total_spin[1] -= 3
        else:
          total_spin[0] -= 2
          total_spin[1] += 3
      priorities[i*N*N:i*N*N+N**2, 0] = total_spin[0]
      priorities[i*N*N:i*N*N+N**2, 1] = total_spin[1]
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N**3):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N, (i%N)//N]
    total_spin = [0, 0]
    for k in range(6):
      if h[site_nbrs[0]][site_nbrs[1]][k] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities.append([total_spin[0], -total_spin[1]])
  return np.array(priorities)


#score: {'data3D.txt': -0.00010980000000000057}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+k, 0] = total_spin[0]
          priorities[i*N*N+k, 1] = -total_spin[1] + np.mean(h[i].flatten())
        else:
          priorities[i*N*N+k, 0] = -total_spin[0]
          priorities[i*N*N+k, 1] = total_spin[1] + np.mean(h[i].flatten())
  return priorities


#score: {'data3D.txt': -0.001757}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        for l in [0, 1, 2]:
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= 3*total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += 3*total_spin[1]
  return priorities


#score: {'data3D.txt': 0.007909000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        
        # Calculate the priority based on the magnetism and interactions
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) + 1
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - 1
          priorities[i*N+j*N+k][1] += 3
        
  return(priorities)


#score: {'data3D.txt': -0.0040846}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[(i + ((k-1)%2 - 1)) % N][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.098221}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] -= J[m,i,j,k]
          else:
            total_spin[0] += J[m,i,j,k]
        priority = [total_spin[0], -total_spin[1]]
        if np.allclose(total_spin, [0, 0]):
          priorities[i][j][k] = [0, 0]
        elif total_spin[0] > total_spin[1]:
          priorities[i][j][k] = [1, 0]
        else:
          priorities[i][j][k] = [0, 1]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': 0.0859046}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        if sum([h[i][l][k] > 0 for l in range(N)]) > N//2:
          total_spin[0] = -sum([h[i][j][k] > 0 for j in range(N)])
        else:
          total_spin[0] = sum([h[i][j][k] > 0 for j in range(N)])
        priorities[i][j][k] = [total_spin[0], -total_spin[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.002517}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbr = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbr[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
      priorities[i*N+j] = [total_spin[0], -total_spin[1]]
  return(priorities.astype(int))


#score: {'data3D.txt': -0.002407}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          total_spin[0] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + total_spin[1], -total_spin[1]]
        else:
          priority = [-total_spin[0] - total_spin[1], total_spin[1]]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0018638000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          site_nbr = site_nbrs[m // 2]
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + 1, -total_spin[1] - 1]
        else:
          priority = [-total_spin[0] - 1, total_spin[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0020498000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = priority[1]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.41692540000000006}
program:
def priority(N, h, J):
  priorities = h.copy()
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xy = np.roll(np.roll(h, -1, axis=0), -1, axis=1)
  interacting_spins_xz = np.roll(np.roll(h, -1, axis=0), 1, axis=2)
  interacting_spins_yz = np.roll(np.roll(h, -1, axis=1), -1, axis=2)

  interacting_spins_xyz = np.roll(np.roll(h, -1, axis=0), -1, axis=1)[:, :, None] * np.roll(h, 1, axis=2)[None, :, :]
  interacting_spins_xzy = np.roll(np.roll(h, -1, axis=0), 1, axis=2)[:, None, :] * np.roll(h, -1, axis=1)[None, :, :]
  interacting_spins_yxz = np.roll(np.roll(h, -1, axis=1), -1, axis=0)[None, :, :] * np.roll(h, 1, axis=2)[None, :, :]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if l % 4 == 0:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_x[i,j,k]
          elif l % 4 == 1:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_y[i,j,k]
          elif l % 4 == 2:
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_z[i,j,k]
          else:
            if l % 4 == 3:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xy[i,j,k]
            elif l % 4 == 4:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_xz[i,j,k]
            else:
              priorities[i,j,k] += -J[l,i,j,k]*interacting_spins_yz[i,j,k]

  return(np.array([priorities.flatten(), np.zeros(N**3)]).T)


#score: {'data3D.txt': -0.0037614000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xy = np.roll(np.roll(h, -1, axis=0), -1, axis=1)
  interacting_spins_xz = np.roll(np.roll(h, -1, axis=0), 1, axis=2)
  interacting_spins_yz = np.roll(np.roll(h, -1, axis=1), -1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0014729999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0015286}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin_1[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin_minus_1[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin_minus_1[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0023898}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs_x = [(i + ((m % 3) - 1)) % N for m in range(6)]
        site_nbrs_yz = [(j + ((m // 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs_x[m//2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          if h[i][site_nbrs_yz[m%3]][k] > 0:
            total_spin[0] -= J[m, i, j, k]
          else:
            total_spin[0] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + 1, -total_spin[1] - 1]
        else:
          priority = [-total_spin[0] - 1, total_spin[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0014729999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m//2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': 0.0636342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k, 0] = -total_spin[1]
          priorities[i*N**2 + j*N + k, 1] = sum([J[l, i, j, k] for l in range(6)])
        else:
          priorities[i*N**2 + j*N + k, 0] = -(-total_spin[1])
          priorities[i*N**2 + j*N + k, 1] = -sum([J[l, i, j, k] for l in range(6)])
  return(priorities)


#score: {'data3D.txt': 0.0636342}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_energy = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = -total_spin[1]
          priorities[(i*N+j)*N+k, 1] = total_energy
        else:
          priorities[(i*N+j)*N+k, 0] = -(-total_spin[1])
          priorities[(i*N+j)*N+k, 1] = -total_energy
  return(priorities)


#score: {'data3D.txt': 0.0439306}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr_energy = sum([J[l, i, j, k] for l in range(6) if h[i][j][k] == h[site_nbrs[l]][j][k]])
        if h[i][j][k] > 0:
          priorities[(i*N+j)*N+k, 0] = -total_spin[1]
          priorities[(i*N+j)*N+k, 1] = site_nbr_energy
        else:
          priorities[(i*N+j)*N+k, 0] = -(-total_spin[1])
          priorities[(i*N+j)*N+k, 1] = -site_nbr_energy
  return(priorities)


#score: {'data3D.txt': -0.0095574}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.0018969999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,i,site_nbr,k]) + h[i][site_nbr][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[i][site_nbr][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  total_spin = np.zeros((N,N,N))
  for k in range(N):
    site_nbr = (k + ((k-1)%2 - 1)) % N
    for j in range(N):
      for i in range(N):
        total_spin[i][j] += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0053774}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        for l in range(3):
          site = (i + ((l-1)%2 - 1)) % N
          if J[l, i, j, k] > 0:
            total_spin += h[site][j]
          else:
            total_spin -= h[site][j]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        if J[4, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0014729999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = np.sum(np.array([priority[0], priority[1]]))
  return(priorities)


#score: {'data3D.txt': -0.0023662}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if sum(total_spin_1) + h[i][j][k] > 0:
          priority = [sum(total_spin_1) + 1, -sum(total_spin_minus_1) - 1]
        else:
          priority = [-sum(total_spin_minus_1) - 1, sum(total_spin_1) + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0025417999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        for m in range(6):
          if h[i][site_nbrs[m // 2]][k] > 0:
            total_spin_1[0] -= J[m, i, site_nbrs[m // 2], k]
          else:
            total_spin_minus_1[0] += J[m, i, site_nbrs[m // 2], k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + 1, -total_spin_1[1] - 1]
        else:
          priority = [-total_spin_minus_1[0] - 1, total_spin_minus_1[1] + 1]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.002445400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      if total_spin > 0:
        priorities[i][0] += -1
        priorities[i][1] -= 1
      elif total_spin < 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.0012197999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4
  return(priorities)


#score: {'data3D.txt': -0.0023002}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          total_spin += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities.append([total_spin, -1])
        else:
          total_spin -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities.append([-total_spin, 1])
  return(np.array(priorities))


#score: {'data3D.txt': -0.11218379999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin[1] += J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
          else:
            total_spin[1] -= J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
        for site_nbr in site_nbrs:
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
          else:
            total_spin[0] -= J[(site_nbrs.index(site_nbr)+1)//3, i,j,k]
        priority_total = [total_spin[0], -total_spin[1]]
        priorities[i][j][k] = [priority_total[0], priority_total[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.0015286}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_1 = [0, 0]
        total_spin_minus_1 = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin_1[1] -= J[m, i, j, k]
          else:
            total_spin_minus_1[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin_1[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin_1[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin_minus_1[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin_minus_1[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0020142000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), -total_spin[1] - sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        else:
          priority = [-total_spin[0] - sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]), total_spin[1] + sum([-1 if h[site_nbr][j][k] < 0 else 1 for site_nbr in site_nbrs])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= 3*total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += 3*total_spin[1]
  return priorities


#score: {'data3D.txt': -0.0024006000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        for m in range(6):
          site_nbr = site_nbrs[m % 3]
          if h[i][j][k] == h[site_nbr][j][k]:
            total_spin[0] += sum([J[m, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]])
          else:
            total_spin[0] -= sum([J[m, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])
        if h[i][j][k] > 0:
          priority = [total_spin[0] + total_spin[1], -total_spin[0]]
        else:
          priority = [-total_spin[0], total_spin[0] + total_spin[1]]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0014698000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m // 2]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        priority = [total_spin[0], -total_spin[1]]
        if h[i][j][k] > 0:
          priorities[i*N+j+k] = [priority[0] + 1, -(priority[1] + 1)]
        else:
          priorities[i*N+j+k] = [-priority[0] - 1, priority[1] + 1]
  return(priorities)


#score: {'data3D.txt': -0.001563}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          site_nbr = site_nbrs[m // 2]
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        if h[i][j][k] > 0:
          priority = [total_spin[0] + sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]]), 
                 -total_spin[1] - sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])]
        else:
          priority = [-total_spin[0] - sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] == h[i][j][k]]), 
                 total_spin[1] + sum([J[n, i, j, k] for n in range(6) if h[(i + ((n % 3) - 1)) % N][j][k] != h[i][j][k]])]
        priorities[i*N+j+k, 0] = priority[0]
        priorities[i*N+j+k, 1] = -priority[1]
  return(priorities)


#score: {'data3D.txt': -0.0019866000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if any(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0036690000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.005709400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbr][j][k] > 0 for site_nbr in site_nbrs])
        total_spin_zeros = 5 - total_spin_ones
        priority_total = [total_spin_zeros, total_spin_ones]
        for m in range(6):
          if h[(i + ((m % 3) - 1)) % N][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[i*N+j*N+k] = [priority_total[0], priority_total[1]]
  return(priorities.reshape(N**3,2).astype(int))


#score: {'data3D.txt': -0.16672620000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbrs[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        if h[i][j][k] > 0:
          priority_total = [total_spin_zeros, total_spin_ones]
        else:
          priority_total = [-total_spin_zeros, -total_spin_ones]
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[(i*N+j)*N+k] = [priority_total[0], priority_total[1]]
  return(priorities.astype(int))


#score: {'data3D.txt': -0.1073042}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin_ones = sum([h[site_nbrs[m]][j][k] > 0 for m in range(6)])
        total_spin_zeros = 5 - total_spin_ones
        site_nbr_sum = sum([J[l,i,j,k] * (2*h[i][l][k]-1) for l in range(6)])
        priorities[(i*N+j)*N+k] = [total_spin_zeros + site_nbr_sum, -total_spin_ones]
  return(priorities)


#score: {'data3D.txt': -0.002445400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
    else:
      if total_spin > N**3/2:
        priorities[i][1] -= 1
      elif total_spin < -N**3/2:
        priorities[i][0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0022646000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1
      priorities[i][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0038998000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          if J[0, site_nbr, j, k] > 0:
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][1] += 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          if J[0, site_nbr, j, k] > 0:
            priorities[i*N+j*N+k][1] += 4
          else:
            priorities[i*N+j*N+k][1] -= 4
  return(priorities)


#score: {'data3D.txt': 0.004780200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
  return(priorities)


#score: {'data3D.txt': 0.003477}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 4
          site_nbr = (j + ((k-1)%2 - 1)) % N
          total_spin += sum(J[:,site_nbr,i,k]) + h[site_nbr][i][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 4
          site_nbr = (j + ((k-1)%2 - 1)) % N
          total_spin = sum(J[:,site_nbr,i,k]) + h[site_nbr][i][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
          if total_spin > 0:
            priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] -= 4
          else:
            priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(np.abs(h[(i+1)%N:i+2, j:j+2, k:k+2]))
            priorities[i*N+j*N+k][1] += 4
  return(priorities)


#score: {'data3D.txt': 0.0034509999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k]) + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] -= 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] += 4 + (np.sum(J[:,site_nbr,j,k]) > 0)
  return(priorities)


#score: {'data3D.txt': -0.004623399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += 3*total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= 3*total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
  return priorities


#score: {'data3D.txt': -0.0025702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0023790000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N, (j + ((m // 3) % 2 - 1)) % N, (k + ((m // 1) % 2 - 1)) % N]
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0025106}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          total_spin[0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0016273999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0022409999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.04480420000000002}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(6):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities.append([total_spin[0] + 4 * (h[i].flatten().sum() + h[j].flatten().sum() + h[k].flatten().sum()), -5])
        else:
          priorities.append([-total_spin[0] - 4 * (h[i].flatten().sum() + h[j].flatten().sum() + h[k].flatten().sum()), 5])
  return(np.array(priorities))


#score: {'data3D.txt': -0.0346446}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities.append([total_spin[0] + np.mean(h[i].flatten()), -total_spin[1]])
        else:
          priorities.append([-total_spin[0] + np.mean(h[i].flatten()), total_spin[1]])
  return(np.array(priorities))


#score: {'data3D.txt': -0.0040846}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0038401999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        else:
          priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0031982000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] += len([m for m in site_magnetisms if m < 0])
        else:
          priorities[i*N+j+k][0] += sum(m for m in site_magnetisms)
          priorities[i*N+j+k][1] = -sum(m for m in site_magnetisms)

  return(priorities)


#score: {'data3D.txt': -0.0026246000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[0]][j][k] > 0)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.002271000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        total_spin[0] += h[i][j][k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0025354}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] if h[site_nbrs[m]][j][k] > 0 else -h[site_nbrs[m]][j][k])
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.002603400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[0]][j][k] > 0) * (-1 if m%2==0 else 1)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0022078000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0032094000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N, j, k]
          if h[site_nbrs[0]][j][k] > 0:
            total_spin[1] += J[m,i,j,k]
          else:
            total_spin[1] -= J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[0]][j][k] > 0)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0016273999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[1], -total_spin[0]]
  return(priorities)


#score: {'data3D.txt': -0.0059162}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*N+k][1] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
        else:
          total_spin[i*N+j*N+k][1] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
  return(total_spin)


#score: {'data3D.txt': 0.0013173999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for d in range(3):
    for i in range(1,N):
      interacting_spins[d] = np.where(np.arange(N) == (i + ((np.arange(N) - 1) % 2 - 1)) % N, h, interacting_spins[d])
      interacting_spins[3+d] = np.where(np.arange(N) == (i - ((np.arange(N) - 1) % 2 - 1)) % N, h, interacting_spins[3+d])
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,j,k]) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2]))
          priorities[i*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.3049978000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(np.abs(interacting_spins[0,i,j,k])) + \
                      np.sum(np.abs(interacting_spins[3,i,j,k]))
          total_spin[i][j][k][1] -= 2
        else:
          total_spin[i][j][k][0] -= np.sum(np.abs(interacting_spins[0,i,j,k])) + \
                      np.sum(np.abs(interacting_spins[3,i,j,k]))
          total_spin[i][j][k][1] += 2
  
  return(total_spin.flatten().reshape(N**3,2))


#score: {'data3D.txt': -0.002445400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0001225999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms)

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if total_spin > 0:
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif total_spin < 0:
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += -1 * len([m for m in site_magnetisms if m < 0])
  return(priorities)


#score: {'data3D.txt': -0.002445400000000001}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][1] += -sum(1 for _ in site_magnetisms if _ > 0)
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= sum(1 for _ in site_magnetisms if _ < 0)
    else:
      if total_spin > 0:
        priorities[i][1] += -sum(1 for _ in site_magnetisms if _ > 0)
      elif total_spin < 0:
        priorities[i][0] -= sum(1 for _ in site_magnetisms if _ < 0)

  return(priorities)


#score: {'data3D.txt': -0.20221180000000022}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
        if h[site_nbr_x][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[0,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[0,i,j,k]
        
        if h[i][site_nbr_y][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[1,i,j,k]
        
        if h[i][j][site_nbr_z] > 0:
          priorities[i*N*N+j*N+k][0] += J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[2,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': -0.001835}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)

  site_interactions = []
  for k in range(N):
    site_interactions.append([])
    for j in range(N):
      site_interactions[k].append([])
      for i in range(N):
        total_spin = [0, 0]
        for m in range(6):
          if h[(i + ((m % 3) - 1)) % N][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -J[m,i,j,k]*interacting_spins[m,i,j,k]
        site_interactions[k][j].append(total_spin)
  for k in range(N):
    for j in range(N):
      priorities[k*N+j] = [np.prod([x[0] for x in site_interactions[k][j]]), np.prod([x[1] for x in site_interactions[k][j]])]
  return(priorities)


#score: {'data3D.txt': -0.0027434000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0025106}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          total_spin[0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0018174000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[m]][j][k]):
            total_spin[0] += J[m,i,j,k]
          else:
            total_spin[0] -= J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022321999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[l]][j][k]):
            if h[i][j][k] > 0:
              total_spin[0] -= J[l,i,j,k]
            else:
              total_spin[0] += J[l,i,j,k]
          else:
            if h[i][j][k] > 0:
              total_spin[0] += J[l,i,j,k]
            else:
              total_spin[0] -= J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0008797999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          site = site_nbrs[l]
          if abs(h[i][j][k]) == abs(h[site][j][k]):
            total_spin[0] += 2*J[l,i,j,k]
          elif h[i][j][k] * h[site][j][k] > 0:
            total_spin[0] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.20221180000000022}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        
        if h[site_nbr_x][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[0,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[0,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[0,i,j,k]
        
        if h[i][site_nbr_y][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[1,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[1,i,j,k]
        
        if h[i][j][site_nbr_z] > 0:
          priorities[i*N*N+j*N+k][0] += J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[2,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[2,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.0022534000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0025434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 2 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 2 + total_spin[0]
          priorities[i*N+j+k%N][1] = -2 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022534000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017062000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priorities[i*N+j+k%N][0] = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        priorities[i*N+j+k%N][1] = -np.sum([x if h[i][j][k] < 0 else -x for x in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.0006694000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,j,k]) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - total_spin
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) + total_spin
          priorities[i*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -6.26000000000006e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[:,(i + ((k-1)%2 - 1)) % N,j,k]) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(J[:,(i + (k%2 - 1)) % N,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+2, j:j+2, k:k+2])) - np.sum(J[:,(i + (k%2 - 1)) % N,j,k])
          priorities[i*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.00010980000000000057}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs.append([(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N])
          total_spin[0] += J[l, site_nbrs[l][0], site_nbrs[l][1], site_nbrs[l][2]]
          total_spin[1] -= J[l, site_nbrs[l][0], site_nbrs[l][1], site_nbrs[l][2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+k, 0] = total_spin[0]
          priorities[i*N*N+k, 1] = -total_spin[1] + np.mean(h[i].flatten())
        else:
          priorities[i*N*N+k, 0] = -total_spin[0]
          priorities[i*N*N+k, 1] = total_spin[1] + np.mean(h[i].flatten())
  return priorities


#score: {'data3D.txt': -0.0015778}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        J_sum = sum(J[:,site_nbrs[0], site_nbrs[1], site_nbrs[2]])
        h_val = h[i][j][k]
        if h_val > 0:
          priorities[i*N*N+k, 0] = J_sum + np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N*N+k, 1] = -J_sum + h_val
        else:
          priorities[i*N*N+k, 0] = -J_sum - np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) + np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N*N+k, 1] = J_sum - h_val
  return priorities


#score: {'data3D.txt': -0.0105946}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] -= 4 + (total_spin > 0)
        else:
          priorities[i*N+j*N+k][0] -= np.sum(np.abs(h[i:i+3, j:j+3, k:k+3])) - np.sum(np.abs(h[(i+1)%N:(i+2), j:j+3, k:k+3]))
          priorities[i*N+j*N+k][1] += 4 + (total_spin > 0)
  return(priorities)


#score: {'data3D.txt': -0.0022534000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + sum(interacting_spins)
          priorities[i*N+j+k%N][1] -= 1 - sum(total_spin[1:])
        else:
          priorities[i*N+j+k%N][0] -= 1 + sum(interacting_spins)
          priorities[i*N+j+k%N][1] = -1 + sum(total_spin[1:])
  return(priorities)


#score: {'data3D.txt': -0.0024482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 2 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 2 * total_spin[0]
          priorities[i*N+j+k%N][1] = -2 * total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.005795399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0016385999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((3-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += sum(total_spin[0] for _ in range(6))
          priorities[i*N+j+k%N][1] -= sum(total_spin[1] for _ in range(6))
        else:
          priorities[i*N+j+k%N][0] -= sum(total_spin[0] for _ in range(6))
          priorities[i*N+j+k%N][1] = -sum(total_spin[1] for _ in range(6))
  return(priorities)


#score: {'data3D.txt': -0.0018797999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        magnetism = h[i][j][k]
        for m in range(6):
          total_spin[0] += J[m,i,j,k] * (h[site_nbrs[m]][j][k] > 0)
          total_spin[1] -= J[m,i,j,k] * (h[site_nbrs[m]][j][k] < 0)
        if magnetism > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0016385999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0013794000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.07869580000000002}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority = np.tanh(-total_spin)
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[site_nbr_x][j][k]
        for x in range(3):
          if J[x, i, j, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if J[y, i, site_nbr_y, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if J[z, site_nbr_x, j, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.33024339999999974}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][j][0]
      if h[i][j][0] > 0:
        priorities[i*N*N+j][0] += 1
        priorities[i*N*N+j][1] -= 1
      else:
        priorities[i*N*N+j][0] -= 1
        priorities[i*N*N+j][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0001225999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] = sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms)
  return(priorities)


#score: {'data3D.txt': -0.0001225999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      spin = -1 if sum(m for m in site_magnetisms) > 0 else 1
      priorities[i][0] += total_spin
      priorities[i][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += np.sum(total_spin)
          priorities[i*N*N + j + k, 1] -= np.prod(np.array([3, 1])) * total_spin[1]
        else:
          priorities[i*N*N + j + k, 0] -= np.sum(total_spin)
          priorities[i*N*N + j + k, 1] += np.prod(np.array([3, 1])) * total_spin[1]
  return priorities


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)


#score: {'data3D.txt': 0.0019558}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          priorities[i*N*N + j + k, 0] += J[l, site_nbr, j, k]
          priorities[i*N*N + j + k, 1] -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin
          priorities[i*N*N + j + k, 1] -= total_spin * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin
          priorities[i*N*N + j + k, 1] += total_spin * 3
  return priorities


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)


#score: {'data3D.txt': -0.005795399999999999}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    total_spin = sum([h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs])
    
    if all(m > 0 for m in [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]):
      priorities[k][0] -= 1
      priorities[k][1] += 1
    
  return(priorities)


#score: {'data3D.txt': -0.005795399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.012296600000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        magnetism = h[i][j][k]

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

        total_spin = 0

        for x in range(N):
          if h[x][j][k] > 0:
            total_spin += J[0, i, j, k]
          else:
            total_spin -= J[0, i, j, k]

        for y in range(N):
          if h[i][y][k] > 0:
            total_spin += J[1, i, j, k]
          else:
            total_spin -= J[1, i, j, k]

        for z in range(N):
          if h[i][j][z] > 0:
            total_spin += J[2, i, j, k]
          else:
            total_spin -= J[2, i, j, k]

        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0041618}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += len([m for m in site_magnetisms if m < 0])
        else:
          site_spin = sum(m > 0 for m in site_magnetisms) - sum(m < 0 for m in site_magnetisms)
          priorities[i*N+j+k][0] -= site_spin
          priorities[i*N+j+k][1] += abs(site_spin)
  return(priorities)


#score: {'data3D.txt': -0.0027174000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1 + total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] = -1 - total_spin
        else:
          if any(m > 0 for m in site_magnetisms):
            priorities[i*N+j+k][0] += -1 + (len([m for m in site_magnetisms if m > 0]))
            priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
          else:
            priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
            priorities[i*N+j+k][1] += 1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0032998000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0])
        else:
          priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
  return(priorities)


#score: {'data3D.txt': -0.0028774}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in range(6)]])
        if h[i][j][k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        for p in range(6):
          site_nbr = (i + ((p-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k][0] -= total_spin
            priorities[i*N+j+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.07869580000000002}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority_x = np.tanh(-total_spin)
        priorities[i*N*N+j*N+k][0] = -priority_x
        priorities[i*N*N+j*N+k][1] = priority_x
        
  return(priorities)


#score: {'data3D.txt': -0.07869580000000002}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for x in range(3):
          if interacting_spins_x[x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if interacting_spins_y[i][y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in range(3):
          if interacting_spins_z[i][j][z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priority = np.tanh(-total_spin)
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)


#score: {'data3D.txt': -0.24526700000000007}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        for x in range(3):
          if J[x, i, j, k] > 0:
            site_interactions[i][j][k] += 1
          else:
            site_interactions[i][j][k] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)


#score: {'data3D.txt': -0.0030110000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if total_spin > 0:
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif total_spin < 0:
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      priorities[i][0] = -sum(m for m in site_magnetisms)
      priorities[i][1] = sum(m for m in site_magnetisms)

  return(priorities)


#score: {'data3D.txt': -0.0001225999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][(i // (N//3)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += len([m for m in site_magnetisms if m < 0])
    else:
      total_spin = sum((site_magnetisms[j-1] + site_magnetisms[(j+1)%6]) / 2.0 for j in range(6))
      priorities[i][0] += -total_spin
      priorities[i][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  total_spin = np.zeros((N, N, N, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        magnetism = h[i][j][k]
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        if magnetism > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] = total_spin[i][j][k][0]
        priorities[i*N*N+j*N+k][1] = -total_spin[i][j][k][1]

  return(priorities)


#score: {'data3D.txt': -0.34395820000000016}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N

        magnetism = h[i][j][k]

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum(J[0, x, j, k] for x in range(N))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[0, x, j, k] for x in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum(J[0, x, j, k] for x in range(N))
          priorities[i*N*N+j*N+k][1] += -1 + sum(J[0, x, j, k] for x in range(N))

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum(J[1, i, y, k] for y in range(N))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[1, i, y, k] for y in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum(J[1, i, y, k] for y in range(N))
          priorities[i*N*N+j*N+k][1] += -1 + sum(J[1, i, y, k] for y in range(N))

        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum(J[2, i, j, z] for z in range(N))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[2, i, j, z] for z in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum(J[2, i, j, z] for z in range(N))
          priorities[i*N*N+j*N+k][1] += -1 + sum(J[2, i, j, z] for z in range(N))

  return(priorities)


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][i][k] > 0:
        priorities[i*N*N + j + k, 0] += total_spin[0]
        priorities[i*N*N + j + k, 1] -= total_spin[1]
      else:
        priorities[i*N*N + j + k, 0] -= total_spin[0]
        priorities[i*N*N + j + k, 1] += total_spin[1]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[i][j][site_nbr] > 0:
        priorities[i*N*N + j + k, 0] += total_spin[0]
        priorities[i*N*N + j + k, 1] -= total_spin[1]
      else:
        priorities[i*N*N + j + k, 0] -= total_spin[0]
        priorities[i*N*N + j + k, 1] += total_spin[1]

  return priorities


#score: {'data3D.txt': -0.0013142}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j+((i-1)%2 - 1)) % N, (k+((j-1)%2 - 1)) % N]
        total_spin = [0, 0]
        
        for l in range(3):
          total_spin[0] += J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
          total_spin[1] -= J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j + k, 0] += total_spin[0]
          priorities[i*N*N + j + k, 1] -= total_spin[1] * 3
        else:
          priorities[i*N*N + j + k, 0] -= total_spin[0]
          priorities[i*N*N + j + k, 1] += total_spin[1] * 3
        
  return(priorities)


#score: {'data3D.txt': 0.0548146}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for x in range(3):
          if J[x, i, j, k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in range(3):
          if J[y, i, (j+1)%N, k] > 0:
            total_spin += 1
          elif J[y, i, j, k] <= 0 and J[y, i, (j+1)%N, k] < 0:
            total_spin -= 2
          else:
            total_spin += 1
        for z in range(3):
          if J[z, (i+1)%N, j, k] > 0:
            total_spin += 1
          elif J[z, i, j, k] <= 0 and J[z, (i+1)%N, j, k] < 0:
            total_spin -= 2
          else:
            total_spin += 1

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.24526700000000007}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        for x in range(3):
          if J[x, i, j, k] > 0:
            site_interactions[i][j][k] += 1
          else:
            site_interactions[i][j][k] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)


#score: {'data3D.txt': -0.1011122}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_x = np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, 1, axis=2)

  site_interactions = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          site_interactions[i][j][k] += 1
        elif J[1, i, j, k] > 0:
          site_interactions[i][j][k] -= 1
        else:
          site_interactions[i][j][k] = -2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if interacting_spins_x[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_y[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if interacting_spins_z[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priority = np.tanh(-total_spin + site_interactions[i][j][k])
        priorities[i*N*N+j*N+k][0] = -priority
        priorities[i*N*N+j*N+k][1] = priority

  return(priorities)


#score: {'data3D.txt': -0.0025310000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0022078000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        for m in range(6):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0022078000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  # Calculate priorities along each axis
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m,i,j,k]
            else:
              total_spin[1] += J[m,i,j,k]
            site_nbr = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin[0] += 1
            else:
              total_spin[0] -= 1
          priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  # Calculate priorities diagonally
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)


#score: {'data3D.txt': -0.0022497999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += total_spin[0]
            priorities[i*N+j+k%N][1] -= total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= total_spin[0]
            priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.002426600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0025578000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
          priorities[i*N+j+k%N][0] = total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
          priorities[i*N+j+k%N][0] = -total_spin[0]
          priorities[i*N+j+k%N][1] = total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0024482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022078000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate priorities along each axis
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m,i,j,k]
            else:
              total_spin[1] += J[m,i,j,k]
            site_nbr = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin[0] += 1
            else:
              total_spin[0] -= 1
          priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  # Calculate priorities diagonally
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)


#score: {'data3D.txt': -0.0022078000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          for m in range(6):
            if h[site_nbrs[m]][j][k] > 0:
              total_spin[1] -= J[m, i, j, k]
            else:
              total_spin[1] += J[m, i, j, k]
            site_nbr = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin[0] += 1
            else:
              total_spin[0] -= 1
          priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0022078000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate priorities along each axis
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  # Calculate priorities diagonally
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)


#score: {'data3D.txt': -0.004795400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        for l in range(3):
          site = (i + ((l-1)%2 - 1)) % N
          if J[l, i, j, k] > 0:
            total_spin += h[site][j]
          else:
            total_spin -= h[site][j]
        for l in range(6):
          if J[l, i, j, k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for site_nbr in [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]:
          total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  
  # calculate total magnetism at each site
  total_spin = [[0., 0.] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i*N*N + j*N + k
        total_spin[site_nbr][0] += h[i][j][k]
        if h[i][j][k] > 0:
          total_spin[site_nbr][0] += 1
          total_spin[site_nbr][1] -= 1
        else:
          total_spin[site_nbr][0] -= 1
          total_spin[site_nbr][1] += 1
        
  # assign priorities to each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = i*N*N + j*N + k
        if h[i][j][k] > 0:
          priorities[site_nbr][0] = total_spin[site_nbr][0]
          priorities[site_nbr][1] = -total_spin[site_nbr][0]
        else:
          priorities[site_nbr][0] = -total_spin[site_nbr][0]
          priorities[site_nbr][1] = total_spin[site_nbr][0]
        
  return priorities


#score: {'data3D.txt': -0.0029902}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * (len([m for m in site_magnetisms if m > 0]) + total_spin)
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * (len([m for m in site_magnetisms if m < 0]) + total_spin)
          priorities[i*N+j+k][1] = -1 - len([m for m in site_magnetisms if m < 0]) - total_spin
        else:
          priorities[i*N+j+k][0] += sum(m for m in site_magnetisms) + total_spin
          priorities[i*N+j+k][1] = -sum(m for m in site_magnetisms) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0032974000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
        else:
          if any(m > 0 for m in site_magnetisms):
            priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
            priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
          else:
            priorities[i*N+j+k][0] -= len([m for m in site_magnetisms if m < 0])
            priorities[i*N+j+k][1] = -1 * (len([m for m in site_magnetisms if m < 0]) - 1) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0029006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
        elif all(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1 * len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
        else:
          priorities[i*N+j+k][0] += sum(m for m in site_magnetisms)
          priorities[i*N+j+k][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0023334000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] -= len(interacting_spins)
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins])
          priorities[i*N+j+k%N][1] = -len(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0016506000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.0015374}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum
        priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum)
  return(priorities)


#score: {'data3D.txt': -0.002399000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        priorities[i*N+j+k%N][0] = priority
        priorities[i*N+j+k%N][1] = -priority
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': 0.0194198}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs)
          priorities[i*N**2 + j*N + k][1] -= len(site_nbrs)
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs)
          priorities[i*N**2 + j*N + k][1] += len(site_nbrs)
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.21795620000000032}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': 0.001998600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_x][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
      for k in range(N):
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin += h[i][site_nbr_y][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities


#score: {'data3D.txt': -0.005795399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.001998600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': 0.001998600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = (J[:, i, j, k].sum() - total_spin)
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -(J[:, i, j, k].sum() - total_spin)
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  return priorities


#score: {'data3D.txt': 0.001998600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum([h[site_nbr][k] for site_nbr in [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  return priorities


#score: {'data3D.txt': -0.22429860000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_x][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
      
      site_nbr_y = (j + ((k-1)%2 - 1)) % N
      total_spin += h[i][site_nbr_y][k]
      if h[i][j][k] > 0:
        priorities[i*N**2 + j*N + k][0] += 1
        priorities[i*N**2 + j*N + k][1] -= 1
      else:
        priorities[i*N**2 + j*N + k][0] -= 1
        priorities[i*N**2 + j*N + k][1] += 1
      
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr_z = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        total_spin += h[site_nbr_z][k][i]
        if h[i][k][j] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
      
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in [i-1, i+1]:
          if 0 <= l < N:
            site_nbr_x = (l + ((k-1)%2 - 1)) % N
            total_spin += h[site_nbr_x][j]
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
            
        for l in [j-1, j+1]:
          if 0 <= l < N:
            site_nbr_y = (i + ((l-1)%2 - 1)) % N
            total_spin += h[i][site_nbr_y][k]
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
        
        for l in [k-1, k+1]:
          if 0 <= l < N:
            site_nbr_z = (i + ((j-1)%2 - 1)) % N
            total_spin += h[site_nbr_z][l]
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities


#score: {'data3D.txt': -0.0029753999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += sum([abs(t) for t in total_spin])
          priorities[i*N+j+k%N][1] -= sum([-t for t in total_spin])
        else:
          priorities[i*N+j+k%N][0] -= sum([abs(t) for t in total_spin])
          priorities[i*N+j+k%N][1] = -sum([-t for t in total_spin])
  return(priorities)


#score: {'data3D.txt': -0.0024482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 2 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 2 * total_spin[0]
          priorities[i*N+j+k%N][1] = -2 * total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0028618000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + sum(J[m,i,j,k] for m in range(6))
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + sum(J[m,i,j,k] for m in range(6))
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.002906600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.004173}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      site_spin = sum(m > 0 for m in site_magnetisms) - sum(m < 0 for m in site_magnetisms)
      priorities[i][0] -= site_spin
      priorities[i][1] += abs(site_spin)
  return(priorities)


#score: {'data3D.txt': 0.006669400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    i, j, l = (k % N, k // N % N, k // (N * N) % N)
    site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
    interacting_spin_magnetisms = [h[site_nbr][j][l] if J[0, i, j, l] > 0 else -h[site_nbr][j][l] for site_nbr in site_nbrs]
    total_spin = sum(interacting_spin_magnetisms)
    
    if all(m > 0 for m in interacting_spin_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in interacting_spin_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0025198000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N//N][k%N%N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[k][0] += -1 * (sum(1 for _ in site_magnetisms) + total_spin)
      priorities[k][1] -= 1
    elif any(m < 0 for m in site_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0031289999999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if any(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.002441000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][i // (N**2)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if total_spin > 0:
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0]) + total_spin
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
    elif total_spin < 0:
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] += -1 * len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms) + total_spin
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2080138000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in [-1, 0, 1]:
          site_nbr_x = (i + x) % N
          if h[site_nbr_x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in [-1, 0, 1]:
          site_nbr_y = (j + y) % N
          if h[i][site_nbr_y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in [-1, 0, 1]:
          site_nbr_z = (i + z) % N
          if h[site_nbr_z][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr_x = (i + ((j-1)%2 - 1)) % N
      site_nbr_y = (j + ((k-1)%2 - 1)) % N
      site_nbr_z = (i + ((k-1)%2 - 1)) % N
      
      for k in range(N):
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities


#score: {'data3D.txt': -0.0034342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []
        
        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)
          
          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)
          
          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)
        
        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])
        
        priorities[i*N+j+k%N] = [priority_x, -priority_y]
  
  return(priorities)


#score: {'data3D.txt': -0.0018502}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for axis in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          total_spin = [0, 0]
          interacting_spins = []
          
          for l in range(6):
            if h[site_nbrs[l]][j][k] > 0:
              interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
              total_spin[1] -= interacting_spin
            else:
              interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
              total_spin[0] += interacting_spin
            
            if h[i][j][k] > 0:
              priority_total = [total_spin[0] + 1, -total_spin[1] - 1]
            else:
              priority_total = [-total_spin[0] - 1, total_spin[1] + 1]
            
            priorities[i*N+j+k%N] = priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.0019285999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priority = np.sum([x if h[i][j][k] > 0 else -x for x in total_spin])
        priorities[i*N+j+k%N][0] = priority
        priorities[i*N+j+k%N][1] = -priority
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_x][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin += h[i][site_nbr_y][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr_z][k][i]
        if h[i][k][j] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.021464199999999982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr_x][j][k]
        priorities[i*N**2 + j*N + k][0] += np.sign(total_spin)
        priorities[i*N**2 + j*N + k][1] -= np.sign(total_spin)
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin = h[i][site_nbr_y][k]
        priorities[i*N**2 + j*N + k][0] += np.sign(total_spin)
        priorities[i*N**2 + j*N + k][1] -= np.sign(total_spin)
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr_z][k][i]
        priorities[i*N**3:(i+1)*N**3+j].T[0] += np.sign(total_spin)
        priorities[i*N**3:(i+1)*N**3+j].T[1] -= np.sign(total_spin)
        
  return priorities


#score: {'data3D.txt': -0.17237619999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.0024550000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        priority_total = total_spin[0]
        for m in range(6):
          if h[i][j][k] > 0:
            priority_total += J[m,i,j,k] * (h[site_nbrs[m]][j][k] > 0)
          else:
            priority_total -= J[m,i,j,k] * (1 - (h[site_nbrs[m]][j][k] > 0))
        priorities[i*N+j+k%N][0] = priority_total
        priorities[i*N+j+k%N][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.002603400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          interacting_spins.append(-2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1))
        site_nbr = (i + ((3-1) % 2 - 1)) % N
        total_spin[0] += sum(interacting_spins)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0017518000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        total_spin[0] += h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': 0.0046226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    i, j, l = (k % N, k // N % N, k // (N * N) % N)
    site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
    interacting_spin_magnetisms = [h[site_nbr][j][l] if J[0, i, j, l] > 0 else -h[site_nbr][j][l] for site_nbr in site_nbrs]
    total_spin = sum(interacting_spin_magnetisms)
    
    # Sort the interacting spins based on their magnetism
    sorted_spin_magnetisms = sorted(zip(interacting_spin_magnetisms, range(len(interacting_spin_magnetisms))), key=lambda x: abs(x[0]))
    
    for site_nbr, _ in sorted_spin_magnetisms:
      if site_nbr > 0:
        priorities[k][0] += -1
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.006184599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    i, j, l = (k % N, k // N % N, k // (N * N) % N)
    site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
    interacting_spin_magnetisms = [h[site_nbr][j][l] if J[0, i, j, l] > 0 else -h[site_nbr][j][l] for site_nbr in site_nbrs]
    total_spin = sum(interacting_spin_magnetisms)
    
    if all(m > 0 for m in interacting_spin_magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1 + (len([m for m in interacting_spin_magnetisms if m > 0]))
    elif any(m < 0 for m in interacting_spin_magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] = 1 - total_spin
    else:
      if any(m > 0 for m in interacting_spin_magnetisms):
        priorities[k][0] += -1 + (len([m for m in interacting_spin_magnetisms if m > 0]))
        priorities[k][1] -= len([m for m in interacting_spin_magnetisms if m > 0]) - total_spin
      else:
        priorities[k][0] -= len([m for m in interacting_spin_magnetisms if m < 0])
        priorities[k][1] += 1 + total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.0161782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    magnetisms = [h[site_nbr][k%N][k//N%N] if J[0, k%N, k//N%N, k//((N*N))] > 0 else -h[site_nbr][k%N][k//N%N] for site_nbr in site_nbrs]
    total_spin = sum(magnetisms)
    
    if all(m > 0 for m in magnetisms):
      priorities[k][0] += -1
      priorities[k][1] -= 1 + total_spin
    elif any(m < 0 for m in magnetisms):
      priorities[k][0] -= 1
      priorities[k][1] = -1 - total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.17237619999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities


#score: {'data3D.txt': -0.004119800000000001}
program:
def priority(N, h, J):
  priorities = [[0., 0.] for _ in range(N**3)]
  
  # calculate total magnetism at each site
  total_spin = [0., 0.]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for x in range(2):
          for y in range(2):
            for z in range(2):
              site_nbr_x = (i + ((k-1)%2 - 1)) % N
              site_nbr_y = (j + ((x-1)%2 - 1)) % N
              site_nbr_z = (i + ((y-1)%2 - 1)) % N
              
              total_spin[0] += h[site_nbr_x][site_nbr_y][site_nbr_z]
              if h[site_nbr_x][site_nbr_y][site_nbr_z] > 0:
                total_spin[1] -= 1
              else:
                total_spin[1] += 1
        
        if total_spin[0] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': 0.0005897999999999993}
program:
def priority(N, h, J):
  priorities = [[0., 0.] for _ in range(N**3)]
  
  # Calculate total magnetism at each site and its neighbors
  total_spin = [[0., 0.] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin[i*N**2 + j*N + k][0] += h[site_nbr_x][j][k]
        total_spin[i*N**2 + j*N + k][0] += h[i][site_nbr_y][k]
        total_spin[i*N**2 + j*N + k][0] += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          total_spin[i*N**2 + j*N + k][1] -= 1
        else:
          total_spin[i*N**2 + j*N + k][1] += 1
        
  # Assign priorities to each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin[i*N**2 + j*N + k][0]
          priorities[i*N**2 + j*N + k][1] = -total_spin[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin[i*N**2 + j*N + k][0]
          priorities[i*N**2 + j*N + k][1] = total_spin[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0., 0.] for _ in range(N**3)]
  
  # calculate total magnetism at each site
  total_spin = [[0., 0.] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N * N*N + j*N + k
        total_spin[site_nbr][0] += h[i][j][k]
        if h[i][j][k] > 0:
          total_spin[site_nbr][0] += 1
          total_spin[site_nbr][1] -= 1
        else:
          total_spin[site_nbr][0] -= 1
          total_spin[site_nbr][1] += 1
  
  # assign priorities to each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N * N*N + j*N + k
        if h[i][j][k] > 0:
          priorities[site_nbr][0] += total_spin[site_nbr][0]
          priorities[site_nbr][1] -= total_spin[site_nbr][0]
        else:
          priorities[site_nbr][0] -= total_spin[site_nbr][0]
          priorities[site_nbr][1] = -total_spin[site_nbr][0]
  
  return priorities


#score: {'data3D.txt': -0.1929298000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] -= np.sum([J[l, i, j, k] for l in [1, 4]])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] += np.sum([J[l, i, j, k] for l in [1, 4]])
  
  return priorities


#score: {'data3D.txt': -0.0020873999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0020874}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site_center = (i, j, k)
        for dir in [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]:
          site = tuple(a + b for a, b in zip(site_center, dir))
          if 0 <= site[0] < N and 0 <= site[1] < N and 0 <= site[2] < N:
            total_spin[0] += J[3,i,j,k]
            total_spin[1] -= J[4,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017938000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += (2*h[site_nbrs[m]][j][k] - 1) * J[m,i,j,k]
        site_nbr = (i + ((3-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin[0] + J[5,i,j,k]
          priorities[i*N+j+k%N][1] = -total_spin[1] - J[5,i,j,k]
        else:
          priorities[i*N+j+k%N][0] = total_spin[0] - J[5,i,j,k]
          priorities[i*N+j+k%N][1] = -total_spin[1] + J[5,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.0008041999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0,i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        if J[1,i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        elif J[1,i,j,k] < 0:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        if J[2,i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        elif J[2,i,j,k] < 0:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.32622659999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      total_spin = np.zeros(2)
      site_nbr_x = (i + ((N-1)%2 - 1)) % N
      site_nbr_y = (j + ((N-1)%2 - 1)) % N
      
      total_spin[0] += h[i][site_nbr_y][0]
      total_spin[0] += h[site_nbr_x][j][0]
      
      if h[i][j][0] > 0:
        priorities[i*N**2 + j*N][0] += total_spin[0]
        priorities[i*N**2 + j*N][1] -= total_spin[0]
      else:
        priorities[i*N**2 + j*N][0] -= total_spin[0]
        priorities[i*N**2 + j*N][1] += total_spin[0]
  
  return priorities


#score: {'data3D.txt': 0.16642819999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        
  return priorities


#score: {'data3D.txt': -0.0161782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    magnetisms = [h[site_nbr][k%N][k//N%N] if J[0, k%N, k//N%N, k//((N*N))] > 0 else -h[site_nbr][k%N][k//N%N] for site_nbr in site_nbrs]
    total_spin = sum(magnetisms)
    
    priority_total = np.zeros(2)
    
    if all(m > 0 for m in magnetisms):
      priority_total[0] += -1
      priority_total[1] -= 1 + total_spin
    elif any(m < 0 for m in magnetisms):
      priority_total[0] -= 1
      priority_total[1] = -1 - total_spin
    
    priorities[k] = priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.0021149999999999997}
program:
def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] -= J[l,i,j,k]
            priorities[i*N+j*k][1] += J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] += J[l,i,j,k]
            priorities[i*N+j*k][1] -= J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.003267400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(interacting_spins)
        if all(m > 0 for m in interacting_spins):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        elif any(m < 0 for m in interacting_spins):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0022646000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbrs = [(i % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i%N][i//N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -sum(1 for _ in range(N))
      priorities[i][1] -= len([_ for _ in range(N)])
    elif any(m < 0 for m in site_magnetisms):
      priorities[i][0] -= sum(1 for _ in range(N))
      priorities[i][1] += len([_ for _ in range(N)])

  return(priorities)


#score: {'data3D.txt': -0.0022646000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    total_spin = sum([h[site_nbr][k%N][k//N] for site_nbr in site_nbrs])
    if all(m > 0 for m in [h[site_nbr][k%N][k//N] for site_nbr in site_nbrs]):
      priorities[k][0] += -1
      priorities[k][1] -= 1
    elif any(m < 0 for m in [h[site_nbr][k%N][k//N] for site_nbr in site_nbrs]):
      priorities[k][0] -= 1
      priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0023125999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins]) + total_spin[0]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017054000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          interacting_spins.append(J[m,i,j,k] * (2*h[site_nbr][j][k] - 1))
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum(interacting_spins)
          priorities[i*N+j+k%N][1] -= len(interacting_spins)
        else:
          priorities[i*N+j+k%N][0] -= np.sum(interacting_spins)
          priorities[i*N+j+k%N][1] = -len(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0015242000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0015242000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0018574000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(6):
        if J[k,i,j,(i+(((k-1)%2)-1))%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0021106}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(6):
        if J[k,i,j,site_nbr] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0011421999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N**3):
    site_nbrs = [(k % N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][k%N][(k//N)**2%N] if J[p, k%N, (k//N)**2%N, k//((N*N*N))] > 0 else -h[site_nbr][k%N][(k//N)**2%N] for p, site_nbr in enumerate(site_nbrs)]
    total_spin = sum(site_magnetisms)
    
    priority_total = np.zeros(2)
    
    if all(m > 0 for m in site_magnetisms):
     priority_total[0] += -1 * len([m for m in site_magnetisms if m > 0])
     priority_total[1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif any(m < 0 for m in site_magnetisms):
     priority_total[0] += -1 * len([m for m in site_magnetisms if m < 0])
     priority_total[1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
     priority_total[0] += sum(m for m in site_magnetisms)
     priority_total[1] = -sum(m for m in site_magnetisms) + total_spin
    
    priorities[k] = priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.0005562000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    total_spin = sum(h[site_nbr][i % N][(i // (N**2)) % N] if J[0, i % N, (i // (N*N)), (i // (N*N)) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs)
    site_magnetisms = [h[site_nbr][i % N][(i // (N*N)) % N] if J[0, i % N, (i // (N*N)), (i // (N*N)) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs]
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priorities[i][0] += sum(m for m in site_magnetisms)
      priorities[i][1] = -sum(m for m in site_magnetisms) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0003650000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] if J[0, i % N, (i // (N*N)) % N, (i // ((N*N))) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      for m in site_magnetisms:
        if m > 0:
          priorities[i][0] += -1
          priorities[i][1] -= 1
        elif m < 0:
          priorities[i][0] -= 1
          priorities[i][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.0018301999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N][(i // (N**2)) % N] if J[0, i % N, (i // (N*N)) % N, (i // ((N*N)**2)) % N] > 0 else -h[site_nbr][i % N][(i // (N*N)) % N] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    
    priority_total = np.zeros(2)
    if all(m > 0 for m in site_magnetisms):
      priority_total[0] += -1 * len([m for m in site_magnetisms if m > 0])
      priority_total[1] -= len([m for m in site_magnetisms if m > 0]) + total_spin
    elif all(m < 0 for m in site_magnetisms):
      priority_total[0] += -1 * len([m for m in site_magnetisms if m < 0])
      priority_total[1] = -len([m for m in site_magnetisms if m < 0]) + total_spin
    else:
      priority_total[0] += sum(m for m in site_magnetisms)
      priority_total[1] = -sum(m for m in site_magnetisms) + total_spin
    
    priorities[i] = priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0,0]
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j,site_nbr] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priorities[i*N+j][0] = total_spin[0]
      priorities[i*N+j][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.002054200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N + ((p-1)%2 - 1)) % N for p in range(6)]
    site_magnetisms = [h[site_nbr][i % N // (N//3)][((i // (N//3)) % N)] for site_nbr in site_nbrs]
    total_spin = sum(site_magnetisms)
    if all(m > 0 for m in site_magnetisms):
      priorities[i][0] += -1 * len([m for m in site_magnetisms if m > 0])
      priorities[i][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
    elif all(m < 0 for m in site_magnetisms):
      priorities[i][0] -= len([m for m in site_magnetisms if m < 0])
      priorities[i][1] = 1 + total_spin
    else:
      if any(m > 0 for m in site_magnetisms):
        priorities[i][0] += -1 * (len([m for m in site_magnetisms if m > 0]) - total_spin)
        priorities[i][1] -= len([m for m in site_magnetisms if m > 0])
      else:
        priorities[i][0] -= len([m for m in site_magnetisms if m < 0]) - total_spin
        priorities[i][1] = 1 + (len([m for m in site_magnetisms if m < 0]))
  return(priorities)


#score: {'data3D.txt': -0.0037498}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(6)]
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if h[i][j][k] > 0:
          priorities[i*N+j+k][0] += -1 + len([m for m in site_magnetisms if m > 0])
          priorities[i*N+j+k][1] -= len([m for m in site_magnetisms if m > 0]) - total_spin
        elif h[i][j][k] < 0:
          priorities[i*N+j+k][0] -= 1 + len([m for m in site_magnetisms if m < 0])
          priorities[i*N+j+k][1] = -1 - total_spin + len([m for m in site_magnetisms if m < 0])
        else:
          priorities[i*N+j+k][0] += -total_spin
          priorities[i*N+j+k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.0016422000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 4 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 4 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 4 * total_spin[0]
          priorities[i*N+j+k%N][1] = -4 * total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0024586000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 3 * total_spin[0]
          priorities[i*N+j+k%N][1] -= 3 * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 3 * total_spin[0]
          priorities[i*N+j+k%N][1] = -3 * total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022382000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        priority = [total_spin[0], -total_spin[1]]
        interacting_spins.sort(key=lambda x: abs(x), reverse=True)
        for spin in interacting_spins:
          if h[i][j][k] > 0:
            priority[0] += spin
            priority[1] -= spin
          else:
            priority[0] -= spin
            priority[1] = -spin
        priorities[i*N+j+k%N] = priority
  return(priorities)


#score: {'data3D.txt': -0.0013982000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if J[0,i,j,k] > 0:
          total_spin += 1
        elif J[0,i,j,k] < 0:
          total_spin -= 1
        if J[1,i,j,k] > 0:
          total_spin += interacting_spins[1][i,site_nbr,k]
        elif J[1,i,j,k] < 0:
          total_spin -= interacting_spins[1][i,site_nbr,k]
        if J[2,i,j,k] > 0:
          total_spin += interacting_spins[2][i,site_nbr,k]
        else:
          total_spin -= interacting_spins[2][i,site_nbr,k]
        priorities[i*N+j+k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0021149999999999997}
program:
def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  
  # Calculate interacting spins
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate priority for each site based on its neighbors and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] -= sum([J[l,i,j,k] for l in range(6)])
          priorities[i*N+j*k][1] += sum([J[l,i,j,k] for l in range(6)])
        else:
          priorities[i*N+j*k][0] += sum([J[l,i,j,k] for l in range(6)])
          priorities[i*N+j*k][1] -= sum([J[l,i,j,k] for l in range(6)])

  return(priorities)


#score: {'data3D.txt': 0.0368114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = h[i][j][k]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': 0.0194198}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': 0.0194198}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': 0.0194198}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_nbr_values)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.0018898000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(3):
          if J[d,i,j,k] > 0:
            total_spin += 1
          elif J[d,i,j,k] < 0:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.4288834000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if h[i][j][k] > 0:
          priority_total = [np.sum(J[:, i, j, k]) - 1, -(np.sum(J[:, i, j, k])) - 1]
          priorities[i*N**2 + j*N + k] = priority_total
        else:
          priority_total = [-np.sum(J[:, i, j, k]) + 1, -(np.sum(J[:, i, j, k])) + 1]
          priorities[i*N**2 + j*N + k] = priority_total
  
  return priorities


#score: {'data3D.txt': 0.0368114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = h[i][j][k] + sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] = -np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.0030509999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][1] += -sum(1 for _ in site_magnetisms)
        else:
          priorities[i*N+j+k][1] -= -sum(1 for _ in site_magnetisms)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if any(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -total_spin
          priorities[i*N+j+k][1] -= total_spin
        else:
          priorities[i*N+j+k][0] -= total_spin
          priorities[i*N+j+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.003267400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        if all(m > 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1
        elif any(m < 0 for m in site_magnetisms):
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        else:
          if total_spin > N**2 / 2:
            priorities[i*N+j+k][0] += -1
            priorities[i*N+j+k][1] -= 1
          elif total_spin < -N**2 / 2:
            priorities[i*N+j+k][0] -= 1
            priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0043526}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 4, 5]]
        site_nbrs.extend([(i + ((p-1)%2 - 1)) % N for p in [2, 3]])
        site_magnetisms = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = sum(site_magnetisms)
        
        if any(m > 0 for m in site_magnetisms):
          priority = np.sum([J[p,i,j,k]*m for p,m in enumerate(site_magnetisms)])
          priorities[i*N+j+k][0] += -1
          priorities[i*N+j+k][1] -= 1 + priority
        else:
          priority = np.sum([-J[p,i,j,k]*m for p,m in enumerate(site_magnetisms)])
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1 - priority
  
  return(priorities)


#score: {'data3D.txt': -0.0023334000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        for m in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += total_spin[0] + (h[i][j][k])
            priorities[i*N+j+k%N][1] -= total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= total_spin[0] - (h[i][j][k])
            priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0025902000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        for m in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += total_spin[0] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
            priorities[i*N+j+k%N][1] -= total_spin[1] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
          else:
            priorities[i*N+j+k%N][0] -= total_spin[0] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
            priorities[i*N+j+k%N][1] = total_spin[1] + sum(J[m,i,j,k] for m in range(6) if (site_nbrs[m] == i and j == (m+1)%N) or (site_nbrs[m] == i and k == ((k+2)%N)))
  return(priorities)


#score: {'data3D.txt': -0.0017585999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] -= 2 * total_spin[0] - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] = 2 * total_spin[0] - total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0011890000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + 1
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] - 1
          priorities[i*N+j+k%N][1] = total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017138}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for d in range(6):
          if J[d//3, i, j, k] > 0:
            total_spin += 1
          elif J[d//3, i, j, k] < 0:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0037186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(3):
          if J[d,i,j,k] > 0:
            total_spin += 1
          elif J[d,i,j,k] < 0:
            total_spin -= 1
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j,k]
        if h[i,j,k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0017138}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(6):
          if J[d//3,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0016189999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(6):
          if J[d,i,j,k] > 0:
            total_spin += 1
          elif J[d,i,j,k] < 0:
            total_spin -= 1
          if h[site_nbr][j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = total_spin
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      for k in range(N):
        if h[site_nbr][j,k] > 0:
          priorities[i*N+j+k][1] += 1
        else:
          priorities[i*N+j+k][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0018674000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += 3 * J[4,i,j,k]
          total_spin[1] -= 2 * J[5,i,j,k]
        else:
          total_spin[0] -= 3 * J[4,i,j,k]
          total_spin[1] += 2 * J[5,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0018558000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        for m in range(6):
          site_nbr = (i + ((m % 2) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] -= 1
            priorities[i*N+j+k%N][1] += 1
          else:
            priorities[i*N+j+k%N][0] += 1
            priorities[i*N+j+k%N][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0037186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        priority = [total_spin[0], -total_spin[1]]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 2
          priorities[i*N+j+k%N][1] -= 2
        else:
          priorities[i*N+j+k%N][0] -= 2
          priorities[i*N+j+k%N][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0021065999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] = -total_spin[0] + total_spin[1]
        else:
          priorities[i*N+j+k%N][0] = -total_spin[0] - total_spin[1]
          priorities[i*N+j+k%N][1] = total_spin[0] + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 3
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 3
          priorities[i*N**2 + j*N + k][1] += 1
        
  return priorities


#score: {'data3D.txt': -3.100000000000069e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for m in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N if m == 0 else (j + ((k-1)%2 - 1)) % N if m == 1 else (i + ((j-1)%2 - 1)) % N
          total_spin += h[site_nbr][i][j]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in [i, j, k] if (x+1) % N == site_nbr])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] += len([x for x in [i, j, k] if (x+1) % N == site_nbr])
  
  return priorities


#score: {'data3D.txt': -0.22190700000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  return priorities


#score: {'data3D.txt': -0.0026066}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += 1 + total_spin[0]
            priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
            priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0026018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        priority = [total_spin[0], -total_spin[1]]
        priorities[i*N+j+k][0] += total_spin[0]
        priorities[i*N+j+k][1] -= total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0010702000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = np.array([h[site_nbr][j][k] for site_nbr in site_nbrs])
        for m in range(6):
          total_spin[1] -= J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.002383}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] if k == 0 else 0
        for l in range(6):
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          total_spin += interacting_spins
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*interacting_spins
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.002303800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = 3*total_spin[0] + total_spin[1]
          priorities[i*N+j+k%N][1] = -(4*total_spin[0] + 2*total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -3*total_spin[0] - total_spin[1]
          priorities[i*N+j+k%N][1] = (4*total_spin[0] - 2*total_spin[1])
  return(priorities)


#score: {'data3D.txt': -0.0026601999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0019838}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k]
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k]
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)


#score: {'data3D.txt': -0.002906600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m, i, j, k]
          else:
            total_spin[1] += J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0] + sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0005037999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        for l in range(6):
          total_spin[0] += -2*J[l,i,j,k]
          if h[site_nbrs[l]][j][k] > 0:
            priorities[i*N+j+k%N][0] -= 1
            priorities[i*N+j+k%N][1] += 1
          else:
            priorities[i*N+j+k%N][0] += 1
            priorities[i*N+j+k%N][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.003011}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        site_nbrs.sort()
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.0013025999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        total_spin_sum = np.sum(total_spin)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin_sum
          priorities[i*N+j+k%N][1] -= total_spin_sum
        else:
          priorities[i*N+j+k%N][0] -= total_spin_sum
          priorities[i*N+j+k%N][1] = -total_spin_sum
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += abs(h[site_nbr_x][j][k]) + abs(h[i][site_nbr_y][k]) + abs(h[i][j][site_nbr_z])
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= abs(h[site_nbr_x][j][k]) + abs(h[i][site_nbr_y][k]) + abs(h[i][j][site_nbr_z])
          priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.018762599999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin - np.sum(J[:(i+1),:,:])
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin - np.sum(J[:(i+1),:,:])
  
  return priorities


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*interacting_spins + total_spin
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0023070000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j] if k == 0 else h[site_nbr2][j]
        for l in range(6):
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          total_spin += interacting_spins
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*interacting_spins
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0020866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            interacting_spins += 1
          else:
            interacting_spins -= 1
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.002322200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins_sum = 0
        interacting_spins_count = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins_sum += J[l,i,j,k]
          interacting_spins_count += np.roll(h, -1, axis=l)[i][j][k] if l < 3 else np.roll(h, 1, axis=l-3)[i][j][k]
        total_spin *= h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins_sum + interacting_spins_count
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins_sum - interacting_spins_count
  return(priorities)


#score: {'data3D.txt': -0.0017666000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0021498}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        for l in range(6):
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        priority_total = total_spin + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = priority_total
          priorities[i*N+j*k][1] = -priority_total - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -priority_total - interacting_spins
          priorities[i*N+j*k][1] = priority_total + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0020902000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0027406}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        if h[site_nbr1][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        interacting_spins += J[0,i,j,k]
        interacting_spins += J[1,i,j,k]
        interacting_spins += J[2,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 3*interacting_spins
  return(priorities)


#score: {'data3D.txt': 0.16642819999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        
  return priorities


#score: {'data3D.txt': -0.22190700000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.0020874000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - total_spin[1]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0020633999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017377999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0015374}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0026990000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0029674000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        interacting_spins = np.array([h[site_nbr][j][k] for site_nbr in site_nbrs])
        total_spin = [0, 0]
        for m in range(6):
          if h[i][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
            total_spin[0] += -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
          else:
            total_spin[1] += J[m,i,j,k]
            total_spin[0] -= -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022694000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = np.array([h[site_nbr][j][k] for site_nbr in site_nbrs])
        for m in range(6):
          if h[i][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
            total_spin[0] += -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
          else:
            total_spin[1] += J[m,i,j,k]
            total_spin[0] -= -2 * J[m,i,j,k] + (interacting_spins[m] > 0) * (-1 if m%2==0 else 1)
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0019682}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0026018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        site_nbr1 = (i + ((0)%2 - 1)) % N
        site_nbr2 = (i + ((2)%2 - 1)) % N
        site_nbr3 = (i + ((4)%2 - 1)) % N
        for l in range(6):
          if l < 3:
            interacting_spins += J[l,i,j,k] + np.roll(h, -1, axis=l)[site_nbr1][j][k]
          else:
            interacting_spins += J[l,i,j,k] + np.roll(h, 1, axis=l-3)[site_nbr2][j][k]
        total_spin += h[site_nbr1][j][k] if k == 0 else (h[site_nbr2][j][k] if k == N-1 else h[site_nbr3][j][k])
        for l in range(2):
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 2*(interacting_spins + h[site_nbr1][j][k])
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 2*(interacting_spins + h[site_nbr1][j][k])
  return(priorities)


#score: {'data3D.txt': -0.0029146000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        for l in range(6):
          interacting_spins = J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
          total_spin += interacting_spins
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] = total_spin + interacting_spins
            priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
          else:
            priorities[i*N+j*k][0] = -total_spin - interacting_spins
            priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0022754000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = 0
        total_energy = 0
        for m in range(6):
          neighbor_spin = (i + ((m % 3) - 1)) % N
          if h[neighbor_spin][j][k] > 0:
            site_spin += 1
          else:
            site_spin -= 1
          total_energy += J[m,i,j,k]*site_spin*h[neighbor_spin][j][k]
        priorities[i*N+j+k%N] = [total_energy, -total_energy]
  return(priorities)


#score: {'data3D.txt': -0.0024638}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=(i//2)%2+1)

  site_interactions = []
  for k in range(N):
    site_interactions.append([])
    for j in range(N):
      site_interactions[k].append([])
      for i in range(N):
        total_spin = [0, 0]
        for m in range(6):
          if h[(i + ((m % 3) - 1)) % N][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        site_interactions[k][j].append(total_spin)
  for k in range(N):
    for j in range(N):
      priorities[k*N+j] = [np.prod([x[0] for x in site_interactions[k][j]]), np.prod([x[1] for x in site_interactions[k][j]])]
  return(priorities)


#score: {'data3D.txt': -0.004303800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          site_nbr = (i + ((m-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N+j+k%N] = [total_spin[0],-total_spin[1]]
  
  return(priorities)


#score: {'data3D.txt': -0.003162200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.002391}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0037186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        for l in range(6):
          site = (i + ((l%2) - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += 1
            priorities[i*N+j+k%N][1] -= 1
          else:
            priorities[i*N+j+k%N][0] -= 1
            priorities[i*N+j+k%N][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0027369999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          if abs(h[i][j][k]) == abs(h[site_nbrs[l]][j][k]):
            if h[i][j][k] > 0:
              total_spin[0] -= J[l,i,j,k]
            else:
              total_spin[0] += J[l,i,j,k]
          else:
            if h[i][j][k] > 0:
              total_spin[0] += J[l,i,j,k]
            else:
              total_spin[0] -= J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        for m in range(3):
          if h[i][j][k] > 0:
            total_spin[0] += J[m,i,j,k]
            total_spin[1] -= J[m+3,i,j,k]
          else:
            total_spin[0] -= J[m+3,i,j,k]
            total_spin[1] += J[m,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0020838000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        if h[i][j][k] > 0:
          priority = [total_spin[0], -total_spin[1]]
        else:
          priority = [-total_spin[0], total_spin[1]]
        priorities[i*N+j+k%N] = priority
  return(priorities)


#score: {'data3D.txt': -0.0026994000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] -= J[4,i,j,k]
        else:
          total_spin[0] += J[3,i,j,k]
          total_spin[1] += J[4,i,j,k]
        priorities[i*N+j+k%N][0] = total_spin[0] + 2*h[i][j][k]
        priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0020798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        priority = 0
        if h[i][j][k] > 0:
          priority = total_spin + interacting_spins * 2
        else:
          priority = -total_spin - interacting_spins * 2
        priorities[i*N+j*k][0] = priority
        priorities[i*N+j*k][1] = -priority
  return(priorities)


#score: {'data3D.txt': -0.0027330000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k]
        interacting_spins = J[0,i,j,k] + J[1,i,j,k] + J[2,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + 3*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          for m in range(3):
            site_nbr2 = (i + ((m-1)%2 - 1)) % N
            if h[site_nbr2][j][k] > 0:
              interacting_spins += 1
            else:
              interacting_spins -= 1
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0023577999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][i,j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][i,j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + sum(interacting_spins)
          priorities[i*N+j*k][1] = -total_spin - 3*sum(interacting_spins)
        else:
          priorities[i*N+j*k][0] = -total_spin - sum(interacting_spins)
          priorities[i*N+j*k][1] = total_spin + 3*sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0034342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]

        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]

        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []

        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)

          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)

          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)

        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])

        priorities[i*N+j+k%N] = [priority_x, -priority_y]

  return(priorities)


#score: {'data3D.txt': -0.0034342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_y = [(j + ((m % 2) - 1)) % N for m in range(6)]
        site_nbrs_z = [(k + ((m % 2) - 1)) % N for m in range(6)]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        interacting_spins_x = []
        interacting_spins_y = []
        interacting_spins_z = []
        
        for m in range(6):
          if h[site_nbrs_x[m]][j][k] > 0:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] - 1)
            total_spin_x[1] -= interacting_spin_x
          else:
            interacting_spin_x = J[m,i,j,k] * (2*h[site_nbrs_x[m]][j][k] + 1)
            total_spin_x[0] += interacting_spin_x
          interacting_spins_x.append(interacting_spin_x)
          
          if h[i][site_nbrs_y[m]][k] > 0:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] - 1)
            total_spin_y[1] -= interacting_spin_y
          else:
            interacting_spin_y = J[m,i,j,k] * (2*h[i][site_nbrs_y[m]][k] + 1)
            total_spin_y[0] += interacting_spin_y
          interacting_spins_y.append(interacting_spin_y)
          
          if h[i][j][site_nbrs_z[m]] > 0:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] - 1)
            total_spin_z[1] -= interacting_spin_z
          else:
            interacting_spin_z = J[m,i,j,k] * (2*h[i][j][site_nbrs_z[m]] + 1)
            total_spin_z[0] += interacting_spin_z
          interacting_spins_z.append(interacting_spin_z)
        
        priority_x = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_x])
        priority_y = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_y])
        priority_z = np.sum([x if h[i][j][k] > 0 else -x for x in interacting_spins_z])
        
        priorities[i*N+j+k%N] = [priority_x, -priority_y]
  
  return(priorities)


#score: {'data3D.txt': -0.0016385999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k] + (h[site_nbrs[m]][j][k] > 0) * (-1 if m%2==0 else 1)
        site = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.005343400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.0027402000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x for x in interacting_spins]) + total_spin[1]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[0]
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x for x in interacting_spins]) + total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0016914000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum([x for x in interacting_spins]) - len(interacting_spins)
          priorities[i*N+j+k%N][1] = -np.sum([x for x in interacting_spins])
        else:
          priorities[i*N+j+k%N][0] = -np.sum([x for x in interacting_spins]) + len(interacting_spins)
          priorities[i*N+j+k%N][1] = np.sum([x for x in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)


#score: {'data3D.txt': -0.002084200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + 1
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - 1
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + 1
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - 1
  return(priorities)


#score: {'data3D.txt': -0.002962600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for m in range(6):
          site_nbr = (i + ((m % 2) - 1)) % N
          interacting_spin = J[m, i, j, k] * (2*h[site_nbr][j][k] - 1)
          total_spin += interacting_spin
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0021966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum([x for x in interacting_spins]) + total_spin[1]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = len(interacting_spins) - total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0025537999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
      for k in range(N):
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += J[m,i,j,k] * (2*h[site_nbrs[m]][j][k] - 1)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum(total_spin) - len(site_nbrs) * total_spin[1]
          priorities[i*N+j+k%N][1] = -np.sum(total_spin) + len(site_nbrs) * total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= np.sum(total_spin) - len(site_nbrs) * total_spin[1]
          priorities[i*N+j+k%N][1] = -np.sum(total_spin) + len(site_nbrs) * total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022758000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
      for k in range(N):
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((k-1)%3 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum([x for x in interacting_spins]) + total_spin[1]
          priorities[i*N+j+k%N][1] -= len(interacting_spins) - total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -np.sum([x for x in interacting_spins]) - total_spin[0]
          priorities[i*N+j+k%N][1] = -len(interacting_spins) + total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017338000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = [J[l,i,j,k] * (2*h[site_nbr][j][k] - 1) if h[site_nbr][j][k] > 0 else J[l,i,j,k] * (2*h[site_nbr][j][k] + 1) for l, site_nbr in enumerate(site_nbrs)]
        total_spin[1] = -np.sum(interacting_spins)
        total_spin[0] = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += total_spin[0]
          priorities[i*N+j+k%N][1] -= total_spin[1]
        else:
          priorities[i*N+j+k%N][0] -= total_spin[0]
          priorities[i*N+j+k%N][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.04857700000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((k-1)%2 - 1)) % N]
        site_nbrs_z = [(i + ((j-1)%2 - 1)) % N]

        total_spin_x = np.sum([h[site][k] for site in site_nbrs_x])
        total_spin_y = np.sum([h[i][site][k] for site in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site] for site in site_nbrs_z])

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x - total_spin_y - total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  for i in range(N):
    for j in range(N):
      total_spin = np.zeros(2)
      site_nbr_x = (i + ((N-1)%2 - 1)) % N
      site_nbr_y = (j + ((N-1)%2 - 1)) % N

      total_spin[0] += h[i][site_nbr_y][0]
      total_spin[0] += h[site_nbr_x][j][0]

      if h[i][j][0] > 0:
        priorities[i*N**2 + j*N][0] += total_spin[0]
        priorities[i*N**2 + j*N][1] = -priorities[i*N**2 + j*N][0]
      else:
        priorities[i*N**2 + j*N][0] -= total_spin[0]
        priorities[i*N**2 + j*N][1] = -priorities[i*N**2 + j*N][0]

  return priorities


#score: {'data3D.txt': -0.21306860000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((N-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        site_nbr_z = [(i + ((N-1)%2 - 1)) % N, (i + ((k-1)%2 - 1)) % N]
        
        total_spin_x = np.sum([h[site_nbr][k] for site_nbr in site_nbrs_x])
        total_spin_y = np.sum([h[i][site_nbr][k] for site_nbr in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site_nbr] for site_nbr in site_nbr_z])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
          
  return priorities


#score: {'data3D.txt': -0.0021414000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = total_spin + sum(interacting_spins)
        priorities[i*N+j*k][0] = priority_total
        if site_magnetism > 0:
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.0034662000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0021994000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = (total_spin + interacting_spins) / 2
          priorities[i*N+j*k][1] = -spin_diff
        else:
          priorities[i*N+j*k][0] = -(total_spin + interacting_spins) / 2
          priorities[i*N+j*k][1] = spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0032534}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + 3*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0022613999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 1 + total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] = -1 + total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0006622000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 1
          total_spin[i*N+j*N+k][1] -= 1
        else:
          total_spin[i*N+j*N+k][0] -= 1
          total_spin[i*N+j*N+k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][1]

  return(priorities)


#score: {'data3D.txt': 0.0013521999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][1]
  return(priorities)


#score: {'data3D.txt': -0.21514300000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -1 - total_spin
          priorities[i*N**2 + j*N + k][1] = 1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.00028700000000000063}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i - 1) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_y = (j - 1) % N
        if h[i][site_nbr_y][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_z = (i - 1) % N
        if h[site_nbr_z][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': -0.0016062}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities


#score: {'data3D.txt': -0.006596999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in [-1, 0, 1]:
          site_nbr_x = (i + x) % N
          if h[site_nbr_x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in [-1, 0, 1]:
          site_nbr_y = (j + y) % N
          if h[i][site_nbr_y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in [-1, 0, 1]:
          site_nbr_z = (i + z) % N
          if h[site_nbr_z][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin + 1
          priorities[i*N**2 + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin - 1
          priorities[i*N**2 + j*N + k][1] = total_spin + 1
  
  return priorities


#score: {'data3D.txt': -0.002399000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum)
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) - priority_sum
  return(priorities)


#score: {'data3D.txt': -0.0011158000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -priority_sum + total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -priority_sum - total_spin[0]
          priorities[i*N+j+k%N][1] = priority_sum - total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0024002000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) - total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0015374}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        priority_sum = sum([x if h[i][j][k] > 0 else -x for x in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + priority_sum + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) + priority_sum - total_spin[0])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) - priority_sum - total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) + priority_sum - total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0017270000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = 1 + total_spin
        priority_down = -1 - spin_diff
        priorities[i*N+j*k][0] = max(0, priority_up)
        priorities[i*N+j*k][1] = max(0, priority_down)
  return(priorities)


#score: {'data3D.txt': -0.002521400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = spin_diff
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = -spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0008838000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 3 * total_spin
          priorities[i*N+j*k][1] = -1 - spin_diff
        else:
          priorities[i*N+j*k][0] = -3 * total_spin
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.002245}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum((h[i][j][k] if h[site][j][k] > 0 else -1) * (1 if h[site][j][k] == h[i][j][k] else -1) for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -spin_diff
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0017054000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + interacting_spins_sum - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0025050000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = np.sum(h[(i + ((k-1)%2 - 1)) % N, j, :], axis=0)
        interacting_spins = np.sum(J[:, i, j, k], axis=0)
        
        total_spin = np.dot(site_nbr_sum, interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0026601999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum
  return(priorities)


#score: {'data3D.txt': 0.0007705999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr_x = (i // N**2 % N - 1) % N
    site_nbr_y = ((i // N) % N - 1) % N
    site_nbr_z = (i % N - 1) % N
    
    total_spin = h[site_nbr_x][site_nbr_y][site_nbr_z]
    
    if total_spin > 0:
      priorities[i][0] += 3 - site_nbr_x - site_nbr_y - site_nbr_z
      priorities[i][1] -= 3 - site_nbr_x - site_nbr_y - site_nbr_z
    else:
      priorities[i][0] -= 3 - site_nbr_x - site_nbr_y - site_nbr_z
      priorities[i][1] += 3 - site_nbr_x - site_nbr_y - site_nbr_z
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i - 1) % N if i > 0 else N - 1
        site_nbr_y = (j - 1) % N if j > 0 else N - 1
        site_nbr_z = (k - 1) % N if k > 0 else N - 1
        
        total_spin += h[site_nbr_x][i][j] + h[i][site_nbr_y][k] + h[site_nbr_z][i][j]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities


#score: {'data3D.txt': 0.0006549999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr_x = (i//N//N + ((i%N)//N - 1)) % N
    site_nbr_y = ((i//N)%N + ((i%N) // N - 1)) % N
    site_nbr_z = (i//N % N + ((i%N-1)%N - 1)) % N
    
    if h[site_nbr_x][site_nbr_y][site_nbr_z] > 0:
      priorities[i][0] += 2
      priorities[i][1] -= 3
    else:
      priorities[i][0] -= 2
      priorities[i][1] += 3
    
  return priorities


#score: {'data3D.txt': -0.00028700000000000063}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i - 1) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_y = (j - 1) % N
        if h[i][site_nbr_y][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr_z = (i - 1) % N
        if h[site_nbr_z][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N**2 + j*N + k][0] = total_spin + abs(total_spin)
        priorities[i*N**2 + j*N + k][1] = -total_spin + abs(total_spin)

  return priorities


#score: {'data3D.txt': -0.0008797999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
          site = site_nbrs[l]
          if abs(h[i][j][k]) == abs(h[site][j][k]):
            total_spin[0] += 2*J[l,i,j,k]
          elif h[i][j][k] * h[site][j][k] > 0:
            total_spin[0] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
  return(priorities)


#score: {'data3D.txt': -0.0025098000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        priorities[i*N+j+k%N] = [total_spin[0], -total_spin[1]]
      for k in range(N):
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin = [1, 0]
        else:
          total_spin = [-1, 0]
        priorities[i*N+j+k%N][0] += total_spin[0]
        priorities[i*N+j+k%N][1] -= total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0017130000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
          total_spin[0] += interacting_spin
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[1] += J[l,i,j,k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = sum(total_spin)
          priorities[i*N+j+k%N][1] -= total_spin[0]
        else:
          priorities[i*N+j+k%N][0] = -sum(total_spin)
          priorities[i*N+j+k%N][1] = -total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.3109617999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        for m in range(3):
          site_nbr = (i + ((m-1)%2 - 1)) % N if m == 0 else (j + ((m-1)%2 - 1)) % N if m == 1 else (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][i][j]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in [i, j, k] if (x+1) % N == site_nbr])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in [i, j, k] if (x-1) % N == site_nbr])
          priorities[i*N**2 + j*N + k][1] += len([x for x in [i, j, k] if (x+1) % N == site_nbr])
        
  return priorities


#score: {'data3D.txt': -0.3399837999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N

        total_spin += h[site_nbr_x][j][k]
        total_spin += h[i][site_nbr_y][k]
        total_spin += h[i][j][site_nbr_z]

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + len([x for x in [i, j, k] if (x-1) % N == site_nbr_x])
          priorities[i*N**2 + j*N + k][1] -= 1 - len([x for x in [i, j, k] if (x+1) % N == site_nbr_y]) - len([x for x in [i, j, k] if (x-1) % N == site_nbr_z])
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 - len([x for x in [i, j, k] if (x+1) % N == site_nbr_x])
          priorities[i*N**2 + j*N + k][1] += 1 + len([x for x in [i, j, k] if (x-1) % N == site_nbr_y]) + len([x for x in [i, j, k] if (x+1) % N == site_nbr_z])

  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N if m == 0 else (j+1)%N if m == 1 else (k+1)%N for m in range(3)]
        total_spin = sum(h[site_nbr][i][j] for site_nbr in site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in site_nbrs if x < i])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in site_nbrs if x > i])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in site_nbrs if x < i])
          priorities[i*N**2 + j*N + k][1] += len([x for x in site_nbrs if x > i])
  
  return priorities


#score: {'data3D.txt': -0.0023250000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1) + h[i][j][k]
          if h[i][j][k] > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = -(np.sum(interacting_spins) - total_spin[1])
        else:
          priorities[i*N+j+k%N][0] = -np.sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = np.sum(interacting_spins) - total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0023974}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
          if h[site_nbrs[l]][j][k] > 0:
            total_spin[1] -= J[l,i,j,k]
          else:
            total_spin[0] += J[l,i,j,k]
          interacting_spins.append(total_spin[0 - int(h[site_nbrs[l]][j][k] > 0)])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = sum(interacting_spins) + total_spin[1]
          priorities[i*N+j+k%N][1] = -sum(interacting_spins) - total_spin[1]
        else:
          priorities[i*N+j+k%N][0] = -sum(interacting_spins) + total_spin[0]
          priorities[i*N+j+k%N][1] = sum(interacting_spins) + total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0040838}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          interacting_spin = J[l, i, j, k] * (2*h[site_nbrs[l]][j][k] - 1)
          if h[i][j][k] > 0:
            priorities[i*N+j+k%N][0] += interacting_spin
            priorities[i*N+j+k%N][1] -= 1
          else:
            priorities[i*N+j+k%N][0] -= interacting_spin
            priorities[i*N+j+k%N][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0019766000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if (h[site_nbr][j][k] > 0) else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = site_nbr_sum + interacting_spins_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0017166000000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = 1 + total_spin
        priority_down = -1 - spin_diff
        priorities[i*N+j*k][0] = max(0, priority_up + interacting_spins)
        priorities[i*N+j*k][1] = max(0, priority_down - interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0028058000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + interacting_spins_sum - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0027458}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0033858000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [site_nbr1, site_nbr2])
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6) if l < 3)
        interacting_spins_sum += sum(J[l, i, j, k] for l in range(6) if l >= 3)
        total_spin += interacting_spins_sum
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [site_nbr1, site_nbr2])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - 2*interacting_spins_sum + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + 2*interacting_spins_sum - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0025337999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= 1 - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          for y in range(3):
            if h[site_nbr][j][(x+y)%3] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)


#score: {'data3D.txt': -0.0025337999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= 1 - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)


#score: {'data3D.txt': -0.0017626000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((k-1)%2 - 1)) % N, (i + (k+1)%N) % N])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N**3):
    site_nbr_x = (i//N//N + ((i%N)//N - 1)) % N
    site_nbr_y = ((i//N)%N + ((i%N) // N - 1)) % N
    site_nbr_z = (i//N % N + ((i%N-1)%N - 1)) % N

    total_spin = np.sum([h[site_nbr_x][j][k] for j in range(N) for k in range(N)])

    if h[i//N//N][i//N%N][i%N] > 0:
      priorities[i][0] += 2 + total_spin
      priorities[i][1] -= 3 - total_spin
    else:
      priorities[i][0] -= 2 - total_spin
      priorities[i][1] += 3 + total_spin

  return priorities


#score: {'data3D.txt': 0.001840599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((k-1)%2 - 1)) % N]
        site_nbrs_z = [(i + ((j-1)%2 - 1)) % N]

        total_spin_x = np.sum([h[site][k] for site in site_nbrs_x])
        total_spin_y = np.sum([h[i][site][k] for site in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site] for site in site_nbrs_z])

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((k-1)%2 - 1)) % N]
        site_nbrs_z = [(i + ((j-1)%2 - 1)) % N]

        total_spin_x = np.sum([h[site][k] for site in site_nbrs_x])
        total_spin_y = np.sum([h[i][site][k] for site in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site] for site in site_nbrs_z])

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= (total_spin_x + total_spin_y + total_spin_z) * 3
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]

  return priorities


#score: {'data3D.txt': -0.000921}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spins = np.zeros((N**3,))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] for _ in range(6)) + sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0018482000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] for _ in range(6))
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0029653999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros((N, N, N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin[i][j][k][0] += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin[i][j][k][1] = -total_spin[i][j][k][0]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += total_spin[i][j][k][0]
          priorities[i*N+j*k][1] = -total_spin[i][j][k][0]
        else:
          priorities[i*N+j*k][0] -= total_spin[i][j][k][0]
          priorities[i*N+j*k][1] = total_spin[i][j][k][0]
  return(priorities)


#score: {'data3D.txt': -0.0018742000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -9.999999999993348e-07}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr_x = (i // N**2 % N - 1) % N
    site_nbr_y = ((i // N) % N - 1) % N
    site_nbr_z = (i % N - 1) % N
    
    total_spin = h[site_nbr_x][site_nbr_y][site_nbr_z]
    
    if total_spin > 0:
      priorities[i][0] += np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
      priorities[i][1] -= np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N % N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
    else:
      priorities[i][0] -= np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N % N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
      priorities[i][1] += np.sum([J[k][i//N**2][((i//N)**N**(k%N)%N % N - 1) % N][(((i//N)**N**(k%N)%N-1)%N)] for k in range(3)])
  
  return priorities


#score: {'data3D.txt': -0.0027698}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2*total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] -= 2*total_spin - 2*interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 2*total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 2*total_spin - 2*interacting_spins_sum
  return(priorities)


#score: {'data3D.txt': -0.0022834000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + 1
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= total_spin + 1
          priorities[i*N+j*k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0026990000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin[0] += np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin[0]
          priorities[i*N+j+k%N][1] -= 1 - total_spin[0]
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
          priorities[i*N+j+k%N][1] = -1 - total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0018646000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        for m in range(6):
          if h[site_nbrs[m]][j][k] > 0:
            total_spin[1] -= J[m,i,j,k]
          else:
            total_spin[1] += J[m,i,j,k]
          total_spin[0] += -2 * J[m,i,j,k]
        total_spin[0] += h[i][j][k]
        for m in range(6):
          site_nbr = site_nbrs[m]
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += 1 + total_spin[0]
            priorities[i*N+j+k%N][1] -= 1 - total_spin[1]
          else:
            priorities[i*N+j+k%N][0] -= 1 + total_spin[0]
            priorities[i*N+j+k%N][1] = -1 - total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0026990000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for m in range(6):
          site_nbrs = [(i + ((m % 2) - 1)) % N]
          interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
          total_spin += np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += 1 + total_spin
          priorities[i*N+j+k%N][1] -= 1 - total_spin
        else:
          priorities[i*N+j+k%N][0] -= 1 + total_spin
          priorities[i*N+j+k%N][1] = -1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0271254}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        site_nbrs_y = [(j + ((N-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        site_nbr_z = [(i + ((N-1)%2 - 1)) % N, (i + ((k-1)%2 - 1)) % N]
        
        total_spin_x = np.sum([h[site_nbr][k] for site_nbr in site_nbrs_x])
        total_spin_y = np.sum([h[i][site_nbr][k] for site_nbr in site_nbrs_y])
        total_spin_z = np.sum([h[i][j][site_nbr] for site_nbr in site_nbr_z])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
          
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_x][j][k] + h[i][site_nbr_y][k] + h[i][j][site_nbr_z]
        
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] > 0]) - len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] < 0])
          priorities[i*N**2 + j*N + k][1] -= priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] > 0]) - len([site_nbr for site_nbr in [site_nbr_x, site_nbr_y, site_nbr_z] if h[site_nbr][j][k] < 0])
          priorities[i*N**2 + j*N + k][1] += priorities[i*N**2 + j*N + k][0]
          
  return priorities


#score: {'data3D.txt': 0.0005897999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((j-1)%2 - 1)) % N
        
        total_spin_x = h[site_nbr_x][j][k]
        total_spin_y = h[i][site_nbr_y][k]
        total_spin_z = h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin_x + total_spin_y + total_spin_z
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  return priorities


#score: {'data3D.txt': -0.0178806}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0095574}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.008441}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] = -total_spin[0][j][k][0]
  return(priorities)


#score: {'data3D.txt': -0.0031022000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[i][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1 - interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = -1 + interacting_spins - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0178806}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return priorities


#score: {'data3D.txt': -0.0178806}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        for l in range(3):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
  return(priorities)


#score: {'data3D.txt': -0.0022833999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        total_spin[0] += -2*np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] -= 1
          priorities[i*N+j+k%N][1] += 1
        else:
          priorities[i*N+j+k%N][0] += 1
          priorities[i*N+j+k%N][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0018086}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            priorities[i*N+j+k%N][0] += interacting_spin
            priorities[i*N+j+k%N][1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            priorities[i*N+j+k%N][0] -= interacting_spin
            priorities[i*N+j+k%N][1] += interacting_spin
  return(priorities)


#score: {'data3D.txt': -0.0016253999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin = [0, 0]
        interacting_spins = []
        for l in range(6):
          if h[site_nbrs[l]][j][k] > 0:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] - 1)
            total_spin[1] -= interacting_spin
          else:
            interacting_spin = J[l,i,j,k] * (2*h[site_nbrs[l]][j][k] + 1)
            total_spin[0] += interacting_spin
          interacting_spins.append(interacting_spin)
        for m in range(6):
          site_nbr = (i + ((m % 3) - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j+k%N][0] += np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] -= np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
          else:
            priorities[i*N+j+k%N][0] -= np.sum([x if h[site_nbrs[m]][j][k] > 0 else -x for x in interacting_spins])
            priorities[i*N+j+k%N][1] = -np.sum([x if h[site_nbrs[m]][j][k] < 0 else -x for x in interacting_spins])
        total_spin[0] += np.sum([-2*J[l,i,j,k] for l in range(6)])
        if np.mean(h[i].flatten()) > 0:
          priorities[i*N+j+k%N][0] += np.sum([1 if h[i][j][k] > 0 else -1 for j in range(N) for k in range(N)])
          priorities[i*N+j+k%N][1] -= np.sum([1 if h[i][j][k] < 0 else -1 for j in range(N) for k in range(N)])
        else:
          priorities[i*N+j+k%N][0] -= np.sum([1 if h[i][j][k] > 0 else -1 for j in range(N) for k in range(N)])
          priorities[i*N+j+k%N][1] = -np.sum([1 if h[i][j][k] < 0 else -1 for j in range(N) for k in range(N)])
  return(priorities)


#score: {'data3D.txt': -0.2869110000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] -= np.sum([J[l, i, j, k] for l in [1, 4]])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N**2 + j*N + k][1] += np.sum([J[l, i, j, k] for l in [1, 4]])
        
  return priorities


#score: {'data3D.txt': -0.31795419999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        total_spin = np.sum([h[site_nbr][k] for site_nbr in site_nbrs])
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += len(site_nbrs) + total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= len(site_nbrs) - total_spin
          priorities[i*N**2 + j*N + k][1] = -priorities[i*N**2 + j*N + k][0]
        
        for l in range(6):
          if J[l, i, j, k] > 0:
            if h[i][j][k] > 0:
              priorities[i*N**2 + j*N + k][0] += 1
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][0] -= 1
              priorities[i*N**2 + j*N + k][1] += 1
          
  return priorities


#score: {'data3D.txt': -0.18127899999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = 0
        total_spin_y = 0
        total_spin_z = 0
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin_x += 1
        else:
          total_spin_x -= 1
          
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        if h[i][site_nbr_y][k] > 0:
          total_spin_y += 1
        else:
          total_spin_y -= 1
          
        site_nbr_z = (i + ((k-1)%2 - 1)) % N
        if h[i][j][site_nbr_z] > 0:
          total_spin_z += 1
        else:
          total_spin_z -= 1
        
        priorities[i*N**2 + j*N + k][0] = total_spin_x + total_spin_y + total_spin_z + abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)
        priorities[i*N**2 + j*N + k][1] = -total_spin_x - total_spin_y - total_spin_z + abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)
  
  return priorities


#score: {'data3D.txt': -0.0021914000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k] + 2 * np.sum(total_spin1)
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k] + 2 * np.sum(total_spin1)
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)


#score: {'data3D.txt': -0.0023506}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k] + 5 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k] - 5 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)


#score: {'data3D.txt': -0.0021914000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        total_spin0 = 0
        total_spin1 = 0
        for m in range(6):
          interacting_spin = J[m, i, j, k] * (2*h[site_nbrs[m]][j][k] - 1)
          if h[site_nbrs[m]][j][k] > 0:
            total_spin1 -= J[m, i, j, k]
          else:
            total_spin1 += J[m, i, j, k]
          total_spin0 += -2 * J[m, i, j, k]
        site_nbr = (i + ((2-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] = total_spin0 + 3 * J[4, i, j, k] + 2 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 - 2 * J[5, i, j, k]
        else:
          priorities[i*N+j+k%N][0] = total_spin0 - 3 * J[4, i, j, k] + 2 * total_spin1
          priorities[i*N+j+k%N][1] = -total_spin1 + 2 * J[5, i, j, k]
  return(priorities)


#score: {'data3D.txt': -0.0024322000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        total_spin -= 2 * interacting_spins
        spin_diff -= 2 * sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin
          priorities[i*N+j*k][1] = -spin_diff
        else:
          priorities[i*N+j*k][0] = -total_spin
          priorities[i*N+j*k][1] = spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0022642}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 3 * total_spin + spin_diff
          priorities[i*N+j*k][1] = -1 - 2 * spin_diff
        else:
          priorities[i*N+j*k][0] = -3 * total_spin - spin_diff
          priorities[i*N+j*k][1] = 1 + 2 * spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0029998000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        site_nbrs_sum = sum(sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)]) for _ in range(6))
        interacting_spins_sum -= site_nbrs_sum
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = -1 - (1 + total_spin + interacting_spins_sum)
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 1 - (1 + total_spin + interacting_spins_sum)
  return(priorities)


#score: {'data3D.txt': -0.0012109999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 3) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.002069}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += (total_spin + np.sum([x if x > 0 else -1 for x in interacting_spins])) + 1
          priorities[i*N+j+k%N][1] -= (total_spin + np.sum([x if x < 0 else -1 for x in interacting_spins])) - 1
        else:
          priorities[i*N+j+k%N][0] -= (total_spin + np.sum([x if x > 0 else -1 for x in interacting_spins])) + 1
          priorities[i*N+j+k%N][1] = -(total_spin + np.sum([x if x < 0 else -1 for x in interacting_spins])) - 1
  return(priorities)


#score: {'data3D.txt': -0.0020558000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((m % 2) - 1)) % N for m in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N+j+k%N][0] += np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] -= np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
        else:
          priorities[i*N+j+k%N][0] -= np.sum([x if x > 0 else -1 for x in interacting_spins]) + total_spin
          priorities[i*N+j+k%N][1] = -np.sum([x if x < 0 else -1 for x in interacting_spins]) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.002285}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)]]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0025838000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(1 if h[i][j][k] > 0 else -1 for _ in range(6)), 
                  -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.004045400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0027826000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = []
      interacting_spins = []
      total_spin = 0
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          interacting_spins.append(1)
        else:
          interacting_spins.append(-1)
        total_spin += h[i][j][k]
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j, k] > 0:
          total_spin -= interacting_spins[k]
      priority_total = [total_spin, -total_spin]
      priorities[i*N+j*N+N-1] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0034902000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for _ in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= interacting_spins + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = interacting_spins - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0023882000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1 - interacting_spins + total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = -1 + interacting_spins - total_spin
  return(priorities)


#score: {'data3D.txt': -0.005760600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          
  return(priorities)


#score: {'data3D.txt': -0.003230600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0049998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 3
        else:
          total_spin[i*N+j*N+k][0] -= 3

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][0]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][0]

  return(priorities)


#score: {'data3D.txt': -0.005279400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.006683400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
          total_spin = 0
          for d in range(3):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          total_spin = 0
          for d in range(3):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin -= 1
            else:
              total_spin += 1
          priorities[i*N+j*N+k][0] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.0016858000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(1,N):
    for j in range(1,N):
      for k in range(1,N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+N+k][0] += 1
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N*j+N+k][0] -= 1
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.005343400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = lambda i, j, k: ((i + (k-1)%2 - 1)) % N

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:, i, j, k])

  return(priorities)


#score: {'data3D.txt': -0.008369800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.0032534}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin + 3*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0026022000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbr_sum = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin * (1 + sum(J[l,i,j,k] for l in range(6)))
          priorities[i*N+j*k][1] -= -total_spin + site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= total_spin * (1 + sum(J[l,i,j,k] for l in range(6)))
          priorities[i*N+j*k][1] = -total_spin - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0038838000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] -= -site_nbr_sum - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] = -site_nbr_sum + 3*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if (h[site_nbr][j][k] > 0) else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] if J[l, i, j, k] > 0 else -1 for l in range(6))
        total_spin = site_nbr_sum + interacting_spins_sum
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*N+k][0] += 1 + total_spin
        priorities[i*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if (h[site_nbr][j][k] > 0) else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] if J[l, i, j, k] > 0 else -1 for l in range(6))
        total_spin = site_nbr_sum + interacting_spins_sum
        for site_nbr_sum_val in [site_nbr_sum]:
          priority_total = [total_spin + site_nbr_sum_val, -total_spin - site_nbr_sum_val]
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0171698}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(J[l, (i + ((l-1)%2 - 1)) % N, j, k] if J[l, (i + ((l-1)%2 - 1)) % N, j, k] > 0 else -J[l, (i + ((l-1)%2 - 1)) % N, j, k] for l in range(6))
        total_spin = site_nbr_sum + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1 + total_spin
          priorities[i*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0026166}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin - interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin + interacting_spins_sum
  return(priorities)


#score: {'data3D.txt': -0.0028182000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins_sum
          priorities[i*N+j*k][1] -= 2 * site_nbr_sum - 2 * interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum - interacting_spins_sum
          priorities[i*N+j*k][1] = 2 * site_nbr_sum + 2 * interacting_spins_sum
  return(priorities)


#score: {'data3D.txt': -0.0026822000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + 1
          priorities[i*N+j*k][1] -= interacting_spins_sum - site_nbr_sum - 1
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum + 1
          priorities[i*N+j*k][1] = interacting_spins_sum - site_nbr_sum + 1
  return(priorities)


#score: {'data3D.txt': -0.0018969999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins_sum
          priorities[i*N+j*k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0023769999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1
            else:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
            else:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.0014010000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])
          
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0031582000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          for y in range(3):
            for z in range(3):
              site = (i + ((x-1)%2 - 1)) % N
              if h[i][j][k] > 0:
                total_spin += J[(((x+y+z)-3)//2)%6, i, j, k]
              else:
                total_spin -= J[(((x+y+z)-3)//2)%6, i, j, k]

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0017905999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        for x in range(3):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          else:
            priorities[i*N+j*N+k][0] -= np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = -priorities[i*N+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': -0.007495}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = float('-inf')
        else:
          priorities[i*N+j*N+k][0] = -2*(N**3-total_spin-1)*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for l in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][l][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)


#score: {'data3D.txt': -0.008369800000000002}
program:
def priority(N, h, J):
  priorities = [[0.0,0.0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.011892199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.016707}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][l][k] for l in range(3))
        priorities[i*N+j*N+k][0] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.0020893999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if any(h[site][j][k] > 0 for site in site_nbrs):
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] += 1
        else:
          priorities[i*N+j*N+k][1] -= 1
  return(priorities)


#score: {'data3D.txt': 0.0052606}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(J[:,site_nbr,j,k]) * h[site_nbr][j][k]
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.0143014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site][j][k] for site in [i, site_nbr])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 2*total_spin*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 2*total_spin*np.sum(J[:, i, j, k])
  return(priorities)


#score: {'data3D.txt': -0.0026846000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          site_nbrs.append((site_nbr, d))
        priorities[i*N+j*N+k][0] = -total_spin
        for site_nb in site_nbrs:
          if h[site_nb[0]][j][k] > 0:
            priorities[i*N+j*N+k][0] += 1
          else:
            priorities[i*N+j*N+k][0] -= 1
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][1] -= J[l,i,j,k]
          else:
            priorities[i*N+j*N+k][1] += J[l,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.0025838000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(1 if h[i][j][k] > 0 else -1 for _ in range(6)), 
         -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = -total_spin
        priorities[i*N+j+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0028450000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        total_spin = h[site_nbr1][j][k] if k == 0 else h[site_nbr2][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1 + 2*interacting_spins - total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = -1 + 2*interacting_spins - total_spin
  return(priorities)


#score: {'data3D.txt': 0.0022542}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      total_spin[0] += J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]]*h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)


#score: {'data3D.txt': -0.0022614}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = -total_spin
        site_nbr2 = (i + ((k-1)%2 - 1)) % N
        for m in range(N):
          if J[3][site_nbr][m][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0040154}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 4*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 4*np.sum(J[:,i,j,k])
        
  return(priorities)


#score: {'data3D.txt': -0.013463000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
        
        # calculate the priority for assigning spins to -1 and 1
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin**2
          priorities[i*N+j*N+k][1] -= (total_spin+1)**2
        else:
          priorities[i*N+j*N+k][0] -= (total_spin-1)**2
          priorities[i*N+j*N+k][1] += total_spin**2
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for x in range(3):
          if h[i][(x+1)%N][((k+1)%2)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        priorities[i*N+j*N+k][1] = float('-inf')
  return(priorities)


#score: {'data3D.txt': -0.0023838}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = total_spin * np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = -np.sum(J[:,i,j,k]) * (total_spin + 1)
        else:
          priorities[i*N+j*N+k][0] = -(total_spin + 1) * np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = -np.sum(J[:,i,j,k]) * total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.007283799999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)


#score: {'data3D.txt': 0.0022542}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      neighbor_sites = []
      if (site_nbr[0] == 0 or site_nbr[0] == N-1):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      if (site_nbr[1] == 0 or site_nbr[1] == N-1):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      if (site_nbr[2] == 0 or site_nbr[2] == N-1):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      for k in range(len(neighbor_sites)):
        total_spin[0] += J[j][neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]*h[neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)


#score: {'data3D.txt': -0.0064789999999999995}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)


#score: {'data3D.txt': -0.002607000000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(2):
      priorities[i][j] = -total_spin[j]
  return(priorities)


#score: {'data3D.txt': -0.0022478000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l, i, j, k] + (np.roll(h, -1, axis=l)[site_nbrs[0]][j][k] if l < 3 else np.roll(h, 1, axis=l-3)[site_nbrs[0]][j][k]) for l in range(6)]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2 + total_spin
          priorities[i*N+j*k][1] = -4 - spin_diff
        else:
          priorities[i*N+j*k][0] -= 2 + total_spin
          priorities[i*N+j*k][1] = 4 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0022478000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = sum(J[l,i,j,k] if (l < 3 and site_nbr == i) or (l >= 3 and site_nbr == (i+1)%N) else 0 for l,site_nbr in zip(range(6),site_nbrs))
        total_spin = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        spin_diff = total_spin + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2 + spin_diff
          priorities[i*N+j*k][1] -= 3 - spin_diff
        else:
          priorities[i*N+j*k][0] -= 2 - spin_diff
          priorities[i*N+j*k][1] = 1 + spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0031598000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins + total_spin
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = 2*interacting_spins - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0019682}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0030886000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = -total_spin
          priorities[i*N+j*k][1] += 1
        else:
          priorities[i*N+j*k][0] = total_spin
          priorities[i*N+j*k][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.001739}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] for _ in range(6))
        for l, interacting_spin in enumerate(interacting_spins):
          total_spin += J[l, i, j, k]*interacting_spin
        if total_spin > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.002607000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0026414}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])
          
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.005998200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate total spin and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.009281000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (site + ((y-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_spin += np.sum(J[:,site,j,k])
            else:
              total_spin -= np.sum(J[:,site,j,k])
          
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.004881800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        # Add magnetism and interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
            total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0033862}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0064789999999999995}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0019385999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] = -(total_spin+interacting_spins)
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = 1 + (total_spin+interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0016726000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = 2 + total_spin
          priorities[i*N+j*k][1] = -2 - spin_diff
        else:
          priorities[i*N+j*k][0] = -2 + total_spin
          priorities[i*N+j*k][1] = 2 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0016726000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] if h[site][j][k] > 0 else -1 for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site][j][k] if h[i][j][k] > 0 else -1 - h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = sum(1 for _ in range(N)) + total_spin
          priorities[i*N+j*k][1] = -sum(1 for _ in range(N)) - spin_diff
        else:
          priorities[i*N+j*k][0] = -sum(1 for _ in range(N)) + total_spin
          priorities[i*N+j*k][1] = sum(1 for _ in range(N)) - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0038721999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N] + [(i + (k+1)%N) % N]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in site_nbrs)
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k]>0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(h[i][l][k] if h[i][l][k]>0 else -1 for l in range(N)), -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0017458000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        priority_total = [total_spin + interacting_spins, -total_spin - interacting_spins]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2
          priorities[i*N+j*k][1] -= 2
        else:
          priorities[i*N+j*k][0] -= 2
          priorities[i*N+j*k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.002741}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins_site = [J[l, i, j, k] if J[l, i, j, k]>0 else -1 for l in range(6)]
        interacting_spins = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin += h[site_nbr][j][k]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin - interacting_spins
          priorities[i*N+j*k][1] = 2*interacting_spins - 1
  return(priorities)


#score: {'data3D.txt': -0.0035954000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site) else h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        total_spin[0] += h[i][j][k]
        total_spin[1] -= h[i][j][k]
        if site_nbr_sum > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        elif site_nbr_sum < 0:
          total_spin[0] -= 1
          total_spin[1] += 1
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin[0]
          priorities[i*N+j*k][1] = -total_spin[1]
        else:
          priorities[i*N+j*k][0] = -total_spin[0]
          priorities[i*N+j*k][1] = total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0049366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k] + h[i][site_nbr2][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
        
        # Calculate total spin for sites with the same z-coordinate as site (i,j)
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,site,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.008369800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += np.sum(J[:,i,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.001957400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr1 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + h[i][site_nbr1][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0029598000000000003}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0033862}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbrs = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbrs = [site_nbrs[0], site_nbrs[1], (j+1)%3]
      total_spin[0] += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0033446}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  total_spin = [0.0] * 2
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0033862}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Add the magnetism and interaction energy to the priority
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0025166000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] = -(total_spin + interacting_spins) - spin_diff
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0026634000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + site_nbr_sum
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -2 * (h[i][j][k] <= 0) for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = -total_spin - interacting_spins_sum
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins_sum
          priorities[i*N+j*k][1] = 1 - spin_diff
  return(priorities)


#score: {'data3D.txt': -0.0022906000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        spin_sum = total_spin + spin_diff
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 2 * spin_sum + interacting_spins
          priorities[i*N+j*k][1] -= 2 * spin_sum - 2 * interacting_spins
        else:
          priorities[i*N+j*k][0] -= 2 * spin_sum + interacting_spins
          priorities[i*N+j*k][1] = 2 * spin_sum - 2 * interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0032166}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority for each site based on total spin and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or \
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] + \
                   interacting_spins[1][site_nbr_ij][k] + \
                   interacting_spins[2][j][site_nbr_ij]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -priorities[i][0]
    priorities[i][1] = -priorities[i][1]
  
  return(priorities)


#score: {'data3D.txt': -0.0044142}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = [(i//N)%N,(i%N//N)%N,(i%N)%N]
  for i in range(N**3):
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)


#score: {'data3D.txt': -0.0064789999999999995}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': 0.0022542}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      neighbor_sites = []
      if (site_nbr[0] == 0 or site_nbr[0] == N-1) and (j < 3):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      if (site_nbr[1] == 0 or site_nbr[1] == N-1) and (j >= 3):
        neighbor_sites.append([site_nbr[0],site_nbr[1],site_nbr[2]])
      for k in range(len(neighbor_sites)):
        total_spin[0] += J[j][neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]*h[neighbor_sites[k][0]][neighbor_sites[k][1]][neighbor_sites[k][2]]
        if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0038457999999999995}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site_nbr = [(i+((k-1)%2 - 1))%N,(i%N//N)%N,i%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      for k in range(8):
        if k < 4:
          total_spin[0] += J[j][site_nbr[0]][(site_nbr[1]+k%2-N//2)%N][(site_nbr[2]+k%2-N//2)%N]*h[(site_nbr[0]+k%2-N//2)%N][(site_nbr[1]+k%2-N//2)%N][k%2]
        else:
          total_spin[1] -= J[j][site_nbr[0]][(site_nbr[1]+k%2-N//2)%N][(site_nbr[2]+k%2-N//2)%N]*h[(site_nbr[0]+k%2-N//2)%N][(site_nbr[1]+k%2-N//2)%N][k%2]
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)


#score: {'data3D.txt': -0.005343400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.010131800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 3
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 3
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': 0.007420199999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin + 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= total_spin - 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0418206}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr_k][j][i]
        for l in range(6):
          if J[l, k, j, i] > 0:
            total_spin += -J[l, k, j, i]
          else:
            total_spin -= J[l, k, j, i]
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr_ij = (i + ((k-1)%2 - 1)) % N
        interacting_spin = (
          h[site_nbr_ij][j][k] +
          J[0][site_nbr_ij][j][k]*h[(site_nbr_ij+1)%N][j][k] +
          J[1][i][j][k]*h[i][(j+1)%N][k] +
          J[2][i][j][k]*h[i][j][(k+1)%N]
        )
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      site_nbr_j = (j + ((2-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((1-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] +\
                  interacting_spins[1][site_nbr_ij][k] +\
                  interacting_spins[2][j][site_nbr_ij]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0064789999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbrs = [(i//N)%N,(i%N//N)%N,j]
      total_spin[0] += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0019410000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j+k][0] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0025518}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] -= 1 - total_spin[0]
        priorities[i][1] = -total_spin[1]
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] += 1 + total_spin[0]
        priorities[i][1] -= 1
    return(priorities)


#score: {'data3D.txt': -0.011540600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr[0]]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = total_spin + sum(interacting_spins)
        priorities[i*N+j*k][0] = np.exp(site_magnetism * (2*priority_total))
        priorities[i*N+j*k][1] = -priorities[i*N+j*k][0]
  return(priorities)


#score: {'data3D.txt': -0.0020710000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        site_magnetism = h[i][j][k]
        priority_total = np.sum(interacting_spins)
        if site_magnetism > 0:
          priorities[i*N+j*k][0] = priority_total
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][0] = -priority_total
          priorities[i*N+j*k][1] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0024246}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = (total_spin + sum(interacting_spins)) * site_magnetism
        priorities[i*N+j*k][0] = priority_total
        if site_magnetism > 0:
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.0026509999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [J[l][site_nbrs[l]][j,k] if h[site_nbrs[l]][j][k] > 0 else -J[l][site_nbrs[l]][j,k] for l in range(6)]
        total_spin = sum([1 if h[site_nbrs[l]][j][k] > 0 else -1 for l in range(6)])
        site_magnetism = h[i][j][k]
        priority_total = total_spin + sum(interacting_spins)
        if site_magnetism > 0:
          priorities[i*N+j*k][0] = priority_total
          priorities[i*N+j*k][1] = -priority_total
        else:
          priorities[i*N+j*k][0] = -priority_total
          priorities[i*N+j*k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.0016338000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins_sum = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin += interacting_spins_sum
        priority_total = [total_spin, -total_spin]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + sum(a>0 for a in priority_total)
          priorities[i*N+j*k][1] -= 1 - sum(1-a for a in priority_total)
        else:
          priorities[i*N+j*k][0] -= 1 + sum(a>0 for a in priority_total)
          priorities[i*N+j*k][1] = 1 - sum(1-a for a in priority_total)
  return(priorities)


#score: {'data3D.txt': -0.0018742000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        interacting_spins_sum = sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        total_spin += interacting_spins_sum
        priority_total = [total_spin, -total_spin]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0023453999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs), 
                  -total_spin - sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.002421000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        priority_total = [total_spin + len([x for x in interacting_spins_site if x > 0]), -total_spin - len([x for x in interacting_spins_site if x < 0])]
        priorities[i*N+j*k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0024390000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        h_site = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        J_site = sum(J[l, i, j, k]*h[site_nbr][j][k] for l, site_nbr in enumerate(site_nbrs))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = h_site + J_site
          priorities[i*N+j*k][1] = -h_site - J_site
        else:
          priorities[i*N+j*k][0] = -h_site - J_site
          priorities[i*N+j*k][1] = h_site + J_site
  return(priorities)


#score: {'data3D.txt': -0.0018782000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        total_spin += sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = 1 + total_spin
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] = -1 + total_spin
          priorities[i*N+j*k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0018782000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_site = [h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs]
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6)) + sum(J[l, i, j, k]*interacting_spin for l, interacting_spin in enumerate(interacting_spins_site))
        if sum(h[i][j][k] for _ in range(6)) > 0:
          priorities[i*N+j*k][0] = 1 + total_spin
          priorities[i*N+j*k][1] = -total_spin
        else:
          priorities[i*N+j*k][0] = -1 + total_spin
          priorities[i*N+j*k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0010029999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  # Calculate magnetization and interaction energies
  total_spin_magnetism = np.zeros((N,N,N,2))
  for i in range(N):
   for j in range(N):
    for k in range(N):
     site_nbr = (i + ((k-1)%2 - 1)) % N
     total_spin_magnetism[i][j][k] = [h[site_nbr][j][k], np.sum(J[:,i,j,k])]
  
  # Calculate priorities based on magnetization and interaction energies
  for i in range(N):
   for j in range(N):
    for k in range(N):
     total_spin_magnetism[i][j][k][0] += h[i][j][k]
     if h[i][j][k] > 0:
      priorities[i*N+j*N+k][0] = -total_spin_magnetism[i][j][k][1]
      priorities[i*N+j*N+k][1] += total_spin_magnetism[i][j][k][1]
     else:
      priorities[i*N+j*N+k][0] = total_spin_magnetism[i][j][k][1]
      priorities[i*N+j*N+k][1] -= total_spin_magnetism[i][j][k][1]
  
  return(priorities)


#score: {'data3D.txt': -0.0023742}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  # Calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  # Calculate final priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.0026414}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0031098000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(1,N-1):
    for j in range(1,N-1):
      for k in range(1,N-1):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site_x = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_x,j,k])
          else:
            total_spin -= np.sum(J[:,site_x,j,k])
        
        for y in range(3):
          site_y = (i + ((y-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,site_y,k])
          else:
            total_spin -= np.sum(J[:,i,site_y,k])
        
        for z in range(3):
          site_z = (i + ((z-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,site_z])
          else:
            total_spin -= np.sum(J[:,i,j,site_z])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+N+k][0] = -total_spin
          priorities[i*N*j+N+k][1] += total_spin
        else:
          priorities[i*N*j+N+k][0] = total_spin
          priorities[i*N*j+N+k][1] -= total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0004918000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(1,N):
    for j in range(1,N):
      for k in range(1,N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.001957400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr1 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + h[i][site_nbr1][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          if x == 0:
            site = (i + ((x-1)%2 - 1)) % N
          elif x == 1:
            site = (j + ((x-1)%2 - 1)) % N
          else:
            site = (k + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.001957400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr1 = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + h[i][site_nbr1][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.005760600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          total_spin += h[site][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.0038838000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] -= -site_nbr_sum - 3*interacting_spins
        else:
          priorities[i*N+j*k][0] -= site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] = -site_nbr_sum + 3*interacting_spins

  return(priorities)


#score: {'data3D.txt': -0.0038838000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
          interacting_spins = sum(J[l,i,j,k] for l in range(6))
          priorities[i*N+j*k][0] += site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] -= -site_nbr_sum - 3*interacting_spins
        else:
          site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
          interacting_spins = sum(J[l,i,j,k] for l in range(6))
          priorities[i*N+j*k][0] -= site_nbr_sum + interacting_spins
          priorities[i*N+j*k][1] = -site_nbr_sum + 3*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0034578}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site][j][k] if (i == site and l > 0) or (l == N-1 and i == site) else h[site][j][k] for site, l in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        interacting_spins = sum(J[l,i,j,k] for l in range(6))
        total_spin = site_nbr_sum + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin + interacting_spins
          priorities[i*N+j*k][1] -= -total_spin + 2*interacting_spins
        else:
          priorities[i*N+j*k][0] -= total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0019370000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (i + (k+1)%N) % N
        for l in range(6):
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
          else:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
        priority_total = total_spin + interacting_spins
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = priority_total + abs(total_spin) * 2
          priorities[i*N+j*k][1] = -priority_total - 4*abs(total_spin)
        else:
          priorities[i*N+j*k][0] = -priority_total - 2*interacting_spins
          priorities[i*N+j*k][1] = priority_total + 4*abs(total_spin) - interacting_spins
  return(priorities)


#score: {'data3D.txt': 0.006143399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    total_spin = 0
    for k in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N//N][i%N%N] > 0:
        total_spin += J[k, site_nbr, i%N//N, i%N%N]
      else:
        total_spin -= J[k, site_nbr, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spin = np.sum(J[:,site_nbr,j,k])
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin + interacting_spin
          priorities[i*N+j*N+k][1] -= total_spin - interacting_spin
        else:
          priorities[i*N+j*N+k][0] -= total_spin - interacting_spin
          priorities[i*N+j*N+k][1] += total_spin + interacting_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((k+1)%2 - 1)) % N]
        total_spin = np.sum(J[:,site_nbrs[0],j,k]) * h[site_nbrs[0]][j][k] - np.sum(J[:,site_nbrs[1],j,k]) * h[site_nbrs[1]][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.007443000000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    for j in range(3):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[i][0] = -total_spin[1]
    priorities[i][1] = -total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0008774000000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  total_spin = [0, 0]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    if J[0][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] -= -total_spin[1]
    elif J[0][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1]
    else:
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': 0.0025758000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(N):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    for j in range(3):
      site_nbr = [site_nbr[0], site_nbr[1], (j+1)%3]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0021474000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins_sum + total_spin - site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = -2*interacting_spins_sum - total_spin + site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0020434000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins_sum + total_spin - site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = 2*interacting_spins_sum - total_spin + site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0034966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2*interacting_spins_sum - site_nbr_sum
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = 2*interacting_spins_sum - site_nbr_sum
  return(priorities)


#score: {'data3D.txt': -0.0022274000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        interacting_spins_sum = sum(J[l, i, j, k] for l in range(6))
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 2 * interacting_spins_sum + site_nbr_sum - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 - total_spin
          priorities[i*N+j*k][1] = -2 * interacting_spins_sum + site_nbr_sum + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0178806}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0058418}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total magnetism at each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 1
          total_spin[i*N+j*N+k][1] -= 1
        else:
          total_spin[i*N+j*N+k][0] -= 1
          total_spin[i*N+j*N+k][1] += 1
  
  # Calculate priority for each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][1]
        else:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][1]
  
  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] +\
                  interacting_spins[1][site_nbr_ij][k] +\
                  interacting_spins[2][j][site_nbr_ij]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      for i in range(N):
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] + sum(h[i][m] for m in range(3))
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0300662}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interactions along each axis
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  # Calculate interactions and update priorities
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_i = (i + ((0-1)%2 - 1)) % N
        
        # Calculate interacting spin values along each axis
        interacting_spin_x = interacting_spins_x[site_nbr_i][j][k]
        interacting_spin_y = interacting_spins_y[i][site_nbr_j][k]
        interacting_spin_z = interacting_spins_z[i][j][site_nbr_k]
        interacting_spin_xo = interacting_spins_xo[site_nbr_i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][site_nbr_j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][site_nbr_k]

        # Calculate total spin value and update priorities
        total_spin = h[i][j][k] + interacting_spin_x + interacting_spin_y + interacting_spin_z
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)  

  total_spin = np.zeros((N**3, 2))
  for k in range(N):
    site_nbr = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        interacting_spin = interacting_spins[0][site_nbr_ij][site_nbr_j] +\
                  interacting_spins[1][site_nbr_ij][k] +\
                  interacting_spins[2][j][site_nbr_ij]
        total_spin[k*N**2+j*N+i][0] += h[i][j][k] 
        if h[i][j][k] > 0:
          total_spin[k*N**2+j*N+i][1] -= 1
        else:
          total_spin[k*N**2+j*N+i][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_k = (k + ((2-1)%2 - 1)) % N
        site_nbr_j = (j + ((1-1)%2 - 1)) % N
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr_k][j][i]
        for l in range(6):
          if J[l, k, j, i] > 0:
            total_spin += -J[l, k, j, i]
          else:
            total_spin -= J[l, k, j, i]
        priority_total = np.zeros((1,2))
        site_nbr_kk = (k + ((2-1)%2 - 1)) % N
        for ll in range(6):
          if h[site_nbr_kk][j][i] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if total_spin > 0:
          priority_total[0][0] += 1
          priority_total[0][1] -= 1
        else:
          priority_total[0][0] -= 1
          priority_total[0][1] += 1
        priorities[i*N**2+j*N+k][0] = priority_total[0][0]
        priorities[i*N**2+j*N+k][1] = priority_total[0][1]
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_ij = (i + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr_k][j][i]
        for l in range(6):
          if J[l, k, j, i] > 0:
            total_spin += -J[l, k, j, i]
          else:
            total_spin -= J[l, k, j, i]
        site_spin = (total_spin > 0) * 1
        priorities[k*N**2+j*N+i][0] = site_spin + np.sum(h == h[site_nbr_k][j][i])
        priorities[k*N**2+j*N+i][1] = -site_spin + N**3 - np.sum(h == h[site_nbr_k][j][i])
  return(priorities)


#score: {'data3D.txt': -0.0025390000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = max(total_spin + interacting_spins, 0) 
        priority_down = max(-total_spin - spin_diff, 0)
        priorities[i*N+j*k][0] = priority_up
        priorities[i*N+j*k][1] = priority_down
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = max(0, total_spin + interacting_spins)
        priority_down = max(0, spin_diff + interacting_spins)
        priorities[i*N+j*k][0] = priority_up
        priorities[i*N+j*k][1] = -priority_down
  return(priorities)


#score: {'data3D.txt': -0.0016638000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = 2 + total_spin
        priority_down = -3 - spin_diff
        priorities[i*N+j*k][0] = max(0, priority_up)
        priorities[i*N+j*k][1] = max(0, priority_down)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1 for site_nbr in site_nbrs)
        interacting_spins = sum(J[l, i, j, k] for l in range(6))
        spin_diff = sum(h[site_nbr][j][k] if h[i][j][k] > 0 else -1 - h[site_nbr][j][k] for site_nbr in site_nbrs)
        priority_up = total_spin + interacting_spins
        priority_down = spin_diff + total_spin
        priorities[i*N+j*k][0] = max(0, min(priority_up, priority_down))
        priorities[i*N+j*k][1] = -priorities[i*N+j*k][0]
  return(priorities)


#score: {'data3D.txt': -0.00010939999999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N%N] > 0:
      total_spin = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6) if interacting_spins[k][site_nbr][i//N%N][i%N%N] == h[site_nbr][i//N%N][i%N%N])
    else:
      total_spin = sum(-J[k, site_nbr, i//N%N, i%N%N] for k in range(6) if interacting_spins[k][site_nbr][i//N%N][i%N%N] == h[site_nbr][i//N%N][i%N%N])

    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': 0.0029226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N//N][i%N%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N//N][i%N%N] > 0:
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        total_spin -= J[k, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': 0.006143399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    total_spin = 0
    for k in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N//N][i%N%N] > 0:
        total_spin += J[k, site_nbr, i%N//N, i%N%N]
      else:
        total_spin -= J[k, site_nbr, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': -0.0018294000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((i-1)%2 - 1)) % N
        site_nbr3 = (k + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for x in range(6):
          if J[x, i, j, k] > 0:
            total_spin += h[site_nbr1][j][k]
          else:
            total_spin -= h[site_nbr1][j][k]
        
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        
  return(priorities)


#score: {'data3D.txt': -0.0048318}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_h = sum(J[k, site_nbr, i//N%N, i%N%N] * h[site_nbr][i//N%N][i%N%N] for k in range(6) if abs(h[site_nbr][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
  
  return priorities


#score: {'data3D.txt': -0.002469800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    priorities[i][1] = -total_spin[1] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
  return(priorities)


#score: {'data3D.txt': -0.0017749999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          interacting_spins += J[l,i,j,k]
          for axis, offset in [(0, -1), (0, 1), (1, -1), (1, 1), (2, -1), (2, 1)]:
            if site_nbr1 != i and abs(site_nbr1-i) == offset:
              interacting_spins += h[site_nbr1][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.0017998000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = i + ((l-3)%2 - 1) % N if l < 3 else i + ((l-9)%2 - 1) % N
          total_spin += h[site_nbr1][j][k]
          interacting_spins += J[l,i,j,k]
          if l < 3:
            interacting_spins += np.roll(h, -1, axis=l)[i][j][k]
            interacting_spins -= np.roll(h, -2, axis=l-3)[i][j][k] if i > 0 else 0
          elif l < 6:
            interacting_spins += np.roll(h, 1, axis=l-3)[i][j][k]
            interacting_spins -= np.roll(h, 2, axis=l-3)[i][j][k] if i < N-1 else 0
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = total_spin + interacting_spins
          priorities[i*N+j*k][1] = -total_spin - 2*interacting_spins
        else:
          priorities[i*N+j*k][0] = -total_spin - interacting_spins
          priorities[i*N+j*k][1] = total_spin + 2*interacting_spins
  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interactions along each axis
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  # Calculate interactions and update priorities
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spin_x = interacting_spins_x[i][j][k]
        interacting_spin_y = interacting_spins_y[i][j][k]
        interacting_spin_z = interacting_spins_z[i][j][k]
        interacting_spin_xo = interacting_spins_xo[i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][k]

        if h[i][j][k] > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.035633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for x in [0, 1]:
          site_nbr_x = (i + ((x-1)%2 - 1)) % N
          if interacting_spins_x[site_nbr_x][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for y in [0, 1]:
          site_nbr_y = (j + ((y-1)%2 - 1)) % N
          if interacting_spins_y[i][site_nbr_y][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for z in [0, 1]:
          site_nbr_z = (k + ((z-1)%2 - 1)) % N
          if interacting_spins_z[i][j][site_nbr_z] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.023341}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate interactions along each axis
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xo = np.roll(h, 1, axis=0)
  interacting_spins_yo = np.roll(h, 1, axis=1)
  interacting_spins_zo = np.roll(h, 1, axis=2)

  # Calculate interactions and update priorities
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_i = (i + ((0-1)%2 - 1)) % N
        
        # Calculate interacting spin values along each axis
        interacting_spin_x = interacting_spins_x[site_nbr_i][j][k]
        interacting_spin_y = interacting_spins_y[i][site_nbr_j][k]
        interacting_spin_z = interacting_spins_z[i][j][site_nbr_k]
        interacting_spin_xo = interacting_spins_xo[site_nbr_i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][site_nbr_j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][site_nbr_k]

        # Calculate total spin value and update priorities
        total_spin = h[i][j][k] + interacting_spin_x + interacting_spin_y + interacting_spin_z
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1
        
  # Calculate interactions along each axis and update priorities
  for k in range(N):
    site_nbr_k = (k + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_j = (j + ((1-1)%2 - 1)) % N
      for i in range(N):
        site_nbr_i = (i + ((0-1)%2 - 1)) % N
        
        # Calculate interacting spin values along each axis
        interacting_spin_xo = interacting_spins_xo[site_nbr_i][j][k]
        interacting_spin_yo = interacting_spins_yo[i][site_nbr_j][k]
        interacting_spin_zo = interacting_spins_zo[i][j][site_nbr_k]

        # Calculate total spin value and update priorities
        total_spin = h[i][j][k] + interacting_spin_xo + interacting_spin_yo + interacting_spin_zo
        if total_spin > 0:
          priorities[k*N**2+j*N+i][0] += 1
          priorities[k*N**2+j*N+i][1] -= 1
        else:
          priorities[k*N**2+j*N+i][0] -= 1
          priorities[k*N**2+j*N+i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.28452779999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins_x = h[(i+1)%N][j][k] if (i+1)<N else h[0][j][k]
        interacting_spins_y = h[i][(j+1)%N][k] if (j+1)<N else h[i][0][k]
        interacting_spins_z = h[i][j][(k+1)%N] if (k+1)<N else h[i][j][0]
        
        # Calculate total spin and update priorities
        if total_spin + interacting_spins_x > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        elif total_spin + interacting_spins_x < 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
        
        if total_spin + interacting_spins_y > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        elif total_spin + interacting_spins_y < 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j+N*k][1] += 1
        
        if total_spin + interacting_spins_z > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        elif total_spin + interacting_spins_z < 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.0027002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] -= 1 - (total_spin[0] + 1) if np.sum(h[site_nbr]) > 0 else 1 + (total_spin[0] + 1)
        priorities[i][1] = -total_spin[1]
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] += 1 + (total_spin[0] + 1) if np.sum(h[site_nbr]) < 0 else -1 + (total_spin[0] + 1)
        priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': 0.0023001999999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1]
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1] + 2 * np.sum(h)
  return(priorities)


#score: {'data3D.txt': -0.0060886}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
    
    # Calculate priority based on magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Normalize the priority
    norm = (priorities[i][0]**2 + priorities[i][1]**2)**0.5
    if norm > 0:
      priorities[i][0] /= norm
      priorities[i][1] /= norm
    
  return(priorities)


#score: {'data3D.txt': -0.0016669999999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    total_spin = [0, 0]
    for j in range(6):
      site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(N):
      site_nbr = [(i//N)%N,j,(i%N)%N]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = -total_spin[1]
        priorities[i][1] = total_spin[0]
      else:
        priorities[i][0] = total_spin[1]
        priorities[i][1] = -total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0025245999999999997}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    return(priorities)


#score: {'data3D.txt': -0.0036874}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0006514000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 4*np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 4*np.sum(J[:,i,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.00021900000000000042}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] - h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += np.sum(J[:,i,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.0006514000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        
        total_spin1 = h[site_nbr1][j][k] + np.sum(J[:,i,j,k])
        total_spin2 = h[i][site_nbr2][k] + np.sum(J[:,i,site_nbr2,k])
        
        if total_spin1 > 0:
          priorities[i*N*j+N+k][0] += 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,j,k])
        elif total_spin1 < 0:
          priorities[i*N*j+N+k][0] -= 2*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,j,k])
          
        if total_spin2 > 0:
          priorities[i*N*j+N+k][0] += 2*np.sum(J[:,i,site_nbr2,k])
          priorities[i*N*j+N+k][1] -= 2*np.sum(J[:,i,site_nbr2,k])
        elif total_spin2 < 0:
          priorities[i*N*j+N+k][0] -= 2*np.sum(J[:,i,site_nbr2,k])
          priorities[i*N*j+N+k][1] += 2*np.sum(J[:,i,site_nbr2,k])
  
  return(priorities)


#score: {'data3D.txt': -0.002564200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.0005530000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N*j+N+k][0] = total_spin*np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][1] -= np.sum(J[:,i,j,k])
        else:
          priorities[i*N*j+N+k][1] += np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': 0.0012865999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.0079794}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  site_interactions = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          # Update priorities based on total spin and magnetism
          site_interactions[site_nbr][j][k][0] = -total_spin
          site_interactions[site_nbr][j][k][1] += total_spin
          
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0020098000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] = np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = -np.sum(J[:,i,j,k])

  return(priorities)


#score: {'data3D.txt': -0.0013914000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0077794}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': 0.0069822}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k] + h[i][site_nbr2][k]
        
        if np.sum(J[:, i, j, k]) > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0069338}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total magnetism at each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        total_spin[i*N+j*N+k][0] += sum(interacting_spins)
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0032166}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on site's proximity to the boundary and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary
    if site_nbr[2] == 0:
      total_spin[1] += 1
    elif site_nbr[2] == N-1:
      total_spin[1] -= 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.006916599999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary and magnetism
    priorities[i][0] = -total_spin[0]
    if (site_nbr[0] == 0 or site_nbr[0] == N-1) and (site_nbr[1] == 0 or site_nbr[1] == N-1):
      priorities[i][1] += total_spin[0]
    elif site_nbr[0] < N//2:
      priorities[i][1] -= total_spin[0]
    else:
      priorities[i][1] += total_spin[0]
  
  return(priorities)


#score: {'data3D.txt': -0.0045194}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority for each site based on total spin and magnetism
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] += total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0010214}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority for each site based on total spin and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0025294}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': 0.002103000000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    
    # Sum the magnetism and count the number of positive interactions
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0029049999999999996}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][1] -= total_spin[1] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      else:
        priorities[i][0] -= total_spin[0] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][1] = -total_spin[1] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    
    return(priorities)


#score: {'data3D.txt': -0.011572999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    if np.sum(h[site_nbr]) > 0:
      priorities[i][0] = -total_spin[0] + np.sum(h)
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1] - np.sum(h)
  return(priorities)


#score: {'data3D.txt': -0.0026482}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = -total_spin[1]
      else:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    return(priorities)


#score: {'data3D.txt': -0.0025245999999999997}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = 0
    total_spin_1 = 0
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 -= 1
      else:
        total_spin_0 -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    return(priorities)


#score: {'data3D.txt': -0.0038766}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.00036900000000000046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.10552060000000031}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N**3):
    if h[i//N**(2)][(i//N)%N][(i%N)] > 0:
      priorities[i][0] = -total_spin[i//N**(2)][(i//N)%N][(i%N)][0]
      priorities[i][1] -= total_spin[i//N**(2)][(i//N)%N][(i%N)][1]
    else:
      priorities[i][0] = total_spin[i//N**(2)][(i//N)%N][(i%N)][0]
      priorities[i][1] = -total_spin[i//N**(2)][(i//N)%N][(i%N)][1]

  return(priorities)


#score: {'data3D.txt': -0.008369800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(J[:, i, j, k])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0047826000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = float('-inf')
        else:
          priorities[i*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': -0.0029154000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = np.zeros(2)
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if h[i][j][k] > 0:
            priority_total[0] += 1 + total_spin
            priority_total[1] -= 1 - total_spin
          else:
            priority_total[0] -= 1 + total_spin
            priority_total[1] = -1 + total_spin
        priorities[i*N+j*N+k][0] = priority_total[0]
        priorities[i*N+j*N+k][1] = priority_total[1]
  return(priorities)


#score: {'data3D.txt': -0.007495}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for l in range(6): 
          if J[l,i,j,k] > 0:  
            total_spin += 1 
          else:   
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -2*total_spin*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = float('-inf')
        else:
          priorities[i*N+j*N+k][0] = -2*(N**3-total_spin-1)*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': 0.021155399999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0008845999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

          for y in range(3):
            site = (i + ((y-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin += np.sum(J[:,site_nbr,j,k])
            else:
              total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.004627}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate magnetism at site_nbr
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0011634000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k]) + np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k]) - np.sum(J[:,site,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,i,site_nbr,k]) + np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,i,site_nbr,k]) - np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0058362}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0.0] * 2
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
      else:
        total_spin[0] -= 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.004251400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in range(3):
          for y in range(3):
            site_nbr = (i + ((x-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_spin += J[(((x+y-k)//2)%6), i, j, k]
            else:
              total_spin -= J[(((x+y-k)//2)%6), i, j, k]

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0028014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in [-1,0,1]:
          for y in [-1,0,1]:
            for z in [-1,0,1]:
              site = (i + x) % N
              if site == i:
                continue
              if h[site][j][k] > 0:
                total_spin += J[(((x+y+z-3)//2)%6), i, j, k]
              else:
                total_spin -= J[(((x+y+z-3)//2)%6), i, j, k]

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0058418}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total magnetism at each site
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j*N+k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i*N+j*N+k][0] += 1
          total_spin[i*N+j*N+k][1] -= 1
        else:
          total_spin[i*N+j*N+k][0] -= 1
          total_spin[i*N+j*N+k][1] += 1
        
  # Calculate priority for each site based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i*N+j*N+k][1]
        else:
          priorities[i*N+j*N+k][0] = -total_spin[i*N+j*N+k][0]
          priorities[i*N+j*N+k][1] += total_spin[i*N+j*N+k][1]
        
  return(priorities)


#score: {'data3D.txt': -0.0048318}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    total_spin_h = sum(J[k, (i % N + ((i//N-1)%2 - 1)) % N, i//N%N, i%N%N] * h[(i % N + ((i//N-1)%2 - 1)) % N][i//N%N][i%N%N] for k in range(6) if abs(h[(i % N + ((i//N-1)%2 - 1)) % N][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, (i % N + ((i//N-1)%2 - 1)) % N, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
  
  return priorities


#score: {'data3D.txt': -0.0027749999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_h = sum(J[k, site_nbr, i//N%N, j%N] * h[site_nbr][j%N][k%N] for k in range(6) if abs(h[site_nbr][j%N][k%N]) > 0)
        total_spin_j = sum(J[k, site_nbr, i//N%N, j%N] for k in range(6))
        
        if h[i//N%N][j%N][k%N] > 0:
          priorities[i*N+j+N+k][0] += total_spin_h + total_spin_j
          priorities[i*N+j+N+k][1] -= total_spin_h + total_spin_j
        else:
          priorities[i*N+j+N+k][0] -= total_spin_h + total_spin_j
          priorities[i*N+j+N+k][1] += total_spin_h + total_spin_j
        
  return priorities


#score: {'data3D.txt': -0.0048318}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_h = sum(J[k, site_nbr, i//N%N, i%N%N] * h[site_nbr][i//N%N][i%N%N] for k in range(6) if abs(h[site_nbr][i//N%N][i%N%N]) > 0)
    total_spin_j = sum(J[k, site_nbr, i//N%N, i%N%N] for k in range(6))
    
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin_h + total_spin_j
      priorities[i][1] -= total_spin_h + total_spin_j
    else:
      priorities[i][0] -= total_spin_h + total_spin_j
      priorities[i][1] += total_spin_h + total_spin_j
    
  return priorities


#score: {'data3D.txt': 0.021155399999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin * 2
      priorities[i][0] += total_spin * 2
    else:
      priorities[i][1] = total_spin * 2
      priorities[i][0] -= total_spin * 2
    
  return(priorities)


#score: {'data3D.txt': -0.000551}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    priority_total = np.zeros(2)
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        priority_total[1] -= J[x,site_nbr,i // N % N,i % N]
        priority_total[0] += J[x,site_nbr,i // N % N,i % N]
      else:
        priority_total[1] += J[x,site_nbr,i // N % N,i % N]
        priority_total[0] -= J[x,site_nbr,i // N % N,i % N]
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin + priority_total[0]
      priorities[i][0] = total_spin + priority_total[1]
    else:
      priorities[i][1] = total_spin + priority_total[0]
      priorities[i][0] = -total_spin + priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': 0.021155399999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.021155399999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i // N % N][i % N]
    
    # Add interactions with nearest neighbors
    for x in range(6):
      site = (i // N + ((x-1)%2 - 1)) % N
      if h[site_nbr][i // N % N][i % N] > 0:
        total_spin += np.sum(J[x,site_nbr,i // N % N,i % N])
      else:
        total_spin -= np.sum(J[x,site_nbr,i // N % N,i % N])
    
    # Update priorities based on total spin and magnetism
    if h[site_nbr][i // N % N][i % N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin * (h[site_nbr][i // N % N][i % N])
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin * (h[site_nbr][i // N % N][i % N])
  
  return(priorities)


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.007197000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N//N][i%N//N][i%N%N] + h[site_nbr][i//N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[i//N//N][i%N//N][i%N%N] > 0:
        total_spin += J[k, i//N//N, i%N//N, i%N%N]
      else:
        total_spin -= J[k, i//N//N, i%N//N, i%N%N]

    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i//N//N][i%N%N] > 0:
        total_spin += J[k, site_nbr, i//N//N, i%N%N]
      else:
        total_spin -= J[k, site_nbr, i//N//N, i%N%N]

    # Update priorities based on total spin and magnetism
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.0021298000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      if k < 3:
        site = (i % N + ((k-1)%2 - 1)) % N
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        site = (i % N + ((k-4)%2 - 1)) % N
        total_spin -= J[k-3, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.00015339999999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.00015339999999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': -0.002923400000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary and magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    if site_nbr[0] == 0 or site_nbr[0] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[0] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0032166}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary, magnetism and interactions
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if (k == 2 and i >= N*N*(N-1)) or\
        (k == 0 and i < N) or (k == 1 and i % N < N//3):
        total_spin[1] += 1
      elif h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.006549800000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,i%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary, magnetism and interactions
    priorities[i][0] = -total_spin[0]
    if i < N or i >= N**3-N or (i % N) < N//3:
      priorities[i][1] += total_spin[0]
    elif i > N*N*(N-1):
      priorities[i][1] -= total_spin[0]
  
  return(priorities)


#score: {'data3D.txt': -0.0042650000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:, i, j, k])
  return(priorities)


#score: {'data3D.txt': -0.0068062}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] -= total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] += total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = total_spin[i][j][k][1]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] -= 2*np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] = -2*np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] = -2*np.sum(J[:, i, j, k])

  return(priorities)


#score: {'data3D.txt': 0.0080298}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in [i-1, i, i+1]:
          if 0 <= l < N:
            total_spin += h[l][j][k]
        for m in [j-1, j, j+1]:
          if 0 <= m < N:
            total_spin += h[i][m][k]
        for n in [k-1, k, k+1]:
          if 0 <= n < N:
            total_spin += h[i][j][n]
        if total_spin > 0:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 2
        else:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 2
  return(priorities)


#score: {'data3D.txt': -0.0086806}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] for site in [(i + ((k-1)%2 - 1)) % N])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0029426000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if any(h[site][j][k] > 0 for site in site_nbrs):
          total_spin = sum(h[site][j][k] for site in site_nbrs)
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + (2*total_spin - N)
        else:
          total_spin = sum(h[site][j][k] for site in site_nbrs)
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - (2*total_spin - N)
  return(priorities)


#score: {'data3D.txt': -0.008369800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0031122000000000007}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    # Calculate total spin
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism and interactions
    if total_spin[0] > total_spin[1]:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    elif total_spin[0] < total_spin[1]:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    else:
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = total_spin[1]
      else:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.007532199999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    # Calculate the priority based on magnetism and interactions
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism
    if total_spin[0] > 0 and total_spin[1] < 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1]
    elif total_spin[0] > 0 and total_spin[1] >= 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = -total_spin[1]
    elif total_spin[0] <= 0 and total_spin[1] < 0:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.004233400000000001}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    
    # Sum the magnetism and count the number of positive interactions
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    # Prioritize spins in the same direction as the site's magnetism
    if np.sum(total_spin) > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': 0.0018498000000000006}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0060886}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    # Calculate priority based on distance from the boundary
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    # Calculate priority based on magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Normalize the priority
    norm = (priorities[i][0]**2 + priorities[i][1]**2)**0.5
    if norm > 0:
      priorities[i][0] /= norm
      priorities[i][1] /= norm
    
  return(priorities)


#score: {'data3D.txt': -0.004397}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    # Calculate priority based on magnetism
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Calculate priority based on site interactions
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if J[0][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] = -total_spin[1]
    
    # Normalize the priority
    norm = (priorities[i][0]**2 + priorities[i][1]**2)**0.5
    if norm > 0:
      priorities[i][0] /= norm
      priorities[i][1] /= norm
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs = [(i//N)%N,(i%N//N)%N,(i%N)%N]
  
  for i in range(N**3):
    total_spin = [0, 0]
    
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(6):
      if J[j][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        priorities[i][0] = -total_spin[0]
        priorities[i][1] = total_spin[1]
      else:
        priorities[i][0] = total_spin[0]
        priorities[i][1] = -total_spin[1]
    
  return(priorities)


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.005186200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    site_nbr = (k-1)%2
    for i in range(N):
      for j in range(N):
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  for k in range(N):
    site_nbr = (k-1)%2
    for i in range(N):
      for j in range(N):
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0026558000000000003}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = 0
    total_spin_1 = 0
    
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 -= 1
      else:
        total_spin_0 -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin_1 += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += total_spin_0
        priorities[i][1] -= total_spin_1
      else:
        priorities[i][0] -= total_spin_0
        priorities[i][1] = -total_spin_1
    
    return(priorities)


#score: {'data3D.txt': -0.0023618}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin_0 = sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] * (J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0) for j in range(6))
    total_spin_1 = len([j for j in range(6) if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0])
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      
      total_spin_0 += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin_0 += 1
        total_spin_1 -= 1
      else:
        total_spin_0 -= 1
        total_spin_1 += 1
    
    priorities[i] = [-total_spin_0, -total_spin_1]
  
  return(priorities)


#score: {'data3D.txt': -0.007283799999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    for k in range(3):
      if (k == 0 and i < N) or (k == 1 and i % N < N//3) or (k == 2 and i >= N*N*(N-1)):
        total_spin[1] += 1
    
    total = [0, 0]
    
    for j in range(6):
      site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
      
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total[1] -= 1
      else:
        total[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total[1] += 1
    
    for j in range(2):
      priorities[i][j] = -total[j]
  
  return(priorities)


#score: {'data3D.txt': 0.0018498000000000006}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    if site_nbr[0] == (i//N)%N and i < N:
      total_spin[1] += 1
    if site_nbr[1] == (i%N//N)%N and i % N < N//3:
      total_spin[1] += 1
    if site_nbr[2] == (i%N)%N and i >= N*N*(N-1):
      total_spin[1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    
  return(priorities)


#score: {'data3D.txt': -0.003581}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          if J[l,i,j,k]>0:
            total_spin += -J[l,i,j,k]
          else:
            total_spin -= -J[l,i,j,k]
        priorities[i*N+j*k][0] += total_spin
        priorities[i*N+j*k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.005186200000000001}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[0,i,j,k]
          priorities[i*N+j*k][1] -= J[0,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[0,i,j,k]
          priorities[i*N+j*k][1] += J[0,i,j,k]

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[1,i,j,k]
          priorities[i*N+j*k][1] -= J[1,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[1,i,j,k]
          priorities[i*N+j*k][1] += J[1,i,j,k]

        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[2,i,j,k]
          priorities[i*N+j*k][1] -= J[2,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[2,i,j,k]
          priorities[i*N+j*k][1] += J[2,i,j,k]

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[3,i,j,k]
          priorities[i*N+j*k][1] -= J[3,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[3,i,j,k]
          priorities[i*N+j*k][1] += J[3,i,j,k]

        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[4,i,j,k]
          priorities[i*N+j*k][1] -= J[4,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[4,i,j,k]
          priorities[i*N+j*k][1] += J[4,i,j,k]

        site_nbr = ((k + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[5,i,j,k]
          priorities[i*N+j*k][1] -= J[5,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[5,i,j,k]
          priorities[i*N+j*k][1] += J[5,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.005186200000000001}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((k + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0008126}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(1,N-1):
    for j in range(1,N-1):
      for k in range(1,N-1):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] -= 4*np.sum(J[:,i,j,k])
        elif total_spin < 0:
          priorities[i*N*j+N+k][0] -= 4*np.sum(J[:,i,j,k])
          priorities[i*N*j+N+k][1] += 4*np.sum(J[:,i,j,k])
        
  for i in range(N-1,N):
    for j in range(1,N-1):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][j][0] + h[site_nbr][j][0]
      
      if total_spin > 0:
        priorities[i*N+j][0] += 4*np.sum(J[:,i,j,0])
        priorities[i*N+j][1] -= 4*np.sum(J[:,i,j,0])
      elif total_spin < 0:
        priorities[i*N+j][0] -= 4*np.sum(J[:,i,j,0])
        priorities[i*N+j][1] += 4*np.sum(J[:,i,j,0])
        
  return(priorities)


#score: {'data3D.txt': -0.0082638}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        
        total_spin = sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N+j*N+k][0] += sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        elif total_spin < 0:
          priorities[i*N+j*N+k][0] -= sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2
        
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    total_spin = h[site_nbr][N//2][N//2]
    
    if total_spin > 0:
      priorities[i*N+N//2+N//2][0] += sum(J[:,i,N//2,N//2])
      priorities[i*N+N//2+N//2][1] -= 2
    elif total_spin < 0:
      priorities[i*N+N//2+N//2][0] -= sum(J[:,i,N//2,N//2])
      priorities[i*N+N//2+N//2][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.0018498000000000006}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    if site_nbr[0] == (i//N)%N and i < N:
      total_spin[1] += 1
    if site_nbr[1] == (i%N//N)%N and i % N < N//3:
      total_spin[1] += 1
    if site_nbr[2] == (i%N)%N and i >= N*N*(N-1):
      total_spin[1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[1]
    else:
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[1]
    
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Calculate priority based on distance from the boundary, magnetism and interactions
    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    if site_nbr[0] == 0 or site_nbr[0] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[0] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]
    
    if sum(total_spin) > 0:
      priorities[i][0] = -sum(total_spin)
      priorities[i][1] = max(0, sum(total_spin))
    elif sum(total_spin) < 0:
      priorities[i][0] = -max(0, -sum(total_spin))
      priorities[i][1] = -sum(total_spin)
    else:
      priorities[i][0] = 0
      priorities[i][1] = 0
  
  return(priorities)


#score: {'data3D.txt': -0.0066262}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]

  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]

    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    for k in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,k]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1

    if site_nbr[0] == 0 or site_nbr[0] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[0] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]

    if site_nbr[1] == 0 or site_nbr[1] == N-1:
      total_spin[1] += total_spin[0]
    elif site_nbr[1] < N//2:
      total_spin[1] -= total_spin[0]
    else:
      total_spin[1] += total_spin[0]

    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]

  return(priorities)


#score: {'data3D.txt': -0.0044142}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total spin at each site based on magnetism and interactions
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    total_spin = [0, 0]
    interacting_spins = []
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for j in range(3):
      site_nbr = [(i//N)%N,(i%N//N)%N,j]
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = total_spin[1]
  
  for i in range(N**3):
    site_nbr = [(i//N)%N,(i%N//N)%N,(i%N)%N]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0005685999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    
    site_spin = [h[site_nbr[0]][site_nbr[1]][site_nbr[2]], 0]
    for k in range(3):
      site_nbr = (i // N % N, (i % N // N) % N, ((k-1)%2 - 1) % N)
      if J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        site_spin[1] += 1
      else:
        site_spin[1] -= 1
    
    priorities[i][0] = -total_spin[0] + site_spin[0]
    priorities[i][1] = total_spin[1] + site_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.0038734}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
          total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    for k in range(3):
      site = (i // N % N, i % N // N % N, (i % N // N % N + ((k-1)%2 - 1)) % N)
      if h[site[0]][site[1]][site[2]] > 0:
        total_spin[0] += 1
      else:
        total_spin[0] -= 1
    priorities[i][0] = -total_spin[0] + h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    priorities[i][1] = -total_spin[1] - h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
  return(priorities)


#score: {'data3D.txt': -0.0040073999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    if site_nbr[2] == 0:
      priorities[i][1] += 1
    elif site_nbr[2] == N-1:
      priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': 0.011613400000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[i][j][k] > 0:
            priorities[i*N+j*N+k][0] -= J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i*N+j*N+k][1] += 1
          else:
            priorities[i*N+j*N+k][0] += J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i*N+j*N+k][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.006154199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N % N, i % N // N % N, i % N % N)
    total_spin = [0, 0]
    for j in range(6):
      if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0] + sum([J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] * h[s][t][u] for j, (s, t, u) in enumerate([(site_nbr[0], site_nbr[1], site_nbr[2])] * 6)])
    priorities[i][1] = -total_spin[1] - sum([J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] * h[s][t][u] for j, (s, t, u) in enumerate([(site_nbr[0], site_nbr[1], site_nbr[2])] * 6)])
  return(priorities)


#score: {'data3D.txt': -0.0023822}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  # get the neighboring sites
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.005186200000000001}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[4,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[5,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.36082339999999974}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        if h[i][j][k] > 0:
          spin_energy += 1
        else:
          spin_energy -= 1
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += J[l, i, j, k]
          else:
            spin_energy -= J[l, i, j, k]
        priorities[i*N*N + j*N + k][1] = -spin_energy
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate interacting spins
  interacting_spins_x = np.roll(h, -1, axis=2)
  interacting_spins_y = np.roll(h, 1, axis=2)
  interacting_spins_z = np.roll(h, -1, axis=1) + np.roll(h, 1, axis=1)

  for k in range(N):
    for i in range(N):
      for j in range(N):
        site_nbr_x = (i + (k-1)%2 - 1) % N
        site_nbr_y = (j + (k-1)%2 - 1) % N
        
        total_spin = h[site_nbr_x][j] + h[i][site_nbr_y]
        
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += -J[0, i, j, k]
          priorities[i*N+j*k][1] -= J[0, i, j, k]
        else:
          priorities[i*N+j*k][0] -= J[0, i, j, k]
          priorities[i*N+j*k][1] += J[0, i, j, k]

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += -J[0,i,j,k]
          priorities[i*N+j*k][1] -= J[0,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[0,i,j,k]
          priorities[i*N+j*k][1] += J[0,i,j,k]

  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[i][site_nbr]
      
      if J[1,i,j,0] > 0:
        priorities[i*N+j][0] += -J[1,i,j,0]
        priorities[i*N+j][1] -= J[1,i,j,0]
      else:
        priorities[i*N+j][0] -= J[1,i,j,0]
        priorities[i*N+j][1] += J[1,i,j,0]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[2,i,j,0] > 0:
        priorities[i*N+j][0] += -J[2,i,j,0]
        priorities[i*N+j][1] -= J[2,i,j,0]
      else:
        priorities[i*N+j][0] -= J[2,i,j,0]
        priorities[i*N+j][1] += J[2,i,j,0]

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
   site_nbr = (k-1)%2
   for i in range(N):
    for j in range(N):
     total_spin = h[site_nbr][j]
     if J[0,i,j,k] > 0:
      priorities[i*N+j*k][0] += -J[0,i,j,k]
      priorities[i*N+j*k][1] -= J[0,i,j,k]
     else:
      priorities[i*N+j*k][0] -= J[0,i,j,k]
      priorities[i*N+j*k][1] += J[0,i,j,k]

     site_nbr = (j-1)%2
     total_spin += h[site_nbr][i]
     if J[3,i,j,k] > 0:
      priorities[i*N+j*k][0] += -J[3,i,j,k]
      priorities[i*N+j*k][1] -= J[3,i,j,k]
     else:
      priorities[i*N+j*k][0] -= J[3,i,j,k]
      priorities[i*N+j*k][1] += J[3,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.003149}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(N):
    for i in range(N):
      for j in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbr = ((j + (k-1)%2 - 1)) % N
        total_spin += h[site_nbr][i]
        if J[3,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0020134000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if k < 3:
          site_nbrs += [j]
        else:
          site_nbrs += [i]
        total_spin = sum(h[site_nbr][k%N] for site_nbr in site_nbrs)
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0024914000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.34337860000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_parity = [0] * (N ** 3)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if h[i][j][k] > 0:
          total_parity[i*N*N + j*N + k] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          total_parity[i*N*N + j*N + k] -= 1
          priorities[i*N*N + j*N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += J[l, i, j, k]
          else:
            spin_energy -= J[l, i, j, k]

        priorities[i*N*N + j*N + k][1] = -spin_energy
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities


#score: {'data3D.txt': 0.0063658000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site][j][k] for site in [i, site_nbr])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 2*total_spin*np.sum(J[:, i, j, k]) + np.sum(J[:, site_nbr, j, k])
          priorities[i*N+j*N+k][1] -= total_spin - np.sum(J[:, i, j, k])
        else:
          priorities[i*N+j*N+k][0] -= 2*total_spin*np.sum(J[:, i, j, k]) + np.sum(J[:, site_nbr, j, k])
          priorities[i*N+j*N+k][1] += total_spin - np.sum(J[:, i, j, k])

  return(priorities)


#score: {'data3D.txt': -0.0037854}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(3)])
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        
        for x in range(3):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
          else:
            priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
  
  return(priorities)


#score: {'data3D.txt': 0.004187399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 2
        else:
          total_spin -= 2

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.004187399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 2
        else:
          total_spin -= 2

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0038746}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priority_total = np.zeros(2)
        for x in range(3):
          if h[site_nbr][j][((x+1)%3)-1] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priority_total[0] += 1 + total_spin
            priority_total[1] -= 1 - total_spin
          else:
            priority_total[0] -= 1 + total_spin
            priority_total[1] = -1 + total_spin
        priorities[i*N+j*N+k][0] = priority_total[0]
        priorities[i*N+j*N+k][1] = priority_total[1]
  return(priorities)


#score: {'data3D.txt': -0.0095762}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for site in [(i + ((x-1)%2 - 1)) % N for x in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0095762}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(3))
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.001711}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((x-1)%2 - 1)) % N for x in range(6)]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = -2*total_spin
        priorities[i*N+j*N+k][1] = np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.0030166000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        if h[i][j][k] > 0:
          total_spin += 2*np.sum(J[:,i,j,k])
        else:
          total_spin -= 2*np.sum(J[:,i,j,k])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N+j*N+k][0] = total_spin
        priorities[i*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.0029398}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1
            else:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
        else:
          priorities[i*N+j*N+k][0] -= total_spin
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
          for d in range(3):
            site_nbr = (i + ((d-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N+j*N+k][0] -= 1
              priorities[i*N+j*N+k][1] += 1
            else:
              priorities[i*N+j*N+k][0] += 1
              priorities[i*N+j*N+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.34337860000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_parity = [0] * (N ** 3)
  spin_energy = np.zeros((N**3))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if h[i][j][k] > 0:
          total_parity[i*N*N + j*N + k] += 1
          spin_energy[i*N*N + j*N + k] -= 2
        else:
          total_parity[i*N*N + j*N + k] -= 1
          spin_energy[i*N*N + j*N + k] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy_sum = 0
        for l in range(6):
          interacting_spin = interacting_spins[l][i][j][k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy_sum += J[l, i, j, k]
          else:
            spin_energy_sum -= J[l, i, j, k]

        priorities[i*N*N + j*N + k][1] = -spin_energy_sum
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities


#score: {'data3D.txt': 0.17194819999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in [0, 1, 2]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in [0, 1, 2]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        site_spin = int(np.sign(total_spin))
        priorities[i*N*N + j*N + k][0] = -site_spin
        priorities[i*N*N + j*N + k][1] = 1-site_spin
  return(priorities)


#score: {'data3D.txt': -0.0331746}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for d in [0, 1, 2]:
          site_nbr2 = (site_nbr + ((d-1)%2 - 1)) % N
          if J[d, i, j, k] > 0:
            total_spin += h[site_nbr2][j][k]
          else:
            total_spin -= h[site_nbr2][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.0228414}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j] * (h[site_nbr][j] > 0) - (h[site_nbr][j] < 0))
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.17216099999999981}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in [0, 1, 2]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.003581}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
            priorities[i*N+j*k][1] -= -J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] -= -J[l,i,j,k]
            priorities[i*N+j*k][1] += -J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.0023381999999999995}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  return(priorities)


#score: {'data3D.txt': -0.34234539999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_parity[i*N*N + j*N + k] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          total_parity[i*N*N + j*N + k] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        for l in range(6):
          interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
          if h[i][j][k] * interacting_spin > 0:
            spin_energy += interacting_spin
          else:
            spin_energy -= interacting_spin
        
        priorities[i*N*N + j*N + k][1] = -spin_energy
        total_parity[i*N*N + j*N + k] += h[i][j][k]
        if total_parity[i*N*N + j*N + k] > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities


#score: {'data3D.txt': 0.004627}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate magnetism at site_nbr
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 6.259999999999988e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    total_spin = sum(h[site][i//N%N][i%N] for site in [(i + ((k-1)%2 - 1)) % N for k in range(6)])
    
    if h[i//N%N][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    for k in range(3):
     site_nbr = (i + ((k-1)%2 - 1)) % N
     if h[site_nbr][i//N%N][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] += np.sum(J[:,site_nbr,i//N%N,i%N])
     else:
       priorities[i][0] += np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] -= np.sum(J[:,site_nbr,i//N%N,i%N])
  
  return(priorities)


#score: {'data3D.txt': -0.0022458}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site][j][k] for site in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
          else:
            priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
            priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.0022854}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] -= -J[l,i,j,k]
            priorities[i*N+j*k][1] += -J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
            priorities[i*N+j*k][1] -= -J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.003581}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if J[l,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[l,i,j,k]
            priorities[i*N+j*k][1] -= -J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] -= -J[l,i,j,k]
            priorities[i*N+j*k][1] += -J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.008475}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i-1)%N, i, (i+1)%N, (j-1)%N, j, (j+1)%N, (k-1)%N, k, (k+1)%N]
        site_nbrs = [site for site in site_nbrs if 0 <= site < N]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += total_spin + 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= total_spin - 2*np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.005700200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i-1)%N + (j-1)%N + (k-1)%N, 
               (i+1)%N + (j-1)%N + (k-1)%N, 
               (i-1)%N + (j+1)%N + (k-1)%N, 
               (i+1)%N + (j-1)%N + (k+1)%N, 
               (i-1)%N + (j+1)%N + (k+1)%N, 
               (i+1)%N + (j+1)%N + (k+1)%N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr//N][site_nbr%N][site_nbr//N%N]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] -= np.sum(J[:, i, j, k]) + total_spin
          priorities[i*N+j*N+k][1] += 2
        else:
          priorities[i*N+j*N+k][0] += np.sum(J[:, i, j, k]) - total_spin
          priorities[i*N+j*N+k][1] -= 2
  return(priorities)


#score: {'data3D.txt': 0.0018774000000000009}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  for k in range(N):
    site_nbr = (k + ((i-1)%2 - 1)) % N
    total_spin += h[site_nbr][j]
    if J[3,k,j,k]>0:
      priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
    else:
      priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)


#score: {'data3D.txt': -0.0041198}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if J[0, i, j, k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0025982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        J_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] = -J_sum
          priorities[i*N*j+N+k][1] = 2*J_sum
        else:
          priorities[i*N*j+N+k][0] = J_sum
          priorities[i*N*j+N+k][1] = -2*J_sum
  return(priorities)


#score: {'data3D.txt': -0.016896599999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if total_spin > 0:
          spin1 = -1
          spin2 = 1
        else:
          spin1 = 1
          spin2 = -1
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N+j*N+k][0] += 1
            priorities[i*N+j*N+k][1] -= 1
          else:
            priorities[i*N+j*N+k][0] -= 1
            priorities[i*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.0001433999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interaction_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += total_spin*interaction_sum
          priorities[i*N*j+N+k][1] -= interaction_sum
        else:
          priorities[i*N*j+N+k][0] -= total_spin*interaction_sum
          priorities[i*N*j+N+k][1] = -interaction_sum
  return(priorities)


#score: {'data3D.txt': -0.21840260000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        parity = h[i][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
          if parity * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N + j*N + k][1] = -total_spin
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities


#score: {'data3D.txt': -0.3377885999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities


#score: {'data3D.txt': 0.20275100000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_spin = sum(sum(J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          total_spin = sum(sum(-J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 - total_spin
  
  return priorities


#score: {'data3D.txt': -0.32961419999999975}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
  
  return priorities


#score: {'data3D.txt': -0.03404699999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': -0.14424340000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin
          priorities[i*N*N + j*N + k][1] = 1 + total_spin
  return priorities


#score: {'data3D.txt': -0.1533362000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l][site_nbr][j][k] * h[site_nbr][l][k] for l in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.14424340000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
  return priorities


#score: {'data3D.txt': -0.1067058000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [h[i][j][k], 2 + total_spin - (total_spin > 0)]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities


#score: {'data3D.txt': -0.14424340000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin - np.sum(np.abs(h[site_nbr, j, k]))
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin + np.sum(np.abs(h[site_nbr, j, k]))
          priorities[i*N*N + j*N + k][1] = 1 + total_spin
  return priorities


#score: {'data3D.txt': -0.0036070000000000004}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k]>0:
            total_spin += J[l,i,j,k]
            priorities[i*N+j*k][0] -= J[l,i,j,k]
            priorities[i*N+j*k][1] += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
            priorities[i*N+j*k][0] += J[l,i,j,k]
            priorities[i*N+j*k][1] -= J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.0015706000000000001}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

    for k in range(N):
      site_nbr = (k + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,k,j,k]>0:
        priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
      else:
        priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

    for i in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][k]
      if J[5,i,k,0]>0:
        priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
      else:
        priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)


#score: {'data3D.txt': -0.0023822}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  # get the neighboring sites
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.22463819999999998}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N ** 3)]
  total_spin = np.zeros((N, N, N, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]  # get the neighboring sites
        total_spin[i][j][k][0] += h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -J[0, i, j, k]
          total_spin[i][j][k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][1] -= -J[0, i, j, k]
          total_spin[i][j][k][1] += 1

  return priorities


#score: {'data3D.txt': -0.004420599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, site_nbr, i//N%N, i%N%N] * (h[site_nbr][i//N%N][i%N%N] == h[i//N%N][i%N%N][i%N%N]) for k in range(6))
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': -0.0051994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate nearest neighbor interactions
  interacting_spins = []
  for i in range(6):
    interacting_spin = np.copy(h)
    if i < 3:
      interacting_spin[:, :, :-1] = h[:, :, 1:]
    else:
      interacting_spin[:, :-1, :] = h[:, 1:, :]
    interacting_spins.append(interacting_spin)

  # Calculate priorities for each site
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Calculate the total magnetism at this site
    for k in range(6):
      if interacting_spins[k][site_nbr, i//N%N, i%N//N] == h[site_nbr, i//N%N, i%N%N]:
        total_spin += J[k, site_nbr, i//N%N, i%N%N]
    
    # Calculate the priority for each spin
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0009382000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = sum(J[k, site_nbr, i//N%N, i%N%N] for k in [0, 4])
    total_spin_down = sum(-J[k, site_nbr, i//N%N, i%N%N] for k in [1, 2, 3, 5])

    if h[site_nbr][i//N%N][i%N%N] > 0:
      priorities[i][0] += total_spin_up - total_spin_down
      priorities[i][1] -= total_spin_up + total_spin_down
    else:
      priorities[i][0] -= total_spin_up + total_spin_down
      priorities[i][1] += total_spin_up - total_spin_down

  return(priorities)


#score: {'data3D.txt': 0.0003821999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [h[(site_nbr+k)%N][i//N%N][i%N%N] if k < 3 else h[(site_nbr+(k-3)%6)%N][i//N%N][i%N%N] for k in range(6)]
    total_spin = sum(J[k, site_nbr, i//N%N, i%N%N] * interacting_spins[k] for k in range(6))
    if h[i//N%N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': 0.005190199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j] * (h[site_nbr][j] > 0) - (h[site_nbr][j] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if h[tuple(np.mod([site_nbr_nbr[0], site_nbr_nbr[1], site_nbr_nbr[2]], N))]:
            total_spin += J[d, i, j, k] * h[tuple(np.mod([site_nbr_nbr[0], site_nbr_nbr[1], site_nbr_nbr[2]], N))]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.18088540000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j] * (h[site_nbr][j] > 0) - (h[site_nbr][j] < 0))
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        if np.sum(h[i][j][k] * (h[i][j][k] > 0) - (h[i][j][k] < 0)) > 0:
          priorities[i*N*N + j*N + k][0] = total_spin + 1
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin - 1
          priorities[i*N*N + j*N + k][1] = total_spin + 1
  return(priorities)


#score: {'data3D.txt': 0.029998600000000052}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr_nbr = [site_nbr]
        for d in [0, 1]:
          site_nbr_nbr.append((i + ((d-1)%3 - 1)) % N)
        for nbr in set(site_nbr_nbr):
          total_spin += h[nbr][j][k] * (h[nbr][j][k] > 0) - (h[nbr][j][k] < 0)
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.011892199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 4
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 4
          priorities[i*N+j*N+k][1] += 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.0140674}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 4 + total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 4 - total_spin
          priorities[i*N+j*N+k][1] = 2*np.sum(J[:,i,j,k])
  return(priorities)


#score: {'data3D.txt': -0.006528199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 3 + total_spin
          priorities[i*N+j*N+k][1] -= 2*np.sum(J[:,i,j,k])
        else:
          priorities[i*N+j*N+k][0] -= 3 + total_spin
          priorities[i*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0023990000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]
        interaction_term = np.sum(J[:, i, j, k])

        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] -= total_spin - interaction_term
          priorities[i*N+j*N+k][1] += total_spin + interaction_term
        else:
          priorities[i*N+j*N+k][0] += total_spin + interaction_term
          priorities[i*N+j*N+k][1] -= total_spin - interaction_term

  return(priorities)


#score: {'data3D.txt': 0.0043682}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  # Perform a quicksort on the priority list to reduce computation time
  for i in range(N**3):
    if priorities[i, 0] < priorities[i, 1]:
      priorities[[i, N**3-1-i], :]=priorities[[N**3-1-i, i], :]

  return(priorities)


#score: {'data3D.txt': -0.0017221999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + h[site_nbr][j][k]

        # Add interactions with nearest neighbors
        for x in range(3):
          for y in range(3):
            site_x = (i + ((x-1)%2 - 1)) % N
            site_y = (j + ((y-1)%2 - 1)) % N
            total_spin += np.sum(J[:,site_x,site_y,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.0002510000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N

        # Calculate magnetism term
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Add interactions with next-nearest neighbors (if they exist)
        for x in range(3):
          site = ((i+x)%N + ((k-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,site,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.23482820000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.0013662000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        for _ in range(8): 
          if np.random.rand() < 0.5:
            priorities[i*N**2 + j*N + k][0] = -total_spin
            priorities[i*N**2 + j*N + k][1] = total_spin
          else:
            priorities[i*N**2 + j*N + k][0] = total_spin
            priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.14579980000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin
  return priorities


#score: {'data3D.txt': -0.003352200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site,j,k])
          else:
            total_spin -= np.sum(J[:,site,j,k])
        
        # Calculate priority based on total spin and magnetism
        if h[site_nbr][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  # Normalize the priority values for each site
  max_val = np.max(priorities, axis=0)
  min_val = np.min(priorities, axis=0)
  
  priorities[:, 0] = (priorities[:, 0] - min_val[0]) / (max_val[0] - min_val[0])
  priorities[:, 1] = (priorities[:, 1] - min_val[1]) / (max_val[1] - min_val[1])
  
  return(priorities)


#score: {'data3D.txt': -0.007593}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  # Sort sites by priority in descending order
  for i in range(N**3):
    for j in range(2):
      if priorities[i][j] > 0:
        priorities[i][1-j] = -priorities[i][j]
  
  return(priorities)


#score: {'data3D.txt': -0.003230600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0100506}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N**2):
    site_nbr = ((i % N) + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i % N, (i // N), site_nbr] > 0:
      priorities[i][0] += -J[0, i % N, (i // N), site_nbr]
    else:
      priorities[i][1] -= -J[0, i % N, (i // N), site_nbr]

  return(priorities)


#score: {'data3D.txt': -0.0023822}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.0023822}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.0012554}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interaction_sum = 0
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
            interaction_sum -= J[x, i, j, k]
          else:
            total_spin -= 1
            interaction_sum += J[x, i, j, k]
        priorities[i*N*j+N+k][0] = -total_spin*interaction_sum
        priorities[i*N*j+N+k][1] = interaction_sum
  return(priorities)


#score: {'data3D.txt': 0.0002409999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interaction_sum = np.sum(J[:,i,j,k])
        if total_spin > 0:
          priorities[i*N*j+N+k][0] += 4*total_spin*interaction_sum
          priorities[i*N*j+N+k][1] -= interaction_sum
        else:
          priorities[i*N*j+N+k][0] -= 4*total_spin*interaction_sum
          priorities[i*N*j+N+k][1] = -interaction_sum
  return(priorities)


#score: {'data3D.txt': 0.20275100000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_spin = sum(sum(J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          total_spin = sum(sum(-J[l, i, site, k] for l in range(6)) for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
          priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 - total_spin
        
  return priorities


#score: {'data3D.txt': 0.17953780000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_spin = sum(sum(J[l, i, site, k] for l, site in enumerate(((i + ((l-1)%2 - 1)) % N for l in range(6)))) for _ in range(N))
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          total_spin = sum(sum(-J[l, i, site, k] for l, site in enumerate(((i + ((l-1)%2 - 1)) % N for l in range(6)))) for _ in range(N))
          priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 * total_spin
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = -1
        
  return priorities


#score: {'data3D.txt': -0.05237220000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for l, site_nbr in enumerate(site_nbrs):
          interacting_spin = J[l][i][j][k] * h[site_nbr][j][k]
          if interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin + np.sum(h[i][j]), 2 + total_spin - (total_spin > 0)]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities


#score: {'data3D.txt': -0.061783400000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin + np.sum(h[i][j][:]), 
                  -2 if total_spin < 0 else 2]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities


#score: {'data3D.txt': 0.16770260000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr_nbr = [(site_nbr, d) for d in [0, 1]]
        for nbr in set(site_nbr_nbr):
          total_spin += h[nbr[0]][j][k] * (h[nbr[0]][j][k] > 0) - (h[nbr[0]][j][k] < 0)
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(3):
    interacting_spins = np.roll(h, 1, axis=i)
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]  
        total_spin = h[site_nbrs[0]][j][k]
        for l in range(6):
          if J[l,i,j,k]>0:
            total_spin += interacting_spins[(l-1)%3][j][k]
          else:
            total_spin -= interacting_spins[(l-1)%3][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][1] -= -total_spin
          priorities[i * N * N + j * N + k][0] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0013157999999999998}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k]>0:
              priorities[i*N*N+k+j][0] += -J[l,i,j,k]
            else:
              priorities[i*N*N+k+j][1] -= -J[l,i,j,k]
        else:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k]>0:
              priorities[i*N*N+k+j][1] += -J[l,i,j,k]
            else:
              priorities[i*N*N+k+j][0] -= -J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.0021298000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    
    # Add interactions with nearest neighbors
    for k in range(6):
      if k < 3:
        site = (i % N + ((k-1)%2 - 1)) % N
        total_spin += J[k, site, i%N//N, i%N%N]
      else:
        site = (i % N + ((k-4)%2 - 1)) % N
        total_spin -= J[k-3, site, i%N//N, i%N%N]

    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] += total_spin
    else:
      priorities[i][1] = total_spin
      priorities[i][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.0019578}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[site_nbr][i%N//N][i%N%N] > 0:
      total_spin += 2*np.sum(J[:, site_nbr, i%N//N, i%N%N])
    else:
      total_spin -= 2*np.sum(J[:, site_nbr, i%N//N, i%N%N])
    priorities[i][1] = -total_spin
    priorities[i][0] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.00044419999999999947}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    if h[site_nbr][i%N//N][i%N%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(6):
      site = (i % N + ((k-1)%2 - 1)) % N
      
      if h[site][i%N//N][i%N%N] > 0:
        if k < 3:
          total_spin += J[k, site, i%N//N, i%N%N]
        else:
          total_spin -= J[k-3, site, i%N//N, i%N%N]
      else:
        if k < 3:
          total_spin -= J[k, site, i%N//N, i%N%N]
        else:
          total_spin += J[k-3, site, i%N//N, i%N%N]
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.33250379999999974}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for m in range(6):
          if h[site_nbr][j][k] == J[m, i, j, k]:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.00031420000000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.1717913999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + ((k-1)%2 - 1)) % N) * N*N + j*N + k
        parity = h[i][j][k]
        if parity > 0:
          total_parity[site_nbr] += 1
          priorities[site_nbr][1] -= 1
        else:
          total_parity[site_nbr] -= 1
          priorities[site_nbr][1] += 1

  for i in range(N):
    for j in range(N):
      site_energy = 0
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N * N*N + j*N + k
        if h[i][j][k] * J[k, i, j, k] > 0:
          site_energy += J[k, i, j, k]
        else:
          site_energy -= J[k, i, j, k]

      priorities[site_nbr][1] = -site_energy
      total_parity[site_nbr] += h[i][j][k]
      if total_parity[site_nbr] > 0:
        priorities[site_nbr][0] += 2
        priorities[site_nbr][1] -= 1
      else:
        priorities[site_nbr][0] -= 1
        priorities[site_nbr][1] += 2

  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        if parity > 0:
          total_parity[i*N*N + j*N + k] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          total_parity[i*N*N + j*N + k] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.1701173999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.1701173999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': 0.039783800000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = -np.sum(h[i][j][k] * (h[i][j][k] > 0) - (h[i][j][k] < 0))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0026701999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if np.sum(h[site_nbr][j]) > 0:
          priorities[i*N*N + j*N + k] = [-np.sum(h[site_nbr][j]), np.sum(h[site_nbr][j])]
        else:
          priorities[i*N*N + j*N + k] = [np.sum(h[site_nbr][j]), -np.sum(h[site_nbr][j])]
  return(priorities)


#score: {'data3D.txt': 0.028877800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for d in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0018890000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
          
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][site][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Add interactions with diagonally adjacent sites
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][site] > 0:
            total_spin += np.sum(J[:,i,j,site])
          else:
            total_spin -= np.sum(J[:,i,j,site])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0019206000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Add interactions with nearest neighbors
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if interacting_spins[x][site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,i,j,k])
          else:
            total_spin -= np.sum(J[:,i,j,k])
        
        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin
          priorities[i*N+j*N+k][1] += total_spin
        else:
          priorities[i*N+j*N+k][0] = total_spin
          priorities[i*N+j*N+k][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.03404699999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[s][j][k] for s in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': 0.4288834000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l][i][j][k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.15721100000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.0020009999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N))
  for i in range(N**3):
    site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
    interacting_spin = sum(h[site][i//N%N][i%N] for site in site_nbrs)
    
    if h[i//N%N][i%N][0] > 0:
      priorities[i][0] += interacting_spin
      priorities[i][1] -= 2 + np.sum(J[:,i//N%N,i%N,0])
    else:
      priorities[i][0] -= interacting_spin
      priorities[i][1] += 2 - np.sum(J[:,i//N%N,i%N,0])

  return(priorities)


#score: {'data3D.txt': -0.004812599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [h[site][j][k] for site in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*N+k][0] += np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k])
          priorities[i*N+j*N+k][1] += 2

  # calculate the priority for each site based on its magnetism and interactions
  for i in range(N**3):
    total_spin = sum(h[site][i//N%N][i%N] for site in [(i + ((k-1)%2 - 1)) % N for k in range(6)])
    
    if h[i//N%N][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    for k in range(3):
     site_nbr = (i + ((k-1)%2 - 1)) % N
     if h[site_nbr][i//N%N][i%N] > 0:
       priorities[i][0] -= np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] += np.sum(J[:,site_nbr,i//N%N,i%N])
     else:
       priorities[i][0] += np.sum(J[:,site_nbr,i//N%N,i%N])
       priorities[i][1] -= np.sum(J[:,site_nbr,i//N%N,i%N])

  return(priorities)


#score: {'data3D.txt': 0.4288834000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += np.sum(J[:,i,j,k]) - 1
          priorities[i*N**2 + j*N + k][1] -= np.sum(J[:,i,j,k]) + 1
        else:
          priorities[i*N**2 + j*N + k][0] -= np.sum(J[:,i,j,k]) - 1
          priorities[i*N**2 + j*N + k][1] = -np.sum(J[:,i,j,k]) + 1
  return priorities


#score: {'data3D.txt': -0.3383158000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.057733400000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in site_nbrs:
          total_spin += h[neighbor][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': -0.3928838}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  return priorities


#score: {'data3D.txt': -0.228707}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        site_parity = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if sum(site_parity) > 0:
          priorities[i*N**2 + j*N + k][0] += len([x for x in site_parity if x > 0])
          priorities[i*N**2 + j*N + k][1] -= len([x for x in site_parity if x < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([x for x in site_parity if x > 0])
          priorities[i*N**2 + j*N + k][1] += len([x for x in site_parity if x < 0])
  return priorities


#score: {'data3D.txt': 0.3425773999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs.append((i + ((k-1)%2 - 1)) % N)
  
  site_nbr_map = {site:i for i,site in enumerate(site_nbrs)}
  site_nbr_inv = {i:site for i,site in enumerate(site_nbrs)}

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N**3):
    site = (i // N**(2), i % N**(2) // N, i % N)
    if h[site[0]][site[1]][site[2]] > 0:
      priorities[i][0] = -total_spin[site[0]][site[1]][site[2]][0]
      priorities[i][1] -= total_spin[site[0]][site[1]][site[2]][1]
    else:
      priorities[i][0] = total_spin[site[0]][site[1]][site[2]][0]
      priorities[i][1] = -total_spin[site[0]][site[1]][site[2]][1]

  return(priorities)


#score: {'data3D.txt': 0.011032599999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N**3):
    if h[(i//N)**(2)%N][(i//N)%N][(i%N)] > 0:
      priorities[i][0] = -total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][0]
      priorities[i][1] -= total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][1]
    else:
      priorities[i][0] = total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][0]
      priorities[i][1] = -total_spin[(i//N)**(2)%N][(i//N)%N][(i%N)][1]

  return(priorities)


#score: {'data3D.txt': -0.0004950000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][1]
  
  return(priorities)


#score: {'data3D.txt': -0.3424029999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities


#score: {'data3D.txt': 0.012453}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          if J[l, i, site_nbr, k] * h[i][j][k] > 0:
            total_spin[1] -= J[l, i, site_nbr, k]
          else:
            total_spin[1] += J[l, i, site_nbr, k]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 2
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += h[i][j][k]
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 2
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities


#score: {'data3D.txt': -0.15837580000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if J[0][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l+1][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.295207}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(6):
          site = (i + ((l-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.0075998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((x-1)%2 - 1)) % N for x in range(6)]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if total_spin > 0:
          priorities[i*N+j*N+k][0] = np.sum(J[:,i,j,k]) + len([x for x in site_nbrs if h[x][j][k] > 0])
          priorities[i*N+j*N+k][1] = -2*len([x for x in site_nbrs if h[x][j][k] > 0])
        elif total_spin < 0:
          priorities[i*N+j*N+k][0] = -np.sum(J[:,i,j,k]) - len([x for x in site_nbrs if h[x][j][k] < 0])
          priorities[i*N+j*N+k][1] = 2*len([x for x in site_nbrs if h[x][j][k] < 0])
  return(priorities)


#score: {'data3D.txt': -0.0046366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N+j*N+k][0] = 2*total_spin
        for x in range(6):
          site_nbr = (i + ((x-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*N+k][1] += J[x,i,j,k]
          else:
            priorities[i*N+j*N+k][1] -= J[x,i,j,k]
  return(priorities)


#score: {'data3D.txt': 0.009815399999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.004954200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for y in range(3):
          site = (i + ((y-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  # Calculate the priority for each site based on interactions with its nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
        else:
          priorities[i*N+j*N+k][1] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])

  return(priorities)


#score: {'data3D.txt': 0.004627}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and magnetism
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        # Add interactions with nearest neighbors
        for x in range(3):
          site = (i + ((x-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        for y in range(3):
          site = (i + ((y-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += np.sum(J[:,site_nbr,j,k])
          else:
            total_spin -= np.sum(J[:,site_nbr,j,k])

        # Update priorities based on total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][1] = -total_spin
          priorities[i*N+j*N+k][0] += total_spin
        else:
          priorities[i*N+j*N+k][1] = total_spin
          priorities[i*N+j*N+k][0] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.19256180000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        
        if h[i][j][k] > 0:
          site_nbrs += [j, i, (j+1)%N, (i+1)%N, (j+i-1)%N]
        else:
          site_nbrs = [(i + ((k-1)%2 - 1)) % N, j, i, (j+1)%N, (i+1)%N, (j+i-1)%N]
        
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k] if h[i][j][k] == J[0, i, j, k] else -h[site_nbr][j][k]
        
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0020134000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if k < 3:
          site_nbrs += [j]
        else:
          site_nbrs += [i]
        total_spin = sum(h[site_nbr][k%N] for site_nbr in site_nbrs)
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.032626199999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if h[i][j][k] > 0:
          for m in site_nbrs:
            if J[0, i, j, k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        else:
          for m in site_nbrs:
            if J[0, i, j, k] < 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': 0.034185400000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        if k < 3:
          site_nbrs += [j]
        else:
          site_nbrs += [i]
        
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          
        if J[k, i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0035905999999999993}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k] > 0:
              priorities[i*N*N+k+j][0] += -J[l,i,j,k]
              for m in range(6):
                site_nbrs_2 = [(site_nbrs[0] + (m % 2)) % N, (site_nbrs[1] + ((m//2)%2 - 1)) % N, (site_nbrs[2] + ((m//4)%2 - 1)) % N]
                if J[m,i,j,k] > 0:
                  priorities[i*N*N+k+j][0] += -J[m,i,j,k]
                else:
                  priorities[i*N*N+k+j][1] -= -J[m,i,j,k]
            else:
              priorities[i*N*N+k+j][1] += J[l,i,j,k]
        else:
          for l in range(6):
            site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
            if J[l,i,j,k] > 0:
              priorities[i*N*N+k+j][1] += -J[l,i,j,k]
              for m in range(6):
                site_nbrs_2 = [(site_nbrs[0] + (m % 2)) % N, (site_nbrs[1] + ((m//2)%2 - 1)) % N, (site_nbrs[2] + ((m//4)%2 - 1)) % N]
                if J[m,i,j,k] > 0:
                  priorities[i*N*N+k+j][1] += -J[m,i,j,k]
                else:
                  priorities[i*N*N+k+j][0] -= -J[m,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.0028738000000000006}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        total_spin = 0
        for l in range(6):
          site_nbrs = [(i + (l % 2)) % N, (j + ((l//2)%2 - 1)) % N, (k + ((l//4)%2 - 1)) % N]
          total_spin += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
          
          if J[l,i,j,k]>0:
            priorities[i*N*N+k+j][0] += -J[l,i,j,k]*total_spin
          else:
            priorities[i*N*N+k+j][1] -= -J[l,i,j,k]*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0026686000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  # Calculate the priority for assigning spins to -1 and 1
  for i in range(N**3):
    total_spin = h[i//N//N][i%N//N][i%N%N]
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add interactions with nearest neighbors
    total_spin += np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    for x in range(3):
      for y in range(3):
        site = (i % N + ((y-1)%2 - 1)) % N
        if h[site][i//N//N][i%N%N] > 0:
          total_spin += np.sum(J[:, site, i//N//N, i%N%N])
        else:
          total_spin -= np.sum(J[:, site, i//N//N, i%N%N])

    # Update priorities based on total spin and magnetism
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] += total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.00015339999999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N] + np.sum(J[:, site_nbr, i//N//N, i%N%N])
    
    if h[i//N//N][i%N//N][i%N%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = np.sum(J[:,site_nbr,i//N//N,i%N%N], axis=0)
    
    if h[site_nbr][i//N//N][i%N%N] > 0:
      priorities[i][0] += h[site_nbr][i//N//N][i%N%N] + np.sum(interacting_spins)
      priorities[i][1] -= h[site_nbr][i//N//N][i%N%N] - np.sum(interacting_spins)
    else:
      priorities[i][0] -= h[site_nbr][i//N//N][i%N%N] + np.sum(interacting_spins)
      priorities[i][1] += h[site_nbr][i//N//N][i%N%N] - np.sum(interacting_spins)

  return(priorities)


#score: {'data3D.txt': 0.0264526}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          if h[site_nbr_nbr][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.15721100000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  total_magnetism = np.sum(h, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin = 1
        else:
          total_spin = -1
        
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.03029540000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr_nbr][j][k]
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.10349660000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d,i,j,k]*h[site_nbr_nbr][j][k]
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.07231620000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2, 3]:
          if l == 1:
            site_nbr = (i + ((l-1)%2 - 1)) % N
          elif l == 2:
            site_nbr = (j + ((l-1)%2 - 1)) % N
          else:
            site_nbr = (k + ((l-1)%2 - 1)) % N
          
          total_spin[0] += h[site_nbr][i%N][j%N]
          interacting_spin = J[l, i%N, j%N, k%N]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.013477}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [3, 4, 5]:
          site_nbr = (i + ((l-2)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.0016389999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for l in [3, 4]:
          site_nbr = (i + ((l-3)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.18907620000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        priorities[i*N*N + j*N + k][0] = site_parity + total_spin[0]
        priorities[i*N*N + j*N + k][1] = -site_parity - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.16461060000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = -np.sum(h[site_nbr][j][k] * (h[site_nbr][j][k] > 0) - (h[site_nbr][j][k] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
        else:
          priorities[i*N*N + j*N + k][0] = total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.15673940000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.25791540000000057}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j][k] * h[i][j][k])
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[i][j][k]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.15673940000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0092466}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = np.sum(h[site_nbr][j][k] * (h[site_nbr][j][k] > 0) - (h[site_nbr][j][k] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          total_spin += np.sum(J[d, :, :, :] * h[site_nbr_nbr])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.16666860000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = -np.sum(h[site_nbr][j][k] * (h[site_nbr][j][k] > 0) - (h[site_nbr][j][k] < 0))
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
            if h[i][j][k] > 0:
              priorities[i*N*N + j*N + k][0] -= total_spin
              priorities[i*N*N + j*N + k][1] = -priorities[i*N*N + j*N + k][0]
            else:
              priorities[i*N*N + j*N + k][0] = -priorities[i*N*N + j*N + k][0]
              priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.047046199999999955}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = -np.sum(h[i][j][k] * (h[i][j][k] > 0) - (h[i][j][k] < 0))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
            if h[i][j][k] > 0:
              priorities[i*N*N + j*N + k][0] = -total_spin
              priorities[i*N*N + j*N + k][1] = total_spin
            else:
              priorities[i*N*N + j*N + k][0] = total_spin
              priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.0008377999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = h[site_nbrs[0]][j][k] + h[i][site_nbrs[1]][k] + h[i][j][site_nbrs[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
        for l in range(3):
          site_nbrs_site = [(site_nbrs[0] + ((l-1)%2 - 1)) % N, (j + (l-1)%2 - 1) % N, (k + (l-1)%2 - 1) % N]
          total_spin += h[site_nbrs_site[0]][site_nbrs_site[1]][site_nbrs_site[2]]
        if J[0,i,j,k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.00011540000000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1+1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.0023381999999999995}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    total_spin = 0
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

  return(priorities)


#score: {'data3D.txt': 0.032626199999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = 0
        if h[i][j][k] > 0:
          for m in site_nbrs:
            if J[0, i, j, k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        else:
          for m in site_nbrs:
            if J[0, i, j, k] < 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = 0
        if h[i][j][k] > 0:
          for m in site_nbrs:
            total_spin += 1
        else:
          for m in site_nbrs:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': 0.05503500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + (l-1)%2 - 1) % N for l in [0,1,2]]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if J[0, i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.0006721999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbr_nbr = tuple(np.mod([i, j, k], N))
          if np.any(J[d, :, :, :] * h[site_nbr_nbr]):
            total_spin += J[d, i, j, k] * h[site_nbr_nbr]
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.0264526}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for d in range(6):
          site_nbr_nbr = (i + ((d-1)%3 - 1)) % N
          if h[site_nbr_nbr][j][k] > 0:
            priorities[i*N*N + j*N + k][0] -= J[d, i, j, k]
            priorities[i*N*N + j*N + k][1] += J[d, i, j, k]
          else:
            priorities[i*N*N + j*N + k][0] += J[d, i, j, k]
            priorities[i*N*N + j*N + k][1] -= J[d, i, j, k]
  return(priorities)


#score: {'data3D.txt': 0.0240058}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          site_nbr = (i + ((d-1)%3 - 1)) % N
          total_spin += J[d, i, j, k] * h[site_nbr][j][k]
        
        if np.sum(h[i][j][k]) > 0:
          priorities[i*N*N + j*N + k][0] = total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': 6.77999999999993e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin for each site
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += total_spin[i][j][k][0]
          total_spin[i][j][k][1] -= total_spin[i][j][k][1]
        else:
          total_spin[i][j][k][0] -= total_spin[i][j][k][0]
          total_spin[i][j][k][1] += total_spin[i][j][k][1]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][1]

  return(priorities)


#score: {'data3D.txt': -0.0011002000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] -= np.sum(J[:,i,j,k])
        else:
          total_spin[i][j][k][0] -= np.sum(J[:,i,j,k])
          total_spin[i][j][k][1] += np.sum(J[:,i,j,k])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = -total_spin[i][j][k][0] + total_spin[i][j][k][1]
          priorities[i*N+j*N+k][1] -= total_spin[i][j][k][0] - total_spin[i][j][k][1]
        else:
          priorities[i*N+j*N+k][0] = total_spin[i][j][k][0] + total_spin[i][j][k][1]
          priorities[i*N+j*N+k][1] = -total_spin[i][j][k][0] - total_spin[i][j][k][1]

  return(priorities)


#score: {'data3D.txt': -0.013106200000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k] + np.sum(J[:,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] += 1 + total_spin
          priorities[i*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.10061580000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0,0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += h[i][j][k]
        total_spin[1] = -total_spin[0]
        
        if np.sum(h[i][j]) > 0:
          priorities[i*N*N + j*N + k][0] += 2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] -= 2 * (np.sum(np.abs(h[i][j])) - total_spin[1])
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] += 2 * (np.sum(np.abs(h[i][j])) - total_spin[1])
  
  return priorities


#score: {'data3D.txt': 0.0071334}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = 2 + np.sum(total_spin)
          priorities[i*N*N + j*N + k][1] = -np.sum(total_spin) - 2
        else:
          priorities[i*N*N + j*N + k][0] = -2 - np.sum(total_spin)
          priorities[i*N*N + j*N + k][1] = 2 + np.sum(total_spin)
  return priorities


#score: {'data3D.txt': -0.33910299999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += h[i][j][k]
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 2 - total_spin[0] - np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 + total_spin[1] + np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.0037186}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0032878000000000004}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if J[:, i, j, k].sum() > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.13098620000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        parity = h[i][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
          if parity * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*N + j*N + k][1] = -total_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + np.sum(np.abs(h[i]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + np.sum(np.abs(h[i]))
        
  return priorities


#score: {'data3D.txt': 0.20013500000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = site_parity * (total_spin[0] - total_spin[1])
        priorities[i*N*N + j*N + k][1] = site_parity * (total_spin[0] + total_spin[1])
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.2499474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin + h[site_nbr][j][k]
        priorities[i*N**2 + j*N + k][1] = -total_spin + h[site_nbr][j][k]
  return priorities


#score: {'data3D.txt': -0.3884378}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if J[0][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l+1][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  return priorities


#score: {'data3D.txt': -0.1960806000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.1421818000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 1, 2]]
        total_spin = [0, 0]
        
        for site_nbr in site_nbrs:
          interacting_spins = J[:, i, site_nbr, k]
          
          if h[site_nbr][j][k] > 0:
            total_spin[0] += np.sum(interacting_spins)
            total_spin[1] -= np.sum(interacting_spins)
          else:
            total_spin[0] -= np.sum(interacting_spins)
            total_spin[1] += np.sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -2 * (np.sum(np.abs(h[i][j])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = 1 + total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.034866600000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0,0]
        
        # Calculate the magnetism at each site
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        # Calculate the priority based on the magnetism and interactions
        if np.sum(h[i]) > 0:
          priorities[i*N*N + j*N + k][0] = 2 * (np.sum(np.abs(h[i])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = -2 * (np.sum(np.abs(h[i])) - total_spin[1])
        else:
          priorities[i*N*N + j*N + k][0] = -2 * (np.sum(np.abs(h[i])) - total_spin[0])
          priorities[i*N*N + j*N + k][1] = 2 * (np.sum(np.abs(h[i])) - total_spin[1])
  
  return priorities


#score: {'data3D.txt': -0.0020134000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0024914000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0020134000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0024914000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[k,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.3429965999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  for i in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j][k] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[i][site][k] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  priorities[i*N**2 + j*N + k][0] = -total_spin
  priorities[i*N**2 + j*N + k][1] = total_spin
  return priorities


#score: {'data3D.txt': -0.1960806000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if h[site_nbr][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.0023822}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.0038766}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          for l in range(6):
            if J[l,i,j,k]>0:
              priorities[i*N+j*k][0] += -J[l,i,j,k]
            else:
              priorities[i*N+j*k][1] -= -J[l,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.031546999999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin * total_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin * total_spin
  
  return priorities


#score: {'data3D.txt': -0.32961419999999975}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        # Add more spin configurations here...
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.17194819999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N+j*N+k][0] = -total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  site_nbr = lambda i, j, k: ((i + (k-1)%2 - 1)) % N
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_val = site_nbr(i, j, k)
        total_spin[i*N*N+j*N+k][0] += h[site_nbr_val][j][k]
        if h[site_nbr_val][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return priorities


#score: {'data3D.txt': -0.0008205999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [(i+1)%N, (i-1+N)%N]:
          interacting_spin = J[0, i, l, k] * (h[l][j][k] if l != i else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for m in [(j+1)%N, (j-1+N)%N]:
          interacting_spin = J[1, i, j, m] * (h[i][m][k] if m != j else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for n in [(k+1)%N, (k-1+N)%N]:
          interacting_spin = J[2, i, j, k] * (h[i][j][n] if n != k else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.0106726}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  return priorities


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = lambda i, j, k: (i + ((k-1)%2 - 1)) % N

  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin[i*N*N+j*N+k][0] += h[site_nbr(i,j,k)][j][k]
        if h[site_nbr(i,j,k)][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0020986}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for j in range(N):
      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[i,k,j,k]>0:
          priorities[k*N+j][0] += 1
          priorities[k*N+j][1] -= 1
        else:
          priorities[k*N+j][0] -= 1
          priorities[k*N+j][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.0016629999999999995}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[3,k,j,k]>0:
          priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
        else:
          priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)


#score: {'data3D.txt': -0.22557780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[site_nbr2][k]
        if J[0, i, j, k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.000942600000000001}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for k in range(N):
      for j in range(N):
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr][k]
        if J[i,k,j,0]>0:
          priorities[k*N+j][0] += J[i,k,j,0]-J[i,k,j,1]
        else:
          priorities[k*N+j][1] -= J[i,k,j,0]+J[i,k,j,1]

  for i in range(N):
    for k in range(N):
      site_nbr = (k + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i,k,k]>0:
        priorities[i*N+k][0] += J[3,i,k,k]-J[4,i,k,k]
      else:
        priorities[i*N+k][1] -= J[3,i,k,k]+J[4,i,k,k]

  for j in range(N):
    site_nbr = (j + ((i-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)


#score: {'data3D.txt': -0.0020126000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(interacting_spins[0,i,j,k]) + h[i][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= 1

  return(priorities)


#score: {'data3D.txt': -0.0093394}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N**2):
    site_nbr = ((i % N) + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i % N]
    if J[0, i % N, (i // N), site_nbr] > 0:
      priorities[i][0] += -J[0, i % N, (i // N), site_nbr]
    else:
      priorities[i][1] -= -J[0, i % N, (i // N), site_nbr]

  for k in range(3):
    for i in range(N**2):
      site = ((i % N) + ((i//N-1)%2 - 1)) % N
      total_spin = h[site][i % N]
      if J[k, i % N, (i // N), site] > 0:
        priorities[i][0] += -J[k, i % N, (i // N), site]
      else:
        priorities[i][1] -= -J[k, i % N, (i // N), site]

  return(priorities)


#score: {'data3D.txt': -0.0040102}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(6):
    interacting_spins = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)
    for j in range(N):
      for k in range(N):
        site_nbr = ((j + ((k-1)%2 - 1)) % N)
        total_spin = h[site_nbr][k]
        if J[i, j, k, site_nbr] > 0:
          priorities[j*N*N + k][0] += -J[i, j, k, site_nbr]
        else:
          priorities[j*N*N + k][1] -= -J[i, j, k, site_nbr]
  return(priorities)


#score: {'data3D.txt': -0.0100506}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N**2):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N]
    total_spin = h[site_nbrs[0]][i % N]
    if J[0, i % N, (i // N), site_nbrs[0]] > 0:
      for m in site_nbrs:
        priorities[i][0] += -J[0, i % N, (i // N), m]
    else:
      for m in site_nbrs:
        priorities[i][1] -= -J[0, i % N, (i // N), m]

  return(priorities)


#score: {'data3D.txt': 0.0014605999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Count the number of neighboring sites with positive magnetism
        count_pos = 0
        for l in range(6):
          interacting_site = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_site > 0:
            count_pos += 1
          
        # Calculate the priority based on the total spin and magnetism
        priority_total = [2*count_pos - np.sum(h[i][j][:]), 
                  -2 if count_pos < N**3/2 else 2]
        
        priorities[i*N*N + j*N + k] = priority_total
        
  return priorities


#score: {'data3D.txt': -0.061783400000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin + np.sum(h[i][j][:]), 
                 -2 if total_spin < 0 else 2]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities


#score: {'data3D.txt': -0.11006180000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = 0
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            site_energy += J[l, i, j, k]
            total_spin += 1
          else:
            site_energy -= J[l, i, j, k]
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -site_energy
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for s in site_nbrs:
          if h[s][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': -0.305677}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] = -total_spin[i][j][k][0]
          priorities[i*N*N+j*N+k][1] += total_spin[i][j][k][0]

  return(priorities)


#score: {'data3D.txt': -0.0046738}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(N):
        interacting_spin = J[0, i, site_nbr, k] + J[1, i, j, k] + J[2, i, site_nbr, k]
        if h[i][j][k] * interacting_spin > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total = [total_spin + np.sum(h[i][j][:]), -2 if total_spin < 0 else 2]
      priorities[i*N*N + j*N + k] = priority_total
  return priorities


#score: {'data3D.txt': -0.20907940000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  return(priorities)


#score: {'data3D.txt': -0.0639878}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  return(priorities)


#score: {'data3D.txt': -0.016313400000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[0, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[1, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i, j, k]

  return(priorities)


#score: {'data3D.txt': -0.04243580000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]
        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin
  return priorities


#score: {'data3D.txt': 0.058817400000000054}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin + 2
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin + 2
  return priorities


#score: {'data3D.txt': 0.001733399999999999}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[3,k,j,k]>0:
          priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
        else:
          priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5,i,k,0]>0:
      priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
    else:
      priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  for i in range(N):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    total_spin += h[site_nbr][j]
    if J[1,i,j,k]>0:
      priorities[i*N+j][0] += J[1,i,j,k]-J[2,i,j,k]
    else:
      priorities[i*N+j][1] -= J[1,i,j,k]+J[2,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.0016629999999999995}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i, 0, j, 0] > 0:
        priorities[j*N][0] += J[i, 0, j, 0] - J[i, 1, j, 0]
      else:
        priorities[j*N][1] -= J[i, 0, j, 0] + J[i, 1, j, 0]

      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[3, k, j, k] > 0:
          priorities[k*N+k][0] += J[3, k, j, k] - J[4, k, j, k]
        else:
          priorities[k*N+k][1] -= J[3, k, j, k] + J[4, k, j, k]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    if J[5, i, k, 0] > 0:
      priorities[i*N+k][0] += J[5, i, k, 0] - J[5, i, k, 1]
    else:
      priorities[i*N+k][1] -= J[5, i, k, 0] + J[5, i, k, 1]

  return(priorities)


#score: {'data3D.txt': 0.0020066}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(6):
    if i < 3:
      direction = [(i-1)%2 - 1]
    else:
      direction = [((i-4)%2) - 1]
    for j in range(N):
      site_nbr = (j + direction[0]) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

      for k in range(N):
        site_nbr = (k + direction[0]) % N
        total_spin += h[site_nbr][j]
        if J[3,k,j,k]>0:
          priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
        else:
          priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

  return(priorities)


#score: {'data3D.txt': 0.01501379999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] * J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.17194819999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        site_interactions = sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][0] = -total_spin + site_interactions
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0320118}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l, i, j, k] * h[site_nbr][j][k] for l in range(6))
        if np.sum(h[i][j]) > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin + np.sum(h[site_nbr][j])
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = total_spin - np.sum(h[site_nbr][j])
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.1498885999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(6))
        priorities[i*N*N+j*N+k][0] = -total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022970000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        priorities[i*N*N + j*N + k][0] = np.sum(np.abs(h[i][j])) - 2 * (site_parity > 0) + total_spin[0]
        priorities[i*N*N + j*N + k][1] = -np.sum(np.abs(h[i][j])) - 2 * (site_parity <= 0) - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.13098620000000008}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return [[x[0], x[1]] for x in priorities]


#score: {'data3D.txt': -0.1707794}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.087471}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr_x = (i + ((l-3)%2 - 1)) % N
          site_nbr_y = (j + ((l%3-1)%2 - 1)) % N
          site_nbr_z = (k + ((l//3-1)%2 - 1)) % N
          
          interacting_spin_x = J[0, i, site_nbr_x, k]
          interacting_spin_y = J[1, j, site_nbr_y, k]
          interacting_spin_z = J[2, i, site_nbr_z, k]
          
          if h[site_nbr_x][j][k] * interacting_spin_x > 0:
            total_spin[0] += interacting_spin_x
          else:
            total_spin[1] -= interacting_spin_x
          
          if h[i][site_nbr_y][k] * interacting_spin_y > 0:
            total_spin[0] += interacting_spin_y
          else:
            total_spin[1] -= interacting_spin_y
          
          if h[i][j][site_nbr_z] * interacting_spin_z > 0:
            total_spin[0] += interacting_spin_z
          else:
            total_spin[1] -= interacting_spin_z
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': 0.006841000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, ((i+j-2)%2 - 1), ((i+j-4)%2 - 1)]
        
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  return priorities


#score: {'data3D.txt': 0.0106726}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_parity = [0] * (N ** 3)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        # Calculate the interacting spin energy
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        # Calculate the priority based on the site's magnetism and spin energy
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = -total_parity[i*N*N + j*N + k] + total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.0106726}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        
        for site in interacting_sites:
          if site_parity * h[i][site][k] > 0:
            total_spin[0] += J[0][i][site][k]
            total_spin[1] -= J[0][i][site][k]
          else:
            total_spin[0] -= J[0][i][site][k]
            total_spin[1] += J[0][i][site][k]
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0011129999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        
        for site in interacting_sites:
          if site_parity * h[site][j][k] > 0:
            total_spin[0] += J[0][i][site][k]
            total_spin[1] -= J[5][i][site][k]
          else:
            total_spin[0] -= J[0][i][site][k]
            total_spin[1] += J[5][i][site][k]
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  return priorities


#score: {'data3D.txt': -0.10301780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        site_total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            site_total_spin[0] += interacting_spin
          else:
            site_total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity + site_total_spin[0]
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        # Calculate the total spin from interacting sites
        for l in range(6):
          if l % 2 == 1:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            interacting_spin = J[l//2, i, site_nbr, k]
            if h[site_nbr][j][k] * interacting_spin > 0:
              total_spin[0] += interacting_spin
            else:
              total_spin[1] -= interacting_spin
        
        # Assign priorities based on the total spin and local magnetism
        if site_parity > 0:
          priorities[i*N**2 + j*N + k][0] = 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N**2 + j*N + k][1] = -2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N**2 + j*N + k][0] = -1 - total_spin[0] - np.sum(np.abs(h[i][j]))
          priorities[i*N**2 + j*N + k][1] = 3 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.008112600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += J[k, i, j, k] * h[site_nbr][j][k]
        total_spin[1] -= J[k, i, j, k] * h[i][j][k]
      priorities[i*N*N+j*N+k][0] = -total_spin[0] + sum(h[site_nbr][j])
      priorities[i*N*N+j*N+k][1] = total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0320118}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l, i, j, k] * h[site_nbr][j][k] for l in range(6))
        if np.sum(h[i][j]) > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin + np.sum(h[site_nbr][j])
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = total_spin - np.sum(h[site_nbr][j])
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0364858}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[0, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[1, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[2, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[0, i, j, k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 2 * J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += 2 * J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += 2 * J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= 2 * J[3, i, j, k]

  return(priorities)


#score: {'data3D.txt': 0.063195}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] -= J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[3, i, j, k]
  return(priorities)


#score: {'data3D.txt': -0.002438600000000001}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
          if J[0,i,j,k]>0:
            total_spin += J[0,i,l,k] + J[1,i,j,l] + J[2,i,j,k]
            priorities[i*N+j*k][0] -= 3*J[0,i,l,k] + J[1,i,j,l]
          else:
            total_spin -= J[0,i,l,k] + J[1,i,j,l] + J[2,i,j,k]
            priorities[i*N+j*k][1] += 3*J[0,i,l,k] + J[1,i,j,l]
  
  return(priorities)


#score: {'data3D.txt': -0.0023822}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3) + np.roll(h, 1, axis=i%3)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]  
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            priorities[i*N+j*k][0] += -J[0,i,j,k]
          else:
            priorities[i*N+j*k][1] -= -J[0,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.17083460000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = sum(h[(i+1)%N][j][k] if (i+1)%N == i else 
                 h[(i-1)%N][j][k] if (i-1)%N == i else 0 for _ in range(3)) + \
              sum(J[l, i, (i+1)%N, k] if (i+1)%N == i else J[l, i, (i-1)%N, k] 
                for l in [1,2,3,4,5])
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        
  return priorities


#score: {'data3D.txt': -0.3416189999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]

        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin

        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin

        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities


#score: {'data3D.txt': -0.2545690000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        total_spin_sum = sum(h[i][j])
        if total_spin_sum > 0:
          priorities[i*N*N + j*N + k][0] += 2 * (total_spin_sum > 0)
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * (total_spin_sum < 0)
          priorities[i*N*N + j*N + k][1] += 2
        
  return priorities


#score: {'data3D.txt': -0.3424029999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
        
        # Add more spin configurations here...
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.1564158}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
 
  return priorities


#score: {'data3D.txt': -0.29681820000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= 2 * np.sum(np.abs(h[i][j])) - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] += 2 * np.sum(np.abs(h[i][j])) - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.04226019999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        site_parity = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l, i, site_nbr, k] * site_parity > 0:
            total_spin[0] += 1
          else:
            total_spin[1] -= 1
        
        priorities[i*N*N + j*N + k][0] = np.sum(np.abs(h[i][j])) - total_spin[0]
        priorities[i*N*N + j*N + k][1] = -priorities[i*N*N + j*N + k][0]
  
  return priorities


#score: {'data3D.txt': -0.0020150000000000007}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        
        if J[0,i,j,k]>0:
          priorities[i*N+j*k][0] += 4*J[0,i,j,k]-J[5,i,k,0]
        else:
          priorities[i*N+j*k][1] -= 4*J[0,i,j,k]+J[5,i,k,0]

  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    total_spin += h[site_nbr][k]
    
    if J[3,i,j,k]>0:
      priorities[i*N+j*k][0] += J[3,i,j,k]-J[4,i,j,k]
    else:
      priorities[i*N+j*k][1] -= J[3,i,j,k]+J[4,i,j,k]

  for i in range(N):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    total_spin += h[site_nbr][j]
    
    if J[5,i,j,0]>0:
      priorities[i*N+j*k][0] += J[5,i,j,0]-J[5,i,k,0]
    else:
      priorities[i*N+j*k][1] -= J[5,i,j,0]+J[5,i,k,0]

  return(priorities)


#score: {'data3D.txt': -0.0018202}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][i][0]
        if J[0,k,j,0]>0:
          priorities[i*N+j*k][0] += J[0,k,j,0]-J[1,k,j,0]
        else:
          priorities[i*N+j*k][1] -= J[0,k,j,0]+J[1,k,j,0]
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k][0]
        if J[3,i,k,0]>0:
          priorities[i*N+j*k][0] += J[3,i,k,0]-J[4,i,k,0]
        else:
          priorities[i*N+j*k][1] -= J[3,i,k,0]+J[4,i,k,0]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][0]
        if J[5,i,j,0]>0:
          priorities[i*N+j*k][0] += J[5,i,j,0]-J[5,i,j,1]
        else:
          priorities[i*N+j*k][1] -= J[5,i,j,0]+J[5,i,j,1]

  return(priorities)


#score: {'data3D.txt': -0.0017458000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0, 0]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, interacting_spins[:, i, j, k])):
          total_spin[0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)    
  for k in range(N**2):
    site_nbrs = [(i//N + ((k%N-1)%2 - 1)) % N for _ in range(6)]
    total_spin = [0, 0]
    for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, interacting_spins[:, i//N, i%N, k%N])):
      if h[site_nbr][k%N][k//N] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    priorities[k][0] = -total_spin[0]
    priorities[k][1] = float('-inf')
  return(priorities)


#score: {'data3D.txt': -0.0023390000000000004}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, interacting_spins[:, i, j, k])):
          total_spin[i*N+j*k][0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= 1
          else:
            total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': -0.0017458000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0, 0]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, J[ :, i, j, k])):
          total_spin[0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
        else:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.037901}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for l in [0, 1]:
          total_spin += J[l, i, j, k]
        if total_spin > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0639878}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2)) 
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3, i, j, k]
          priorities[i*N*N+j*N+k][1] += J[4, i, j, k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5, i, j, k]
          priorities[i*N*N+j*N+k][1] -= J[3, i, j, k]

  for k in range(N):
    for j in range(N):
      for i in range(N):
        if h[i][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for k in range(N):
    for j in range(N):
      for i in range(N):
        if total_spin[i][j][k][0] > total_spin[i][j][k][1]:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        elif total_spin[i][j][k][0] < total_spin[i][j][k][1]:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        for l in [0, 4]:  # top and bottom neighbors
          if h[site_nbr][j][k] > 0:
            total_spin -= J[l, i, j, k]
          else:
            total_spin += J[l, i, j, k]

        for l in [1, 2, 3, 5]:  # left, right and front neighbors
          if h[i][j][k] > 0:
            total_spin -= J[l, i, j, k]
          else:
            total_spin += J[l, i, j, k]

        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.3174125999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = 0

        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]

        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin

        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin

        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2 - np.sum(np.abs(J[:, i, :, k]))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2 - np.sum(np.abs(J[:, i, :, k]))

  return priorities


#score: {'data3D.txt': 0.0332162}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        parity = h[i][j][k]
        if parity > 0:
          for l in [0, 1]:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            interacting_spin = J[3*l, i, j, k] - J[3*l+1, i, j, k] - J[3*l+2, i, j, k]
            if h[site_nbr][j][k] * interacting_spin > 0:
              total_spin -= interacting_spin
            else:
              total_spin += interacting_spin
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          for l in [0, 1]:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            interacting_spin = J[3*l, i, j, k] + J[3*l+1, i, j, k] + J[3*l+2, i, j, k]
            if h[site_nbr][j][k] * interacting_spin > 0:
              total_spin -= interacting_spin
            else:
              total_spin += interacting_spin
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  
  return priorities


#score: {'data3D.txt': 0.17194819999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1

        for l in range(6):
          interacting_site = [(i+((l-1)%3 - 1)) % N, (j+((l-1)%2 - 1)) % N, (k+((l-1)%3 - 1)) % N]
          if h[interacting_site[0]][interacting_site[1]][interacting_site[2]] > 0:
            priorities[i*N**2 + j*N + k][1] -= J[l, i, interacting_site[0], interacting_site[2]]
          else:
            priorities[i*N**2 + j*N + k][1] += J[l, i, interacting_site[0], interacting_site[2]]

        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin

  return priorities


#score: {'data3D.txt': -0.0017414000000000004}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      for k in range(N):
        priorities[k*N+j+k][0] += J[i, k, j, k]
        priorities[k*N+j+k][1] -= J[i, k, j, k]
  
  # Prioritize based on magnetism
  for i in range(N**3):
    if h[0][0][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.005308599999999998}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        
        for l in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j]
          if J[l, i, j, k] > 0:
            priorities[i*N+j+k][0] += 1
            priorities[i*N+j+k][1] -= 1
          else:
            priorities[i*N+j+k][0] -= 1
            priorities[i*N+j+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0027198}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      for k in range(N):
        total_spin = h[site_nbr][0]
        if J[i, 0, j, 0] > 0:
          priorities[j*N+k][0] += 1
          priorities[j*N+k][1] -= 2
        else:
          priorities[j*N+k][0] -= 1
          priorities[j*N+k][1] += 2
        
        total_spin += h[site_nbr][j]
        if J[i, j, k, k] > 0:
          priorities[j*N+k][0] += 3
          priorities[j*N+k][1] -= 4
        else:
          priorities[j*N+k][0] -= 3
          priorities[j*N+k][1] += 4
          
  return(priorities)


#score: {'data3D.txt': -0.0028781999999999996}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (i + (k-1)%2 - 1) % N]
        total_spin = sum(h[site][k] for site in [site_nbrs[0], i, site_nbrs[1]])
        if J[(k-1)//3%6,i,j,k]>0:
          priorities[i*N+j*k][0] -= sum(3*J[(k-1)//3%6,i,l,k] + J[(k-1)%2//2%2,i,j,l] for l in [site_nbrs[0], i, site_nbrs[1]])
        else:
          priorities[i*N+j*k][1] += sum(3*J[(k-1)//3%6,i,l,k] + J[(k-1)%2//2%2,i,j,l] for l in [site_nbrs[0], i, site_nbrs[1]])
  return(priorities)


#score: {'data3D.txt': -0.0012197999999999998}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = sum(h[site][j][k] for site in [site_nbrs[0], i, site_nbrs[1]] 
                 + [site_nbrs[2], j, k])
        if J[0,i,j,k] > 0:
          priorities[i*N*N+k][0] += total_spin
          priorities[i*N*N+k][1] -= total_spin
        else:
          priorities[i*N*N+k][0] -= total_spin
          priorities[i*N*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l, i, j, k] * h[site_nbr][j][k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
  return priorities


#score: {'data3D.txt': 0.04096339999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] * J[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = 2 - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 1
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin + 1
          priorities[i*N*N+j*N+k][1] = total_spin - 1
  return(priorities)


#score: {'data3D.txt': 0.0266862}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        site_interactions = sum(J[l, i, j, k] * (2*h[(i + ((l-1)%2 - 1)) % N][j][k] - 1) for l in range(6))
        priorities[i*N*N+j*N+k][0] = -(total_spin + site_interactions)
        priorities[i*N*N+j*N+k][1] = total_spin + site_interactions
  return(priorities)


#score: {'data3D.txt': 0.1498885999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(6))
        priorities[i*N*N+j*N+k][0] = -total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6)) - total_spin
        priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': -0.0243098}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][j][k] if h[i][j][k] > 0 else -1 for _ in range(6))
        priority_total = np.sum(J[:, i, j, k]) * total_spin
        priorities[i*N*N+j*N+k][0] = priority_total
        priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': 0.17194819999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin=0
        for l in range(6):
          site_nbr=(i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
  return(priorities)


#score: {'data3D.txt': -0.0017458000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N, (i+(k+1)%2) % N]
        total_spin = [0, 0]
        for l, site_nbr in enumerate(site_nbrs):
          total_spin[0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.2041958000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += h[i][j][k]
          else:
            total_spin -= h[i][j][k]
        priorities[i*N**2 + j*N + k][1] = -total_spin
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 2
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        if h[i][site_nbr][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.2509690000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]
        priorities[i*N**2 + j*N + k][1] = -total_spin
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.21858619999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          interacting_spin = J[l][site_nbr][j][k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin += interacting_spin
          else:
            total_spin -= interacting_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 2
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  return priorities


#score: {'data3D.txt': 0.25233540000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]
        priorities[i*N**2 + j*N + k][1] = -total_spin
        if J[0][i][j][k] > 0 or J[1][i][j][k] > 0 or J[2][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
        elif J[3][i][j][k] > 0 or J[4][i][j][k] > 0 or J[5][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] -= 1
  return priorities


#score: {'data3D.txt': -0.0021778}
program:
def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  total_spin = [0., 0.]
  for site_nbr in range(N**3):
    total_spin[0] += h[site_nbr//N**2][site_nbr%N//N][site_nbr%N]%N
    if h[site_nbr//N**2][site_nbr%N//N][site_nbr%N]%N > 0:
      priorities[site_nbr] = [-1*total_spin[0],float('-inf')]
    else:
      priorities[site_nbr] = [float('-inf'),-1*total_spin[0]]
    for i in range(N):
      total_spin[1] += h[site_nbr//N**2][i][site_nbr%N]%N
      if h[site_nbr//N**2][i][site_nbr%N]%N > 0:
        priorities[site_nbr][0] -= total_spin[1]
      else:
        priorities[site_nbr][1] += -total_spin[1]
  return(priorities)


#score: {'data3D.txt': -0.03404699999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': 0.0656834}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
  return priorities


#score: {'data3D.txt': 0.07837819999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in site_nbrs:
          total_spin += h[neighbor][j][k]
        if sum(J[l][i][j][k] for l in range(6)) > 0:
          priorities[i*N**2 + j*N + k][0] = -sum(h[s][j][k] for s in site_nbrs)
          priorities[i*N**2 + j*N + k][1] = sum(-h[s][j][k] for s in site_nbrs)
        else:
          priorities[i*N**2 + j*N + k][0] = sum(h[s][j][k] for s in site_nbrs)
          priorities[i*N**2 + j*N + k][1] = -sum(h[s][j][k] for s in site_nbrs)
  return priorities


#score: {'data3D.txt': 0.031211799999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[neighbor][j][k] for neighbor in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.0015706000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(6):
    interacting_spins = np.zeros((N,N,N))
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][0]
      if J[i,0,j,0]>0:
        priorities[j*N][0] += J[i,0,j,0]-J[i,1,j,0]
      else:
        priorities[j*N][1] -= J[i,0,j,0]+J[i,1,j,0]

    for k in range(N):
      site_nbr = (k + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,k,j,k]>0:
        priorities[k*N+k][0] += J[3,k,j,k]-J[4,k,j,k]
      else:
        priorities[k*N+k][1] -= J[3,k,j,k]+J[4,k,j,k]

    for i in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][k]
      if J[5,i,k,0]>0:
        priorities[i*N+k][0] += J[5,i,k,0]-J[5,i,k,1]
      else:
        priorities[i*N+k][1] -= J[5,i,k,0]+J[5,i,k,1]

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        for l in range(6):
          if l < 3: # x-interactions
            spin_energy += -J[l, i, j, k] * h[(i+1)%N, j, k]
          else: # y- and z-interactions
            spin_energy += -J[l, i, j, k] * (h[(i+1)%N, j, k] if l == 3 else h[i, (j+1)%N, k])
        priorities.append([-spin_energy, float('-inf')]) if h[i, j, k] > 0 else priorities.append([float('-inf'), -spin_energy])
  return(priorities)


#score: {'data3D.txt': -0.1687482000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_parity = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        if site_parity > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N**2 + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  return priorities


#score: {'data3D.txt': -0.14636259999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  return priorities


#score: {'data3D.txt': -0.0044066}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        
        total_spin += h[site_nbr][j]
        if J[2, i, j, k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0047426}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
          priorities[i*N+j+k][1] += 1
        
        total_spin += h[site_nbr][k]
        if J[1, i, j, k] > 0:
          priorities[i*N+j+k][0] += 2
          priorities[i*N+j+k][1] -= 2
        else:
          priorities[i*N+j+k][0] -= 2
          priorities[i*N+j+k][1] += 2
        
        total_spin += h[site_nbr][i]
        if J[2, i, j, k] > 0:
          priorities[i*N+j+k][0] += 3
          priorities[i*N+j+k][1] -= 3
        else:
          priorities[i*N+j+k][0] -= 3
          priorities[i*N+j+k][1] += 3
        
  return(priorities)


#score: {'data3D.txt': -0.0027265999999999996}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(6):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      for k in range(N):
        total_spin = h[site_nbr][0]
        if J[i, 0, j, 0] > 0:
          priorities[j*N+k][0] += 1
          priorities[j*N+k][1] -= 2
        else:
          priorities[j*N+k][0] -= 1
          priorities[j*N+k][1] += 2
        
        total_spin += h[site_nbr][j]
        if J[i, j, k, k] > 0:
          priorities[j*N+k][0] += 3
          priorities[j*N+k][1] -= 4
        else:
          priorities[j*N+k][0] -= 3
          priorities[j*N+k][1] += 4
        
        total_spin += h[site_nbr][k]
        if J[i, j, k, k] > 0:
          priorities[j*N+k][0] += 5
          priorities[j*N+k][1] -= 6
        else:
          priorities[j*N+k][0] -= 5
          priorities[j*N+k][1] += 6
        
  return(priorities)


#score: {'data3D.txt': -0.019357799999999998}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(N):
        total_spin = h[site_nbr][k]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*N+k][0] += 1
          priorities[i*N+j*N+k][1] -= 1
        else:
          priorities[i*N+j*N+k][0] -= 1
          priorities[i*N+j*N+k][1] += 1
        
        total_spin += h[i][j]
        if J[1, i, j, k] > 0:
          priorities[i*N+j*N+k][0] += 2
          priorities[i*N+j*N+k][1] -= 2
        else:
          priorities[i*N+j*N+k][0] -= 2
          priorities[i*N+j*N+k][1] += 2
        
        total_spin += h[site_nbr][k]
        if J[2, i, j, k] > 0:
          priorities[i*N+j*N+k][0] += 3
          priorities[i*N+j*N+k][1] -= 3
        else:
          priorities[i*N+j*N+k][0] -= 3
          priorities[i*N+j*N+k][1] += 3
        
  return(priorities)


#score: {'data3D.txt': 0.0022141999999999995}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        for l in range(6):
          if l < 3: # x-interactions
            if h[(i+1)%N, j, k] > 0:
              total_spin[0] += 1
              total_spin[1] -= 1
            else:
              total_spin[0] -= 1
              total_spin[1] += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            if h[i, (j+1)%N, k] > 0:
              total_spin[0] += 1
              total_spin[1] -= 1
            else:
              total_spin[0] -= 1
              total_spin[1] += 1
          else: # z- interactions
            if h[i, j, (k+1)%N] > 0:
              total_spin[0] += 1
              total_spin[1] -= 1
            else:
              total_spin[0] -= 1
              total_spin[1] += 1
        priorities.append([-total_spin[0], -total_spin[1]])
  return(priorities)


#score: {'data3D.txt': 0.1236582}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l, i, j, k] * (2*h[site_nbr][j][k] - 1) for l in range(6))
        priorities[i*N*N+j*N+k][0] = -(total_spin)
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.11094660000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for l in range(6):
          if l % 3 == 0:
            total_spin += J[l, i, j, k] * (2*h[(i + ((l-1)%2 - 1)) % N][j][k] - 1)
          elif l % 3 == 1:
            total_spin -= J[l, i, j, k] * (2*h[(i + ((l-1)%2 - 1)) % N][j][k] - 1)
        priorities[i*N*N+j*N+k][0] = -(total_spin)
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0017730000000000003}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0020386000000000002}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  # Calculate total spin and set priority based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i+((k-1)%2 - 1)) % N
        site_nbr2 = (j+((k-1)%2 - 1)) % N
        total_spin = h[i][site_nbr1][k] + h[j][site_nbr2][k]
        
        if J[0,i,j,k]>0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0021126000000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            total_spin += J[0,i,site_nbr,k] + J[1,i,j,site_nbr]
            priorities[i*N+j*k][0] -= 2*J[0,i,site_nbr,k] + J[1,i,j,site_nbr]
          else:
            total_spin -= J[0,i,site_nbr,k] + J[1,i,j,site_nbr]
            priorities[i*N+j*k][1] += 2*J[0,i,site_nbr,k] + J[1,i,j,site_nbr]
  
  return(priorities)


#score: {'data3D.txt': -0.0011942000000000003}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        for site_nbr in site_nbrs:
          if J[0,i,j,k]>0:
            total_spin += J[0,i,j,site_nbr] + J[1,i,site_nbr,j] + J[2,i,j,k]
            priorities[i*N+j*k][0] -= 3*J[0,i,j,site_nbr] + J[1,i,site_nbr,j]
          else:
            total_spin -= J[0,i,j,site_nbr] + J[1,i,site_nbr,j] + J[2,i,j,k]
            priorities[i*N+j*k][1] += 3*J[0,i,j,site_nbr] + J[1,i,site_nbr,j]
  
  return(priorities)


#score: {'data3D.txt': -0.000881}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Process all possible sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (j-1)%2 - 1)) % N
        total_spin = h[site_nbr][k]
        if J[0,k,j,0]>0:
          priorities[i*N+k][0] += J[0,k,j,0]-J[1,k,j,0]
        else:
          priorities[i*N+k][1] -= J[0,k,j,0]+J[1,k,j,0]
        
        site_nbr = ((j + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[3,i,k,0]>0:
          priorities[i*N+k][0] += J[3,i,k,0]-J[4,i,k,0]
        else:
          priorities[i*N+k][1] -= J[3,i,k,0]+J[4,i,k,0]
        
        site_nbr = ((k + (i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[5,i,j,0]>0:
          priorities[i*N+j][0] += J[5,i,j,0]-J[5,i,j,1]
        else:
          priorities[i*N+j][1] -= J[5,i,j,0]+J[5,i,j,1]

  return(priorities)


#score: {'data3D.txt': -0.0010609999999999999}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][i]
        if J[k,i,j,0]>0:
          priorities[i*N+j][0] += J[k,i,j,0]-J[k,i,j,1]
        else:
          priorities[i*N+j][1] -= J[k,i,j,0]+J[k,i,j,1]

  return(priorities)


#score: {'data3D.txt': 0.014252599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [3, 4]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[i][site_nbr][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [5]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[i][j][site_nbr]
          interacting_spin = J[l, i, j, site_nbr]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.0127474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [(1,2), (2,1), (0,3), (3,0), (4,5), (5,4)]:
          site_nbr = (i + ((l[0]-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l[1], i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0015393999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0, 0]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, J[:, i, j, k])):
          total_spin[0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + sum([int(x>0) for x in total_spin])
            priorities[i*N+j*k][1] -= 1 - sum([int(x>0) for x in total_spin])
          else:
            priorities[i*N+j*k][0] -= 1 + sum([int(x>0) for x in total_spin])
            priorities[i*N+j*k][1] = -1 + sum([int(x>0) for x in total_spin])
  return(priorities)


#score: {'data3D.txt': -0.0014181999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0, 0]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, J[:, i, j, k])):
          total_spin[0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + sum(total_spin)
            priorities[i*N+j*k][1] -= 1 - sum(total_spin)
          else:
            priorities[i*N+j*k][0] -= 1 + sum(total_spin)
            priorities[i*N+j*k][1] = -1 + sum(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.0011042000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N]
        total_spin = [0]
        for l, neighbor in enumerate(J[ :, i, j, k]):
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
        for l in range(6):
          site_nbrs.append((i+((l-1)%2 - 1)) % N)
          if h[i][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.roll(h, 1, axis=0) + np.roll(h, -1, axis=0) + \
             np.roll(h, 1, axis=1) + np.roll(h, -1, axis=1) + \
             np.roll(h, 1, axis=2) + np.roll(h, -1, axis=2)
  interacting_spins = np.abs(interacting_spins - h)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0]
        for l in range(6):
          site_nbrs = [(i+((l-1)%2 - 1)) % N, j, k]
          if h[tuple(site_nbrs)] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1

        for l in range(6):
          site_nbr = tuple([i+((l-1)%2 - 1), j, k])
          if h[site_nbr] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]

  return priorities


#score: {'data3D.txt': -0.004358600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, J[:, i, j, k])):
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
        for l in range(6):
          site_nbrs.append((i+((l-1)%2 - 1)) % N)
          if h[i][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0019353999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N]
        total_spin = [0]
        for l, neighbor in enumerate(J[:, i, j, k]):
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
        for l in range(6):
          site_nbrs.append((i+((l-1)%2 - 1)) % N)
          if h[i][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        for site_nbr in site_nbrs:
          total_spin[0] += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N]
        total_spin = [0, 0]
        for l, neighbor in enumerate(J[:, i, j, k]):
          if h[site_nbrs[-1]][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
          site_nbrs.append((i+((l-1)%2 - 1)) % N)
          if h[site_nbrs[-1]][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_parity = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][j] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        priorities[i*N**2 + j*N + k][0] = total_spin[0] + np.sum(np.abs(h))
        priorities[i*N**2 + j*N + k][1] = -total_spin[1] + np.sum(np.abs(h))
  return priorities


#score: {'data3D.txt': 0.34034019999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_parity = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        priorities[i*N**2 + j*N + k][0] = -total_spin[0]
        priorities[i*N**2 + j*N + k][1] = total_spin[1]
  return priorities


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        priorities[i*N**2 + j*N + k][0] = site_parity + np.sum(total_spin)
        priorities[i*N**2 + j*N + k][1] = -site_parity + np.sum(total_spin)
  return priorities


#score: {'data3D.txt': 0.0045590000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
          priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
        else:
          priorities[i*N*N+j*N+k][0] = total_spin + sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
          priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': -0.13579739999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(6))
        interaction_energy = sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][0] = total_spin + interaction_energy
        priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': 0.13710859999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(6))
        spin_energy = sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][0] = -total_spin + spin_energy
        priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': 0.13710859999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] for _ in range(6))
        interacting_spins = sum(J[l, i, j, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        priorities[i*N*N+j*N+k][0] = -total_spin + interacting_spins
        priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        if J[5,i,j,k]>0:
          priorities[i*N+j*k][0] += -J[5,i,j,k]
          priorities[i*N+j*k][1] -= J[5,i,j,k]
        else:
          priorities[i*N+j*k][0] -= J[5,i,j,k]
          priorities[i*N+j*k][1] += J[5,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.0018202}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (k + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((i-1)%2 - 1)) % N
        site_nbr3 = (i + ((k-1)%2 - 1)) % N
        
        if J[0,k,j,0] > 0:
          priorities[i*N+j*k][0] += J[0,k,j,0]-J[1,k,j,0]
        else:
          priorities[i*N+j*k][1] -= J[0,k,j,0]+J[1,k,j,0]
          
        if J[3,i,k,0] > 0:
          priorities[i*N+j*k][0] += J[3,i,k,0]-J[4,i,k,0]
        else:
          priorities[i*N+j*k][1] -= J[3,i,k,0]+J[4,i,k,0]
          
        if J[5,i,j,0] > 0:
          priorities[i*N+j*k][0] += J[5,i,j,0]-J[5,i,j,1]
        else:
          priorities[i*N+j*k][1] -= J[5,i,j,0]+J[5,i,j,1]
          
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][i]
        
        if J[0,k,j,0] > 0:
          priorities[i*N+j*k][0] += -J[0,k,j,0]
          priorities[i*N+j*k][1] -= J[0,k,j,0]
        else:
          priorities[i*N+j*k][0] -= J[0,k,j,0]
          priorities[i*N+j*k][1] += J[0,k,j,0]
        
        if J[3,i,k,0] > 0:
          priorities[i*N+j*k][0] += -J[3,i,k,0]
          priorities[i*N+j*k][1] -= J[3,i,k,0]
        else:
          priorities[i*N+j*k][0] -= J[3,i,k,0]
          priorities[i*N+j*k][1] += J[3,i,k,0]
        
        if J[5,i,j,0] > 0:
          priorities[i*N+j*k][0] += -J[5,i,j,0]
          priorities[i*N+j*k][1] -= J[5,i,j,0]
        else:
          priorities[i*N+j*k][0] -= J[5,i,j,0]
          priorities[i*N+j*k][1] += J[5,i,j,0]
  
  return(priorities)


#score: {'data3D.txt': -0.00011540000000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1+1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin

  return(priorities)


#score: {'data3D.txt': 0.01618780000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1+1)%2 - 1)) % N]
        total_spin = sum(h[site][j][k] for site in site_nbrs) + h[i][j][k]
        if J[0,i,j,k]>0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.006097}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin[0] += site_parity
        total_spin[1] -= site_parity
        
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        priorities[i*N**2 + j*N + k][0] = total_spin[0]
        priorities[i*N**2 + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0021902000000000007}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y)):
          total_spin[i*N+j*k][0] += h[site_nbr[0]][site_nbr[1]][k]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= 1
          else:
            total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': -0.0050002}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)    
  for i in range(N**3):
    site_nbrs = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_spin = [h[site_nbr][i%N//N][i%N%N] for site_nbr in site_nbrs]
    if sum(site_nbrs_spin) > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= len([spin for spin in site_nbrs_spin if spin > 0])
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += len([spin for spin in site_nbrs_spin if spin < 0])
  return(total_spin)


#score: {'data3D.txt': -0.0050002}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_spin = [h[site_nbr][i%N//N][i%N%N] for site_nbr in site_nbrs]
    if sum(site_nbrs_spin) > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= len([spin for spin in site_nbrs_spin if spin > 0])
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += len([spin for spin in site_nbrs_spin if spin < 0])
  return(total_spin)


#score: {'data3D.txt': -0.002678200000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_spin = [h[site_nbr][i%N//N][i%N%N] for site_nbr in site_nbrs]
    if sum(site_nbrs_spin) > 0:
      total_spin[i][0] += len([spin for spin in site_nbrs_spin if spin > 0])
      total_spin[i][1] -= len([spin for spin in site_nbrs_spin if spin < 0])
    else:
      total_spin[i][0] -= len([spin for spin in site_nbrs_spin if spin > 0])
      total_spin[i][1] += len([spin for spin in site_nbrs_spin if spin < 0])
  return(total_spin)


#score: {'data3D.txt': 0.031271}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        for l in [0, 4]:  
         if h[site_nbr][j][k] > 0:
          total_spin -= J[l, i, j, k]
         else:
          total_spin += J[l, i, j, k]

        for l in [1, 2, 3, 5]:  
         if h[i][j][k] > 0:
          total_spin -= J[l, i, j, k]
         else:
          total_spin += J[l, i, j, k]

        total_spin += h[site_nbr][j][k]
        
        priorities[i*N**2+j*N+k][0] = -total_spin
        priorities[i*N**2+j*N+k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.10466420000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(3):
    for j in range(N):
      for i in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        for l in [0]:  # top neighbors
          if h[site_nbr][j][k] > 0:
            total_spin -= J[l, i, j, k]
          else:
            total_spin += J[l, i, j, k]

        for l in [1]:  # left and right neighbors
          if h[i][site_nbr][k] > 0:
            total_spin -= J[l, i, site_nbr, k]
          else:
            total_spin += J[l, i, site_nbr, k]

        for l in [2]:  # front neighbors
          if h[i][j][0] > 0:
            total_spin -= J[l, i, j, 0]
          else:
            total_spin += J[l, i, j, 0]

        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N):
   for j in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin = 0
      
      for l in [0, 4]:  
        if h[site_nbr][j][k] > 0:
          total_spin -= J[l, i, j, k]
        else:
          total_spin += J[l, i, j, k]

      for l in [1, 2, 3, 5]:  
        if h[i][j][k] > 0:
          total_spin -= J[l, i, j, k]
        else:
          total_spin += J[l, i, j, k]

      priorities[i*N**2+j*N+k][0] = -total_spin
      priorities[i*N**2+j*N+k][1] = -total_spin
      
  return(priorities)


#score: {'data3D.txt': -0.004358600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0]
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, J[:, i, j, k])):
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
        site_nbrs.append((i+((3-1)%2 - 1)) % N)
        site_nbrs.append((i+((4-1)%2 - 1)) % N)
        if h[i][j][k] > 0:
          total_spin[0] += 1
        else:
          total_spin[0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0040478}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*k][0] += 1 + len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N+j*k][1] -= len([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N+j*k][0] -= 1 - len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N+j*k][1] = -1 + len([spin for spin in interacting_spins if spin < 0])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_spin = [h[(i + ((k-1)%2 - 1)) % N][j][k], 
                 h[i][(j+1)%N][k],
                 h[i][j][(k+1)%N],
                 h[i][(j-1)%N][k],
                 h[i][j][(k-1)%N],
                 h[i][(j-1)%N][(k-1)%N]]
        total_spin = sum(site_nbrs_spin)
        if sum([spin for spin in site_nbrs_spin if spin > 0]) > 0:
          priorities[i*N+j*k][0] += 1 + total_spin
          priorities[i*N+j*k][1] -= 1 - total_spin
        else:
          priorities[i*N+j*k][0] -= 1 + total_spin
          priorities[i*N+j*k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0]
        if h[i][j][k] > 0:
          total_spin[0] += 1
        else:
          total_spin[0] -= 1
        for l, (site_nbr, neighbor) in enumerate(zip(site_nbrs, J[:, i, j, k])):
          site_nbr = (i+((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.0043258}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        site_nbrs_spin = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if sum(site_nbrs_spin) > 0:
          total_spin[i*N+j*k][0] += 1
          total_spin[i*N+j*k][1] -= len([spin for spin in site_nbrs_spin if spin > 0])
        else:
          total_spin[i*N+j*k][0] -= 1
          total_spin[i*N+j*k][1] += len([spin for spin in site_nbrs_spin if spin < 0])
  return(total_spin)


#score: {'data3D.txt': -0.0019546}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y, site_nbr_z)):
          total_spin[i*N+j*k][0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= 1
          else:
            total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': -0.0024894000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbrz = [(k+1)%N if l == 0 or l == 5 else (k-1)%N for l in range(6)]
        for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y, site_nbrz)):
          total_spin = h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
          if total_spin > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0014982000000000003}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l % 2 == 0 else (k-1)%N for l in range(6)]
        for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y, site_nbr_z)):
          total_spin[i*N+j*k][0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= 1
          else:
            total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': -0.0016178000000000004}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        total_spin[i*N+j*k][0] += sum(h[site_nbr[0]][site_nbr[1]][k]*(h[i][j][k]*J[l, i, j, k] < 0) for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y)))
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= sum((h[site_nbr[0]][site_nbr[1]][k]*J[l, i, j, k] < 0) for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y)))
        else:
          total_spin[i*N+j*k][1] += sum((h[site_nbr[0]][site_nbr[1]][k]*J[l, i, j, k] > 0) for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y)))
  return(total_spin)


#score: {'data3D.txt': -0.0020246}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        site_neighbors = list(itertools.product(site_nbrs_x, site_nbrs_y, site_nbr_z))
        for site_neighbor in site_neighbors:
          total_spin[i*N+j*k][0] += h[site_neighbor[0]][site_neighbor[1]][site_neighbor[2]]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= 1
          else:
            total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': -0.003231000000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        total_spin[i*N+j*k][0] += np.sum([h[site_nbr[0]][site_nbr[1]][site_nbr[2]]/abs(h[site_nbr[0]][site_nbr[1]][site_nbr[2]]) for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= np.sum([abs(h[site_nbr[0]][site_nbr[1]][site_nbr[2]]) for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
        else:
          total_spin[i*N+j*k][1] += np.sum([abs(h[site_nbr[0]][site_nbr[1]][site_nbr[2]]) for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
  return(total_spin)


#score: {'data3D.txt': 0.17083460000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = sum(h[(i+1)%N][j][k] if (i+1)%N == i else 
                 h[(i-1)%N][j][k] if (i-1)%N == i else 0 for _ in range(3)) +\
              sum(J[l, i, (i+1)%N, k] if (i+1)%N == i else J[l, i, (i-1)%N, k] 
               for l in [1,2,3,4,5])
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        
  return priorities


#score: {'data3D.txt': -0.27550300000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = sum(h[(i+1)%N][j][k] if (i+1)%N == i else 
                 h[(i-1)%N][j][k] if (i-1)%N == i else 0 for _ in range(3)) +\
              sum(J[l, i, (i+1)%N, k] if (i+1)%N == i else J[l, i, (i-1)%N, k] 
               for l in [1,2,3,4,5])
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities


#score: {'data3D.txt': 0.0256038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = sum(h[(i+1)%N][j][k] if (i+1)%N == i else 
                 h[(i-1)%N][j][k] if (i-1)%N == i else 0 for _ in range(3)) +\
               sum(J[l, i, (i+1)%N, k] if (i+1)%N == i else J[l, i, (i-1)%N, k] 
               for l in [1,2,3,4,5])
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin - sum(h[(i+1)%N][j][k] for _ in range(3))
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin + sum(h[(i+1)%N][j][k] for _ in range(3))

  return priorities


#score: {'data3D.txt': 0.17083460000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = sum(h[(i+1)%N][j][k] if (i+1)%N == i else 
                 h[(i-1)%N][j][k] if (i-1)%N == i else 0 for _ in range(3)) +\
               sum(J[l, i, (i+1)%N, k] if (i+1)%N == i else J[l, i, (i-1)%N, k] 
                for l in [1,2,3,4,5])
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += 1
          else:
            total_spin[1] -= 1
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        if site_parity > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin[0]
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin[1]
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin[0]
          priorities[i*N**2 + j*N + k][1] += 1 - total_spin[1]
  return priorities


#score: {'data3D.txt': 0.15978820000000019}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        if site_parity > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin[0]
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin[1]
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin[0]
          priorities[i*N**2 + j*N + k][1] += 1 - total_spin[1]
  return priorities


#score: {'data3D.txt': -0.0752194}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] = site_parity + total_spin
        priorities[i*N*N + j*N + k][1] = -priorities[i*N*N + j*N + k][0]
  return priorities


#score: {'data3D.txt': -0.1687482000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        if site_parity > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N**2 + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  return priorities


#score: {'data3D.txt': 0.16103099999999995}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = [0, 0]
        for l in range(6):
          if l < 3: # x-interactions
            total_spin[0] += h[site_nbr][j,k]
            total_spin[1] -= h[site_nbr][j,k]
          elif l == 3: # y- interactions
            site_nbr = (i + ((k-1)%2 - 1)) % N
            total_spin[0] += h[i, site_nbr, k]
            total_spin[1] -= h[i, site_nbr, k]
          else: # z- interactions
            site_nbr = (i + ((k-1)%2 - 1)) % N
            total_spin[0] += h[i, j, site_nbr]
            total_spin[1] -= h[i, j, site_nbr]
        priorities.append([-total_spin[0], -total_spin[1]])
  return(priorities)


#score: {'data3D.txt': -0.15404579999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N**3, 2))
  site_nbr = lambda i, j, k: ((i + (k-1)%2 - 1)) % N
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_val = site_nbr(i, j, k)
        total_spin[i*N*N+j*N+k][0] += h[site_nbr_val][j][k]
        if h[site_nbr_val][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  for k in range(3):
    site = lambda i, j: (i + ((k-1)%2 - 1)) % N
    for i in range(N):
      for j in range(N):
        total_spin[i*N*N+j*N+site(i, j)][0] += h[site(i, j)][j][k]
        if h[site(i, j)][j][k] > 0:
          priorities[i*N*N+j*N+site(i, j)][0] += 1
          priorities[i*N*N+j*N+site(i, j)][1] -= 1
        else:
          priorities[i*N*N+j*N+site(i, j)][0] -= 1
          priorities[i*N*N+j*N+site(i, j)][1] += 1

  for i in range(N):
    if h[0][i][0] > 0:
      priorities[i*N*N][:] = [total_spin[i*N*N][0], -total_spin[i*N*N][0]]
    else:
      priorities[i*N*N][:] = [-total_spin[i*N*N][0], total_spin[i*N*N][0]]

  for j in range(N):
    if h[0][0][j] > 0:
      priority_total = [total_spin[j*N*N][:], -total_spin[j*N*N][:]]
    else:
      priority_total = [-total_spin[j*N*N][:], total_spin[j*N*N][:]]

  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_val = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr_val][j][k]
        if total_spin > 0:
          priorities.append([-total_spin, float('-inf')])
        else:
          priorities.append([float('-inf'), total_spin])
  return np.array(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbr = lambda i, j, k: ((i + (k-1)%2 - 1)) % N
  total_spin = np.zeros((N**3, 2))
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr_val = site_nbr(i, j, k)
        total_spin[i*N*N+j*N+k][0] += h[site_nbr_val][j][k]
        if h[site_nbr_val][j][k] > 0:
          priority_total = [1, -1]
        else:
          priority_total = [-1, 1]
        for i in range(N):
          for j in range(N):
            site_nbr_val = site_nbr(i, j, k)
            total_spin[i*N*N+j*N+k][1] += J[k,i,j,k]*h[site_nbr_val][j][k]
        
  return(priorities)


#score: {'data3D.txt': -0.012871}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[i][max(0, min(i+1, N-1))][k] if h[i][j][k] > 0 else -h[i][min(i+1, N-1)][k] for _ in range(3)) +\
               sum(J[l, i, max(0, min(j+1, N-1)), k] if J[l, i, j, k] > 0 else -J[l, i, min(j+1, N-1), k] for l in [1,2,3,4,5])
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.0026106000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[(i+1)%N][j][k] - h[i-1 if i>0 else N-1, j][k] 
                 + J[l, i, (i+1)%N if l==1 or l==5 else i-1 if i>0 else N-1, k] 
                 for l in [1,2,3,4])
        
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
  
  return priorities


#score: {'data3D.txt': -0.002585}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            total_spin_1 += h[i][site_nbr][k]
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.2524638000000004}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z]
        for l in range(6):
          if l == 0:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
          elif l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.00028700000000000063}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [1,3,5]]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin_0 += 1
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.07418340000000004}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
            if h[i][j][k] > 0:
              total_spin_1 -= 1
            else:
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            total_spin_1 += h[i][site_nbr][k]
            if h[i][j][k] > 0:
              total_spin_0 -= 1
            else:
              total_spin_0 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.00028700000000000063}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0,1,5]]
        for site_nbr, direction in zip(site_nbrs, ['x', 'y', 'z']):
          if h[site_nbr][j][k] > 0:
            total_spin_0 += 1
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': 0.1754810000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l, i, (i + ((l-1)%2 - 1)) % N, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.06059019999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[neighbor][j][k] * (J[l, neighbor, i, k] > 0) for l, neighbor in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.0011566}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(1 if J[l, i, (i + ((l-1)%2 - 1)) % N, k] * h[(i + ((l-1)%2 - 1)) % N][j][k] > 0 else -1 for l in range(6))
        priorities[i*N**2 + j*N + k][0] = total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.031211799999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = sum(h[neighbor][j][k] for neighbor in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if site_parity > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.0159358}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.014559}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [3, 4]:
          site_nbr_x = (i + ((l-2)%2 - 1)) % N
          site_nbr_z = (k + ((l-2)%2 - 1)) % N
          
          if l == 3:
            total_spin[0] += h[i][j][site_nbr_z]
            interacting_spin = J[l, i, j, site_nbr_z]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
          
          if l == 4:
            total_spin[0] += h[i][site_nbr_x][k]
            interacting_spin = J[l, i, site_nbr_x, k]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
        
        for l in [5]:
          site_nbr_y = (j + ((l-4)%2 - 1)) % N
          
          total_spin[0] += h[i][site_nbr_y][k]
          interacting_spin = J[l, i, site_nbr_y, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.013973399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [3, 4, 5]:
          site_nbr = (i + ((l-2)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for m in range(6):
          site_nbr = (i + ((m-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[m, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0015854000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+((0-1)%2 - 1)) % N]
        site_nbrs_y = [(j+((1-1)%2 - 1)) % N]
        site_nbrs_z = [(k+((2-1)%2 - 1)) % N]

        total_spin_0 = h[i][j][k]
        total_spin_1 = -h[i][j][k] - h[i][j][k]

        for l in range(6):
          if l < 3:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1

          elif l < 6 and (l == 3 or l == 4):
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1

          else:
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1

        priorities[i*N+j*k][0] = total_spin_0
        priorities[i*N+j*k][1] = total_spin_1

  return(priorities)


#score: {'data3D.txt': -0.003955}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0]
        site_nbrs_x = [(i+((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j+((l-1)%2 - 1)) % N for l in range(3)]
        site_nbrs_z = [(k+((l-5)%2 - 1)) % N for l in range(6)]
        for site_nbr, neighbor in zip(itertools.chain(*[site_nbrs_x, site_nbrs_y, site_nbrs_z]), J[:, i, j, k]):
          if h[site_nbr][j][k] > 0:
            priorities[i*N+j*k][0] += 1 + total_spin[0]
            priorities[i*N+j*k][1] -= 1 - total_spin[0]
          else:
            priorities[i*N+j*k][0] -= 1 + total_spin[0]
            priorities[i*N+j*k][1] = -1 + total_spin[0]
        if h[i][j][k] > 0:
          total_spin[0] += 1
        else:
          total_spin[0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0032750000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+((k-1)%2 - 1)) % N]
        site_nbrs_y = [(j+((l-1)%2 - 1)) % N for l in range(3)]
        site_nbrs_z = [(k+((l-1)%2 - 1)) % N for l in range(3)]
        total_spin_0, total_spin_1 = 0, 0
        for x, y, z in itertools.product(site_nbrs_x, site_nbrs_y, site_nbrs_z):
          if h[x][y][z] > 0:
            total_spin_0 += 1 + (total_spin_1 - total_spin_0)
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 = 1 - total_spin_1
        priorities[i*N+j*k][0] = total_spin_0
        priorities[i*N+j*k][1] = total_spin_1
  return(priorities)


#score: {'data3D.txt': -0.0028654000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        priority = 0
        if h[i][j][k] > 0:
          priority -= 1
        else:
          priority += 1

        total_spin = np.sum(h[(i+((j-1)%2 - 1)) % N][(k-1)%N], axis=0)

        for l in range(6):
          if interacting_spins[l][i][j][k] > 0:
            priority -= J[l][i][j][k]
          else:
            priority += J[l][i][j][k]

        priorities[i*N+j+k][0] = -total_spin
        priorities[i*N+j+k][1] = priority

  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          for m in range(2):
            if h[i][j][k] > 0:
              priorities[i*N+j*k][m] += -J[l,i,j,k]*(-1)**l
            else:
              priorities[i*N+j*k][m] -= J[l,i,j,k]*(-1)**l
  return(priorities)


#score: {'data3D.txt': -0.079267}
program:
def priority(N, h, J):
  cache = {}
  priorities = np.zeros((N**3, 2))
  
  def get_interacting_spin(i, j, k, l):
    if (i, j, k, l) in cache:
      return cache[(i, j, k, l)]
    interacting_spin = J[l, i, (i+((l-1)%2 - 1)) % N, k]
    cache[(i, j, k, l)] = interacting_spin
    return interacting_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        
        for l in range(6):
          interacting_spin = get_interacting_spin(i, j, k, l)
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.09598900000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 3
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= 2
          priorities[i*N*N + j*N + k][1] += 3
        
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if total_spin * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N + j*N + k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': 0.012477799999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        if h[i][j][k] > 0:
          for l in range(6):
            interacting_spin = J[l, i, site_nbr, k]
            if interacting_spin > 0:
              total_spin += 1
            else:
              total_spin -= 1
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = total_spin
        else:
          for l in range(6):
            interacting_spin = J[l, i, site_nbr, k]
            if interacting_spin > 0:
              total_spin -= 1
            else:
              total_spin += 1
          priorities[i*N*N + j*N + k][0] = -total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin_0 += 1
          total_spin_1 -= 1
        else:
          total_spin_0 -= 1
          total_spin_1 += 1
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.2847918}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        total_spin_0 += h[site_nbr_x][j][k]
        total_spin_0 -= h[i][site_nbr_y][k] - h[i][j][site_nbr_z]
        for l in range(6):
          if l == 0:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
          elif l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.2524638000000004}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z]
        
        for l in range(6):
          if l == 0:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
          elif l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        
        priorities.append([-total_spin_1, -total_spin_0])
  return(priorities)


#score: {'data3D.txt': -0.0012870000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += len([spin for spin in [h[site_nbr][j][k] for site_nbr in site_nbrs] if spin > 0]) + total_spin
          priorities[i*N+j*k][1] -= len([spin for spin in [h[site_nbr][j][k] for site_nbr in site_nbrs] if spin < 0]) - total_spin
        else:
          priorities[i*N+j*k][0] -= len([spin for spin in [h[site_nbr][j][k] for site_nbr in site_nbrs] if spin > 0]) + total_spin
          priorities[i*N+j*k][1] = -len([spin for spin in [h[site_nbr][j][k] for site_nbr in site_nbrs] if spin < 0]) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0040478}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0, 0]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*k][0] += 1 + len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N+j*k][1] -= len([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N+j*k][0] -= 1 - len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N+j*k][1] = -1 + len([spin for spin in interacting_spins if spin < 0])
  return(priorities)


#score: {'data3D.txt': -0.0040478}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(6)]
        total_spin = [0]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if sum(interacting_spins) > 0:
          priorities[i*N+j*k][0] += 1 + len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N+j*k][1] -= len([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N+j*k][0] -= 1 - len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N+j*k][1] = -1 + len([spin for spin in interacting_spins if spin < 0])
  return(priorities)


#score: {'data3D.txt': -0.07467340000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j,k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.0005530000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N**3):
    site_nbr = ((i // N**2) % N + ((i // N - 1) % 2 - 1)) % N
    total_spin = h[site_nbr][i % N][i // (N ** 2) % N]
    for l in range(6):
      if J[l, site_nbr, i % N, i // N**2 % N] > 0:
        priorities[i][0] += 1 + total_spin
        priorities[i][1] -= 1 - total_spin
      else:
        priorities[i][0] -= 1 + total_spin
        priorities[i][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': 0.0016930000000000011}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += np.abs(interacting_spin)
            total_spin[1] -= np.abs(interacting_spin)
          else:
            total_spin[0] -= np.abs(interacting_spin)
            total_spin[1] += np.abs(interacting_spin)
        
        for l in [3, 4]:
          site_nbr = (i + ((l-3)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          
          if site_parity * interacting_spin > 0:
            total_spin[0] += np.abs(interacting_spin)
            total_spin[1] -= np.abs(interacting_spin)
          else:
            total_spin[0] -= np.abs(interacting_spin)
            total_spin[1] += np.abs(interacting_spin)
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.001255}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in itertools.chain(range(1), range(2, 5)):
          if l % 2 == 0:
            spin_direction = -1
          else:
            spin_direction = 1
          
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          
          if h[site_nbr][j][k] * interacting_spin * spin_direction > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.13596340000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        for l in range(6):
          if l % 3 == 1:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            interacting_spin = J[l, i, site_nbr, k]
            
            if h[site_nbr][j][k] * interacting_spin > 0:
              total_spin_x[0] += interacting_spin
            else:
              total_spin_x[1] -= interacting_spin
            
          elif l % 3 == 2:
            site_nbr = (i + ((l-2)%2 - 1)) % N
            interacting_spin = J[l, i, j, k]
            
            if h[i][site_nbr][k] * interacting_spin > 0:
              total_spin_y[0] += interacting_spin
            else:
              total_spin_y[1] -= interacting_spin
            
          elif l % 3 == 0:
            site_nbr = (i + ((l-0)%2 - 1)) % N
            interacting_spin = J[l, i, j, k]
            
            if h[i][j][site_nbr] * interacting_spin > 0:
              total_spin_z[0] += interacting_spin
            else:
              total_spin_z[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = (total_spin_x[0] + total_spin_y[0] + total_spin_z[0])
        priorities[i*N*N + j*N + k][1] = -((total_spin_x[1] + total_spin_y[1] + total_spin_z[1]))
        
  return priorities


#score: {'data3D.txt': 0.0014394}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          interacting_spin = J[l, i, ((l-1)%2 - 1 + i)%N, k]
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):  # consider all neighbors
          if l % 2 == 1:  # horizontal or vertical neighbors
            site_nbr_i = (i + ((l-1)%2 - 1)) % N
            interacting_spin = J[l, i, j, k]
            
            if site_parity * interacting_spin > 0:
              total_spin[0] += np.abs(interacting_spin)
              total_spin[1] -= np.abs(interacting_spin)
            else:
              total_spin[0] -= np.abs(interacting_spin)
              total_spin[1] += np.abs(interacting_spin)
          else:  # diagonal neighbors
            site_nbr_j = (j + ((l-2)%2 - 1)) % N
            interacting_spin = J[l, i, site_nbr_j, k]
            
            if site_parity * interacting_spin > 0:
              total_spin[0] += np.abs(interacting_spin)
              total_spin[1] -= np.abs(interacting_spin)
            else:
              total_spin[0] -= np.abs(interacting_spin)
              total_spin[1] += np.abs(interacting_spin)
        
        priorities[i*N*N + j*N + k][0] = site_parity + total_spin[0]
        priorities[i*N*N + j*N + k][1] = -site_parity - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for axis in range(3):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        total_spin += h[i][j][k]
        priorities[i*N*N + j*N + k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.003035400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        total_spin = np.sum([h[site_nbr[0]][site_nbr[1]][site_nbr[2]]/abs(h[site_nbr[0]][site_nbr[1]][site_nbr[2]]) for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin
          priorities[i*N+j*k][1] -= abs(total_spin)
        else:
          priorities[i*N+j*k][0] -= abs(total_spin)
          priorities[i*N+j*k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022890000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z):
          if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          else:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 2
        else:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.0034506000000000007}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        for l in range(6):
          x = (i + ((l-1)%2 - 1)) % N
          y = (j + ((l%2) - 1)) % N
          z = (k + ((l+4)%6 - 3)) % N
          site_nbrs.append((x, y, z))
        total_spin[i*N+j*k][0] += np.sum([h[x][y][z]/abs(h[x][y][z]) for x,y,z in site_nbrs])
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= np.sum([abs(h[x][y][z]) for x,y,z in site_nbrs])
        else:
          total_spin[i*N+j*k][1] += np.sum([abs(h[x][y][z]) for x,y,z in site_nbrs])
  return(total_spin)


#score: {'data3D.txt': 0.09907820000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l, i, (i + ((l-1)%2 - 1)) % N, k] if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0 else -J[l, i, (i + ((l-1)%2 - 1)) % N, k] for l in range(6))
        priorities[i*N*N + j*N + k][1] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 2 * total_spin
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = -1
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = []
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
            site_nbrs.append(site_nbr)
          else:
            total_spin -= 1
            site_nbrs.append(site_nbr)
        for site in site_nbrs:
          priorities[i*N**2 + j*N + k][0] += 2 * (h[site][j][k] > 0) - 1
          priorities[i*N**2 + j*N + k][1] -= 2 * (h[site][j][k] > 0) + 1
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(1 if h[site][j][k] > 0 else -1 for site in ((i + ((l-1)%2 - 1)) % N for l in range(6)))
        priorities[i*N*N + j*N + k][1] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin
        
  return priorities


#score: {'data3D.txt': -0.07467340000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j,k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.22463819999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j,k]
        if J[0,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        elif J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.14236540000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    if h[i//N//N][i//N%N][i%N%N] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.13985460000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][jj,k] if jj==j else h[i][jj][k] for jj in range(N))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0017182}
program:
def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i*N+j*N+k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i*N+j*N+k][1] -= -J[l,i,j,k]*interacting_spins[l,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.2143213999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        for axis in range(3):
          if axis == 0:
            site_nbr = (site_nbr + ((j-1)%2 - 1)) % N
          elif axis == 1:
            site_nbr = (i + ((k-1)%2 - 1)) % N
          else:
            site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.09683180000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        for axis in [0, 1]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N + j*N + k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [0,0,0,0,0,0]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        for axis in range(6):
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spins[axis]
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spins[axis]
  return(priorities)


#score: {'data3D.txt': -0.2703593999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        priority_total = [0, 0]
        for axis in range(3):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          if h[i][j][k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = -priority_total[0]
  return(priorities)


#score: {'data3D.txt': -0.002317}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        total_spin = sum(h[site_nbr[0]][site_nbr[1]][k]*(h[i][j][k]*J[l, i, j, k] < 0) for l, site_nbr in enumerate(zip(site_nbrs_x, site_nbrs_y)))
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin
          priorities[i*N+j*k][1] -= total_spin
        else:
          priorities[i*N+j*k][0] -= total_spin
          priorities[i*N+j*k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.0032654000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        total_spin = np.sum(h[site_nbrs_x, j, k]) * (h[i][j][k]*np.sum(J[:, i, j, k]) < 0)
        priorities[i*N+j*k][0] += total_spin
        priorities[i*N+j*k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.0021902000000000007}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        site_nbrs = list(zip(site_nbrs_x, site_nbrs_y, site_nbr_z))
        for site_nbr in site_nbrs:
          total_spin[i*N+j*k][0] += h[site_nbr[0]][site_nbr[1]][k]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= 1
          else:
            total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': -0.069713}
program:
def priority(N, h, J):
  site_nbrs = []
  for i in range(N**3):
    site_nbrs_x = [(i//N//N + ((i//N)%2 - 1)) % N if l < 3 else (i//N//N + ((i//N-1)%2 - 1)) % N for l in range(6)]
    site_nbrs_y = [(i//N%N + ((i//100)%2 - 1)) % N if l >= 3 else (i//N%N + ((i//100-1)%2 - 1)) % N for l in range(6)]
    site_nbr_z = [(i%N + ((i//10)%2 - 1)) % N if l == 4 or l == 5 else (i%N + ((i//10-1)%2 - 1)) % N for l in range(6)]
    site_nbrs.append(list(zip(site_nbrs_x, site_nbrs_y, site_nbr_z)))
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    for site_nbr in site_nbrs[i]:
      if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
    if h[i//N//N][i//N%N][i%N] > 0:
      total_spin[i][0] += 1 + sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for site_nbr in site_nbrs[i])
      total_spin[i][1] -= 2
    else:
      total_spin[i][0] -= 1 + sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for site_nbr in site_nbrs[i])
      total_spin[i][1] = -1 + sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for site_nbr in site_nbrs[i])
  return(total_spin)


#score: {'data3D.txt': -0.0026210000000000005}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        total_spin[i*N+j*k][0] += sum(h[site_nbr[0]][site_nbr[1]][k] for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z))
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= len([site_nbr for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z) if h[site_nbr[0]][site_nbr[1]][k] > 0])
        else:
          total_spin[i*N+j*k][1] += len([site_nbr for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z) if h[site_nbr[0]][site_nbr[1]][k] < 0])
  return(total_spin)


#score: {'data3D.txt': -0.002678200000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_spin = [h[site_nbr][i%N//N][i%N%N] for site_nbr in site_nbrs]
    if np.sum(site_nbrs_spin) > 0:
      total_spin[i][0] += len([spin for spin in site_nbrs_spin if spin > 0])
      total_spin[i][1] -= len([spin for spin in site_nbrs_spin if spin < 0])
    else:
      total_spin[i][0] -= len([spin for spin in site_nbrs_spin if spin > 0])
      total_spin[i][1] += len([spin for spin in site_nbrs_spin if spin < 0])
  return(total_spin)


#score: {'data3D.txt': -0.002678200000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_h = [h[site_nbr][i%N//N][i%N%N] for site_nbr in site_nbrs]
    total_spin[i][0] += np.sum([spin * (spin > 0) for spin in site_nbrs_h])
    total_spin[i][1] -= np.sum([spin * (spin < 0) for spin in site_nbrs_h])
  return(total_spin)


#score: {'data3D.txt': 0.0015514000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = [0, 0]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        interaction_energy = 0

        # Calculate the energy of interactions with nearest neighbors
        for l in [(1,2), (2,1), (0,3), (3,0), (4,5), (5,4)]:
          site_nbr = (i + ((l[0]-1)%2 - 1)) % N
          interaction_energy += J[l[1], i, site_nbr, k] * h[site_nbr][j][k]

        # Assign priority based on total energy and magnetism
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = -interaction_energy - h[i][j][k]
          priorities[i*N*N + j*N + k][1] = interaction_energy + h[i][j][k]
        else:
          priorities[i*N*N + j*N + k][0] = interaction_energy + h[i][j][k]
          priorities[i*N*N + j*N + k][1] = -interaction_energy - h[i][j][k]

  return priorities


#score: {'data3D.txt': -0.001665}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        site_neighbors = list(itertools.product(site_nbrs_x, site_nbrs_y, site_nbr_z))
        site_neighbors_spin = [h[site_neighbor[0]][site_neighbor[1]][site_neighbor[2]] for site_neighbor in site_neighbors]
        total_spin[i*N+j*k][0] += sum(site_neighbors_spin)
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= len([spin for spin in site_neighbors_spin if spin > 0])
        else:
          total_spin[i*N+j*k][1] += len([spin for spin in site_neighbors_spin if spin < 0])
  return(total_spin)


#score: {'data3D.txt': -0.0012758000000000003}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        site_neighbors = list(itertools.product(site_nbrs_x, site_nbrs_y, site_nbr_z))
        spin_sum = sum([h[site_neighbor[0]][site_neighbor[1]][site_neighbor[2]] for site_neighbor in site_neighbors])
        if spin_sum > 0:
          total_spin[i*N+j*k][0] += 1
          total_spin[i*N+j*k][1] -= len([spin for spin in site_neighbors if h[spin[0]][spin[1]][spin[2]] > 0])
        else:
          total_spin[i*N+j*k][0] -= 1
          total_spin[i*N+j*k][1] += len([spin for spin in site_neighbors if h[spin[0]][spin[1]][spin[2]] < 0])
  return(total_spin)


#score: {'data3D.txt': -0.003231000000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        total_spin[i*N+j*k][0] += np.sum([h[x][y][z]/abs(h[x][y][z]) for x,y,z in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= np.sum([abs(h[x][y][z]) for x,y,z in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
        else:
          total_spin[i*N+j*k][1] += np.sum([abs(h[x][y][z]) for x,y,z in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)])
  return(total_spin)


#score: {'data3D.txt': -0.07132939999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      if interacting_spins[l][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += -J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      else:
        priorities[i][0] -= J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][1] -= total_spin
    else:
      priorities[i][1] += total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.010517400000000001}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for k in range(N):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    for i in range(N):
      for j in range(N):
        if h[site_nbr][i][j] > 0:
          priorities[i*N+j+k][0] += 1
          priorities[i*N+j+k][1] -= 1
        else:
          priorities[i*N+j+k][0] -= 1
  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [0,0,0,0,0,0]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spins[axis]
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spins[axis]
  return(priorities)


#score: {'data3D.txt': 0.09683180000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        for axis in [0, 1]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.07501340000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        priorities[i*N*N + j*N + k][0] = total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [0, 0, 0, 0, 0, 0]
        total_spin = h[site_nbr][j][k]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spins[axis]
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spins[axis]
  return(priorities)


#score: {'data3D.txt': -0.0142302}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = []
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spin = J[axis][i][j][k]
          total_spin += interacting_spin * h[site][j][k]
          if h[site][j][k] > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spin
        priorities[i*N*N + j*N + k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.050875400000000015}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.07132939999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  total_prioritys = np.zeros((N,N,N,2))
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      if interacting_spins[l][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_prioritys[site_nbr[0]][site_nbr[1]][site_nbr[2]][0] += -J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      else:
        total_prioritys[site_nbr[0]][site_nbr[1]][site_nbr[2]][0] -= J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      total_prioritys[i//N//N][i//N%N][i%N][1] -= total_spin
    else:
      total_prioritys[i//N//N][i//N%N][i%N][1] += total_spin
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    priorities[i][0] += total_prioritys[site_nbr[0]][site_nbr[1]][site_nbr[2]][0]
    priorities[i][1] += total_prioritys[site_nbr[0]][site_nbr[1]][site_nbr[2]][1]
  
  return(priorities)


#score: {'data3D.txt': 0.00021939999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%3 - 1)) % N
          total_spin += J[l,i,j,k]*h[site_nbr][j,k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = 1
          priorities[i*N*N+j*N+k][1] = -1
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] = -1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[s][j,k] for s in [(i-1)%N, i, (i+1)%N])
        if J[0,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] += -total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += -total_spin
  return(priorities)


#score: {'data3D.txt': -0.14547900000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j,k]
        if J[0,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        elif J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        for l in range(6):
          if np.abs(J[l,i,j,k]) > 1e-5: 
            site_nbr = (i + ((l+2)%3 - 1)) % N
            total_spin += h[site_nbr][j,k]
            if J[l,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
              priorities[i*N*N+j*N+k][1] -= 1
            elif J[l,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= 1
              priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for axis in [0, 1]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin = h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.09683180000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((k+1)%2 - 1)) % N]
        total_spin = h[i][j][k]
        for axis in [0, 1]:
          for site in site_nbrs:
            if h[site][j][k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        priorities[i*N*N + j*N + k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][1] = -total_spin
        else:
          priorities[i*N*N + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l][i][j][k] for l in range(6) if J[l][i][j][k] > 0)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.31823700000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l][site_nbr][j][k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.03936540000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l][i][j][k] * (2*h[i][j][k] - 1) for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.05057220000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%3 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += h[site_nbr][j,k]
          else:
            total_spin -= h[site_nbr][j,k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = 1
          priorities[i*N*N+j*N+k][1] = -1
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] = -1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': 0.00021939999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%3 - 1)) % N
          total_spin += J[l,i,j,k]*h[site_nbr][j,k]
        priority_total = 1 + total_spin if total_spin > 0 else -1 if total_spin < 0 else 0
        priorities[i*N*N+j*N+k][0] = priority_total
        priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%3 - 1)) % N
          total_spin += J[l,i,j,k]*h[site_nbr][j,k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = 2*(total_spin > 0) - 1
        else:
          priorities[i*N*N+j*N+k][0] = 1
  return(priorities)


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j,k]
        for l in range(6):
          site_nbr1 = (i + ((l-1)%3 - 1)) % N
          site_nbr2 = (i + ((l-1+3)%3 - 1)) % N
          if J[l,i,j,k] < 0:
            total_spin += h[site_nbr1][j,k]
            total_spin -= h[site_nbr2][j,k]
          elif J[l,i,j,k] > 0:
            total_spin -= h[site_nbr1][j,k]
            total_spin += h[site_nbr2][j,k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = 1
          priorities[i*N*N+j*N+k][1] = -1
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] = -1
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs_spin = [h[(i//N + ((i%N-1)%2 - 1)) % N][i%N//N][i%N%N] for _ in range(6)]
    if sum(site_nbrs_spin) > 0:
      priorities[i][0] += site_nbrs_spin.count(1)
      priorities[i][1] -= site_nbrs_spin.count(-1)
    else:
      priorities[i][0] -= site_nbrs_spin.count(1)
      priorities[i][1] += site_nbrs_spin.count(-1)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs_spin = [h[site_nbr//N][(site_nbr%N)//N][site_nbr%N%N] if site_nbr < N else 
             -1*h[(site_nbr-N)%N//N][(site_nbr-N)%N%N][site_nbr%N%N] for site_nbr in range(6*i, 6*(i+1))]
    total_spin = np.sum(site_nbrs_spin)
    priorities[i][0] += len([spin for spin in site_nbrs_spin if spin > 0])
    priorities[i][1] -= len([spin for spin in site_nbrs_spin if spin < 0])
  return(priorities)


#score: {'data3D.txt': -0.08786780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.2574166000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        # Calculate interactions from above and below
        interacting_spin = J[1, i, j, k] + J[2, i, j, k]
        if h[(i-1)%N][j][k] * interacting_spin > 0:
          total_spin[0] += interacting_spin
        else:
          total_spin[1] -= interacting_spin
        
        # Calculate interactions from left and right
        interacting_spin = J[3, i, j, k] + J[4, i, j, k]
        if h[i][(j-1)%N][k] * interacting_spin > 0:
          total_spin[0] += interacting_spin
        else:
          total_spin[1] -= interacting_spin
        
        # Calculate interactions from front and back
        interacting_spin = J[5, i, j, k]
        if h[i][j][(k-1)%N] * interacting_spin > 0:
          total_spin[0] += interacting_spin
        else:
          total_spin[1] -= interacting_spin
        
        # Add site parity and adjust the priority
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  return priorities


#score: {'data3D.txt': -0.3195305999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += np.sum(np.abs(h[i][j])) * 3.5 + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= np.sum(np.abs(h[i][j])) * 2.5 - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= np.sum(np.abs(h[i][j])) * 3.5 + total_spin[0]
          priorities[i*N*N + j*N + k][1] += np.sum(np.abs(h[i][j])) * 2.5 - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.3083605999999999}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= 2 * np.sum(np.abs(h[i][j])) - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] += 2 * np.sum(np.abs(h[i][j])) - total_spin[1]
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs_spin = []
    for k in [(0,1), (1,2), (2,0)]:
      for j in [k[1] - 1]:
        site_nbrs_spin.append(h[(i//N + ((i%N-1)%2 - 1)) % N][j//N][j%N])
    total_spin = sum(site_nbrs_spin)
    if total_spin > 0:
      priorities[i][0] += site_nbrs_spin.count(1) + total_spin
      priorities[i][1] -= site_nbrs_spin.count(-1) - total_spin
    else:
      priorities[i][0] -= site_nbrs_spin.count(1) + total_spin
      priorities[i][1] = -site_nbrs_spin.count(-1) - total_spin

  return(priorities)


#score: {'data3D.txt': -0.002678200000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)    
  for i in range(N**3):
    site_nbrs = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_spin = [h[site_nbr][i%N//N][i%N%N] for site_nbr in site_nbrs]
    if sum(site_nbrs_spin) > 0:
      total_spin[i][0] += len([spin for spin in site_nbrs_spin if spin > 0])
      total_spin[i][1] -= len([spin for spin in site_nbrs_spin if spin < 0])
    else:
      total_spin[i][0] -= len([spin for spin in site_nbrs_spin if spin < 0])
      total_spin[i][1] += len([spin for spin in site_nbrs_spin if spin > 0])
  return(total_spin)


#score: {'data3D.txt': 0.0008577999999999999}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)    
  for i in range(N**3):
    site_nbrs_x = [(i//N + ((i%N-1)%2 - 1)) % N for _ in range(6)]
    site_nbrs_y = [(j+((i%N-1)%2 - 1)) % N for j in range(N)]
    site_nbr_z = [(k+((i%N-1)%2 - 1)) % N for k in range(N)]
    if sum([h[site_nbr_x][j][k] for site_nbr_x, j, k in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)]) > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= len([spin for spin in [h[site_nbr_x][j][k] for site_nbr_x, j, k in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)] if spin > 0])
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += len([spin for spin in [h[site_nbr_x][j][k] for site_nbr_x, j, k in zip(site_nbrs_x, site_nbrs_y, site_nbr_z)] if spin < 0])
  return(total_spin)


#score: {'data3D.txt': 0.023521799999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [0, 0, 0, 0, 0, 0]
        total_spin = h[site_nbr][j][k]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        priority_total = [0, 0]
        for axis in range(6):
          if total_spin > 0:
            if interacting_spins[axis] > 0:
              priority_total[0] += 1
              priority_total[1] -= 1
            else:
              priority_total[0] -= 1
              priority_total[1] += 1
          else:
            if interacting_spins[axis] > 0:
              priority_total[0] -= 1
              priority_total[1] += 1
            else:
              priority_total[0] += 1
              priority_total[1] -= 1
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.026605399999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [0, 0, 0, 0, 0, 0]
        total_spin = h[site_nbr][j][k]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        total_spin += sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.1485638000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for axis in range(6):
          site_nbr = (i + ((axis-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin, -total_spin]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            priority_total[1] += 1
          else:
            priority_total[0] -= 1
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.10521820000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins_sum = 0
        interacting_spins_product = 1
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spin = h[site][j][k]
          interacting_spins_sum += interacting_spin
          interacting_spins_product *= (1 + interacting_spin)
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1 - J[axis, i, j, k] * interacting_spins_sum + J[axis, i, j, k] * interacting_spins_product
            priorities[i*N*N + j*N + k][1] -= 1 - J[axis, i, j, k] * (2*interacting_spin - 1) + J[axis, i, j, k] * (2*interacting_spin**2 - 1)
          else:
            priorities[i*N*N + j*N + k][0] -= 1 - J[axis, i, j, k] * interacting_spins_sum - J[axis, i, j, k] * interacting_spins_product
            priorities[i*N*N + j*N + k][1] += 1 - J[axis, i, j, k] * (2*interacting_spin - 1) - J[axis, i, j, k] * (2*interacting_spin**2 - 1)
  return(priorities)


#score: {'data3D.txt': -0.058109799999999996}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    # Add priority based on site magnetism
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.013561400000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    # Add a bonus term to encourage the same spin as neighbors
    for j in range(3):
      site_nbr_j = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%(N-1)) - 1)) % N, (j))
      
      total_spin_j = np.sum(h[site_nbr_j[0]][site_nbr_j[1]][site_nbr_j[2]])
      
      for l in range(6):
        interacting_spins_j = J[l, site_nbr_j[0], site_nbr_j[1], site_nbr_j[2]]
        
        if interacting_spins_j > 0:
          priorities[i][0] -= total_spin_j
          priorities[i][1] += total_spin_j
        else:
          priorities[i][0] += total_spin_j
          priorities[i][1] -= total_spin_j
    
  return(priorities)


#score: {'data3D.txt': 0.050875400000000015}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l][site_nbr[0]][site_nbr[1]][site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.0012506}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l % 2 == 0 else (k-1)%N for l in range(6)]
        total_spin[i*N+j*k][0] += sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z))
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= 1
        else:
          total_spin[i*N+j*k][1] += 1
  return(total_spin)


#score: {'data3D.txt': 0.008668199999999923}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
            if h[i][j][k] > 0:
              total_spin_1 -= J[l, i, j, k]
            else:
              total_spin_1 += J[l, i, j, k]
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            total_spin_0 += h[i][site_nbr][k]
            if h[i][j][k] > 0:
              total_spin_1 -= J[l, i, j, k]
            else:
              total_spin_1 += J[l, i, j, k]
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.0005989999999999994}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        
        for l in range(3):
          if h[site_nbr_x][i][j]:
            total_spin_0 += 1
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 += 1
          
          if h[i][site_nbr_y][k]:
            total_spin_0 += 1
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 += 1
          
          if h[i][j][site_nbr_z]:
            total_spin_0 += 1
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 += 1
        
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.19206020000000004}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0)%2 - 1)) % N
        site_nbr_y = (j + ((1)%2 - 1)) % N
        site_nbr_z = (k + ((2)%2 - 1)) % N
        
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z]

        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.29758980000000007}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0)%2 - 1)) % N
        site_nbr_y = (j + ((1)%2 - 1)) % N
        site_nbr_z = (k + ((2)%2 - 1)) % N
        
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z] + J[0,i,j,k]*h[i][j][k] + J[1,i,j,k]*h[site_nbr_x][j][k] + J[2,i,j,k]*h[i][site_nbr_y][k]
        
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0)%2 - 1)) % N
        site_nbr_y = (j + ((1)%2 - 1)) % N
        site_nbr_z = (k + ((2)%2 - 1)) % N
        
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z]
        
        if h[i][j][k] > 0:
          priority_total = [total_spin_0 + 1, total_spin_1 - 3]
        else:
          priority_total = [-total_spin_0 - 1, total_spin_1 + 1]
          
        priorities.append(priority_total)
  return(priorities)


#score: {'data3D.txt': -0.1442834000000001}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0)%2 - 1)) % N
        site_nbr_y = (j + ((1)%2 - 1)) % N
        site_nbr_z = (k + ((2)%2 - 1)) % N
        
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z] + J[0,i,j,k]*h[site_nbr_x][j][k] + J[1,i,j,k]*-h[i][site_nbr_y][k] + J[2,i,j,k]*-h[i][j][site_nbr_z]
        
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.0006125999999999996}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((0)%2 - 1)) % N
        site_nbr_y = (j + ((1)%2 - 1)) % N
        site_nbr_z = (k + ((2)%2 - 1)) % N
        
        total_spin_0 = h[site_nbr_x][j][k]
        total_spin_1 = -h[i][site_nbr_y][k] - h[i][j][site_nbr_z]

        if h[i][j][k] > 0:
          priorities.append([-total_spin_0, -total_spin_1])
        else:
          priorities.append([total_spin_0, total_spin_1])

  return(priorities)


#score: {'data3D.txt': -0.2671786000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = site_parity * (total_spin[0] + len([l for l in range(6) if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0]))
        priorities[i*N*N + j*N + k][1] = -site_parity * (total_spin[1] + len([l for l in range(6) if h[i][j][(i + ((l-1)%2 - 1)) % N] > 0]))
  
  return priorities


#score: {'data3D.txt': 0.0005242000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k] if l < 3 else J[l-3, i, j, site_nbr]
          total_spin[0] += h[site_nbr][j][k] if l < 3 else h[i][site_nbr][k]
          total_spin[1] -= interacting_spin if parity * interacting_spin > 0 else interacting_spin
          total_spin[1] += interacting_spin if parity * interacting_spin <= 0 else -interacting_spin
        
        for side in [(0, 1), (2, 3)]:
          site_nbr = (i + ((side[1]-1)%2 - 1)) % N
          interacting_spin = J[5, i, j, site_nbr] if parity * h[i][j][site_nbr] > 0 else -J[5, i, j, site_nbr]
          total_spin[0] += h[i][j][site_nbr]
          total_spin[1] -= interacting_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [1, 2, 3, 4, 5, 6]]
        site_interactions = [J[l, i, site, k] if parity * J[l, i, site, k] > 0 else -J[l, i, site, k] for l, site in zip([1, 2, 3, 4, 5], site_nbrs)]
        total_spin = sum(site_interactions)
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 - total_spin
        
  return priorities


#score: {'data3D.txt': -0.002597}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in [0,4]]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in [2,5]]
        site_nbr_z = [(k+1)%N if l == 0 or l == 3 else (k-1)%N for l in [0,4]]
        total_spin_0 = 0
        total_spin_1 = 0
        for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z):
          site_nbr = tuple([i] + list(site_nbr))
          if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
            total_spin_0 += 1
            total_spin_1 -= 1
          else:
            total_spin_0 -= 1
            total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [(i+1)%N, (i-1+N)%N]:
          interacting_spin = J[0, i, l, k] * (h[l][j][k] if l != i else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for m in [(j+1)%N, (j-1+N)%N]:
          interacting_spin = J[1, i, j, m] * (h[i][m][k] if m != j else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        for n in [(k+1)%N, (k-1+N)%N]:
          interacting_spin = J[2, i, j, k] * (h[i][j][n] if n != k else 0)
          if site_parity * interacting_spin > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N*N + j*N + k][0] = total_spin[0]
        priorities[i*N*N + j*N + k][1] = -total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.1960806000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = -total_spin
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.3410145999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j][k] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  priorities[i*N**2 + j*N + k][0] += total_spin
  priorities[i*N**2 + j*N + k][1] = -total_spin
  for j in range(N):
    if h[0][j][k] > 0:
      priorities[j][0] = total_spin
    else:
      priorities[j][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.2633330000000003}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        
        total_spin_0 += h[site_nbr_x][j][k]
        total_spin_1 -= h[i][site_nbr_y][k] - h[i][j][site_nbr_z]
        
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.2865834000000001}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        
        site_nbr_x = (i + ((0)%2 - 1)) % N
        site_nbr_y = (j + ((1)%2 - 1)) % N
        site_nbr_z = (k + ((2)%2 - 1)) % N
        
        total_spin_0 += h[site_nbr_x][j][k]
        total_spin_1 -= h[i][site_nbr_y][k] - h[i][j][site_nbr_z]
        
        for l in range(6):
          if l == 0:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
            total_spin_1 -= 1
          elif l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            if h[i][site_nbr][k] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.32621540000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    for k in range(6):
      if J[k][i//N//N][i//N%N][i%N%N] < 0:
        priorities[i][0] += 1 + total_spin
        priorities[i][1] -= 1 - total_spin
      elif J[k][i//N//N][i//N%N][i%N%N] > 0:
        priorities[i][0] -= 1 + total_spin
        priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0810874}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    if h[i//N//N][i//N%N][i%N%N] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    interacting_total_spin = 0
    for j in range(6):
      interacting_spin = interacting_spins[j][i//N//N][i//N%N][i%N%N]
      if J[j,i//N//N,i%N//N,i%N%N] > 0:
        interacting_total_spin += 1
      else:
        interacting_total_spin -= 1
    priorities[i][0] += total_spin + interacting_total_spin
    priorities[i][1] = -total_spin - interacting_total_spin

  return(priorities)


#score: {'data3D.txt': -0.0099462}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N//N][i%N%N]
    if J[0,i//N//N,i%N//N,i%N%N] < 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    elif J[0,i//N//N,i%N//N,i%N%N] > 0:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][i][j]
      if J[0,i,j,0] < 0:
        priorities[i*N+j][0] += 1 + total_spin
        priorities[i*N+j][1] -= 1 - total_spin
      elif J[0,i,j,0] > 0:
        priorities[i*N+j][0] -= 1 + total_spin
        priorities[i*N+j][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.0014862000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k] if l < 3 else J[l-3, i, j, site_nbr]
          total_spin[0] += h[site_nbr][j][k] if l < 3 else h[i][site_nbr][k]
          total_spin[1] -= interacting_spin if parity * interacting_spin > 0 else interacting_spin
          total_spin[1] += interacting_spin if parity * interacting_spin <= 0 else -interacting_spin
        
        for side in [(0, 1), (2, 3)]:
          site_nbr = (i + ((side[1]-1)%2 - 1)) % N
          interacting_spin = J[5, i, j, site_nbr] if parity * h[i][j][site_nbr] > 0 else -J[5, i, j, site_nbr]
          total_spin[0] += h[i][j][site_nbr]
          total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k] if l < 3 else J[l-3, i, j, site_nbr]
          total_spin[0] += h[site_nbr][j][k] if l < 3 else h[i][site_nbr][k]
          total_spin[1] -= interacting_spin if parity * interacting_spin > 0 else interacting_spin
          total_spin[1] += interacting_spin if parity * interacting_spin <= 0 else -interacting_spin
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.06207979999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k] if l < 3 else J[l-3, i, j, site_nbr]
          total_spin[0] += h[site_nbr][j][k] if l < 3 else h[i][site_nbr][k]
          total_spin[1] -= interacting_spin if parity * interacting_spin > 0 else -interacting_spin
        
        for side in [(0, 1), (2, 3)]:
          site_nbr = (i + ((side[1]-1)%2 - 1)) % N
          interacting_spin = J[5, i, j, site_nbr] if parity * h[i][j][site_nbr] > 0 else -J[5, i, j, site_nbr]
          total_spin[0] += h[i][j][site_nbr]
          total_spin[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = max(total_spin[0], 0)
        priorities[i*N*N + j*N + k][1] = -total_spin[0] if parity > 0 else total_spin[0]
  
  return priorities


#score: {'data3D.txt': 0.001239800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin0 = 0
        total_spin1 = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if l < 3:
            interacting_spin0 = J[l, i, site_nbr, k]
            interacting_spin1 = J[l, i, j, site_nbr]
          else:
            interacting_spin0 = J[l-3, i, j, site_nbr]
            interacting_spin1 = -J[l-3, i, site_nbr, k]
            
          total_spin0 += h[site_nbr][j][k] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin1 += h[site_nbr][j][k] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
        
        for side in [(0, 1), (2, 3)]:
          site_nbr = (i + ((side[1]-1)%2 - 1)) % N
          
          interacting_spin0 = J[5, i, j, site_nbr] if h[i][j][site_nbr] > 0 else -J[5, i, j, site_nbr]
          interacting_spin1 = J[5, i, j, site_nbr] if h[i][j][site_nbr] < 0 else -J[5, i, j, site_nbr]
          
          total_spin0 += h[i][j][site_nbr] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin1 += h[i][j][site_nbr] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
        
        priorities[i*N*N + j*N + k][0] = total_spin0
        priorities[i*N*N + j*N + k][1] = total_spin1
  
  return priorities


#score: {'data3D.txt': -0.3110701999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        interacting_spins = []
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
          interacting_spins.append(interacting_spin)
        
        interacting_spins.sort()
        threshold = np.sum(np.abs(interacting_spins[:3]))
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= 2 * np.sum(np.abs(h[i][j])) - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] += 2 * np.sum(np.abs(h[i][j])) - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.3027761999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += np.sum(np.abs(h[i][j])) * 3 + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= np.sum(np.abs(h[i][j])) * 2 - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= np.sum(np.abs(h[i][j])) * 3 + total_spin[0]
          priorities[i*N*N + j*N + k][1] += np.sum(np.abs(h[i][j])) * 2 - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.3031082}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += np.sum(np.abs(h[i][j])) * 3 + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= np.sum(np.abs(h[i][j])) * 2 - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= np.sum(np.abs(h[i][j])) * 3 + total_spin[0]
          priorities[i*N*N + j*N + k][1] += np.sum(np.abs(h[i][j])) * 2 - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.15348260000000005}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += h[site_nbr][j][k]
            total_spin_1 -= J[l, i, j, k]
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            total_spin_0 += h[i][site_nbr][k]
            total_spin_1 -= J[l, i, j, k]
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': 0.008668199999999923}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        
        total_spin_0 += h[site_nbr_x][j][k]
        if h[i][j][k] > 0:
          total_spin_1 -= J[0, i, j, k]
        else:
          total_spin_1 += J[0, i, j, k]

        for l in range(1, 6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if l < 3: # x-interactions
            total_spin_0 += h[site_nbr][j][k]
            if h[i][j][k] > 0:
              total_spin_1 -= J[l, i, j, k]
            else:
              total_spin_1 += J[l, i, j, k]
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            total_spin_0 += h[i][site_nbr][k]
            if h[i][j][k] > 0:
              total_spin_1 -= J[l, i, j, k]
            else:
              total_spin_1 += J[l, i, j, k]
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1

        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.1501082000000001}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin_0 += 1
          total_spin_1 -= 1
        else:
          total_spin_0 -= 1
          total_spin_1 += 1
        for l in range(6):
          site_nbr = None
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin_0 += J[l, i, j, k]
            total_spin_1 -= J[l, i, j, k]
          else:
            total_spin_0 -= J[l, i, j, k]
            total_spin_1 += J[l, i, j, k]
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.10825540000000024}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_0 = 0
        total_spin_1 = 0
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        site_nbr_y = (j + ((1-1)%2 - 1)) % N
        site_nbr_z = (k + ((2-1)%2 - 1)) % N
        if h[site_nbr_x][j][k] > 0:
          total_spin_0 += 1
          total_spin_1 -= 1
        else:
          total_spin_0 -= 1
          total_spin_1 += 1
        for l in range(6):
          if l < 3: # x-interactions
            site_nbr = (i + ((l-1)%2 - 1)) % N
            total_spin_0 += J[l, i, j, k] * h[site_nbr][j][k]
            total_spin_1 -= J[l, i, j, k] * h[site_nbr][j][k]
          elif l < 6 and (l == 3 or l == 4): # y- interactions
            site_nbr = (j + ((l-3)%2 - 1)) % N
            total_spin_0 += J[l, i, j, k] * h[i][site_nbr][k]
            total_spin_1 -= J[l, i, j, k] * h[i][site_nbr][k]
          else: # z- interactions
            site_nbr = (k + ((l-5)%2 - 1)) % N
            if h[i][j][site_nbr] > 0:
              total_spin_0 += 1
              total_spin_1 -= 1
            else:
              total_spin_0 -= 1
              total_spin_1 += 1
        priorities.append([total_spin_0, total_spin_1])
  return(priorities)


#score: {'data3D.txt': -0.07132939999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      if interacting_spins[l][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] += -J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      else:
        priorities[i][0] -= J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][1] -= total_spin
    else:
      priorities[i][1] += total_spin
    
  return(priorities)


#score: {'data3D.txt': 0.050941400000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      if J[l, site_nbr[0], site_nbr[1], site_nbr[2]] < 0:
        priorities[i][0] += -J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
        priorities[i][1] -= 1
      elif J[l, site_nbr[0], site_nbr[1], site_nbr[2]] > 0:
        priorities[i][0] -= J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
        priorities[i][1] += 1
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][1] += total_spin
    else:
      priorities[i][1] -= total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.07932060000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for k in range(6):
      if J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0:
        priorities[i][0] += -J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][1] -= total_spin
      elif J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        priorities[i][0] -= J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]]
        priorities[i][1] += total_spin
    
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][1] -= total_spin
    else:
      priorities[i][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0010082}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        total_spin[i*N+j*k][0] += sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z))
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= len([site_nbr for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z) if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0])
        else:
          total_spin[i*N+j*k][1] += len([site_nbr for site_nbr in zip(site_nbrs_x, site_nbrs_y, site_nbr_z) if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] < 0])
  return(total_spin)


#score: {'data3D.txt': -0.0037266000000000005}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin[i*N+j*k][1] -= sum([J[l,i,j,k] for l in range(6) if h[(i+((l-1)%2 - 1))%N][j][k] > 0])
          total_spin[i*N+j*k][0] += 1
        else:
          total_spin[i*N+j*k][1] += sum([J[l,i,j,k] for l in range(6) if h[(i+((l-1)%2 - 1))%N][j][k] < 0])
          total_spin[i*N+j*k][0] -= 1
  return(total_spin)


#score: {'data3D.txt': -0.0009522000000000002}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i+1)%N if l < 3 else (i-1)%N for l in range(6)]
        site_nbrs_y = [(j+1)%N if l >= 3 else (j-1)%N for l in range(6)]
        site_nbr_z = [(k+1)%N if l == 4 or l == 5 else (k-1)%N for l in range(6)]
        for site_nbr_x, site_nbr_y, site_nbr_z in zip(site_nbrs_x, site_nbrs_y, site_nbr_z):
          total_spin[i*N+j*k][0] += h[site_nbr_x][site_nbr_y][site_nbr_z]
          if h[i][j][k] > 0:
            total_spin[i*N+j*k][1] -= (h[site_nbr_x][site_nbr_y][site_nbr_z] > 0)
          else:
            total_spin[i*N+j*k][1] += (h[site_nbr_x][site_nbr_y][site_nbr_z] < 0)
  return(total_spin)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][site_nbr][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][site_nbr] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = 2 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] = -2 * np.sum(np.abs(h[i][j])) - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = 1 * np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] = -2 * np.sum(np.abs(h[i][j])) - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0408018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        # Calculate interactions with neighboring sites
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        # Calculate priority based on site parity and interactions
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = np.sum(np.abs(h[i][j])) + total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] = -np.sum(np.abs(h[i][j])) - total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.030795799999999998}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    # Add magnetism as well
    priorities[i][0] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    priorities[i][1] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
  
  return(priorities)


#score: {'data3D.txt': 0.11285340000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], (site_nbr[1]+1)%N, site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      interacting_spins = J[l, (site_nbr[0]+1)%N, site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      interacting_spins = J[l, (site_nbr[0]+1)%N, (site_nbr[1]+1)%N, site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], (site_nbr[1]+1)%N, (site_nbr[2]+1)%N]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      interacting_spins = J[l, (site_nbr[0]+1)%N, site_nbr[1], (site_nbr[2]+1)%N]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      interacting_spins = J[l, (site_nbr[0]+1)%N, (site_nbr[1]+1)%N, (site_nbr[2]+1)%N]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
  return(priorities)


#score: {'data3D.txt': 0.06591260000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin + interacting_spins
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin - interacting_spins
  
  return(priorities)


#score: {'data3D.txt': 0.0633534}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (i//N%N + ((i%N-1)%2 - 1)) % N, (i%N))
    
    total_spin = np.sum(h[site_nbr[0]][site_nbr[1]][site_nbr[2]])
    
    for l in range(6):
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
    
    for l in range(6):
      site_nbr = ((i//N//N + ((i//N)%2 - 1)) % N, (site_nbr[1] + ((l+1)%3 - 1)) % N, site_nbr[2])
      
      interacting_spins = J[l, site_nbr[0], site_nbr[1], site_nbr[2]]
      
      if interacting_spins > 0:
        priorities[i][0] += -interacting_spins
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= interacting_spins
        priorities[i][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.11533820000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if J[0][i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.2198758}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.002569}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[(i + ((k-1)%2 - 1)) % N][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        if J[1,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        if J[2,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[2,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.08796660000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for l, site_nbr in enumerate(site_nbrs):
          interacting_spin = J[l][i][j][k] * h[site_nbr][j][k]
          if interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] = 2 + total_spin - np.sum(np.abs(h[site_nbrs, j, k]))
          priorities[i*N*N + j*N + k][1] = -total_spin - 1
        else:
          priorities[i*N*N + j*N + k][0] = -1 + total_spin + np.sum(np.abs(h[site_nbrs, j, k]))
          priorities[i*N*N + j*N + k][1] = 1 + total_spin
  return priorities


#score: {'data3D.txt': 0.04113860000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(sum(J[l][site_nbr_i][j][k] * h[site_nbr][j][k] for site_nbr,site_nbr_i in zip(site_nbrs,[i]*6)) for l in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k] = [2+total_spin - sum(abs(h[site_nbr][j][k]) for site_nbr in site_nbrs),-total_spin-1]
        else:
          priorities[i*N*N + j*N + k] = [-1+total_spin + sum(abs(h[site_nbr][j][k]) for site_nbr in site_nbrs),1+total_spin]
  return priorities


#score: {'data3D.txt': -0.3424029999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = 0
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1

        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin

        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2

  return priorities


#score: {'data3D.txt': -0.1485638000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for axis in range(6):
          site_nbr = (i + ((axis-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [total_spin, -total_spin]
        for axis in range(6):
          site_nbr = (i + ((axis-1)%2 - 1)) % N
          if J[axis,i,j,k] > 0:
            priority_total[1] += 1
          else:
            priority_total[0] -= 1
        priorities[i*N*N + j*N + k] = [priority_total[0], priority_total[1]]
  return(priorities)


#score: {'data3D.txt': -0.1485638000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(1 if h[site_nbr][j][k] > 0 else -1 
                 for site_nbr in ((i + ((axis-1)%2 - 1)) % N
                          for axis in range(6)))
        priority_total = [total_spin, -total_spin]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            priority_total[1] += 1
          else:
            priority_total[0] -= 1
        priorities[i*N**2 + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.1485638000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((axis-1)%2 - 1)) % N for axis in range(6)]])
        priority_total = [total_spin, -total_spin]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            priority_total[1] += 1
          else:
            priority_total[0] -= 1
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k] + h[site_nbr2][j][k] + h[site_nbr3][j][k]
        priority_total = [total_spin, -total_spin]
        for l in range(6):
          if J[l,i,j,k] > 0:
            priority_total[1] += 1
          else:
            priority_total[0] -= 1
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0019529999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = [h[i][j][k] + total_spin, 2 - total_spin]
        priorities[i*N*N + j*N + k] = priority_total
  return priorities


#score: {'data3D.txt': -0.25201620000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        # Calculate the total spin from interactions
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        # Calculate the priority based on the site parity and interaction spin
        priority_total = [site_parity + total_spin[0], -total_spin[1]]
        
        priorities[i*N*N + j*N + k] = priority_total
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += 1
          else:
            total_spin[1] -= 1
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += 1
          else:
            total_spin[1] -= 1
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  return priorities


#score: {'data3D.txt': -0.046282999999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[i][j][k]
        interacting_spins = [h[site_nbr][j][k]]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        total_spin += sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.021851000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([1 if h[site_nbr][j][k] > 0 else -1 for site_nbr in [(i + ((axis-1)%2 - 1)) % N for axis in range(6)]])
        priority_total = [total_spin, -total_spin]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            priority_total[1] += 1
          else:
            priority_total[0] -= 1
          if h[i][j][k] > 0:
            priority_total[1] += total_spin
            priority_total[0] -= total_spin
          else:
            priority_total[1] -= total_spin
            priority_total[0] += total_spin
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.11747500000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for axis in [0, 1]:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          priorities[i*N*N + j*N + k][0] += total_spin
          if h[i][axis][k] > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= 1
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.07356780000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [h[i][j][k]]
        for axis in range(6):
          site_nbr = (i + ((axis-1)%2 - 1)) % N
          if J[axis, i, j, k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] = -sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.3109497999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = [h[(i + ((k-1)%2 - 1)) % N][j][k]]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        total_spin += sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins) - 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = -sum(interacting_spins) + 1
  return(priorities)


#score: {'data3D.txt': -0.042519799999999976}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for axis in range(6):
          if axis < 3:
            site_nbrs.append((i + ((axis-1)%2 - 1)) % N)
          else:
            site_nbrs.append((i + ((axis-4)%2 - 1)) % N)
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum([h[s][j][k] for s in site_nbrs])
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum([h[s][j][k] for s in site_nbrs])
  return(priorities)


#score: {'data3D.txt': -0.11039940000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [h[i][j][k]]
        if i > 0:
          interacting_spins.append(h[i-1][j][k])
        if j > 0:
          interacting_spins.append(h[i][j-1][k])
        if k > 0:
          interacting_spins.append(h[i][j][k-1])
        total_spin += sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.0019617999999999997}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[(i + ((k-1)%2 - 1)) % N][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1 + axis
            priorities[i*N*N + j*N + k][1] -= 1 - axis
          else:
            priorities[i*N*N + j*N + k][0] -= 1 - axis
            priorities[i*N*N + j*N + k][1] = -axis + total_spin
  return(priorities)


#score: {'data3D.txt': 0.04618260000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   J[0][i][j][k]]
        total_spin = sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': 0.011477000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[neighbor][j][k] * (J[l, neighbor, i, k] > 0) for l, neighbor in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += sum(J[l, (i + ((l-1)%2 - 1)) % N, j, k] * (-1) for l in range(6))
          priorities[i*N**2 + j*N + k][1] -= sum(J[l, (i + ((l-1)%2 - 1)) % N, j, k] for l in range(6))
        else:
          priorities[i*N**2 + j*N + k][0] += sum(J[l, (i + ((l-1)%2 - 1)) % N, j, k] * (-1) for l in range(6))
          priorities[i*N**2 + j*N + k][1] = -sum(J[l, (i + ((l-1)%2 - 1)) % N, j, k] for l in range(6))
  return priorities


#score: {'data3D.txt': 0.06330060000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(h[site_nbr][j][k] * (J[l, neighbor, i, k] > 0) for l, neighbor in enumerate([(i + ((l-1)%2 - 1)) % N for l in range(6)]))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.09702099999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(h[site_nbr][j][k] * (J[l, i, j, k] > 0) for l, site_nbr in enumerate(site_nbrs))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.0014273999999999995}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][site_nbr]
      if J[1,i,j,k] > 0:
        priorities[i*N+j*k][0] += 1
        priorities[i*N+j*k][1] -= 1
      elif J[1,i,j,k] < 0:
        priorities[i*N+j*k][0] -= 1
        priorities[i*N+j*k][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[i][site_nbr]
      if J[2,i,j,k] > 0:
        priorities[i*N+j*k][0] += 1
        priorities[i*N+j*k][1] -= 1
      elif J[2,i,j,k] < 0:
        priorities[i*N+j*k][0] -= 1
        priorities[i*N+j*k][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin = h[i][j]
      if J[3,i,j,k] > 0:
        priorities[i*N+j*k][0] += 1
        priorities[i*N+j*k][1] -= 1
      elif J[3,i,j,k] < 0:
        priorities[i*N+j*k][0] -= 1
        priorities[i*N+j*k][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((k-1)%2 - 1)) % N
      total_spin = h[i][site_nbr]
      if J[4,i,j,k] > 0:
        priorities[i*N+j*k][0] += 1
        priorities[i*N+j*k][1] -= 1
      elif J[4,i,j,k] < 0:
        priorities[i*N+j*k][0] -= 1
        priorities[i*N+j*k][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (k + ((i-1)%2 - 1)) % N
      total_spin = h[i][j]
      if J[5,i,j,k] > 0:
        priorities[i*N+j*k][0] += 1
        priorities[i*N+j*k][1] -= 1
      elif J[5,i,j,k] < 0:
        priorities[i*N+j*k][0] -= 1
        priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0019617999999999997}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.012304200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.33646019999999977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k]]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.05085539999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        total_spin = h[i][j][k]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        total_spin += sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum(interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, ((i+j-2)%2 - 1), ((i+j-4)%2 - 1)]
        
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k] if site_parity * h[i][j][k] > 0 else -J[l, i, j, k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = 2*total_spin[0] + site_parity
        priorities[i*N*N + j*N + k][1] = -2*total_spin[1] - site_parity
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        interacting_sites = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, ((i+j-2)%2 - 1), ((i+j-4)%2 - 1)]
        
        for site in interacting_sites:
          interacting_spin = J[0][i][site][k] if site_parity * h[i][site][k] > 0 else -J[0][i][site][k]
          total_spin[0] += interacting_spin
          total_spin[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = np.sum(np.abs(h[i][j])) + site_parity + total_spin[0]
        priorities[i*N*N + j*N + k][1] = -np.sum(np.abs(h[i][j])) - site_parity - total_spin[1]
  return priorities


#score: {'data3D.txt': -0.002569}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j]
          if J[d, i, j, k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.0016373999999999996}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += -1*sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1
    else:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.1533362000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[l][site_nbr][j][k] * h[site_nbr][l][k] for l in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
  return priorities


#score: {'data3D.txt': -0.14506020000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(J[l][site_nbr][j][k] * h[site_nbr][l][k] for l, site_nbr in zip(range(6), site_nbrs))
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.1469934000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = sum(J[l][site_nbrs[0]][j][k] * h[site_nbrs[0]][l][k] for l in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.30813460000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l][i][j][k] * (1 if l % 2 == 0 else -1) for l in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.0010798000000000001}
program:
def priority(N, h, J):
  priorities = [[0. for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [sum(J[l, i, j, k] * h[(l+1)%6][i][j] for l in range(6)), 0]
        if h[i][j][k] > 0:
          priorities[i*N+j*N+k][0] = total_spin[0]
        else:
          priorities[i*N+j*N+k][1] = -total_spin[0]
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l, i, j, k] > 0:
            priorities[i*N*N + j*N + k][0] += -J[l, i, j, k]
            priorities[i*N*N + j*N + k][1] -= 2 * J[l, i, j, k]
          else:
            priorities[i*N*N + j*N + k][0] -= -J[l, i, j, k]
            priorities[i*N*N + j*N + k][1] += 2 * J[l, i, j, k]

  return(priorities)


#score: {'data3D.txt': 0.0141014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in [1, 2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin[0] += h[site_nbr][j][k]
          interacting_spin = J[l, i, site_nbr, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        for l in [3, 4]:
          site_nbr_x = (i + ((l-2)%2 - 1)) % N
          site_nbr_z = (k + ((l-2)%2 - 1)) % N
          
          if l == 3:
            total_spin[0] += h[i][j][site_nbr_z]
            interacting_spin = J[l, i, j, site_nbr_z]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
          
          if l == 4:
            total_spin[0] += h[i][site_nbr_x][k]
            interacting_spin = J[l, i, site_nbr_x, k]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
        
        for l in [5]:
          site_nbr_y = (j + ((l-4)%2 - 1)) % N
          
          total_spin[0] += h[i][site_nbr_y][k]
          interacting_spin = J[l, i, site_nbr_y, k]
          if site_parity * interacting_spin > 0:
            total_spin[1] -= interacting_spin
          else:
            total_spin[1] += interacting_spin
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
  
  return priorities


#score: {'data3D.txt': 0.0429898}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        # Calculate the total spin considering all interactions
        for l in range(6):
          if l == 1:
            site_nbr_x = (i + ((l-1)%2 - 1)) % N
            total_spin[0] += h[site_nbr_x][j][k]
            interacting_spin = J[l, i, site_nbr_x, k]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
          elif l == 2:
            site_nbr_y = (j + ((l-1)%2 - 1)) % N
            total_spin[0] += h[i][site_nbr_y][k]
            interacting_spin = J[l, i, site_nbr_y, k]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
          elif l == 3:
            site_nbr_z = (k + ((l-2)%2 - 1)) % N
            total_spin[0] += h[i][j][site_nbr_z]
            interacting_spin = J[l, i, j, site_nbr_z]
            if site_parity * interacting_spin > 0:
              total_spin[1] -= interacting_spin
            else:
              total_spin[1] += interacting_spin
          
        # Assign the spin with the highest priority
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] = total_spin[0]
          priorities[i*N*N + j*N + k][1] = -total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] = -total_spin[0]
          priorities[i*N*N + j*N + k][1] = total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.0387098}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 2
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.001142200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.1948406000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.002535}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for axis in range(3):
          site_nbrs = [(i+1)%N if axis==0 else (i-1)%N,
                 (j+1)%N if axis==1 else (j-1)%N,
                 (k+1)%N if axis==2 else (k-1)%N]
          total_spin += sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.002569}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for d in range(3)]
        for d, site_nbr in enumerate(site_nbrs):
          total_spin += h[site_nbr][j]
          if J[d, i, j, k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0028054}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i+1)%N,i,(i-1)%N]
        for d in range(6):
          if J[d][i][j][k] > 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d][i][j][k] < 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0028054}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[2, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[2, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[4, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[4, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.002569}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N, (i + ((k-1)%2 - 1)) % N]
        for d, site_nbr in enumerate(site_nbr_list):
          total_spin += h[site_nbr][k if d == 0 else j if d == 1 else i]
          if J[d, i, j, k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d, i, j, k] < 0:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = [np.roll(h, -1, axis=i) if i < 3 else np.roll(h, 1, axis=i-3) for i in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i*N*N + j*N + k][0] += -J[l,i,j,k]*interacting_spins[l][i,N-1-j,N-1-k]
          priorities[i*N*N + j*N + k][1] -= J[l,i,j,k]*interacting_spins[l][i,N-1-j,N-1-k]
  
  return(priorities)


#score: {'data3D.txt': 0.002182199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i,j,k,0] += J[l,i,j,k]*interacting_spins[l,i,j,k]
          priorities[i,j,k,1] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.002183}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k]>0:
            priorities[i*N+j*N+k][1] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          else:
            priorities[i*N+j*N+k][0] += J[l,i,j,k]*interacting_spins[l,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.06621580000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                    h[i][(j+1)%N][k], 
                    h[i][j][(k+1)%N],
                    h[(i+1)%N][j][k], 
                    h[i][(j-1)%N][k], 
                    h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 2 * (axis % 3) - 1
            priorities[i*N*N + j*N + k][1] -= 2 * (axis % 3) + 1
          else:
            priorities[i*N*N + j*N + k][0] -= 2 * (4 - axis) - 1
            priorities[i*N*N + j*N + k][1] = -(4 - axis) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0242318}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 2 * J[axis][i][j][k]
            priorities[i*N*N + j*N + k][1] -= 2 * J[axis][i][j][k]
          else:
            priorities[i*N*N + j*N + k][0] -= 2 * J[axis][i][j][k]
            priorities[i*N*N + j*N + k][1] = -2 * J[axis][i][j][k] + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0021446000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if interacting_spins[axis] > 0:
            priorities[i*N*N + j*N + k][0] += 2 * axis
            priorities[i*N*N + j*N + k][1] -= axis
          else:
            priorities[i*N*N + j*N + k][0] -= axis
            priorities[i*N*N + j*N + k][1] = -axis - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= -2 + 3*axis
          else:
            priorities[i*N*N + j*N + k][0] -= -1
            priorities[i*N*N + j*N + k][1] = 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.0025226000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if h[i][j][k] * interacting_spin > 0:
            priorities[i*N**2 + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N**2 + j*N + k][1] += interacting_spin
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_site = (site_nbr + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if h[i][j][k] * interacting_spin > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] = -1
        
        return priorities


#score: {'data3D.txt': 0.05421740000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in set(site_nbrs):
          total_spin += h[neighbor][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = []
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          site_nbrs.append(site_nbr)
        
        for neighbor in site_nbrs:
          total_spin += J[0, i, neighbor, k] * h[neighbor][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = np.sum([1 + (J[0, i, site_nbr, k] - J[5, i, site_nbr, k]) * h[site_nbr][j][k] for site_nbr in site_nbrs])
          priorities[i*N**2 + j*N + k][1] = -np.sum([1 - (J[0, i, site_nbr, k] - J[5, i, site_nbr, k]) * h[site_nbr][j][k] for site_nbr in site_nbrs])
        else:
          priorities[i*N**2 + j*N + k][0] = np.sum([-1 + (J[0, i, site_nbr, k] - J[5, i, site_nbr, k]) * h[site_nbr][j][k] for site_nbr in site_nbrs])
          priorities[i*N**2 + j*N + k][1] = -np.sum([1 - (J[0, i, site_nbr, k] - J[5, i, site_nbr, k]) * h[site_nbr][j][k] for site_nbr in site_nbrs])
  
  return priorities


#score: {'data3D.txt': 0.03883260000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in site_nbrs:
          total_spin += h[neighbor][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': 0.3190214000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = h[i][j][k]
        for l in [0,1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += J[l][i][site_nbr][k] * (h[site_nbr][j][k] if l==0 else -h[site_nbr][j][k])
          if J[l][i][site_nbr][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in set([*site_nbrs, i]):
          total_spin += h[neighbor][j][k]
        if J[4][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': -0.011428999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in [1,2]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in site_nbrs:
          total_spin += h[neighbor][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] = 2*total_spin
          priorities[i*N**2 + j*N + k][1] = -2*total_spin
        else:
          priorities[i*N**2 + j*N + k][0] = -2*total_spin
          priorities[i*N**2 + j*N + k][1] = 2*total_spin
  return priorities


#score: {'data3D.txt': -0.052626999999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in [0,1]])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += sum(1 if J[l][i][j][k] > 0 else -1 for l in [0,1])
          priorities[i*N**2 + j*N + k][1] -= len([l for l in [0,1] if J[l][i][j][k] > 0]) * 2
        else:
          priorities[i*N**2 + j*N + k][0] -= sum(1 if J[l][i][j][k] < 0 else -1 for l in [0,1])
          priorities[i*N**2 + j*N + k][1] += len([l for l in [0,1] if J[l][i][j][k] < 0]) * 2
  return priorities


#score: {'data3D.txt': -0.0021054}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
  total_spin = np.zeros((N,N,N,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1

  for i in range(N**3):
    site_nbrs = site_nbrs_map
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += -1*sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1
    else:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0017966000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N,i,(i-1)%N,(j+1)%N,j,(j-1)%N,(k+1)%N,k,(k-1)%N]
        total_spin = 0
        for d in range(6):
          if J[d][site_nbrs[d%3]][j][k] > 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d][site_nbrs[d%3]][j][k] < 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0017966000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i+1)%N,i,(i-1)%N]
        for d in range(6):
          if J[d][site_nbrs[d%3]][j][k] > 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d][site_nbrs[d%3]][j][k] < 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.011328600000000001}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif J[0,i%N,i//N,i%N] < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.17127060000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in [0,1]])
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site_nbr, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin * total_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin * total_spin
        
        site_nbr = (i + ((2)%2 - 1)) % N
        interacting_site_nbr = (i + ((3)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        site_nbr = (i + ((4)%2 - 1)) % N
        interacting_site_nbr = (i + ((5)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
  return priorities


#score: {'data3D.txt': -0.026936999999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        parity = h[i][j][k]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in [0, 1]])
        
        if parity > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
        
        for l in range(6):
          interacting_site = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, interacting_site, k]
          if parity * interacting_spin > 0:
            priorities[i*N*N + j*N + k][1] -= interacting_spin * total_spin
          else:
            priorities[i*N*N + j*N + k][1] += interacting_spin * total_spin
        
        # Add the magnetism term
        priorities[i*N*N + j*N + k][1] += 2*h[i][j][k]
  
  return priorities


#score: {'data3D.txt': -0.03658899999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0,1]]
        total_spin = sum(h[site][j][k] for site in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
        for l in [0, 1, 2]:
          site_nbr = (i + ((l-1)%3 - 1)) % N
          interacting_site = (j + ((l-1)%3 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            priorities[i*N**2 + j*N + k][1] -= interacting_spin * total_spin
          else:
            priorities[i*N**2 + j*N + k][1] += interacting_spin * total_spin
  return priorities


#score: {'data3D.txt': -0.0068826}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if interacting_spins[axis] > 0:
            priorities[i*N**2 + j*N + k][0] += -axis
            priorities[i*N**2 + j*N + k][1] += -axis
          else:
            priorities[i*N**2 + j*N + k][0] -= axis
            priorities[i*N**2 + j*N + k][1] = -axis - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0006158}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if interacting_spins[axis] > 0:
            priorities[i*N**2 + j*N + k][0] += axis
            priorities[i*N**2 + j*N + k][1] -= -axis
          else:
            priorities[i*N**2 + j*N + k][0] -= -axis
            priorities[i*N**2 + j*N + k][1] = 2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.32683419999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        total_spin = h[i][j][k]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        total_spin += sum(interacting_spins)
        priority_total = np.array([total_spin, -sum(interacting_spins)])
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [0, 0, 0, 0, 0, 0]
        total_spin = h[i][j][k]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spins[axis]
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spins[axis]
  return(priorities)


#score: {'data3D.txt': -0.022105800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        site_nbr4 = (j + ((0-1)%2 - 1)) % N
        site_nbr5 = (k + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr1][i][j] + h[site_nbr2][i][j] + h[site_nbr3][i][j] + \
               h[i][site_nbr4][j] + h[site_nbr1][i][k] + h[site_nbr2][i][k] + h[site_nbr3][i][k] + \
               J[0, i, j, k] * (h[site_nbr1][i][j] - 0.5) + J[1, i, j, k] * (h[i][site_nbr4][j] - 0.5) + \
               J[2, i, j, k] * (h[site_nbr1][i][k] - 0.5) + J[3, i, j, k] * (h[site_nbr2][i][k] - 0.5) + \
               J[4, i, j, k] * (h[site_nbr3][i][k] - 0.5) + J[5, i, j, k] * (h[i][site_nbr4][j] - 0.5)
        priority_total = [total_spin, -total_spin]
        priorities[i*N**2 + j + k*N] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.12890300000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] 
        priority_total = [total_spin, -total_spin]
        for l in range(6):
          if J[l,i,j,k] > 0:
            if l == 0: # left neighbor
              if i > 0 and h[(i-1)%N][j][k] > 0:
                priority_total[0] -= 1
              else:
                priority_total[1] += 1
            elif l == 1: # right neighbor
              if i < N-1 and h[(i+1)%N][j][k] > 0:
                priority_total[0] += 1
              else:
                priority_total[1] -= 1
            elif l == 2: # front neighbor
              if j > 0 and h[i][j-1][k] > 0:
                priority_total[0] -= 1
              else:
                priority_total[1] += 1
            elif l == 3: # back neighbor
              if j < N-1 and h[i][j+1][k] > 0:
                priority_total[0] += 1
              else:
                priority_total[1] -= 1
            elif l == 4: # left-front neighbor
              if i > 0 and j > 0 and h[(i-1)%N][j-1][k] > 0:
                priority_total[0] -= 2
              else:
                priority_total[1] += 2
            elif l == 5: # right-back neighbor
              if i < N-1 and j < N-1 and h[(i+1)%N][j+1][k] > 0:
                priority_total[0] += 2
              else:
                priority_total[1] -= 2
        priorities[i*N**2 + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.03814779999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k] + h[site_nbr2][j][k] + h[site_nbr3][j][k]
        for axis in [0, 1]:
          if h[i][axis][k] > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= 1
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += 1
        if h[site_nbr1][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.21167220000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        total_spin = h[site_nbr1][j][k] + h[site_nbr2][j][k] + h[site_nbr3][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        elif J[1,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        elif J[2,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        elif J[3,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        elif J[4,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.0026109999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for axis in range(6):
          site_nbr = (i + ((axis-1)%2 - 1)) % N
          if axis < 3:
            interacting_spin = J[axis][i][j][k]
          else:
            interacting_spin = J[axis-3][site_nbr][j][k]
          interacting_spins.append(interacting_spin * h[site_nbr][j][k])
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if interacting_spins[axis] > 0:
            priorities[i*N**2 + j*N + k][0] += -axis
            priorities[i*N**2 + j*N + k][1] += -axis
          else:
            priorities[i*N**2 + j*N + k][0] -= axis
            priorities[i*N**2 + j*N + k][1] = -axis - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          interacting_spin = J[axis][i][j][k]
          if h[i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += -axis
            priorities[i*N**2 + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N**2 + j*N + k][0] -= axis
            priorities[i*N**2 + j*N + k][1] = -interacting_spin
  return(priorities)


#score: {'data3D.txt': -0.0015810000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = [[0, 0] for _ in range(N**3)]
  for k in range(6):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    for j in range(N):
      for i in range(N):
        if h[i][j][site_nbrs[2]] > 0:
          total_spin[i*N+j][1] += J[k, i, site_nbrs[0], j]
          total_spin[i*N+j][0] -= J[k, i, site_nbrs[0], j]
        else:
          total_spin[i*N+j][0] += J[k, i, site_nbrs[0], j]
          total_spin[i*N+j][1] -= J[k, i, site_nbrs[0], j]

  for i in range(N**3):
    if h[(i//N)%N][(i%N)//N][(i%N)%N] > 0:
      priorities[i][0] += -total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]
    else:
      priorities[i][0] = total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]

  return(priorities)


#score: {'data3D.txt': -0.3196845999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [0, 0, 0, 0, 0, 0]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins[axis] = h[site][j][k]
        total_spin = sum(interacting_spins)
        for axis in range(6):
          if total_spin > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spins[axis]
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spins[axis]
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [h[site_nbr][j][k], h[i][(j+1)%N][k],
                   h[i][(j+N-1)%N][k], h[i][j][(k+1)%N],
                   h[i][j][(k+N-1)%N], h[(i+1)%N][j][k]]
        priority_total = [sum(s > 0 for s in interacting_spins), 
                  -sum(s < 0 for s in interacting_spins)]
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [h[(i+((axis-1)%2 - 1))%N][j][k] for axis in range(6)]
        priority_total = np.zeros(2)
        if total_spin > 0:
          priority_total += 1
        else:
          priority_total -= 1
        priority_total += (np.sum(interacting_spins) > 0)*2 - 1
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': 0.023521799999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        priority_total = [0, 0]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spin = h[site][j][k]
          if total_spin > 0:
            if interacting_spin > 0:
              priority_total[0] += 1
              priority_total[1] -= 1
            else:
              priority_total[0] -= 1
              priority_total[1] += 1
          else:
            if interacting_spin > 0:
              priority_total[0] -= 1
              priority_total[1] += 1
            else:
              priority_total[0] += 1
              priority_total[1] -= 1
        priorities[i*N*N + j*N + k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.14636259999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.19652579999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, site_nbr, k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l, i, j, k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        total_spin[0] += site_parity
        total_spin[1] = -total_spin[0]
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin[0] + np.sum(np.abs(h[i][j]))
          priorities[i*N*N + j*N + k][1] += 2 - total_spin[1] - np.sum(np.abs(h[i][j]))
  
  return priorities


#score: {'data3D.txt': -0.2989902}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        total_spin = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l][site_nbr][j][k]
          if h[site_nbr][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l][site_nbr][j][k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l][i][site_nbr][k]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin = J[l][i][j][site_nbr]
          if h[i][j][k] * interacting_spin > 0:
            total_spin[0] += interacting_spin
          else:
            total_spin[1] -= interacting_spin
        
        site_parity_sum = sum(np.sum(h, axis=2).flatten())
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 4 + total_spin[0]
          priorities[i*N*N + j*N + k][1] -= 3 - total_spin[1]
        else:
          priorities[i*N*N + j*N + k][0] -= 2 + total_spin[0]
          priorities[i*N*N + j*N + k][1] += 4 - total_spin[1]
  
  return priorities


#score: {'data3D.txt': -0.001142200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= total_spin - sum(h[site][j][k] for site in site_nbrs)
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] = -total_spin + sum(h[site][j][k] for site in site_nbrs)
  return(priorities)


#score: {'data3D.txt': 0.0016373999999999996}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = sum([h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for _ in range(8)])
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += -1*sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1
    else:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.003915}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(i//N+((k-1)%2 - 1))%N][site_nbrs[1]][site_nbrs[2]] for l,k in zip(range(6),range(3))])
      priorities[i] = [-interacting_spins_sum, -1]
    else:
      interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(i//N+((k-1)%2 - 1))%N][site_nbrs[1]][site_nbrs[2]] for l,k in zip(range(6),range(3))])
      priorities[i] = [interacting_spins_sum, 1]
  
  return(priorities)


#score: {'data3D.txt': 0.0016373999999999996}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += -sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1
    else:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
    # Add more efficient way to update priorities based on neighboring spins
  return(priorities)


#score: {'data3D.txt': 0.09382820000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i][j][k][0] += J[0,i,j,k]
          priorities[i][j][k][1] += -J[0,i,j,k]
        else:
          priorities[i][j][k][0] -= J[3,i,j,k]
          priorities[i][j][k][1] += J[3,i,j,k]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i][j][k][0] -= J[4,i,j,k]
          priorities[i][j][k][1] += -J[4,i,j,k]
        else:
          priorities[i][j][k][0] += J[5,i,j,k]
          priorities[i][j][k][1] -= J[5,i,j,k]
  
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.19987140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = 0
        for l in range(6):
          if (l == 0 and (i < N-1 or j < N-1 or k < N-1)):
            interacting_spins += J[l,i,j,k]
          elif (l == 1 and (i > 0 or j < N-1 or k < N-1)):
            interacting_spins += J[l,i,j,k]
          elif (l == 2 and (i > 0 or j > 0 or k < N-1)):
            interacting_spins += J[l,i,j,k]
          elif (l == 3 and (i < N-1 or j > 0 or k < N-1)):
            interacting_spins += J[l,i,j,k]
          elif (l == 4 and (i < N-1 or j < N-1 or k > 0)):
            interacting_spins += J[l,i,j,k]
          else:
            interacting_spins -= J[l,i,j,k]
        priorities[i,j,k,0] = -interacting_spins
        priorities[i,j,k,1] = interacting_spins
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.0013870000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0019218000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][k]
        if J[4, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[4, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin = h[i][site_nbr]
        if J[1, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin = h[i][site_nbr]
        if J[2, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[2, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
      return(priorities)


#score: {'data3D.txt': -0.019613800000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((axis-1)%2 - 1)) % N for axis in range(6)])
        priority_total = [total_spin, -total_spin]
        priorities[i*N**2 + j + k*N] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.14766780000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        site_nbr4 = (j + ((0-1)%2 - 1)) % N
        site_nbr5 = (k + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr1][i][j] + h[site_nbr2][i][j] + h[site_nbr3][i][j] +\
                h[i][site_nbr4][j] + h[site_nbr1][i][k] + h[site_nbr2][i][k] + h[site_nbr3][i][k] +\
                J[0, i, j, k] * (h[site_nbr1][i][j] - 0.5) + J[1, i, j, k] * (h[i][site_nbr4][j] - 0.5) +\
                J[2, i, j, k] * (h[site_nbr1][i][k] - 0.5) + J[3, i, j, k] * (h[site_nbr2][i][k] - 0.5) +\
                J[4, i, j, k] * (h[site_nbr3][i][k] - 0.5) + J[5, i, j, k] * (h[i][site_nbr4][j] - 0.5)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin for each site
  total_spin = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin[i*N*N + j*N + k] += h[i][j][k]
        
  # Calculate priority based on magnetism and interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[(i+((k-1)%2 - 1)) % N][j][k]]
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        priority_total = [sum(interacting_spins), -sum(interacting_spins)]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= total_spin[i*N*N + j*N + k][0]
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = -total_spin[i*N*N + j*N + k][0]
          
  return(priorities)


#score: {'data3D.txt': -0.30866099999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        site_nbr4 = (j + ((0-1)%2 - 1)) % N
        site_nbr5 = (k + ((0-1)%2 - 1)) % N
        
        interacting_spins = [h[site_nbr1][i][j], h[site_nbr2][i][j], h[site_nbr3][i][j],
                   h[i][site_nbr4][j], h[site_nbr1][i][k], h[site_nbr2][i][k], h[site_nbr3][i][k],
                   h[i][site_nbr5][k]]
        
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spins.append(h[site][j][k])
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[neighbor][j][k] for neighbor in [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 3
          priorities[i*N**2 + j*N + k][1] -= 3
        else:
          priorities[i*N**2 + j*N + k][0] -= 3
          priorities[i*N**2 + j*N + k][1] += 3
  return priorities


#score: {'data3D.txt': 0.08898740000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = 0
        for l in [0, 1]:
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
            site_nbrs.append(site_nbr)
        for neighbor in site_nbrs:
          total_spin += h[neighbor][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 2 * total_spin
          priorities[i*N**2 + j*N + k][1] -= 2 * total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 2 * total_spin
          priorities[i*N**2 + j*N + k][1] += 2 * total_spin
  return priorities


#score: {'data3D.txt': -0.0042806}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,i%N]
    
    total_spin = 0
    for d in range(6):
      site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.0010425999999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += J[0, site_nbr, i%N, i//N//N]
      priorities[i][1] -= J[0, site_nbr, i%N, i//N//N]
    else:
      priorities[i][0] -= J[3, site_nbr, i%N, i//N//N]
      priorities[i][1] += J[3, site_nbr, i%N, i//N//N]

  return(priorities)


#score: {'data3D.txt': -0.33041299999999973}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_parity = h[i][j][k]
        
        total_spin_x = [0, 0]
        total_spin_y = [0, 0]
        total_spin_z = [0, 0]
        
        for l in range(6):
          if l % 3 == 1:
            site_nbr = (i + ((l-1)%2 - 1)) % N
            interacting_spin = J[l, i, site_nbr, k]
            
            if h[site_nbr][j][k] * interacting_spin > 0:
              total_spin_x[0] += interacting_spin
            else:
              total_spin_x[1] -= interacting_spin
            
          elif l % 3 == 2:
            site_nbr = (i + ((l-2)%2 - 1)) % N
            interacting_spin = J[l, i, j, k]
            
            if h[i][site_nbr][k] * interacting_spin > 0:
              total_spin_y[0] += interacting_spin
            else:
              total_spin_y[1] -= interacting_spin
            
          elif l % 3 == 0:
            site_nbr = (i + ((l-0)%2 - 1)) % N
            interacting_spin = J[l, i, j, k]
            
            if h[i][j][site_nbr] * interacting_spin > 0:
              total_spin_z[0] += interacting_spin
            else:
              total_spin_z[1] -= interacting_spin
        
        priorities[i*N*N + j*N + k][0] = (total_spin_x[0] + total_spin_y[0] + total_spin_z[0])
        priorities[i*N*N + j*N + k][1] = -((total_spin_x[1] + total_spin_y[1] + total_spin_z[1]))
        
        if site_parity > 0:
          priorities[i*N*N + j*N + k][0] += 2
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 2
  
  return priorities


#score: {'data3D.txt': -0.0614198}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = []
        for axis in range(6):
          if axis < 3:
            site_nbr = (i + ((axis-1)%2 - 1)) % N
          else:
            site_nbr = (i + ((axis-4)%2 - 1)) % N
          interacting_spin = J[axis][i][j][k]
          total_spin += interacting_spin * h[site_nbr][j][k]
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spin
        priorities[i*N*N + j*N + k][0] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.30622220000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[axis][i][j][k]*h[site_nbr][j][k] for axis in range(6)]
        interacting_spins_sum = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= interacting_spins_sum - 1
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = -interacting_spins_sum + 1
  return(priorities)


#score: {'data3D.txt': -0.32435260000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = []
        for axis in range(6):
          if axis < 3:
            site = (i + ((axis-1)%2 - 1)) % N
          else:
            site = (i + ((axis-4)%2 - 1)) % N
          interacting_spin = J[axis][i][j][k]
          total_spin += interacting_spin * h[site][j][k]
          if h[site][j][k] > 0:
            priorities[i*N*N + j*N + k][0] += 1
            priorities[i*N*N + j*N + k][1] -= interacting_spin
          else:
            priorities[i*N*N + j*N + k][0] -= 1
            priorities[i*N*N + j*N + k][1] += interacting_spin
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((axis-1)%2 - 1)) % N for axis in range(6)]])
        if total_spin > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= sum([J[axis][i][j][k] for axis in range(6)])
        else:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] = -sum([J[axis][i][j][k] for axis in range(6)])
  return(priorities)


#score: {'data3D.txt': -0.13040300000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin0 = 0
        total_spin1 = 0
        
        # Calculate spin-spin interaction
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if l < 3:
            interacting_spin0 = J[l, i, site_nbr, k]
            interacting_spin1 = J[l, i, j, site_nbr]
          else:
            interacting_spin0 = J[l-3, i, j, site_nbr]
            interacting_spin1 = -J[l-3, i, site_nbr, k]
            
          total_spin0 += h[site_nbr][j][k] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin1 += h[site_nbr][j][k] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
        
        # Calculate magnetism
        site_parity = h[i][j][k]
        total_spin0 += site_parity
        total_spin1 = -total_spin0
        
        priorities[i*N*N + j*N + k][0] = total_spin0
        priorities[i*N*N + j*N + k][1] = total_spin1
  
  return priorities


#score: {'data3D.txt': 0.0033825999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin0 = 0
        total_spin1 = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if l < 3:
            interacting_spin0 = J[l, i, site_nbr, k]
            interacting_spin1 = J[l, i, j, site_nbr]
          else:
            interacting_spin0 = J[l-3, i, j, site_nbr]
            interacting_spin1 = -J[l-3, i, site_nbr, k]
          
          total_spin0 += h[site_nbr][j][k] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin1 += h[site_nbr][j][k] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
        
        priorities[i*N*N + j*N + k][0] = total_spin0
        priorities[i*N*N + j*N + k][1] = total_spin1
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin0 = 0
        total_spin1 = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if l < 3:
            interacting_spin0 = J[l, i, site_nbr, k]
            interacting_spin1 = J[l, i, j, site_nbr]
          else:
            interacting_spin0 = J[l-3, i, j, site_nbr]
            interacting_spin1 = -J[l-3, i, site_nbr, k]
            
          total_spin0 += h[site_nbr][j][k] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin1 += h[site_nbr][j][k] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
        
        for side in [(0, 1), (2, 3)]:
          site_nbr = (i + ((side[1]-1)%2 - 1)) % N
          
          interacting_spin0 = J[5, i, j, site_nbr] if h[i][j][site_nbr] > 0 else -J[5, i, j, site_nbr]
          interacting_spin1 = J[5, i, j, site_nbr] if h[i][j][site_nbr] < 0 else -J[5, i, j, site_nbr]
          
          total_spin0 += h[i][j][site_nbr] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin1 += h[i][j][site_nbr] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
        
        priorities[i*N*N + j*N + k][0] = np.sign(total_spin0) if abs(total_spin0) >= abs(total_spin1) else np.sign(total_spin1)
        priorities[i*N*N + j*N + k][1] = np.sign(total_spin1) if abs(total_spin0) < abs(total_spin1) else np.sign(total_spin0)
  
  return priorities


#score: {'data3D.txt': 0.009630199999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin0 = [0, 0]
        total_spin1 = [0, 0]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          interacting_spin0 = J[l, i, site_nbr, k]
          interacting_spin1 = J[l, i, j, site_nbr]
          
          if h[site_nbr][j][k] * interacting_spin0 > 0:
            total_spin0[0] += interacting_spin0
            total_spin0[1] -= interacting_spin0
          else:
            total_spin0[0] -= interacting_spin0
            total_spin0[1] += interacting_spin0
          
          if h[i][site_nbr][k] * interacting_spin1 > 0:
            total_spin1[0] += interacting_spin1
            total_spin1[1] -= interacting_spin1
          else:
            total_spin1[0] -= interacting_spin1
            total_spin1[1] += interacting_spin1
        
        for side in [(0, 1), (2, 3)]:
          site_nbr = (i + ((side[1]-1)%2 - 1)) % N
          
          interacting_spin0 = J[5, i, j, site_nbr] if h[i][j][site_nbr] > 0 else -J[5, i, j, site_nbr]
          interacting_spin1 = J[5, i, j, site_nbr] if h[i][j][site_nbr] < 0 else -J[5, i, j, site_nbr]
          
          total_spin0[0] += h[i][j][site_nbr] * (interacting_spin0 > 0) - (interacting_spin0 < 0)
          total_spin0[1] = total_spin1[0] = total_spin1[1] = 0
          
          total_spin1[0] += h[i][j][site_nbr] * (interacting_spin1 > 0) - (interacting_spin1 < 0)
          total_spin1[1] = total_spin0[0] = total_spin0[1] = 0
        
        priorities[i*N*N + j*N + k][0] = sum(total_spin0)
        priorities[i*N*N + j*N + k][1] = sum(total_spin1)
  
  return priorities


#score: {'data3D.txt': -0.06621580000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1 * total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.12753020000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 1 + total_spin
          priorities[i*N*N + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 1 + total_spin
          priorities[i*N*N + j*N + k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0042806}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,i%N]
    
    total_spin = 0
    for d in range(6):
      site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)


#score: {'data3D.txt': -0.0015362}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  site_nbrs = [(i//N)%N,(i%N)//N,i%N]
  total_spin = h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
  
  for d in range(6):
    if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      total_spin += interacting_spins[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    else:
      total_spin -= interacting_spins[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    
    if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0350198}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for axis in [0, 1]:
          site_nbr1 = (i + ((axis-1)%2 - 1)) % N
          if h[site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          priorities[i*N**2 + j + k*N][0] += total_spin
        site_nbr = (i + ((2-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2 + j + k*N][0] += 1
          priorities[i*N**2 + j + k*N][1] -= 1
        else:
          priorities[i*N**2 + j + k*N][0] -= 1
          priorities[i*N**2 + j + k*N][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.001803}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        site_nbr4 = (j + ((0-1)%2 - 1)) % N
        site_nbr5 = (k + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr1][i][j] + h[site_nbr2][i][j] + h[site_nbr3][i][j] +\
            h[i][site_nbr4][j] + h[site_nbr1][i][k] + h[site_nbr2][i][k] + h[site_nbr3][i][k] +\
            J[0, i, j, k] * (h[site_nbr1][i][j] - 0.5) + J[1, i, j, k] * (h[i][site_nbr4][j] - 0.5) +\
            J[2, i, j, k] * (h[site_nbr1][i][k] - 0.5) + J[3, i, j, k] * (h[site_nbr2][i][k] - 0.5) +\
            J[4, i, j, k] * (h[site_nbr3][i][k] - 0.5) + J[5, i, j, k] * (h[i][site_nbr4][j] - 0.5)
        if h[i][j][k] > 0:
          priorities[i*N**2 + j + k*N][0] += total_spin
          priorities[i*N**2 + j + k*N][1] -= total_spin
        else:
          priorities[i*N**2 + j + k*N][0] -= total_spin
          priorities[i*N**2 + j + k*N][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.022105800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        site_nbr4 = (j + ((0-1)%2 - 1)) % N
        site_nbr5 = (k + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr1][i][j] + h[site_nbr2][i][j] + h[site_nbr3][i][j] +\
                h[i][site_nbr4][j] + h[site_nbr1][i][k] + h[site_nbr2][i][k] + h[site_nbr3][i][k] +\
                J[0, i, j, k] * (h[site_nbr1][i][j] - 0.5) + J[1, i, j, k] * (h[i][site_nbr4][j] - 0.5) +\
                J[2, i, j, k] * (h[site_nbr1][i][k] - 0.5) + J[3, i, j, k] * (h[site_nbr2][i][k] - 0.5) +\
                J[4, i, j, k] * (h[site_nbr3][i][k] - 0.5) + J[5, i, j, k] * (h[i][site_nbr4][j] - 0.5)
        priority_total = [total_spin, -total_spin]
        if total_spin > 0:
          priorities[i*N**2 + j + k*N] = [1, 0]
        elif total_spin < 0:
          priorities[i*N**2 + j + k*N] = [0, 1]
        else:
          priorities[i*N**2 + j + k*N] = [0.5, 0.5]
  return(priorities)


#score: {'data3D.txt': -0.022105800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((0-1)%2 - 1)) % N
        site_nbr2 = (i + ((1-1)%2 - 1)) % N
        site_nbr3 = (i + ((2-1)%2 - 1)) % N
        site_nbr4 = (j + ((0-1)%2 - 1)) % N
        site_nbr5 = (k + ((0-1)%2 - 1)) % N
        total_spin = h[site_nbr1][i][j] + h[site_nbr2][i][j] + h[site_nbr3][i][j] +\
            h[i][site_nbr4][j] + h[site_nbr1][i][k] + h[site_nbr2][i][k] + h[site_nbr3][i][k] +\
            J[0, i, j, k] * (h[site_nbr1][i][j] - 0.5) + J[1, i, j, k] * (h[i][site_nbr4][j] - 0.5) +\
            J[2, i, j, k] * (h[site_nbr1][i][k] - 0.5) + J[3, i, j, k] * (h[site_nbr2][i][k] - 0.5) +\
            J[4, i, j, k] * (h[site_nbr3][i][k] - 0.5) + J[5, i, j, k] * (h[i][site_nbr4][j] - 0.5)
        priority_total = [total_spin, -total_spin]
        priorities[i*N**2 + j + k*N] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.20603380000000032}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin
          priorities[i*N*N + j*N + k][1] -= 3 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 3 + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3295713999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 2 * (sum([i >= 3 or i <= -3 for i in interacting_spins]) + abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * (sum([i >= 3 or i <= -3 for i in interacting_spins]) + abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.12928060000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 2 * total_spin
          priorities[i*N*N + j*N + k][1] -= 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 2 * total_spin
          priorities[i*N*N + j*N + k][1] = -2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.1258590000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [h[site_nbr][j][k], 
                   h[i][(j+1)%N][k], 
                   h[i][j][(k+1)%N],
                   h[(i+1)%N][j][k], 
                   h[i][(j-1)%N][k], 
                   h[i][j][(k-1)%N]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += 2 + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= 2 + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.400033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(h[i][j][k])
        if J[0][i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        for l in range(3):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l+1][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 2
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 2
  return priorities


#score: {'data3D.txt': -0.3383158000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                             J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.18821899999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin[0]
          priorities[i*N**2 + j*N + k][1] = -total_spin[0]
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin[0]
          priorities[i*N**2 + j*N + k][1] = -total_spin[0]
  
  return priorities


#score: {'data3D.txt': 0.286661}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = [np.roll(h, -1, axis=i) if i < 3 else np.roll(h, 1, axis=i-3) for i in range(6)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        if J[1,i,j,k] > 0:
          total_spin += h[(i+1)%N][j]
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        elif J[1,i,j,k] < 0:
          total_spin -= h[(i+1)%N][j]
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1
        if J[2,i,j,k] > 0:
          total_spin += h[i][(j+1)%N]
          priorities[i*N*N + j*N + k][0] += 1
          priorities[i*N*N + j*N + k][1] -= 1
        elif J[2,i,j,k] < 0:
          total_spin -= h[i][(j+1)%N]
          priorities[i*N*N + j*N + k][0] -= 1
          priorities[i*N*N + j*N + k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.19987140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = 0
        for l in range(6):
          if (l == 0 and ((i < N-1) | (j < N-1) | (k < N-1))):
            interacting_spins += J[l,i,j,k]
          elif (l == 1 and ((i > 0) | (j < N-1) | (k < N-1))):
            interacting_spins += J[l,i,j,k]
          elif (l == 2 and ((i > 0) | (j > 0) | (k < N-1))):
            interacting_spins += J[l,i,j,k]
          elif (l == 3 and ((i < N-1) | (j > 0) | (k < N-1))):
            interacting_spins += J[l,i,j,k]
          elif (l == 4 and ((i < N-1) | (j < N-1) | (k > 0))):
            interacting_spins += J[l,i,j,k]
          else:
            interacting_spins -= J[l,i,j,k]
        priorities[i,j,k,0] = -interacting_spins
        priorities[i,j,k,1] = -priorities[i,j,k,0]
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.118309}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = 0
        for l in range(6):
          if (l == 0 and ((i+1)%N != j or (k+1)%N != 0)):
            interacting_spins += J[l,i,j,k]
          elif (l == 1 and ((i-1)%N != j or (k+1)%N != 0)):
            interacting_spins -= J[l,i,j,k]
          elif (l == 2 and ((j+1)%N != i or (k+1)%N != 0)):
            interacting_spins += J[l,i,j,k]
          elif (l == 3 and ((j-1)%N != i or (k+1)%N != 0)):
            interacting_spins -= J[l,i,j,k]
          elif (l == 4 and ((i+1)%N != k or (j+1)%N != 0)):
            interacting_spins += J[l,i,j,k]
          else:
            interacting_spins -= J[l,i,j,k]
        priorities[i,j,k,0] = -interacting_spins
        priorities[i,j,k,1] = interacting_spins
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.4282590000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                             J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin

  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i*N**2 + j*N + k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
            if J[l,i,j,k] > 0:
              priorities[i*N**2 + j*N + k][1] -= 1
            else:
              priorities[i*N**2 + j*N + k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.0010898000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    total_spin = 0
    for j in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[j][site_nbr][i%N][i//N//N] > 0:
        total_spin += h[site_nbr][i%N][i//N//N]
      else:
        total_spin -= h[site_nbr][i%N][i//N//N]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0019085999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in [0, 4]:
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        priorities[i*N+j*N+k][0] = total_spin
        priorities[i*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += J[l, site_nbr, j, k]
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.004035399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = 0
    for k in range(3):
      site = (i % N + ((k-1)%2 - 1)) % N
      interacting_spins += J[k, site_nbr, i%N, i//N//N] * h[site][i%N][i//N//N]
    if h[site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.3380154000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = np.zeros((N, N, N))
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                             J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          interacting_spins[(site_nbr + ((0-1)%2 - 1)) % N, site_nbr%N, k] += J_val
        for site_nbr in range(6):
          total_spin += h[site_nbr][j][k]
          if J[site_nbr][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.27671940000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = np.roll(h, -1, axis=0)[i][j] if i > 0 else h[i][j]
        interacting_spins += np.roll(h, 1, axis=0)[i+1 if i < N-1 else i][j]
        interacting_spins += np.roll(np.roll(h, -1, axis=1), 0, axis=2)[i][j][k] if k > 0 else h[i][j][k]
        interacting_spins += np.roll(np.roll(h, 1, axis=1), 0, axis=2)[i+1 if i < N-1 else i][j][k]
        interacting_spins += np.roll(np.roll(np.roll(h, -1, axis=2), 0, axis=1), 0, axis=0)[i][j][k] if j > 0 else h[i][j][k]
        interacting_spins += np.roll(np.roll(np.roll(h, 1, axis=2), 0, axis=1), 0, axis=0)[i+1 if i < N-1 else i][j][k]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': 0.22906940000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        h_sum = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        J_sum = sum(J[l,i,j,k]*(h[site_nbr][j][k] > 0) for l, site_nbr in zip(range(6), site_nbrs))
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += h_sum
          priorities[i*N**2 + j*N + k][1] -= J_sum - h_sum
        else:
          priorities[i*N**2 + j*N + k][0] -= h_sum
          priorities[i*N**2 + j*N + k][1] = J_sum - h_sum
  return priorities


#score: {'data3D.txt': -0.1960806000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          if h[site_nbr][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.0019617999999999997}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((i-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          if J[l, i, j, k] > 0:
            total_spin += h[site_nbr_i][site_nbr_j][site_nbr_k]
          else:
            total_spin -= h[site_nbr_i][site_nbr_j][site_nbr_k]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.30508820000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        for site_nbr, J_val in zip([(i + ((l-1)%2 - 1)) % N for l in range(6)], [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                       J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.229065}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = []
        for site_nbr in site_nbrs:
          interacting_spins.append(h[site_nbr][j][k])
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0])
        total_spin = h[i][j][k]
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': 0.0480278}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = 0
        interacting_spins = 0
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                          J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            interacting_spins += 1
          else:
            interacting_spins -= 1
        total_spin += h[i][j][k]
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] = -total_spin
          priorities[i*N**2 + j*N + k][1] = 1
        else:
          priorities[i*N**2 + j*N + k][0] = 1
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.0017634000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N]
        for d in range(6):
          if J[d][site_nbrs[d%2]][j][k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d][site_nbrs[d%2]][j][k] < 0:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0017966000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i+1)%N,i,(i-1)%N]
        for d in range(6):
          if J[d][site_nbrs[d%3]][j][k] > 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d][site_nbrs[d%3]][j][k] < 0:
            total_spin += h[site_nbrs[d%3]][j]
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.4282590000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i*N**2 + j*N + k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          if J[l,i,j,k] > 0:
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.2758302}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        h_sum = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        for J_val in [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
               J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]:
          total_spin += h_sum
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin

  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i*N**2 + j*N + k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          if J[l,i,j,k] > 0:
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.4144402}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1

        total_spin += h[i][j][k]
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        for l in range(6):
          priorities[i*N**2 + j*N + k][0] += -J[l, i, j, k] * interacting_spins[l, i, j, k]
          if J[l, i, j, k] > 0:
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][1] += 1

        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.004375400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(i//N+((k-1)%2 - 1))%N][site_nbrs[1]][site_nbrs[2]] for l,k in zip(range(6),range(3))])
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i] = [interacting_spins_sum, -1]
    else:
      priorities[i] = [-interacting_spins_sum, 1]
  return(priorities)


#score: {'data3D.txt': -0.0026954}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.1960806000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          if h[site_nbr][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1 + total_spin
          priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
          priorities[i*N**2 + j*N + k][1] = -1 + total_spin
  return priorities


#score: {'data3D.txt': -0.0026494000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for l,site_nbr in enumerate(site_nbr_list):
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        priority_total = [total_spin, -2*total_spin]
        priorities[i*N*N+j*N+k] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.0013194000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = []
        for l in range(6):
          if (l % 2 == 0): 
            site_nbr = ((i + ((l-1)%3 - 1)) % N, j, k)
            site_nbrs.append(site_nbr)
          else:
            site_nbr = ((i + ((l-4)%3 - 1)) % N, j, k)
            site_nbrs.append(site_nbr)
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
          if J[l,i,j,k] > 0:
            total_spin -= 2
          else:
            total_spin += 2
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    total_spin = 0
    site_nbr = (i // N**(2), i % N**(2) // N, (i % N**(2)) % N)
    for k in range(6):
      if J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin += interacting_spins[k][site_nbr[0]][site_nbr[1]][site_nbr[2]]
      else:
        total_spin -= interacting_spins[k][site_nbr[0]][site_nbr[1]][site_nbr[2]]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] = float('-inf')
    else:
      priorities[i][0] = float('-inf')
      priorities[i][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.229065}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += sum(spin > 0 for spin in interacting_spins)
          priorities[i*N**2 + j*N + k][1] -= sum(spin < 0 for spin in interacting_spins)
        else:
          priorities[i*N**2 + j*N + k][0] -= sum(spin > 0 for spin in interacting_spins)
          priorities[i*N**2 + j*N + k][1] += sum(spin < 0 for spin in interacting_spins)
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.228707}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = h[i][j][k]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0])
  return priorities


#score: {'data3D.txt': -0.229065}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = h[i][j][k]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0])
        total_spin += np.sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.03446380000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += np.count_nonzero([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] -= np.count_nonzero([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.count_nonzero([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] += np.count_nonzero([spin for spin in interacting_spins if spin < 0])
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = -1
  return priorities


#score: {'data3D.txt': -0.0029742}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
  total_spin = np.zeros((N,N,N,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][1] += 1

  for i in range(N**3):
    site_nbrs = site_nbrs_map
    interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += interacting_spins_sum
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= interacting_spins_sum
      priorities[i][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0028450000000000007}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
  
  for i in range(N**3):
    site_nbrs = site_nbrs_map
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] += -sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.003026599999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif J[0,i%N,i//N,i%N] < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.009413}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif J[0,i%N,i//N,i%N] < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  for i in range(N**3):
    for j in range(6):
      if J[j, i // (N ** 2), i % N, i % N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      elif J[j, i // (N ** 2), i % N, i % N] < 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.0074942}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N,i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      elif J[k,i%N,i//N,i%N] < 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k]*interacting_spins[l,i,j,k]>0:
            priorities[i,j,k,0] += J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i,j,k,1] -= J[l,i,j,k]*interacting_spins[l,i,j,k]
          else:
            priorities[i,j,k,0] -= J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i,j,k,1] += J[l,i,j,k]*interacting_spins[l,i,j,k]
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.1960806000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if h[(i + ((l-1)%2 - 1)) % N][j][k] > 0:
            priorities[i*N*N+j*N+k, 0] += 1
            priorities[i*N*N+j*N+k, 1] -= 1
          else:
            priorities[i*N*N+j*N+k, 0] -= 1
            priorities[i*N*N+j*N+k, 1] += 1

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr_list = [(i + ((m-1)%2 - 1)) % N for m in [0, 4, 8]]
          if J[l,i,j,k] > 0:
            for site_nbr in site_nbr_list:
              total_spin += h[site_nbr][j][k]
          else:
            for site_nbr in site_nbr_list:
              total_spin -= h[site_nbr][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        for site_nbr in site_nbr_list:
          total_spin += J[0,i,j,k]*(h[site_nbr][j][k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3

  return(priorities)


#score: {'data3D.txt': -0.1164414000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] -= 2*np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] += 2*np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
   for j in range(N):
    for k in range(N):
     total_spin = 0
     site_nbr = (i, j, k)
     for l in range(6):
      if J[l][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin += interacting_spins[l][site_nbr[0]][site_nbr[1]][site_nbr[2]]
      else:
        total_spin -= interacting_spins[l][site_nbr[0]][site_nbr[1]][site_nbr[2]]

     if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
       priorities[i*N*N + j*N + k][0] += -total_spin
       priorities[i*N*N + j*N + k][1] = float('-inf')
     else:
       priorities[i*N*N + j*N + k][0] = float('-inf')
       priorities[i*N*N + j*N + k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': 0.0020118000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0,1,2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==0)*N+(d==1)*N+(d==2)*6]]
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.22557780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 3
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 3

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        total_magnet = h[i][j][k]
        for x in range(-1,2):
          for y in range(-1,2):
            for z in range(-1,2):
              if abs(x) + abs(y) + abs(z) > 0:
                site_nbr = (i + x)%N
                site_nbr2 = (j + y)%N
                site_nbr3 = (k + z)%N
                total_spin += J[4,i,j,k]*h[site_nbr][site_nbr2][site_nbr3]
                if h[i][j][k] > 0:
                  priorities[i*N*N+j*N+k][0] += 1
                  priorities[i*N*N+j*N+k][1] -= 2
                else:
                  priorities[i*N*N+j*N+k][0] -= 1
                  priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': 0.2198758}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
          total_spin = sum(J[0,i,j,k] for site_nbr in site_nbr_list)
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
          total_spin = sum(-J[0,i,j,k] for site_nbr in site_nbr_list)
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.0031590000000000008}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
  
  for i in range(N**3):
    site_nbrs = site_nbrs_map
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] += -sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1

  # Sort the sites by their priorities
  sorted_indices = np.argsort([priorities[j][0] + (priorities[j][1]) * N**3 for j in range(N**3)])

  # Create a new list of priorities and spins with the correct order
  final_priorities = [[0, 0] for _ in range(N**3)]
  for i, idx in enumerate(sorted_indices):
    if h[site_nbrs_map[0]][site_nbrs_map[1]][site_nbrs_map[2]] > 0:
      final_priorities[idx][0] += priorities[i][0]
      final_priorities[idx][1] -= 1
    else:
      final_priorities[idx][0] += -priorities[i][0]
      final_priorities[idx][1] += 1

  return(final_priorities)


#score: {'data3D.txt': -0.0019086}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]

  for i in range(N**3):
    site_nbrs = site_nbrs_map
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] += -sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1

    # Add additional interactions
    if i < N**3 - N**2:
      site_nbrs[0] = (i//N + ((i%N-1)%N)) % N
      site_nbrs[1] = (i%N)//N
      site_nbrs[2] = i%N % N
    if i < N**3 - 2*N:
      site_nbrs[0] = (i//N + ((i%N-1)%N)) % N
      site_nbrs[1] = (i%N)//N
      site_nbrs[2] = (i%N)%N
    if i < N**3 - 1:
      site_nbrs[0] = (i//N + ((i%N-1)%N)) % N
      site_nbrs[1] = (i%N)//N
      site_nbrs[2] = (i//N)%N

    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] += -sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.31033659999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = np.zeros((N, N, N))
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                         J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          interacting_spins[(site_nbr + ((0-1)%2 - 1)) % N, site_nbr%N, k] += J_val
        for l in range(3):
          for m in [(l, 0), (l+1, 1)]:
            for n in [0, 1]:
              total_spin += h[m[0]][m[1]][k]
              if J[(n*2 + (m[0]+m[1])%2)%6][i][j][k] > 0:
                priorities[i*N**2 + j*N + k][0] += 1
                priorities[i*N**2 + j*N + k][1] -= 1
              else:
                priorities[i*N**2 + j*N + k][0] -= 1
                priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.0021978}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = np.zeros((N, N, N))
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          interacting_spins[(site_nbr + ((0-1)%2 - 1)) % N, site_nbr%N, k] += J_val
        for site_nbr in range(6):
          total_spin = sum([-J[site_nbr][i][j][k] * (h[site_nbr][j][k] if i == site_nbr else h[(site_nbr + ((0-1)%2 - 1)) % N][j][k]) for i in range(N)])
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  return priorities


#score: {'data3D.txt': -0.2499474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  total_spin = np.zeros((N, N, N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = np.zeros((N, N, N))
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          interacting_spins[(site_nbr + ((0-1)%2 - 1)) % N, site_nbr%N, k] += J_val
        for site_nbr in range(6):
          total_spin[i,j,k][0] += h[site_nbr][j][k]
          total_spin[i,j,k][1] -= h[site_nbr][j][k]
          if J[site_nbr][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.14636620000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.all([spin > 0 for spin in interacting_spins]):
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0])
        elif np.all([spin < 0 for spin in interacting_spins]):
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0])
        else:
          total_spin = np.sum(interacting_spins)
          if h[i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1 + total_spin
            priorities[i*N**2 + j*N + k][1] -= 1 - total_spin
          else:
            priorities[i*N**2 + j*N + k][0] -= 1 + total_spin
            priorities[i*N**2 + j*N + k][1] = -1 - total_spin
  return priorities


#score: {'data3D.txt': -0.03446380000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += np.count_nonzero([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] -= np.count_nonzero([spin for spin in interacting_spins if spin < 0])
        else:
          priorities[i*N**2 + j*N + k][0] -= np.count_nonzero([spin for spin in interacting_spins if spin > 0])
          priorities[i*N**2 + j*N + k][1] += np.count_nonzero([spin for spin in interacting_spins if spin < 0])
        if total_spin > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] = -1

  return priorities


#score: {'data3D.txt': -0.0017090000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
   site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
   
   total_spin = 0
   for d in range(6):
    site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
    
    if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
     total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
    else:
     total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
    
    if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
     priorities[k][0] += 1
     priorities[k][1] -= 1
    else:
     priorities[k][0] -= 1
     priorities[k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0022262000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if J[0, i, j, (i+j+N-1)%N] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j, (i+j+N-1)%N] < 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.002569}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for _ in range(3)]
        total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbrs = [(i + ((k-2)%2 - 1)) % N for _ in range(3)]
        total_spin += sum(h[site_nbr][j] for site_nbr in site_nbrs)
        if J[1, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

        site_nbrs = [(i + ((k-3)%2 - 1)) % N for _ in range(3)]
        total_spin += sum(h[site_nbr][j] for site_nbr in site_nbrs)
        if J[2, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[2, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0026494000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        
        priorities[i*N*N+j*N+k][0] = total_spin + h[i][j][k]
        priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] -= 2*np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] += 2*np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
  
  return(priorities)


#score: {'data3D.txt': 0.10772100000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        for m in range(6):
          if J[m][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr_m = (site_nbr + ((m-1)%2 - 1)) % N
          if h[site_nbr_m][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= total_spin
          priorities[i*N**2 + j*N + k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': -0.1565698000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            priorities[i*N**2 + j*N + k][0] += -J[l][i][j][k]
            priorities[i*N**2 + j*N + k][1] -= J[l][i][j][k]
          else:
            priorities[i*N**2 + j*N + k][0] -= J[l][i][j][k]
            priorities[i*N**2 + j*N + k][1] += J[l][i][j][k]
        
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N**2 + j*N + k][0] += total_spin
        priorities[i*N**2 + j*N + k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': -0.004617}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin[0] += 1
            total_spin[1] -= 1
          else:
            total_spin[0] -= 1
            total_spin[1] += 1
        
        priorities[i*N**2 + j*N + k][0] += total_spin[0]
        priorities[i*N**2 + j*N + k][1] = -total_spin[0]
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N**2 + j*N + k][0] += 1
          priorities[i*N**2 + j*N + k][1] -= 1
        else:
          priorities[i*N**2 + j*N + k][0] -= 1
          priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.0037210000000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_sum = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j), (k)]
        for l in range(6):
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin -= J[l][i][j][k]
          else:
            total_spin += J[l][i][j][k]
        interacting_spins_sum[i][j][k] = [total_spin, 1 if h[i][j][k] > 0 else -1]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] += total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0019617999999999997}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  # Calculate total magnetism and interaction at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
        
        # Check if the interaction is positive or negative
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.011328600000000001}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
  
  for i in range(N**2):
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    if J[0,i%N,i//N,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif J[0,i%N,i//N,i%N] < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0004990000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i%N][i//N] += h[site_nbr][i%N]
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0,i,j,k] > 0:
          priorities[k*N+i*N+j][0] += 1
          priorities[k*N+i*N+j][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[k*N+i*N+j][0] -= 1
          priorities[k*N+i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      
      if J[0,i,j,k] > 0:
        priorities[k*N+i*N+j][0] += 1
        priorities[k*N+i*N+j][1] -= 1
      elif J[0,i,j,k] < 0:
        priorities[k*N+i*N+j][0] -= 1
        priorities[k*N+i*N+j][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.3025646}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    total_spin = 0
    site_nbr = (i // N**(2), i % N**(2) // N, (i % N**(2)) % N)
    for k in range(6):
      if J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin += interacting_spins[k][site_nbr[0]][site_nbr[1]][site_nbr[2]]
      else:
        total_spin -= interacting_spins[k][site_nbr[0]][site_nbr[1]][site_nbr[2]]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] = float('-inf')
    else:
      priorities[i][0] = float('-inf')
      priorities[i][1] -= total_spin
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = 0
    for k in range(3):
      site = (i % N + ((k-1)%2 - 1)) % N
      interacting_spins += J[k, site_nbr, i%N, i//N//N] * h[site][i%N][i//N//N]
    if h[site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.00045340000000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = 0
    for k in range(6):
      if J[k][site_nbr][i%N][i//N//N] > 0:
        interacting_spins += h[(i+N*k)%N][i%N][i//N//N]
      else:
        interacting_spins -= h[(i+N*k)%N][i%N][i//N//N]
    if h[site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += interacting_spins + 1
      priorities[i][1] -= interacting_spins - 1
    else:
      priorities[i][0] -= interacting_spins + 1
      priorities[i][1] += interacting_spins - 1
  return(priorities)


#score: {'data3D.txt': -0.0014166}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = 0
    total_spin = 0
    for k in range(6):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      interacting_spins += J[k, site_nbr, i%N, i//N//N] * h[site][i%N][i//N//N]
      if h[site_nbr][i%N][i//N//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = -total_spin + interacting_spins
    priorities[i][1] = -priorities[i][0]
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] = -2*np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
        else:
          priorities[i*N*N+j*N+k][0] = -np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] = 2*np.sum(np.sign(J[site_nbr==i, i==j, k==k]))
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
          site_nbrs.append((site_nbr, np.sign(J[l,i,j,k])))
        for neighbor in set(site_nbrs):
          if neighbor[1] == 1:
            priorities[i*N*N+j*N+k][0] += sum([x[1] for x in site_nbrs if x[0]==neighbor[0]])
            priorities[i*N*N+j*N+k][1] -= 2*sum([x[1] for x in site_nbrs if x[0]==neighbor[0]])
          else:
            priorities[i*N*N+j*N+k][0] -= sum([x[1] for x in site_nbrs if x[0]==neighbor[0]])
            priorities[i*N*N+j*N+k][1] += 2*sum([x[1] for x in site_nbrs if x[0]==neighbor[0]])
  
  return(priorities)


#score: {'data3D.txt': 0.005770199999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(6):
      site = (i // N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N,i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      elif J[k,i%N,i//N,i%N] < 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.005770199999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][k%N]
    for l in range(6):
      if J[l,k%N,k//N,k%N] > 0:
        priorities[k][0] += 1
        priorities[k][1] -= 1
      elif J[l,k%N,k//N,k%N] < 0:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.263279}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        
        for nbr, val in zip(site_nbrs, J[:,i,j,k]):
          if val > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2754306000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_sum = np.sum(J[:,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.count_nonzero(np.array(J_sum) > 0)
          priorities[i*N*N+j*N+k][1] -= np.count_nonzero(np.array(J_sum) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.count_nonzero(np.array(J_sum) > 0)
          priorities[i*N*N+j*N+k][1] += np.count_nonzero(np.array(J_sum) < 0)
  
  return(priorities)


#score: {'data3D.txt': -0.0243098}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.sum(J_values)
          priorities[i*N*N+j*N+k][1] = -2*np.sum(J_values)
        else:
          priorities[i*N*N+j*N+k][0] = -np.sum(J_values)
          priorities[i*N*N+j*N+k][1] = 2*np.sum(J_values)
  
  return(priorities)


#score: {'data3D.txt': 0.0011917999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = 0
        total_spin = 0
        for m in range(6):
          site = (site_nbr + ((m-1)%2 - 1)) % N
          interacting_spins += J[m, site_nbr, i, j]
          if h[site][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i][j][k][0] = -total_spin + interacting_spins
        priorities[i][j][k][1] = -priorities[i][j][k][0]
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.001701}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_sum = sum([J[ll,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for ll in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0115366}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, j, k]
        interacting_spins_sum = sum([J[l][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] * h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j+k][0] += interacting_spins_sum
          priorities[i*N*N+j+k][1] -= 1
        else:
          priorities[i*N*N+j+k][0] -= interacting_spins_sum
          priorities[i*N*N+j+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0015230000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins_sum = np.zeros((N,N,N,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        
        for l in [0,1,2]:
          interacting_spins_sum[i][j][k][0] += J[l,i,j,k] * h[site_nbrs[0]][j][k]
          if J[l,i,j,k] > 0:
            site_nbrs.append((i + ((l-1)%2 - 1)) % N)
            interacting_spins_sum[i][j][k][1] -= 1
          else:
            site_nbrs.append((i + (l+1)%N - 1) % N)
            interacting_spins_sum[i][j][k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*k][0] += sum(interacting_spins_sum[i][j][k])
          priorities[i*N*N+j*k][1] -= 1
        else:
          priorities[i*N*N+j*k][0] -= sum(interacting_spins_sum[i][j][k])
          priorities[i*N*N+j*k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0013194000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        for l in range(6):
          if (l % 2 == 0): 
            site_nbr = ((i + ((l-1)%2 - 1)) % N, j, k)
            site_nbrs.append(site_nbr)
          else:
            site_nbr = ((i + ((l-4)%2 - 1)) % N, j, k)
            site_nbrs.append(site_nbr)
        total_spin = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
          if J[l,i,j,k] > 0:
            total_spin -= 2
          else:
            total_spin += 2
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3
  return(priorities)


#score: {'data3D.txt': 0.2582586}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = []
        for l in range(6):
          if (l % 2 == 0): 
            site_nbr = ((i + ((l-1)%3 - 1)) % N, j, k)
            site_nbrs.append(site_nbr)
          else:
            site_nbr = ((i + ((l-4)%3 - 1)) % N, j, k)
            site_nbrs.append(site_nbr)
        total_spin = sum(h[site[0]][site[1]][site[2]] for site in site_nbrs)
        if sum(J[l,i,j,k] for l in range(6) if J[l,i,j,k] > 0) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 3
  
  return(priorities)


#score: {'data3D.txt': -0.16641140000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[3,i,j,k] > 0:
            total_spin -= J[3,i,j,k]
          else:
            total_spin += J[3,i,j,k]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if J[0,i,j,k] > 0:
          total_spin += J[0,i,j,k]
        else:
          total_spin -= J[0,i,j,k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin -= 1
          else:
            total_spin += 1

        if total_spin > N**2:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2*(N+1)
        elif total_spin < -N**2:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2*(N+1)
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i // N**(2), i % N**(2) // N, (i % N**(2)) % N)
    total_spin = 0
    for k in range(6):
      if J[k][site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
        total_spin += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
      else:
        total_spin -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    if h[site_nbr[0]][site_nbr[1]][site_nbr[2]] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] = float('-inf')
    else:
      priorities[i][0] = float('-inf')
      priorities[i][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': -0.0028054}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[1, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[2, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[2, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[4, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[4, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0013258}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[1, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0028054}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[0, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[1, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[2, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[2, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[4, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[4, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.001701}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins_sum = [0] * (N ** 3)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spin_sum = sum([J[ll,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for ll in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spin_sum
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= interacting_spin_sum
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0017902000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_sum = sum([J[ll,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for ll in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= sum([abs(h[site_nbrs[ll]][j][k]) for ll in range(6)])
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += sum([abs(h[site_nbrs[ll]][j][k]) for ll in range(6)])
  return(priorities)


#score: {'data3D.txt': -0.16510780000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        
        for nbr, val in zip(site_nbrs, J[:,i,j,k]):
          if val > 0:
            total_spin += h[nbr][j][k]
          else:
            total_spin -= h[nbr][j][k]
        
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.16510780000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        
        total_spin = 0
        for nbr, val in zip(site_nbrs, J[:,i,j,k]):
          if val > 0:
            total_spin += h[nbr][j][k]
          else:
            total_spin -= h[nbr][j][k]

        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin

  return(priorities)


#score: {'data3D.txt': -0.0015262}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
  
  total_spin = np.zeros((N,N,N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin[i][j] += h[k][i][j]
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i%N][i//N] += h[site_nbr][i%N]
    
  for k in range(6):
    for i in range(N):
      for j in range(N):
        if J[k,i,j,0] > 0:
          priorities[k*N+i*N+j][0] += 1
          priorities[k*N+i*N+j][1] -= 1
        elif J[k,i,j,0] < 0:
          priorities[k*N+i*N+j][0] -= 1
          priorities[k*N+i*N+j][1] += 1
          
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      
      if J[0,i,j,0] > 0:
        priorities[k*N+i*N+j][0] += 1
        priorities[k*N+i*N+j][1] -= 1
      elif J[0,i,j,0] < 0:
        priorities[k*N+i*N+j][0] -= 1
        priorities[k*N+i*N+j][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.1164414000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        total_spin = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin += J[0,i,j,k]
          else:
            total_spin -= J[0,i,j,k]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

        for d in [1, 2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==1)*N+(d==2)*6]]
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]

          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.32790339999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = []
        for d in [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]:
          site_nbr_list.append((d, j, k))
        for (site_i, j, k) in site_nbr_list:
          total_spin += h[site_i][j][k]
        if J[0, i, j, k] > 0:
          total_spin -= 1
        else:
          total_spin += 1
        
        priorities[i*N*N+j*N+k][0] = total_spin
        priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.00036019999999999927}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        for d in [0]:
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.0020118000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0,1,2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==0)*N+(d==1)*N+(d==2)*6]]
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][0] = int(np.sign(total_spin))
        priorities[i*N*N+j*N+k][1] = 1 - abs(int(np.sign(total_spin)))
  return(priorities)


#score: {'data3D.txt': -1.8000000000000238e-06}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': 0.13656540000000011}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = np.zeros((N, N, N))
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          interacting_spins[(site_nbr + ((0-1)%2 - 1)) % N, site_nbr%N, k] += J_val
        for l in range(3):
          for m in [(l, 0), (l+1, 1)]:
            for n in [0, 1]:
              total_spin += h[m[0]][m[1]][k]
              if J[(n*2 + (m[0]+m[1])%2)%6][i][j][k] > 0:
                priorities[i*N**2 + j*N + k][0] += 1
                priorities[i*N**2 + j*N + k][1] -= 1
              else:
                priorities[i*N**2 + j*N + k][0] -= 1
                priorities[i*N**2 + j*N + k][1] += 1
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N**2 + j*N + k][0] = -total_spin
        priorities[i*N**2 + j*N + k][1] = total_spin
  return priorities


#score: {'data3D.txt': 0.11867460000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if h[site_nbr][j][k] > 0:
            total_spin += J[l, i, j, k]
          else:
            total_spin -= J[l, i, j, k]
        priorities[i*N*N+j*N+k, 0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k, 1] += 1
        else:
          priorities[i*N*N+j*N+k, 1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.1655422000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          if J[l,i,j,k] > 0:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k, 0] += 1
              priorities[i*N*N+j*N+k, 1] -= 1
            else:
              priorities[i*N*N+j*N+k, 0] -= 1
              priorities[i*N*N+j*N+k, 1] += 1
          elif J[l,i,j,k] < 0:
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k, 0] -= 1
              priorities[i*N*N+j*N+k, 1] += 1
            else:
              priorities[i*N*N+j*N+k, 0] += 1
              priorities[i*N*N+j*N+k, 1] -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k, 0] += 1
          priorities[i*N*N+j*N+k, 1] -= 1
        else:
          priorities[i*N*N+j*N+k, 0] -= 1
          priorities[i*N*N+j*N+k, 1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = h[i][j][k]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0]) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0]) - np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0]) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0]) - np.count_nonzero(np.array(interacting_spins) > 0)

        return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in [(i + ((l-1)%2 - 1)) % N for l in range(6)]]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0]) * (np.sum(interacting_spins) / len(interacting_spins))
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0]) * (np.sum(interacting_spins) / len(interacting_spins))
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0]) * (np.sum(interacting_spins) / len(interacting_spins))
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0]) * (np.sum(interacting_spins) / len(interacting_spins))
  return priorities


#score: {'data3D.txt': -0.228707}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0]) + total_spin
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0]) - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0]) - total_spin
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0]) + total_spin
  return priorities


#score: {'data3D.txt': -0.3278594}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        total_spin = h[i][j][k]
        interacting_spins = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        if np.sum(interacting_spins) > 0:
          priorities[i*N**2 + j*N + k][0] += len([spin for spin in interacting_spins if spin > 0]) + total_spin
          priorities[i*N**2 + j*N + k][1] -= len([spin for spin in interacting_spins if spin < 0]) - total_spin
        else:
          priorities[i*N**2 + j*N + k][0] -= len([spin for spin in interacting_spins if spin > 0]) + total_spin
          priorities[i*N**2 + j*N + k][1] += len([spin for spin in interacting_spins if spin < 0]) - total_spin
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
        for site_nbr, J_val in zip(site_nbrs, [J[0][i][j][k], J[1][i][j][k], J[2][i][j][k],
                           J[3][i][j][k], J[4][i][j][k], J[5][i][j][k]]):
          total_spin += h[site_nbr][j][k]
          if J_val > 0:
            priorities[i*N**2 + j*N + k][0] += 1
            priorities[i*N**2 + j*N + k][1] -= 1
          else:
            priorities[i*N**2 + j*N + k][0] -= 1
            priorities[i*N**2 + j*N + k][1] += 1
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N, (i + ((i-1)%2 - 1)) % N]
        total_spin = np.sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N, N, N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][k][0] += J[0, site_nbr, j, k]
        total_spin[i][j][k][1] -= J[0, site_nbr, j, k]
        if h[site_nbr][j][k] > 0:
          total_spin[i][j][k][0] += 1
          total_spin[i][j][k][1] -= 1
        else:
          total_spin[i][j][k][0] -= 1
          total_spin[i][j][k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] = total_spin[i][j][k][0]
        priorities[i*N*N+j*N+k][1] = -total_spin[i][j][k][1]

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N*N*N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l, ((i + ((k-1)%2 - 1)) % N), j, k] for l in range(6) if h[((i + ((k-1)%2 - 1)) % N)][j][k] * J[l, ((i + ((k-1)%2 - 1)) % N), j, k] > 0)
        if sum(J[l, ((i + ((k-1)%2 - 1)) % N), j, k] for l in range(6) if h[((i + ((k-1)%2 - 1)) % N)][j][k] * J[l, ((i + ((k-1)%2 - 1)) % N), j, k] > 0) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': 0.0010042000000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin = sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

        site_nbrs = [(j + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[i][site_nbr,k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        site_nbrs = [(j + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[i][site_nbr,k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

        site_nbrs = [(k + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[i][j][site_nbr] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        site_nbrs = [(k + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[i][j][site_nbr] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0023266000000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  site_nbrs = [(i//N)%N,(i%N)//N,i%N]
  total_spin = h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
  
  for d in range(6):
    if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      total_spin += interacting_spins[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    else:
      total_spin -= interacting_spins[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    
    if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i//N*N+(i%N)*N+i%N][0] += 1
      priorities[i//N*N+(i%N)*N+i%N][1] -= 1
    else:
      priorities[i//N*N+(i%N)*N+i%N][0] -= 1
      priorities[i//N*N+(i%N)*N+i%N][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0026810000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i//N)%N,(i%N)//N,k]
        total_spin = h[tuple(site_nbrs)]
        if J[0][site_nbrs[0]][site_nbrs[1]][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0][site_nbrs[0]][site_nbrs[1]][k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbrs = [(i//N)%N,j,k]
        total_spin += h[tuple(site_nbrs)]
        if J[1][site_nbrs[0]][j][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[1][site_nbrs[0]][j][k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbrs = [(i//N)%N,(i%N)//N,k]
        total_spin += h[tuple(site_nbrs)]
        if J[3][site_nbrs[0]][(i%N)//N][k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3][site_nbrs[0]][(i%N)//N][k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbrs = [(i//N)%N,(i%N)//N,j]
        total_spin += h[tuple(site_nbrs)]
        if J[5][site_nbrs[0]][(i%N)//N][j] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5][site_nbrs[0]][(i%N)//N][j] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0042806}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    site_nbrs = [(k // N) % N, (k % N) // N, k % N]
    total_spin = h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    
    for d in range(6):
      if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin += interacting_spins[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= interacting_spins[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      
      if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        priorities[k][0] += 1
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0037210000000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins_sum = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j), (k)]
        for l in range(6):
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin -= J[l][i][j][k]
          else:
            total_spin += J[l][i][j][k]
        interacting_spins_sum[i][j][k] = [total_spin, 1 if h[i][j][k] > 0 else -1]

  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] += total_spin[1]

  return(priorities)


#score: {'data3D.txt': -0.0037210000000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins_sum = np.zeros((N,N,N,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j), (k)]
        total_spin = 0
        for l in range(6):
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin -= J[l][i][j][k]
          else:
            total_spin += J[l][i][j][k]
        interacting_spins_sum[i][j][k] = [total_spin, 1 if h[i][j][k] > 0 else -1]

  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] += total_spin[1]

  return(priorities)


#score: {'data3D.txt': 0.0022949999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(6):
      if J[j][site_nbr][i%N][i//N//N] > 0:
        total_spin += h[site_nbr][i%N][i//N//N]
      else:
        total_spin -= h[site_nbr][i%N][i//N//N]
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0018746000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0][site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += h[site_nbr][i%N][i//N//N]
      priorities[i][1] -= h[site_nbr][i%N][i//N//N]
    if J[3][site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += h[(site_nbr+1)%N][i%N][i//N//N]
      priorities[i][1] -= h[(site_nbr+1)%N][i%N][i//N//N]
    if J[4][site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += h[site_nbr][(i+1)%N][i//N//N]
      priorities[i][1] -= h[site_nbr][(i+1)%N][i//N//N]
    if J[5][site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += h[(site_nbr+1)%N][(i+1)%N][i//N//N]
      priorities[i][1] -= h[(site_nbr+1)%N][(i+1)%N][i//N//N]
  return(priorities)


#score: {'data3D.txt': -0.004035399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][i//N//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0001162000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][i//N//N]
    if J[0][site_nbr][i%N][i//N//N] > 0:
      total_spin += 1
    elif J[0][site_nbr][i%N][i//N//N] < 0:
      total_spin -= 1
    for j in range(1,6):
      if J[j][site_nbr][i%N][i//N//N] > 0:
        total_spin += 2 - np.sum(J[:j,[site_nbr],i%N,i//N//N])
      elif J[j][site_nbr][i%N][i//N//N] < 0:
        total_spin -= 2 + np.sum(J[:j,[site_nbr],i%N,i//N//N])
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.0007742000000000001}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
    
    total_spin = 0
    for d in range(6):
      if J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] > 0:
        total_spin += h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]

      if J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] > 0:
        priorities[k][0] += sum([interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= sum([interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0017090000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
   site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
   
   total_spin = 0
   for d in range(6):
    site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
    
    if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
     total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
    else:
     total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
    
    if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
     priorities[k][0] += 1
     priorities[k][1] -= 1
    else:
     priorities[k][0] -= 1
     priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0020302000000000007}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
    
    total_spin = 0
    for d in range(6):
      site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[k][0] += sum([J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]*interacting_spins[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]] for l in range(6)])
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= sum([J[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]]*interacting_spins[l, site_nbrs[0], site_nbrs[1], site_nbrs[2]] for l in range(6)])
        priorities[k][1] += 1
    
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin -= J[0,i,j,k]
          else:
            total_spin += J[0,i,j,k]

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[3,i,j,k] > 0:
            total_spin -= J[3,i,j,k]
          else:
            total_spin += J[3,i,j,k]

        priorities[i*N*N+j*N+k][0] = (total_spin >= 0).astype(int)
        priorities[i*N*N+j*N+k][1] = -(total_spin < 0).astype(int)

  return(priorities)


#score: {'data3D.txt': -0.07096420000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbrs = [(i + ((m-1)%2 - 1)) % N for m in [l%3*2, (l+1)%3*2, (l+2)%3*2]]
          for site_nbr in site_nbrs:
            total_spin += h[site_nbr][j][k]
            if J[l,i,j,k] > 0:
              total_spin += J[l,i,j,k]
            else:
              total_spin -= J[l,i,j,k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.08675300000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Nearest-neighbor interactions
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        for site_nbr in site_nbrs:
          total_spin += J[0,i,j,k] * h[site_nbr][j][k]
          
        # Next-to-nearest interactions
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7]]
        for site_nbr in site_nbrs:
          total_spin += J[3,i,j,k] * h[site_nbr][j][k]
          
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.00040460000000000094}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i*N*j+k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          if h[i][j][k] > 0:
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.14579980000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        
        for nbr, val in zip(site_nbrs, J[:,i,j,k]):
          if h[nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.14579980000000017}
program:
def priority(N, h, J):
  priorities=np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin=0
        site_nbrs=[(i + ((l-1)%2 - 1)) % N for l in range(6)]
        for site_nbr, val in zip(site_nbrs, J[:,i,j,k]):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022214}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    for l in range(6):
      if interacting_spins[l,i//N%N,i%N//N,N-1-i%N%N]>0:
        priorities[i][0] -= J[l,i//N%N,i%N//N,N-1-i%N%N]
      else:
        priorities[i][1] += J[l,i//N%N,i%N//N,N-1-i%N%N]
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': 7.260000000000022e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0]]
        total_spin += sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 2
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [3]]
        total_spin = sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        neighbor_sites = [(i + ((l-1)%2 - 1)) % N for l in [0,1,2,4,5]]
        for site_nbr in neighbor_sites:
          if J[0,i,site_nbr,k] > 0:
            total_spin += J[0,i,site_nbr,k]
          else:
            total_spin -= J[0,i,site_nbr,k]
          if J[3,i,j,site_nbr] > 0:
            total_spin += J[3,i,j,site_nbr]
          else:
            total_spin -= J[3,i,j,site_nbr]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l,i,j,k] > 0:
            total_spin += J[l,i,j,k]
          else:
            total_spin -= J[l,i,j,k]
        priorities[i*N*N+j*N+k][0] = total_spin
        priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0014217999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N//N][i%N%N] > 0:
      priorities[i][0] -= np.sum(J[:,site_nbr,i%N//N,i%N%N])
    else:
      priorities[i][1] += np.sum(J[:,site_nbr,i%N//N,i%N%N])

  return(priorities)


#score: {'data3D.txt': -0.004375400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(i//N+((k-1)%2 - 1))%N][site_nbrs[1]][site_nbrs[2]] for l,k in zip(range(6),range(3))])
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i] = [interacting_spins_sum, -1]
    else:
      priorities[i] = [-interacting_spins_sum, 1]
  return(priorities)


#score: {'data3D.txt': 0.0055686}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] -= 4 * sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
      priorities[i][1] += 1
    else:
      priorities[i][0] += 4 * sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
      priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': 0.0026902000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [1, 2, 4]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==1)*N+(d==2)*6]]
          for site_nbr in site_nbr_list:
            total_spin += J[d, i, j, k] * h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': 0.0020118000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_values = []
        site_nbr_J_sites = []

        for d in [0,1,2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==0)*N+(d==1)*6+(d==2)*12]]
          site_nbr_values += [h[site_nbr][j][k] for site_nbr in site_nbr_list]
          site_nbr_J_sites += [J[d,i,j,k] for _ in site_nbr_list]

        total_spin = sum([val * J_site for val, J_site in zip(site_nbr_values, site_nbr_J_sites)])

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3 - len([True for val in site_nbr_values if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3 - len([True for val in site_nbr_values if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.22833100000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        total_spin = sum([h[site_nbr][j][k] * (J[0,i,j,k] if J[0,i,j,k] > 0 else -J[0,i,j,k]) for site_nbr in site_nbrs])
        for d in [1, 2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==1)*N+(d==2)*6]]
          total_spin += sum([h[site_nbr][j][k] * J[d,i,j,k] for site_nbr in site_nbr_list])
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': 0.0020118000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1, 2]:
          site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [(d==0)*N+(d==1)*6+(d==2)*(8-N)]]
          for site_nbr in site_nbrs:
            total_spin += h[site_nbr][j][k] * J[d, i, j, k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 3
  return(priorities)


#score: {'data3D.txt': -0.00030139999999999947}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list1 = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        site_nbr_list2 = [(i + ((l-1)%2 - 1)) % N for l in [3,7,11]]
        for d in [0]:
          for site_nbr in site_nbr_list1:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
          for site_nbr in site_nbr_list2:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.0005618000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        
        for d in [0]:
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
        
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [3,7,11]]
        
        for d in [3]:
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': 0.0016574000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8,12]]
        site_nbr_values = [h[site_nbr][j][k] for site_nbr in site_nbrs]
        J_sites = [J[d, i, j, k] for d in [0,3]]
        total_spin = sum([val * J_site for val, J_site in zip(site_nbr_values, J_sites)])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.08904820000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        
        for d in [0]:
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
          
          if J[3,i,j,k] > 0:
            total_spin += J[3,i,j,k] * (h[(i + ((2-1)%2 - 1)) % N][j][k] + 
                           h[(i + ((4-1)%2 - 1)) % N][j][k])
          if J[5,i,j,k] > 0:
            total_spin += J[5,i,j,k] * (h[(i + ((6-1)%2 - 1)) % N][j][k] + 
                           h[(i + ((8-1)%2 - 1)) % N][j][k])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.1440214000000003}
program:
def priority(N, h, J):
  priorities = []
  for i in range(N**3):
    site_nbr = [i//N//N, (i//N)%N, i%N]
    total_spin = [0, 0]
    for j in range(6):
      for k in range(2):
        if J[j][site_nbr[0]][site_nbr[1]][site_nbr[2]] == -1:
          total_spin[k] += h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
        else:
          total_spin[k] -= h[site_nbr[0]][site_nbr[1]][site_nbr[2]]
    if total_spin[0] > 0:
      priorities.append([-total_spin[0], float('-inf')])
    else:
      priorities.append([float('-inf'), -total_spin[0]])
  return(priorities)


#score: {'data3D.txt': 0.0059426}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] -= sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
      priorities[i][1] += 1 - (h[site_nbr][i//N%N][i%N] + 
                   sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
    else:
      priorities[i][0] += sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
      priorities[i][1] -= 1 + (h[site_nbr][i//N%N][i%N] - 
                   sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
  return(priorities)


#score: {'data3D.txt': -0.0131834}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][1] -= 2 + sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    else:
      total_spin[i][1] += 2 - sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
  return(total_spin)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = []
    for k in range(3):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      site_nbrs.append(site_nbr)
      if k < 2:
        site_nbrs.append((site_nbr + 1) % N)
        site_nbrs.append((site_nbr - 1) % N)
    for spin in [1, -1]:
      priority = sum(J[k, i//N%N, i%N, site_nbr] * (spin == h[site_nbr][i//N%N][i%N]) for k, site_nbr in zip(range(6), site_nbrs))
      priorities[i][0] -= 2 * spin
      priorities[i][1] += priority
  return(priorities)


#score: {'data3D.txt': -0.0013870000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][k]
        if J[3, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[3, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
        site_nbr = (k + ((i-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[5, i, j, k] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[5, i, j, k] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.0015034000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((i-1)%2 - 1)) % N, k]
        total_spin = h[tuple(site_nbrs)]
        if J[0][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities[i*N+j*k][0] += 1
          priorities[i*N+j*k][1] -= 1
        elif J[0][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] < 0:
          priorities[i*N+j*k][0] -= 1
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0012585999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list_x = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        site_nbr_list_y = [(j + ((m-1)%N - N//2)) % N for m in [0,N//2,N//2+N%2]]
        
        for d in [0]:
          for site_nbr_x in site_nbr_list_x:
            total_spin += J[d,i,site_nbr_x,k] * h[site_nbr_x][j][k]
          for site_nbr_y in site_nbr_list_y:
            total_spin += J[d,i,j,site_nbr_y] * h[i][site_nbr_y][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.0028554000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list_x = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        site_nbr_list_y = [(j + ((m-1)%N - N//2)) % N for m in range(N)]
        
        for x in site_nbr_list_x:
          for y in site_nbr_list_y:
            total_spin += J[3,i,x,y] * h[x][y][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.11698540000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0,1,2]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin -= 1
          elif J[0,i,j,k] < 0:
            total_spin += 1
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin

  return(priorities)


#score: {'data3D.txt': 0.14579980000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        
        for site_nbr, val in zip(site_nbrs, J[:,i,j,k]):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2081230000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[3,i,j,k] > 0:
            total_spin -= 1
          else:
            total_spin += 1

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 * np.count_nonzero(np.array(J[:,i,j,k]) > 0)
          priorities[i*N*N+j*N+k][1] -= 2 * np.count_nonzero(np.array(J[:,i,j,k]) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * np.count_nonzero(np.array(J[:,i,j,k]) > 0)
          priorities[i*N*N+j*N+k][1] += 2 * np.count_nonzero(np.array(J[:,i,j,k]) < 0)

  return(priorities)


#score: {'data3D.txt': -0.1360970000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[3,i,j,k] > 0:
            total_spin -= 1
          else:
            total_spin += 1

        total_spin -= np.count_nonzero(np.array(J[:,i,j,k]) > 0)
        total_spin += np.count_nonzero(np.array(J[:,i,j,k]) < 0)

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2 * np.count_nonzero(np.array(J[:,i,j,k]) > 0)
          priorities[i*N*N+j*N+k][1] -= 2 * np.count_nonzero(np.array(J[:,i,j,k]) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * np.count_nonzero(np.array(J[:,i,j,k]) > 0)
          priorities[i*N*N+j*N+k][1] += 2 * np.count_nonzero(np.array(J[:,i,j,k]) < 0)

  return(priorities)


#score: {'data3D.txt': -0.061215000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[0,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [3, 7, 11]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          if J[3,i,j,k] > 0:
            total_spin -= 1
          else:
            total_spin += 1

        priorities[i*N*N+j*N+k][0] += np.count_nonzero(np.array(J[:,i,j,k]) > 0) - (total_spin > 0)
        priorities[i*N*N+j*N+k][1] += np.count_nonzero(np.array(J[:,i,j,k]) < 0) + (total_spin > 0)

  return(priorities)


#score: {'data3D.txt': 0.001957}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][(l%3)] for l in range(6)])
      priorities[i][0] += -total_spin
      priorities[i][1] += 1
    else:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][(l%3)] for l in range(6)])
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
  return(priorities)


#score: {'data3D.txt': 0.0034594000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  # Iterate over all sites
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    # Calculate the total interaction energy for each spin
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += -sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0]+((l-1)%2 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      priorities[i][1] += 1
    else:
      priorities[i][0] += sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0]+((l-1)%2 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      priorities[i][1] -= 1
  
  return(priorities)


#score: {'data3D.txt': -0.0022858}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1)%N, (j+1)%N, (j-1)%N, (k+1)%N, (k-1)%N]
        for d in range(6):
          if J[d][site_nbrs[d%2]][j//3][k//3] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[d][site_nbrs[d%2]][j//3][k//3] < 0:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.0037997999999999994}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][0] += sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    else:
      total_spin[i][0] -= sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][1] += 1 - (h[site_nbr][i//N%N][i%N] + 
                    sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
    else:
      total_spin[i][1] -= 1 + (h[site_nbr][i//N%N][i%N] - 
                    sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
  return(total_spin)


#score: {'data3D.txt': 0.0059426}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] -= sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
      priorities[i][1] += 1 - (h[site_nbr][i//N%N][i%N] + 
                    sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
    else:
      priorities[i][0] += sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
      priorities[i][1] -= 1 + (h[site_nbr][i//N%N][i%N] - 
                    sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
  return(priorities)


#score: {'data3D.txt': -0.22833100000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k] * (J[0,i,j,k] if J[0,i,j,k] > 0 else -J[0,i,j,k])
        
        for d in [1, 2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==1)*N+(d==2)*6]]
          for site_nbr in site_nbr_list:
            total_spin += h[site_nbr][j][k] * J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.16460380000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += J[l,i,j,k] * h[site_nbr][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': 0.10989100000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8]]
        for site_nbr in site_nbrs:
          if J[0,i,j,k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]
        
        for d in [1, 2]:
          site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [(d==1)*N+(d==2)*6]]
          for site_nbr in site_nbr_list:
            if J[d,i,j,k] > 0:
              total_spin += h[site_nbr][j][k]
            else:
              total_spin -= h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = []
  for i in range(N**2):
    site_nbrs.append([(i % N + ((i//N-1)%2 - 1)) % N,(i%N)//N,(i%N)%N])

  for i in range(N**3):
    total_spin = 0
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site_nbrs[i//N**2][0]][site_nbrs[i//N**2][1]][site_nbrs[i//N**2][2]] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site_nbrs[i//N**2][0]][site_nbrs[i//N**2][1]][site_nbrs[i//N**2][2]] > 0:
        priorities[i][0] += 1 + total_spin
        priorities[i][1] -= 1 - total_spin
      else:
        priorities[i][0] -= 1 + total_spin
        priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0] + ((l-1)%3 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] += total_spin + 1
        priorities[i][1] -= 1 - total_spin
      else:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -1 - total_spin
    else:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0] + ((l-1)%3 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -1 - total_spin
      else:
        priorities[i][0] += total_spin + 1
        priorities[i][1] -= 1 - total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.0037997999999999994}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][0] += sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    else:
      total_spin[i][0] -= sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][1] += 1 - (h[site_nbr][i//N%N][i%N] + 
                   sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
    else:
      total_spin[i][1] -= 1 + (h[site_nbr][i//N%N][i%N] - 
                   sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
  return(total_spin)


#score: {'data3D.txt': -0.025495400000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= total_spin - 1
    else:
      priorities[i][0] -= total_spin + 1
      priorities[i][1] = -(total_spin - 1)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.011311400000000001}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][0] += 1 - (h[site_nbr][i//N%N][i%N] + 
                    sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
    else:
      total_spin[i][0] -= 1 - (h[site_nbr][i//N%N][i%N] - 
                    sum(J[k, i//N%N, i%N, ((k-1)%2 - 1)] for k in range(6)))
  return(total_spin)


#score: {'data3D.txt': -0.2354646000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        if h[i][j][k] > 0:
          priority_total = np.sum(J_values) + (np.sum([J_values.count(val) for val in J_values]) // len(J_values))
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -2*priority_total
        else:
          priority_total = -np.sum(J_values) + (np.sum([J_values.count(val) for val in J_values]) // len(J_values))
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = 2*priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.3774194}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        if all(J_values) > 0:
          priorities[i*N*N+j*N+k][0] = np.sum(J_values)
          priorities[i*N*N+j*N+k][1] = -2*np.sum(J_values)
        elif all(J_values) < 0:
          priorities[i*N*N+j*N+k][0] = -np.sum(J_values)
          priorities[i*N*N+j*N+k][1] = 2*np.sum(J_values)
        else:
          total_spin_nbr = sum(1 if val > 0 else -1 for val in J_values)
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] = total_spin + total_spin_nbr
            priorities[i*N*N+j*N+k][1] = -2*(total_spin + total_spin_nbr)
          else:
            priorities[i*N*N+j*N+k][0] = -total_spin - total_spin_nbr
            priorities[i*N*N+j*N+k][1] = 2*(-total_spin - total_spin_nbr)
  
  return(priorities)


#score: {'data3D.txt': -0.0399966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        total_spin = h[i][j][k]
        for l, val in zip(site_nbrs, J_values):
          if val > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N+j*N+k][0] = -total_spin * np.sum(J_values)
        priorities[i*N*N+j*N+k][1] = total_spin * np.sum(J_values)
  
  return(priorities)


#score: {'data3D.txt': -0.0243098}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(J_values)
          priorities[i*N*N+j*N+k][1] -= 2*np.sum(J_values)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(J_values)
          priorities[i*N*N+j*N+k][1] += 2*np.sum(J_values)
  
  return(priorities)


#score: {'data3D.txt': -0.0053038}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = []
  for i in range(N**2):
    site_nbrs.append([(i % N + ((i//N-1)%2 - 1)) % N,(i%N)//N,(i%N)%N])

  for k in range(N**3):
    total_spin = 0
    for d in range(6):
      if J[d][site_nbrs[k//N**2][0]][site_nbrs[k//N**2][1]][site_nbrs[k//N**2][2]] > 0:
        total_spin += interacting_spins[d][site_nbrs[k//N**2][0]][site_nbrs[k//N**2][1]][site_nbrs[k//N**2][2]]
      else:
        total_spin -= interacting_spins[d][site_nbrs[k//N**2][0]][site_nbrs[k//N**2][1]][site_nbrs[k//N**2][2]]

    for i in range(3):
      site = (k + ((i-1)%2 - 1)) % N
      if h[site_nbrs[k//N**2][0]][site_nbrs[k//N**2][1]][site_nbrs[k//N**2][2]] > 0:
        priorities[k][0] += 1 + total_spin
        priorities[k][1] -= 1 - total_spin
      else:
        priorities[k][0] -= 1 + total_spin
        priorities[k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0013437999999999998}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  site_nbrs = []
  for i in range(N**2):
    site_nbrs.append([(i % N + ((i//N-1)%2 - 1)) % N,(i%N)//N,(i%N)%N])

  for k in range(N**3):
   site_nbr = (k // N) % N
   total_spin = h[site_nbr][k % N][k % N]
   
   for d in range(6):
    if J[d][site_nbr][k % N][k % N] > 0:
     total_spin += interacting_spins[d][site_nbr][k % N][k % N]
    else:
     total_spin -= interacting_spins[d][site_nbr][k % N][k % N]

   if J[0][site_nbr][k % N][k % N] > 0:
    priorities[k][0] += total_spin + 1
    priorities[k][1] -= total_spin + 1
   elif J[3][site_nbr][k % N][k % N] > 0:
    priorities[k][0] += total_spin + 1
    priorities[k][1] -= total_spin - 1
   else:
    priorities[k][0] -= total_spin - 1
    priorities[k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.12062140000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(1 if J[d,i,j,k] > 0 else -1 for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[::,i,j,k] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in J[::,i,j,k] if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0007042}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = [[0, 0] for _ in range(N**3)]
  for k in range(6):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    for j in range(N):
      for i in range(N):
        if interacting_spins[k][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          total_spin[i*N+j][1] += J[k, i, site_nbrs[0], site_nbrs[1]]
          total_spin[i*N+j][0] -= J[k, i, site_nbrs[0], site_nbrs[1]]
        else:
          total_spin[i*N+j][0] += J[k, i, site_nbrs[0], site_nbrs[1]]
          total_spin[i*N+j][1] -= J[k, i, site_nbrs[0], site_nbrs[1]]

  for i in range(N**3):
    if h[(i//N)%N][(i%N)//N][(i%N)%N] > 0:
      priorities[i][0] += -total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]
    else:
      priorities[i][0] = total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]

  return(priorities)


#score: {'data3D.txt': -0.025495400000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= total_spin - 1
    else:
      total_spin = sum(-J[k, i//N%N, i//N%N, site_nbr] for k in range(6))
      priorities[i][0] -= total_spin + 1
      priorities[i][1] = -(total_spin - 1)
  return(priorities)


#score: {'data3D.txt': -0.021965400000000003}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    total_spin[i][0] += h[site_nbr][i//N%N][i%N]
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][1] -= spin + 1
    else:
      total_spin[i][1] = -spin + 1
  return(total_spin)


#score: {'data3D.txt': -0.0763178}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        
        for d in [0,3,5]:
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
            
          if J[d,i,j,k] > 0:
            total_spin += J[d,i,j,k] * (h[(i + ((2-1)%2 - 1)) % N][j][k] + 
              h[(i + ((4-1)%2 - 1)) % N][j][k])
          
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.11719020000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        
        for d in [0]:
          for site_nbr in site_nbr_list:
            if J[3,i,j,k] > 0 and (site_nbr == i or site_nbr == j or site_nbr == k):
              total_spin += J[3,i,j,k] * h[site_nbr][j][k]
            elif J[5,i,j,k] > 0 and ((i + (2-1)%2) % N == site_nbr or (i + (4-1)%2) % N == site_nbr):
              total_spin += J[5,i,j,k] * h[site_nbr][j][k]
          
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.08904820000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0,4,8]]
        
        for d in [0]:
          for site_nbr in site_nbr_list:
            total_spin += J[d,i,j,k] * h[site_nbr][j][k]
          
          if J[3,i,j,k] > 0:
            total_spin += J[3,i,j,k] * (h[(i + ((2-1)%2 - 1)) % N][j][k] + 
                        h[(i + ((4-1)%2 - 1)) % N][j][k])
          if J[5,i,j,k] > 0:
            total_spin += J[5,i,j,k] * (h[(i + ((6-1)%2 - 1)) % N][j][k] + 
                        h[(i + ((8-1)%2 - 1)) % N][j][k])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 3
          priorities[i*N*N+j*N+k][1] -= 4
        else:
          priorities[i*N*N+j*N+k][0] -= 3
          priorities[i*N*N+j*N+k][1] += 4
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0,1,2]]
        for l in site_nbrs:
          if h[l][j][k] > 0:
            total_spin += J[(site_nbrs.index(l)), i, j, k]
          else:
            total_spin -= J[(site_nbrs.index(l)), i, j, k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.sign(J[site_nbrs==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] -= 2*np.sum(np.sign(J[site_nbrs==i, i==j, k==k]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.sign(J[site_nbrs==i, i==j, k==k]))
          priorities[i*N*N+j*N+k][1] += 2*np.sum(np.sign(J[site_nbrs==i, i==j, k==k]))
  
  return(priorities)


#score: {'data3D.txt': -0.0243098}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0,1,2]]
        for site_nbr in site_nbrs:
          if J[0,i,j,k] > 0: total_spin += 1
          elif J[0,i,j,k] < 0: total_spin -= 1
          if J[1,i,j,k] > 0: total_spin += 1
          elif J[1,i,j,k] < 0: total_spin -= 1
          if J[2,i,j,k] > 0: total_spin += 1
          elif J[2,i,j,k] < 0: total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.sign(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][1] -= 3*np.sum(np.sign(J[:,i,j,k]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.sign(J[:,i,j,k]))
          priorities[i*N*N+j*N+k][1] += 3*np.sum(np.sign(J[:,i,j,k]))
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = []
    for k in range(3):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      site_nbrs.append(site_nbr)
      if k < 2:
        site_nbrs.append((site_nbr + 1) % N)
        site_nbrs.append((site_nbr - 1) % N)
    for spin in [1, -1]:
      priority = sum(J[k, i//N%N, i%N, site_nbr] * (spin == h[site_nbr][i//N%N][i%N]) for k, site_nbr in zip(range(6), site_nbrs))
      if spin == 1:
        priorities[i][0] += priority
        priorities[i][1] -= priority
      else:
        priorities[i][0] -= priority
        priorities[i][1] += priority
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = []
    for k in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - (k%2)) - (k//2) ) % N
      site_nbrs.append(site_nbr)
    for spin in [1, -1]:
      priority = sum(J[k, i//N%N, i%N, site_nbr] * (spin == h[site_nbr][i//N%N][i%N]) for k, site_nbr in zip(range(6), site_nbrs))
      priorities[i][0] -= 2 * spin
      priorities[i][1] += priority
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = []
    for k in range(6):  # Iterate over all 6 neighbors
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N if k < 2 else ((i//N)%N + i%N) % N
      site_nbrs.append(site_nbr)
    for spin in [1, -1]:
      priority = sum(J[k, i//N%N, i%N, site_nbr] * (spin == h[site_nbr][i//N%N][i%N]) for k, site_nbr in zip(range(6), site_nbrs))
      priorities[i][0] -= 2 * spin
      priorities[i][1] += priority
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = []
    for k in range(6):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N if k%3 < 1 else (i % N + ((i//N+1)%2 - 1)) % N
      site_nbrs.append(site_nbr)
    for spin in [1, -1]:
      priority = sum(J[k, i//N%N, i%N, site_nbr] * (spin == h[site_nbr][i//N%N][i%N]) for k, site_nbr in zip(range(6), site_nbrs))
      priorities[i][0] -= 2 * spin
      priorities[i][1] += priority
  return(priorities)


#score: {'data3D.txt': -0.0019617999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for site_nbr in [(i + ((k-1)%2 - 1)) % N, (j + ((i-1)%2 - 1)) % N, (k + ((i-1)%2 - 1)) % N]:
          total_spin += h[site_nbr][j]
          if J[0, i, j, k] > 0:
            priorities[i*N+j*k][0] += 1
            priorities[i*N+j*k][1] -= 1
          elif J[0, i, j, k] < 0:
            priorities[i*N+j*k][0] -= 1
            priorities[i*N+j*k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.3774194}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        if all(J_values) > 0:
          priorities[i*N*N+j*N+k][0] = np.sum(np.sign(J_values))
          priorities[i*N*N+j*N+k][1] = -2*np.sum(np.sign(J_values))
        elif all(J_values) < 0:
          priorities[i*N*N+j*N+k][0] = -np.sum(np.sign(J_values))
          priorities[i*N*N+j*N+k][1] = 2*np.sum(np.sign(J_values))
        else:
          total_spin_nbr = sum(1 if val > 0 else -1 for val in J_values)
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] = total_spin + total_spin_nbr
            priorities[i*N*N+j*N+k][1] = -2*(total_spin + total_spin_nbr)
          else:
            priorities[i*N*N+j*N+k][0] = -total_spin - total_spin_nbr
            priorities[i*N*N+j*N+k][1] = 2*(-total_spin - total_spin_nbr)
  
  return(priorities)


#score: {'data3D.txt': -0.002392999999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin = sum(J[k, i//N%N, i%N//N, site_nbr] for k in range(6))
    total_spin = h[site_nbr][i//N%N][i%N//N]
    if total_spin > 0:
      priorities[i][0] -= spin + 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] += spin - 1
      priorities[i][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.00030299999999999994}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin = sum(J[k, i//N%N, i%N//N, site_nbr] for k in range(6))
    total_spin[i][0] += h[site_nbr][i//N%N][i%N//N]
    if h[site_nbr][i//N%N][i%N//N] > 0:
      total_spin[i][1] -= spin + 1
    else:
      total_spin[i][1] = -spin + 1

  for i in range(N**3):
    priorities[i][0] += total_spin[i][0]
    priorities[i][1] -= total_spin[i][1]

  return(priorities)


#score: {'data3D.txt': 0.0029570000000000004}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N**3):
    site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [0,1,4,5]]
    for j in site_nbrs:
      total_spin = sum(J[k, i//N%N, i%N//N, j] for k in [0,1,4,5])
      if h[j][i//N%N][i%N//N] > 0:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -total_spin + 1
      else:
        priorities[i][0] = -total_spin + 1
        priorities[i][1] += total_spin

  return(priorities)


#score: {'data3D.txt': -0.005162600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          priorities[i*N*j+k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
          if J[l,i,j,k]>0:
            priorities[i*N*j+k][1] -= 2
          else:
            priorities[i*N*j+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0038766}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N+j*k][1] += J[l,i,j,k]
          else:
            priorities[i*N+j*k][0] -= J[l,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.0033078000000000005}
program:
def priority(N, h, J):
  total_spin = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      total_spin[i][0] += h[site_nbr][i//N%N][i%N] + spin
      total_spin[i][1] = -h[site_nbr][i//N%N][i%N] - spin
    else:
      total_spin[i][0] -= h[site_nbr][i//N%N][i%N] + spin
      total_spin[i][1] = h[site_nbr][i//N%N][i%N] + spin
  return(total_spin)


#score: {'data3D.txt': -0.0033078000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= total_spin - 1
    else:
      priorities[i][0] -= total_spin - 1
      priorities[i][1] += total_spin + 1
  return(priorities)


#score: {'data3D.txt': -0.0033078000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] += (h[site_nbr][i//N%N][i%N] + spin) * N
      priorities[i][1] -= (h[site_nbr][i//N%N][i%N] - spin)
    else:
      priorities[i][0] -= (h[site_nbr][i//N%N][i%N] + spin) * N
      priorities[i][1] += (h[site_nbr][i//N%N][i%N] - spin)
  return(priorities)


#score: {'data3D.txt': -0.0020358}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((i-1)%2 - 1)) % N, (k + ((j-1)%2 - 1)) % N]
        interacting_spins_sum = sum([J[l][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0033042000000000006}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
        for l in range(6):
          if J[l,site_nbrs_map[0],site_nbrs_map[1],site_nbrs_map[2]]>0:
            total_spin+=1
          else:
            total_spin-=1
          
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += total_spin
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= total_spin
          priorities[i*N+j*k][1] += 1
          
  return(priorities)


#score: {'data3D.txt': -0.0006357999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = []
        
        # Get neighbors in x-direction
        for l in [max(0, i-1), min(N-1, i+1)]:
          site_nbr_list.append((l, j, k))
        
        # Get neighbors in y-direction
        for l in [max(0, i-1), min(N-1, i+1)]:
          site_nbr_list.append((l, max(0, j-1), min(N-1, k+1)))
        
        # Get neighbors in z-direction
        for l in [max(0, i-1), min(N-1, i+1)]:
          site_nbr_list.append((l, max(0, j-1), min(N-1, k+1)))
        
        for (site_i, site_j, site_k) in site_nbr_list:
          total_spin += J[0, site_i, site_j, site_k] * h[site_i][site_j][site_k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin + N**2
          priorities[i*N*N+j*N+k][1] = total_spin - N**2
        else:
          priorities[i*N*N+j*N+k][0] = total_spin - N**2
          priorities[i*N*N+j*N+k][1] = -total_spin + N**2

  return(priorities)


#score: {'data3D.txt': -0.24715620000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_list = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        for site_nbr in site_nbr_list:
          if J[0,i,j,k] > 0:
            total_spin += h[site_nbr][j][k]
          else:
            total_spin -= h[site_nbr][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.2332846}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        
        total_spin = h[i][j][k]
        for site_nbr in site_nbrs:
          if J[0,i,j,k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N+j*N+k][0] = -total_spin
        priorities[i*N*N+j*N+k][1] = total_spin
        
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
      total_spin = 0
      for site_nbr in site_nbrs:
        if h[site_nbr][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= 2
      else:
        priorities[i*N*N+j*N+k][0] -= total_spin
        priorities[i*N*N+j*N+k][1] += 2
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
      total_spin = 0
      for site_nbr in site_nbrs:
        if h[i][site_nbr][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= 2
      else:
        priorities[i*N*N+j*N+k][0] -= total_spin
        priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = [[0, 0] for _ in range(N**3)]
  
  for k in range(6):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    for j in range(N):
      for i in range(N):
        if interacting_spins[k][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          total_spin[i*N+j][1] += J[k, i, site_nbrs[0], site_nbrs[1]]
          total_spin[i*N+j][0] -= J[k, i, site_nbrs[0], site_nbrs[1]]
        else:
          total_spin[i*N+j][0] += J[k, i, site_nbrs[0], site_nbrs[1]]
          total_spin[i*N+j][1] -= J[k, i, site_nbrs[0], site_nbrs[1]]

  for i in range(N**3):
    if h[(i//N)%N][(i%N)//N][(i%N)%N] > 0:
      priorities[i][0] = -total_spin[i][0]
      priorities[i][1] = total_spin[i][1]
    else:
      priorities[i][0] = total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]

  return(priorities)


#score: {'data3D.txt': -0.047942600000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 4, 8, 12]]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        for site_nbr, val in zip(site_nbrs, J_values):
          if val > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*N+j*N+k][0] = -total_spin * np.sum(J_values)
        priorities[i*N*N+j*N+k][1] = total_spin * np.sum(J_values)

  return(priorities)


#score: {'data3D.txt': -0.0399966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        J_values = [J[l, i, j, k] for l in range(6)]
        
        total_spin = h[i][j][k]
        for l, val in zip(site_nbrs, J_values):
          if val > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority_sum = np.sum(J_values)
        priorities[i*N*N+j*N+k][0] = -total_spin * priority_sum
        priorities[i*N*N+j*N+k][1] = total_spin * priority_sum
  
  return(priorities)


#score: {'data3D.txt': -0.016977799999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, (i//N)//N%N, (i//N)%N, site_nbr] for k in range(6))
    if h[site_nbr][(i//N)//N%N][(i//N)%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= total_spin - 1
    else:
      priorities[i][0] -= total_spin - 1
      priorities[i][1] += total_spin + 1
  return(priorities)


#score: {'data3D.txt': -0.0033078000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k, i//N%N, i%N, site_nbr] for k in range(6))
    if h[site_nbr][i//N%N][i%N] > 0:
      priorities[i][0] += total_spin + 1
      priorities[i][1] -= total_spin - 1
    else:
      priorities[i][0] -= total_spin - 1
      priorities[i][1] += total_spin + 1
  return(priorities)


#score: {'data3D.txt': 0.012531800000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(1 if J[d,i,j,k] > 0 else -1 for d in [0,1,2])
        interaction_sum = sum(J[d,i,j,k] for d in [0,1,2] if J[d,i,j,k] != 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= abs(interaction_sum)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += abs(interaction_sum)
  
  return(priorities)


#score: {'data3D.txt': -0.30393340000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[::,i,j,k] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in J[::,i,j,k] if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.004343}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N+j+k][0] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i*N+j+k][1] -= 1
          else:
            priorities[i*N+j+k][0] -= -J[l,i,j,k]*interacting_spins[l,i,j,k]
            priorities[i*N+j+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.14880900000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.12704100000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[::,i,j,k] if val > 0]) - len([val for val in J[3:,i,j,k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in J[::,i,j,k] if val < 0]) - len([val for val in J[3:,i,j,k] if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.24023060000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0014946000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_sum = np.zeros((N,N,N,2))
  interacting_spins_count = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j), (k)]
        total_spin = 0
        count = 0
        for l in range(6):
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin -= J[l][i][j][k]
            count -= 1
          else:
            total_spin += J[l][i][j][k]
            count += 1
        interacting_spins_sum[i][j][k] = [total_spin, count]

  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] += total_spin[1]

  return(priorities)


#score: {'data3D.txt': -0.0020274}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbrs = [(i//N)%N,(i%N)//N,k]
        if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
          priorities[i*N+j][0] += J[k, i, site_nbrs[0], j]
          priorities[i*N+j][1] -= J[k, i, site_nbrs[0], j]
        else:
          priorities[i*N+j][0] -= J[k, i, site_nbrs[0], j]
          priorities[i*N+j][1] += J[k, i, site_nbrs[0], j]

  return(priorities)


#score: {'data3D.txt': -0.0015810000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = [[0, 0] for _ in range(N**3)]
  for k in range(6):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    for j in range(N):
      for i in range(N):
        if h[i][j][site_nbrs[2]] > 0:
          total_spin[i*N+j][1] += J[k, i, site_nbrs[0], j]
          total_spin[i*N+j][0] -= J[k, i, site_nbrs[0], j]
        else:
          total_spin[i*N+j][0] += J[k, i, site_nbrs[0], j]
          total_spin[i*N+j][1] -= J[k, i, site_nbrs[0], j]

  for i in range(N**3):
    if h[(i//N)%N][(i%N)//N][(i%N)%N] > 0:
      priorities[i][0] = -total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]
    else:
      priorities[i][0] = total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]

  return(priorities)


#score: {'data3D.txt': -0.0014946000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins_sum = np.zeros((N,N,N,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j), (k)]
        total_spin = [0, 0]
        count = 0
        for l in range(6):
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin[0] -= J[l][i][j][k]
            count -= 1
          else:
            total_spin[0] += J[l][i][j][k]
            count += 1
        interacting_spins_sum[i][j][k] = [total_spin[0], count]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] += total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': -0.003673}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    interacting_spins_sum = sum([J[l,site_nbrs_map[0],site_nbrs_map[1],site_nbrs_map[2]] * h[site_nbrs_map[0]][site_nbrs_map[1]][site_nbrs_map[2]] for l in range(6)])
    
    if h[site_nbrs_map[0]][site_nbrs_map[1]][site_nbrs_map[2]] > 0:
      priorities[i][0] += interacting_spins_sum
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= interacting_spins_sum
      priorities[i][1] += 1
    
  return(priorities)


#score: {'data3D.txt': -0.28351060000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[::,site_nbr,j,k] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in J[::,site_nbr,j,k] if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.0004481999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin
        if J[0][i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.002181}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_sum = sum([J[ll,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][j][k] for ll in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= sum([abs(h[site_nbr][j][k]) for site_nbr in site_nbrs])
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += sum([abs(h[site_nbr][j][k]) for site_nbr in site_nbrs])
  return(priorities)


#score: {'data3D.txt': -0.0017902000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_sum = sum([J[ll,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for ll in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= sum([abs(h[site_nbrs[ll]][j][k]) for ll in range(6)])
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += sum([abs(h[site_nbrs[ll]][j][k]) for ll in range(6)])

  return(priorities)


#score: {'data3D.txt': -0.0023873999999999996}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in range(6)]
        interacting_spins_sum = sum([J[ll,site_nbrs[0],j,k]*h[site_nbrs[0]][j][k] for ll in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= sum([abs(h[site_nbr][j][k]) for site_nbr in site_nbrs])
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += sum([abs(h[site_nbr][j][k]) for site_nbr in site_nbrs])
  return(priorities)


#score: {'data3D.txt': -0.14408820000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.053415000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in J[::,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in J[::,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum
  
  return(priorities)


#score: {'data3D.txt': -0.09803740000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
          
  return(priorities)


#score: {'data3D.txt': -0.14880900000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)


#score: {'data3D.txt': -0.0875378}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= sum(val > 0 for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += sum(val < 0 for val in interacting_spins)
  
  return(priorities)


#score: {'data3D.txt': 0.00022499999999999942}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0056222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.0006618000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin

  # Add the interactions between the site and its nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0][site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 1
        else:
          priorities[i*N*j+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0875378}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= sum(val > 0 for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += sum(val < 0 for val in interacting_spins)
  
  return(priorities)


#score: {'data3D.txt': -0.3176741999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
  
  return(priorities)


#score: {'data3D.txt': -0.0343366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        site_nbr = ((i+((k-1)%2 - 1)) % N) * N + j
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[site_nbr][0] += 1
          priorities[site_nbr][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[site_nbr][0] -= 1
          priorities[site_nbr][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0027930000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (j + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][site_nbr][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.006975800000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
  # Improve the algorithm further by considering more sites and their interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        
  return(priorities)


#score: {'data3D.txt': -0.0108582}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = -total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': 0.004034599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priorities[i*N*j+k][0] = total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0038606000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (j + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][i][site_nbr][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.001629800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate the total spin for each axis
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0013826}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.008359400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr1][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        if h[site_nbr2][i][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        if h[site_nbr3][i][j] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0009334000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        
        for l in [0,1,2]:
          interacting_sites = []
          if J[0, i, j, k] > 0:
            interacting_sites.append((i + (l+1)%N - 1) % N)
          elif J[0, i, j, k] < 0:
            interacting_sites.append((i + ((k-1)%2 - 1)) % N)
          
          for site in interacting_sites:
            priorities[i*N*N+j*k][0] += h[site][j][k]
            if h[site][j][k] > 0:
              priorities[i*N*N+j*k][1] -= 1
            else:
              priorities[i*N*N+j*k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*k][0] += sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
          priorities[i*N*N+j*k][1] -= 3
        else:
          priorities[i*N*N+j*k][0] -= sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
          priorities[i*N*N+j*k][1] += 3
  
  return(priorities)


#score: {'data3D.txt': 0.0106342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.2675862000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.05061020000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0014946000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_sum = np.zeros((N,N,N,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j), (k)]
        total_spin = [0, 0]
        count = 0
        for l in range(6):
          if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
            total_spin[0] -= J[l][i][j][k]
            count -= 1
          else:
            total_spin[0] += J[l][i][j][k]
            count += 1
        interacting_spins_sum[i][j][k] = [total_spin[0], count]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    total_spin = interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin[0]
      priorities[i][1] -= total_spin[1]
    else:
      priorities[i][0] -= total_spin[0]
      priorities[i][1] += total_spin[1]
  
  return(priorities)


#score: {'data3D.txt': 2.9399999999999983e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_l = (l // N * 2 + l % N)
          if site_nbr_i == site_nbr_j and site_nbr_i == site_nbr_k:
            continue
          
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.00014459999999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][1] = -total_spin
    
  return(priorities)


#score: {'data3D.txt': 3.460000000000063e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * (total_spin > 0)
        else:
          priorities[i*N*j+k][1] += 2 * (total_spin > 0)
  
  return(priorities)


#score: {'data3D.txt': 0.3425773999999996}
program:
def priority(N, h, J):
  N3 = N**3
  priorities = np.zeros((N3, 2))
  
  for i in range(N3):
    site_nbr = [(i // (N**2)) % N, (i // N) % N, i % N]
    
    total_spin = [0, 0]
    
    for k in range(6):
      site_nbr_k = list(site_nbr)
      site_nbr_k[k%3] += ((k//8)%2 -1) * N
      site_nbr_k[k%3] %= N
      
      if h[tuple(site_nbr_k)] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
        
    for j in range(2):
      priorities[i][j] = -total_spin[j]
      
  return priorities


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[[0,1,2],i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[[0,1,2],i,j,k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[[0,1,2],i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in J[[0,1,2],i,j,k] if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.0016273999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        if J[k,i,site_nbr,j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[k,i,site_nbr,j]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[k,i,site_nbr,j]] if val < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.14880900000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.012463799999999999}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins_sum = np.zeros((N,N,N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, j, k]
        for l in range(6):
          interacting_spins_sum[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] += J[l][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] * h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j+k][0] += interacting_spins_sum[i][j][k]
          priorities[i*N*N+j+k][1] -= 1
        else:
          priorities[i*N*N+j+k][0] -= interacting_spins_sum[i][j][k]
          priorities[i*N*N+j+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.0029098}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis = i) 
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis = i) 

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N,i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      elif J[k,i%N,i//N,i%N] < 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  # This is the improved part, it iterates over all sites and 
  # updates their priorities based on the magnetism at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j]
        if J[0,i,j,k] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[0,i,j,k] < 0:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.3425773999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i][j][k][0] = -1
          priorities[i][j][k][1] = float('inf')
        else:
          priorities[i][j][k][0] = 1
          priorities[i][j][k][1] = float('-inf')
  return priorities.reshape((N*N*N,2))


#score: {'data3D.txt': 0.0009973999999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for i_ in range(N):
          for j_ in range(N):
            for k_ in range(N):
              if (abs(i - i_) + abs(j - j_) + abs(k - k_)) <= 1:
                total_spin += interacting_spins[l][i_,j,k]
        
        priorities[i*N*j+k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.0014653999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = total_spin + N**2 * 2
          priorities[i*N*j+k][1] = -total_spin - N**2 * 2
        else:
          priorities[i*N*j+k][0] = total_spin - N**2 * 2
          priorities[i*N*j+k][1] = -total_spin + N**2 * 2
  
  return(priorities)


#score: {'data3D.txt': 0.00022900000000000066}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate the magnetism contribution
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += 1
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][0] -= 1
          priorities[i*N*j+k][1] += 2
        
        # Calculate the interaction contribution
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[i][j][k] > 0:
            priorities[i*N*j+k][0] += 2
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][0] -= 2
            priorities[i*N*j+k][1] += 1
        
        priorities[i*N*j+k][0] = total_spin
        priorities[i*N*j+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.00022499999999999942}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin_map = {}
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if (i, j, k) not in total_spin_map:
          total_spin_map[(i, j, k)] = total_spin
        priorities[i*N*j+k][0] = total_spin_map.get((i, j, k), 0)
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2

  return(priorities)


#score: {'data3D.txt': 0.014079400000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] += -total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.014131399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin
        
        if h[site_nbr1][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        if h[site_nbr2][i][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        if h[site_nbr3][i][j] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.008044200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr1][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        if h[site_nbr2][i][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
        if h[site_nbr3][i][j] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0123714}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,(i+1)%N,(j+1)%N,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,(i+1)%N,j,k], J[3,(i+1)%N,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[4,(i+1)%N,j,k], J[4,(i+1)%N,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins_x if val > 0]) + sum([val for val in interacting_spins_y if val > 0]) + sum([val for val in interacting_spins_z if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum([val for val in interacting_spins_x if val < 0]) - sum([val for val in interacting_spins_y if val < 0]) - sum([val for val in interacting_spins_z if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([val for val in interacting_spins_x if val > 0]) - sum([val for val in interacting_spins_y if val > 0]) - sum([val for val in interacting_spins_z if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum([val for val in interacting_spins_x if val < 0]) + sum([val for val in interacting_spins_y if val < 0]) + sum([val for val in interacting_spins_z if val < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.0126502}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                  J[3,(i+1)%N,j,k], J[4,i,j,k],
                  J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.0414782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (2*h[i][j][k] - 1) for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0011606000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_sum = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if h[site_nbr][j][k] > 0:
            total_spin += 1
            site_nbr_sum += 1
          else:
            total_spin -= 1
            site_nbr_sum -= 1
        
        priorities[i*N*j+k][0] += -total_spin + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0030302000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        
        total_spin = [0, 0]
        for l in range(6):
          interacting_sites = []
          if J[l, i, j, k] > 0:
            interacting_sites.append((i + (l+1)%N - 1) % N)
          elif J[l, i, j, k] < 0:
            interacting_sites.append((i + ((k-1)%2 - 1)) % N)
          
          for site in interacting_sites:
            total_spin[0] += h[site][j][k]
            if h[site][j][k] > 0:
              total_spin[1] -= 1
            else:
              total_spin[1] += 1
        
        priorities[i*N*N+j*k][0] = -total_spin[1]
        priorities[i*N*N+j*k][1] = total_spin[0]
  
  return(priorities)


#score: {'data3D.txt': -0.0028114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.zeros(2)
        
        for l in [0,1,2]:
          site_nbrs = [(i + ((k-1)%2 - 1)) % N]
          
          if J[0, i, j, k] > 0:
            site_nbrs.append((i + (l+1)%N - 1) % N)
          elif J[0, i, j, k] < 0:
            site_nbrs.append((i + ((k-1)%2 - 1)) % N)
          
          for site in site_nbrs:
            total_spin[0] += h[site][j][k]
            if h[site][j][k] > 0:
              total_spin[1] -= 1
            else:
              total_spin[1] += 1
        
        priorities[i*N*N+j*k][0] = -total_spin[0]*sum([J[l, i, j, k] for l in range(6)])
        priorities[i*N*N+j*k][1] = total_spin[1]
        
  return(priorities)


#score: {'data3D.txt': -0.002491}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((i-1)%2 - 1)) % N, (k + ((j-1)%2 - 1)) % N]
        interacting_spins_sum = sum([J[l][site_nbr[0]][site_nbr[1]][site_nbr[2]]*h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for l in range(6) for site_nbr in [tuple(map(lambda x: (x + ((x-1)%2 - 1)) % N, site_nbrs))] ])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0030026}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((i-1)%2 - 1)) % N, (k + ((j-1)%2 - 1)) % N]
        interacting_spins_sum = sum([J[l][site_nbr[0]][site_nbr[1]][site_nbr[2]]*h[site_nbr[0]][site_nbr[1]][site_nbr[2]] for l in range(6) for site_nbr in [(i, j, k)]])
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] += interacting_spins_sum
          priorities[i*N+j*k][1] -= 1
        else:
          priorities[i*N+j*k][0] -= interacting_spins_sum
          priorities[i*N+j*k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0096086}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          total_spin += interacting_spins[l][i][j][k]
          
        priorities[i*N*j+k][0] = -total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.0109422}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[site_nbr][j][k] > 0:
          total_spin += 3
        else:
          total_spin -= 3
          
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][0] = -total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
          
  return(priorities)


#score: {'data3D.txt': -0.0017090000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
    
    total_spin = 0
    for d in range(6):
      site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
      
      if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      
      if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        priorities[k][0] += 1
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0017090000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
    
    total_spin = 0
    for d in range(6):
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        total_spin += h[(site_nbrs[0] + ((k//N-1)%2 - 1)) % N][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[(site_nbrs[0] + ((k//N-1)%2 - 1)) % N][site_nbrs[1]][site_nbrs[2]]
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[k][0] += 1
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0017090000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**2):
    site_nbrs = [(k % N + ((k//N-1)%2 - 1)) % N,(k%N)//N,k%N]
    
    total_spin = h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    
    for d in range(6):
      site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        total_spin += interacting_spins[d][site_nbr][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= interacting_spins[d][site_nbr][site_nbrs[1]][site_nbrs[2]]
      
      if J[d, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[k][0] += 1
        priorities[k][1] -= 1
      else:
        priorities[k][0] -= 1
        priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0063458}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs = [(i//N)%N,(i%N)//N,i%N]
  
  total_spin = h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
  
  for i in range(N**3):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N,(i%N)//N,i%N]
    
    total_spin = h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]]
    
    for d in range(6):
      site_nbr = (site_nbrs[0] + ((site_nbrs[2]-1)%2 - 1)) % N
      
      if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        total_spin += h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      else:
        total_spin -= h[site_nbr][site_nbrs[1]][site_nbrs[2]]
      
      if J[d][site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': 0.0012705999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)
        
        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = total_spin + N**2 * 2
          priorities[i*N*j+k][1] = -total_spin - N**2 * 2
        else:
          priorities[i*N*j+k][0] = total_spin - N**2 * 2
          priorities[i*N*j+k][1] = -total_spin + N**2 * 2
  
  return(priorities)


#score: {'data3D.txt': -0.0015497999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          
          if J[l][i][j][k] > 0:
            priorities[i*N*j+k][0] += 1
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][0] -= 1
            priorities[i*N*j+k][1] += 1
        
        return(priorities)


#score: {'data3D.txt': 0.0014653999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = total_spin + N**2 * 2
          priorities[i*N*j+k][1] = -total_spin - N**2 * 2
        else:
          priorities[i*N*j+k][0] = total_spin - N**2 * 2
          priorities[i*N*j+k][1] = -total_spin + N**2 * 2
  
  return(priorities)


#score: {'data3D.txt': -0.0053138000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # update priorities based on site interactions and magnetism
        priority_total = np.zeros((N**3, 2))
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priority_total[i*N**2+j+k][0] += 1
          priority_total[i*N**2+j+k][1] -= 1
        else:
          priority_total[i*N**2+j+k][0] -= 1
          priority_total[i*N**2+j+k][1] += 1
        
        priorities[i*N**2+j+k][0] = priority_total[i*N**2+j+k][0]
        priorities[i*N**2+j+k][1] = priority_total[i*N**2+j+k][1]
  
  return(priorities)


#score: {'data3D.txt': -0.00017940000000000067}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][1] = -total_spin - h[site_nbr_i][j][k]
  
  return(priorities)


#score: {'data3D.txt': 0.0036654}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # Compute the total spin of the current site and its neighbors
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # Adjust the priority based on the magnetism and interaction
        priorities[i*N*j+k][0] = total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0018209999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # Calculate the spin from neighboring sites
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 2
          else:
            total_spin -= 2
        
        # Add the magnetism term
        priorities[i*N*j+k][0] = total_spin + h[i][j][k]
        
        # Set the priority based on the total spin and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0006593999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.000801}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0003778}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_l = (l // N * 2 + l % N)
          if site_nbr_i == site_nbr_j and site_nbr_i == site_nbr_k:
            continue
          
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        for l in range(6):
          site_nbr_l_2 = (l // N * 2 + l % N)
          if site_nbr_i == site_nbr_j and site_nbr_i == site_nbr_k:
            continue
          
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.006893000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.00016300000000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] = -(total_spin + 2)
        else:
          priorities[i*N*j+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0020250000000000003}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  
  total_spin = np.zeros((N,N,N))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i%N][i//N] += h[site_nbr][i%N]
    
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j,0] > 0:
          total_spin[i][j] += h[site_nbr][j]
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k,i,j,0] < 0:
          total_spin[i][j] -= h[site_nbr][j]
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      
      if J[0,i,j,0] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0,i,j,0] < 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0015306000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  total_spin = np.zeros((N,N,N))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i%N][i//N] += h[site_nbr][i%N]
    
  for i in range(6):
    if J[i][0][0][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif J[i][0][0][0] < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.004375400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(i//N+((k-1)%2 - 1))%N][site_nbrs[1]][site_nbrs[2]] for l,k in zip(range(6),range(3))])
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i] = [total_spin, -1]
    else:
      priorities[i] = [-total_spin, 1]
  
  return(priorities)


#score: {'data3D.txt': -0.004375400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(i//N+((k-1)%2 - 1))%N][site_nbrs[1]][site_nbrs[2]] for l,k in zip(range(6),range(3))])
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i] = [interacting_spins_sum, -1]
    else:
      priorities[i] = [-interacting_spins_sum, 1]
  
  return(priorities)


#score: {'data3D.txt': -0.003673}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    interacting_spins_sum = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] = interacting_spins_sum
      priorities[i][1] = -1
    else:
      priorities[i][0] = -interacting_spins_sum
      priorities[i][1] = 1
      
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0] + ((l-1)%3 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] += total_spin + 1
        priorities[i][1] -= 1 - total_spin
      else:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -1 - total_spin
    else:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0] + ((l-1)%3 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -1 - total_spin
      else:
        priorities[i][0] += total_spin + 1
        priorities[i][1] -= 1 - total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.0013662000000000004}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  for i in range(N**3):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0] + ((l-1)%3 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] += total_spin + 1
        priorities[i][1] -= 1 - total_spin
      else:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -1 - total_spin
    else:
      total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*h[(site_nbrs[0] + ((l-1)%3 - 1)) % N][site_nbrs[1]][site_nbrs[2]] for l in range(6)])
      if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
        priorities[i][0] -= total_spin + 1
        priorities[i][1] = -1 - total_spin
      else:
        priorities[i][0] += total_spin + 1
        priorities[i][1] -= 1 - total_spin
        
    # Calculate the priority for assigning spins to -1 and 1 based on site interactions and magnetism
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      spin_priority = -sum([abs(J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]) for l in range(6)])
    else:
      spin_priority = sum([abs(J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]) for l in range(6)])
    
    priorities[i][0] += spin_priority
    if J[0, site_nbrs[0], site_nbrs[1], site_nbrs[2]] > 0:
      priorities[i][1] -= spin_priority
    else:
      priorities[i][1] += spin_priority
    
  return(priorities)


#score: {'data3D.txt': -0.08531740000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
          
  for i in range(N):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    for j in range(N):
      total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
      if h[site_nbr][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
      else:
        priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.2347042000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': -0.09803740000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.35182660000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        
  site_nbr = (i + ((k-1)%2 - 1)) % N
  total_spin += h[site_nbr][j][k]
  
  if h[i][j][k] > 0:
    priorities[i*N*N+j*N+k][0] += 1
    priorities[i*N*N+j*N+k][1] -= 1
  else:
    priorities[i*N*N+j*N+k][0] -= 1
    priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.0028450000000000007}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_nbrs_map = [(i//N)%N,(i%N)//N,(i%N)%N]
  
  for i in range(N**3):
    site_nbrs = site_nbrs_map
    total_spin = sum([J[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]]*interacting_spins[l,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for l in range(6)])
    if h[site_nbrs[0]][site_nbrs[1]][site_nbrs[2]] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] += -total_spin
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0006930000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        if J[0][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
          total_spin += 1
        elif J[0][site_nbr_i][site_nbr_j][site_nbr_k] < 0:
          total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0021826}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin * 2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin - 1
        else:
          priorities[i*N*j+k][1] = total_spin + 1
  
  return(priorities)


#score: {'data3D.txt': 3.380000000000027e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((j-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][i][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][j][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0011006000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority_total = np.array([total_spin, -total_spin])
        
        priorities[i*N*j+k][0] = priority_total[0]
        priorities[i*N*j+k][1] = priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0015426000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.0010882000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_sum = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          site_nbr_sum += abs(J[l][site_nbr][j][k])
        
        priorities[i*N*j+k][0] = total_spin - site_nbr_sum
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin - site_nbr_sum
        else:
          priorities[i*N*j+k][1] = total_spin + site_nbr_sum
  
  return(priorities)


#score: {'data3D.txt': 0.0078614}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] += -total_spin * (h[i][j][k] > 0) + J[0][i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.00046180000000000044}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr = ((i + (l-1)%2 - 1)) % N
          site_nbr_j = ((j + (l-3)%2 - 1)) % N
          site_nbr_k = ((k + (l-5)%2 - 1)) % N
          
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin + J[0][i][j][k]
        else:
          priorities[i*N*j+k][1] = total_spin - J[0][i][j][k]
  
  return(priorities)


#score: {'data3D.txt': -0.0015810000000000002}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  total_spin = [[0, 0] for _ in range(N**3)]
  
  for k in range(6):
    site_nbrs = [(i//N)%N,(i%N)//N,(i%N)%N]
    for j in range(N):
      for i in range(N):
        if h[i][j][site_nbrs[2]] > 0:
          total_spin[i*N+j][1] += J[k, i, site_nbrs[0], j]
          total_spin[i*N+j][0] -= J[k, i, site_nbrs[0], j]
        else:
          total_spin[i*N+j][0] += J[k, i, site_nbrs[0], j]
          total_spin[i*N+j][1] -= J[k, i, site_nbrs[0], j]
          
  for i in range(N**3):
    if h[(i//N)%N][(i%N)//N][(i%N)%N] > 0:
      priorities[i][0] += -total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]
    else:
      priorities[i][0] = total_spin[i][0]
      priorities[i][1] = -total_spin[i][1]
      
  return(priorities)


#score: {'data3D.txt': -0.0015662000000000007}
program:
def priority(N, h, J):
  priorities = [[0 for _ in range(2)] for _ in range(N**3)]
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(6)]
  
  total_spin = np.zeros((N,N,N))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin[i][j] += h[k][i][j]
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i%N][i//N] += h[site_nbr][i%N]
    
  for k in range(6):
    for i in range(N):
      for j in range(N):
        if J[k,i,j,0] > 0:
          priorities[k*N+i*N+j][0] += 1
          priorities[k*N+i*N+j][1] -= 1
        elif J[k,i,j,0] < 0:
          priorities[k*N+i*N+j][0] -= 1
          priorities[k*N+i*N+j][1] += 1
          
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      
      if J[0,i,j,0] > 0:
        priorities[k*N+i*N+j][0] += 1
        priorities[k*N+i*N+j][1] -= 1
      elif J[0,i,j,0] < 0:
        priorities[k*N+i*N+j][0] -= 1
        priorities[k*N+i*N+j][1] += 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      
      if J[0,i,j,0] > 0:
        priorities[k*N+i*N+j][0] += 1
        priorities[k*N+i*N+j][1] -= 1
      elif J[0,i,j,0] < 0:
        priorities[k*N+i*N+j][0] -= 1
        priorities[k*N+i*N+j][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.0106342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += total_spin + sum(1 for val in interacting_spins if val < 0)
  
  return(priorities)


#score: {'data3D.txt': 0.0106342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                  J[3,(i+1)%N,j,k], J[4,i,j,k],
                  J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.2367194000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = [0, 0]
        site_nbr = i*N*N + j*N + k
        for l in range(6):
          if J[l,i,j,k] > 0:
            total_spin[1] += 1
            total_spin[0] -= 1
          else:
            total_spin[1] -= 1
            total_spin[0] += 1
        if h[i][j][k] > 0:
          priorities[i,j,k,0] = -total_spin[0]
          priorities[i,j,k,1] = total_spin[0]
        else:
          priorities[i,j,k,0] = total_spin[0]
          priorities[i,j,k,1] = -total_spin[0]
  return priorities.reshape(N*N*N, 2)


#score: {'data3D.txt': -0.3276881999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3276881999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': 0.33581500000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(val for val in interacting_spins if val < 0) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0008609999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]

        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = total_spin + 1
          priorities[i*N*j+k][1] = -total_spin - 1
        else:
          priorities[i*N*j+k][0] = -total_spin - 1
          priorities[i*N*j+k][1] = total_spin + 1

  return(priorities)


#score: {'data3D.txt': -0.00013580000000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # calculate site interactions
        for l in range(6):
          site_nbr_i = (i + ((l-1)%3 - 1)) % N
          site_nbr_j = (j + ((l-2)%3 - 1)) % N
          site_nbr_k = (k + ((l-3)%3 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.0029925999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin

        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
      
      return(priorities)


#score: {'data3D.txt': -0.3646078000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + J[4,i,site_nbr,k]
        
  return(priorities)


#score: {'data3D.txt': -0.11139700000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[5,i,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[5,i,j,k]] if val > 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[4,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.007065399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in J[::,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in J[::,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site = sum(J[d,i,j,site_nbr] for d in [3,4,5])
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= total_spin_site + len([val for val in J[::,i,j,site_nbr] if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin_site
        else:
          priorities[i*N*N+j*N+k][0] += total_spin_site - len([val for val in J[::,i,j,site_nbr] if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin_site
        
  return(priorities)


#score: {'data3D.txt': -0.032797799999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in J[::,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum - J[3,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in J[::,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum + J[5,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.37157900000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[::,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in J[::,i,j,k] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[::,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] += sum(1 for val in J[::,i,j,k] if val > 0)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.3329026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[::,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[::,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': -0.0011934000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i = (i + ((j-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -9.220000000000006e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr_k = (i + ((j-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr_k][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': 4.099999999999926e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0018209999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 2
          else:
            total_spin -= 2
        
        priorities[i*N*j+k][0] = total_spin + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.00019380000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        priorities[i*N*j+k][0] = total_spin + h[site_nbr][j][k]
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.005251}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = np.sum(np.where(J[0][site_nbr_i][j][k] > 0, [1], [-1]))
        total_spin += np.sum(np.where(J[1][i][site_nbr_j][k] > 0, [1], [-1]))
        total_spin += np.sum(np.where(J[2][i][j][site_nbr_k] > 0, [1], [-1]))
        
        for l in range(3):
          if J[l+3][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * (total_spin > 0)
        else:
          priorities[i*N*j+k][1] += 2 * (total_spin > 0)
  
  return(priorities)


#score: {'data3D.txt': -0.007363}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = np.sum(h[site_nbr_i][j][k] * J[:, site_nbr_i, j, k]) \
              + np.sum(h[site_nbr_j][i][k] * J[:, i, site_nbr_j, k]) \
              + np.sum(h[site_nbr_k][i][j] * J[:, i, j, site_nbr_k])
        
        priorities[i*N*j+k][0] = -total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': 3.460000000000063e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * (total_spin > 0)
        else:
          priorities[i*N*j+k][1] += 2 * (total_spin > 0)

  return(priorities)


#score: {'data3D.txt': -0.0036854000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * (total_spin > 0)
        else:
          priorities[i*N*j+k][1] += 2 * (total_spin > 0)
  
  return(priorities)


#score: {'data3D.txt': -0.0036502000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][i][site_nbr_i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][j][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin * 2
    
    for i in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      
      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] -= total_spin
      else:
        priorities[i*N*j+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0039754000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N
          
          if h[site_nbr1][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr2][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
    
    if h[i][j][k] > 0:
      priorities[i*N*j+k][1] = -1 - total_spin
    else:
      priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.012938199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        priorities[i*N*j+k][1] = -total_spin
    
  return(priorities)


#score: {'data3D.txt': -0.0023374}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(27): # 6 neighbors per site
        site_nbr = ((k%2) % N + (k//2)%2 - 1) % N
        if h[site_nbr][i][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        for l in range(6):
          if J[l][site_nbr][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
      priorities[i*N*j+k%18][0] = -total_spin
    
      if h[i][j][k%3] > 0:
        priorities[i*N*j+k%18][1] -= 2
      else:
        priorities[i*N*j+k%18][1] += 2
      
  return(priorities)


#score: {'data3D.txt': -0.24023060000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)


#score: {'data3D.txt': -0.28721380000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        if i > 0:
          interacting_spins.append(J[3,(i-1)%N,j,k])
        if j > 0:
          interacting_spins.append(J[4,i,(j-1)%N,k])
        if k > 0:
          interacting_spins.append(J[5,(i+1)%N,(j+1)%N,(k-1)%N])
        interacting_spins += [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.1244402}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.09800860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[4,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[5,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.24030980000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) + J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) + J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - J[4,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': -0.0021022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin = h[i][site_nbr_i][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N
          
          if h[site_nbr1][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr2][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((j-1)%2 - 1)) % N
      site_nbr_j = (j + ((i-1)%2 - 1)) % N
      
      if h[site_nbr_i][i][j] > 0:
        total_spin = 1
      else:
        total_spin = -1
      
      for k in range(N):
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        if J[3][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0040558}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N

        total_spin = h[i][j][k]

        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N

          if h[site_nbr1][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr2][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2
  
  if h[i][j][k] > 0:
    priorities[i*N*j+k][1] = -1 - total_spin
  else:
    priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0035902}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # Calculate spin priority based on magnetism and nearest neighbors
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr1][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr2][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr3][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][0] = -total_spin*2
        
        # Adjust spin priority based on magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': 0.0033686}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N
          
          if h[site_nbr1][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr2][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
  
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N
      
      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2656042}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i,j,k][0] += 1
          priorities[i,j,k][1] -= 1
        else:
          priorities[i,j,k][0] -= 1
          priorities[i,j,k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if interacting_spins[l,i,j,k] > 0:
            priorities[i,j,k][0] -= J[l,i,j,k]
            priorities[i,j,k][1] += 2*J[l,i,j,k]
          else:
            priorities[i,j,k][0] += J[l,i,j,k]
            priorities[i,j,k][1] -= 2*J[l,i,j,k]

  return(priorities.flatten().reshape(N*N*N,2))


#score: {'data3D.txt': -0.0035118000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[0,i,site_nbr,j], J[1,i,(j+1)%N,j], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,site_nbr,j], J[4,i,site_nbr,j],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.001162199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[0,i,site_nbr,j], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.13898060000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[d,i,site_nbr,j] for d in range(6) if abs(d-k) == 1 or abs(d-k) == 5]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[k,i,site_nbr,j]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[k,i,site_nbr,j]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.0014642000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[site_nbr_i][j][k]

        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N

        if h[site_nbr1][i][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        if h[site_nbr2][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        if h[site_nbr3][i][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2

  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N

      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0046521999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N

        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2
        
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N
      
      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0034046000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0390162}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += sum([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.0139134}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] * (h[site_nbr][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                 J[3,(i+1)%N,j,k], J[4,i,j,k],
                 J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.33829419999999966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0]) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0]) - sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0]) - sum(abs(val) for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.001162199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[0,i,site_nbr,j], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.08799140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[0,i,site_nbr,j], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_energy - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': 0.2569330000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(abs(val) for val in interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(abs(val) for val in interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin - sum(abs(val) for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': 0.144373}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] * h[site_nbr][j][k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.0230046}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N**2):
    site_nbr = ((i % N) + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][i//N] > 0:
      priorities[i//N][i%N][i//N][0] += 1
      priorities[i//N][i%N][i//N][1] -= 1
    else:
      priorities[i//N][i%N][i//N][0] -= 1
      priorities[i//N][i%N][i//N][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if interacting_spins[l,i,j,k] > 0:
            priorities[i][j][k][0] -= J[l,i,j,k]
            priorities[i][j][k][1] += 2*J[l,i,j,k]
          else:
            priorities[i][j][k][0] += J[l,i,j,k]
            priorities[i][j][k][1] -= 2*J[l,i,j,k]

  return(priorities.flatten().reshape(N*N*N,2))


#score: {'data3D.txt': -0.3117553999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin = sum(h[i][j][p] for p in range(6)) - 1
        else:
          total_spin = sum(h[i][j][p] for p in range(6))
        priorities[i*N*N + j*N + k][0] += total_spin
        priorities[i*N*N + j*N + k][1] -= 2 if h[i][j][k] > 0 else -2
  return priorities


#score: {'data3D.txt': -0.32384300000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin + J[5,i,site_nbr,k]
        
  return(priorities)


#score: {'data3D.txt': -0.06880540000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.43160900000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': 0.0005541999999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N**3):
    for l in range(6):
      priorities[i][0] += -J[l,i//N%N,i%N,i//N//N]*interacting_spins[l,i//N%N,i%N,i//N//N]
      priorities[i][1] += J[l,i//N%N,i%N,i//N//N]*interacting_spins[l,i//N%N,i%N,i//N//N]
  return(priorities)


#score: {'data3D.txt': 0.3425773999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  
  # Calculate interacting_spins for each direction (x, y, z)
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  
  interacting_spins = [interacting_spins_x, interacting_spins_y, interacting_spins_z]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[i,j,k][0] = -1
          priorities[i,j,k][1] = 1
        else:
          priorities[i,j,k][0] = 1
          priorities[i,j,k][1] = -1
  
  for i in range(3):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[j,k][0] += J[i, i, j, k]*-1
          priorities[j,k][1] -= J[i, i, j, k]
        else:
          priorities[j,k][0] += J[i, i, j, k]
          priorities[j,k][1] -= J[i, i, j, k]
  
  for i in range(3):
    for j in range(N):
      for k in range(N):
        if h[i,j,k] > 0:
          priorities[j,k][0] += J[3+i, 3+i, j, k]*-1
          priorities[j,k][1] -= J[3+i, 3+i, j, k]
        else:
          priorities[j,k][0] += J[3+i, 3+i, j, k]
          priorities[j,k][1] -= J[3+i, 3+i, j, k]
  
  return(priorities.reshape(N*N*N,2))


#score: {'data3D.txt': -0.06880540000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': 0.024175000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for d in [3,4,5]:
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.1068202}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        
        for d in range(6):
          site = (i + ((d-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.012938199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority = -total_spin*2
        priorities[i*N*j+k][0] = priority
        priorities[i*N*j+k][1] = -priority
  
  return(priorities)


#score: {'data3D.txt': 0.007337799999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N
        
        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][i][j] > 0:
            priorities[i*N*j+k][0] += 1
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][0] -= 1
        
        site_nbr = (j + ((k-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][i][k] > 0:
            priorities[i*N*j+k][0] += 1
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][0] -= 1
        
        site_nbr = (i + ((j-1)%2 - 1)) % N
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            priorities[i*N*j+k][0] += 1
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][0] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.0060474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0012866000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for m in range(N):
          if h[site_nbr][m][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = -total_spin*2
        
  return(priorities)


#score: {'data3D.txt': -0.0046521999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N
      
      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -2.9799999999999938e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[i][j][k]

        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbr = (i + ((k-1)%2 - 1)) % N
        for x in range(3):
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = total_spin * 2
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin

  return(priorities)


#score: {'data3D.txt': -0.0045934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin * (h[i][j][k] + np.sum(np.where(J[0][i][j][k] > 0, [1], [-1])) +
                                np.sum(np.where(J[1][i][j][k] > 0, [1], [-1])) +
                                np.sum(np.where(J[2][i][j][k] > 0, [1], [-1])))
          priorities[i*N*j+k][1] = -1
        else:
          priorities[i*N*j+k][0] = total_spin * (h[i][j][k] + np.sum(np.where(J[0][i][j][k] > 0, [1], [-1])) +
                                np.sum(np.where(J[1][i][j][k] > 0, [1], [-1])) +
                                np.sum(np.where(J[2][i][j][k] > 0, [1], [-1])))
          priorities[i*N*j+k][1] = 1
        
  return(priorities)


#score: {'data3D.txt': -0.003791800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Calculate the total spin from the nearest neighbors
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # Calculate the priority based on the total spin and magnetism
        priorities[i*N*j+k][0] = -total_spin*2 - h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0008406000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += np.sum(np.where(J[0][i][j][k] > 0, [1], [-1]))
            total_spin += np.sum(np.where(J[1][i][site_nbr2][site_nbr3] > 0, [1], [-1]))
            total_spin += np.sum(np.where(J[2][site_nbr1][j][k] > 0, [1], [-1]))
          else:
            total_spin -= np.sum(np.where(J[0][i][j][k] > 0, [1], [-1]))
            total_spin -= np.sum(np.where(J[1][i][site_nbr2][site_nbr3] > 0, [1], [-1]))
            total_spin -= np.sum(np.where(J[2][site_nbr1][j][k] > 0, [1], [-1]))
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0034046000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0390162}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += sum([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.007246600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.33581500000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                      J[3,(i+1)%N,j,k], J[4,i,j,k],
                      J[5,(i+1)%N,(j+1)%N,(k+1)%N]])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(val for val in interacting_spins if val < 0) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.29402620000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + J[3,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.004130599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        if J[5,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.22428380000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[3,i,j,k], J[4,i,j,k], J[5,i,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.22558100000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0]) - J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0]) + J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0]) + J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0]) - J[5,i,j,k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[4,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': -0.1935882000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        total_spin = sum(J[k,i,j,k] for _ in range(N))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += sum(J[d,site_nbr,j,k] for d in range(3))
        
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.03705619999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        if k < 3:
          interacting_spins.extend([J[d,i,site_nbr,j] for d in [0,1,2]])
        else:
          interacting_spins.extend([J[5,i,site_nbr,(j+1)%N], J[4,i,j,(k-3)%N+1]])
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_energy - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.1967038000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,j,site_nbr] for _ in range(N))
        
        interacting_spins = [J[0,i,j,k], J[1,i,j,(k+1)%N], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.06350499999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(val < 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(val > 0 for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(val < 0 for val in interacting_spins)
  
  return(priorities)


#score: {'data3D.txt': -0.0641086}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(3)]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= sum(val > 0 for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += sum(val < 0 for val in interacting_spins)
  
  return(priorities)


#score: {'data3D.txt': -0.38925540000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        interacting_spins = [J[3,i,j,k], J[4,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(val for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum(val for val in interacting_spins)
        
  return(priorities)


#score: {'data3D.txt': 0.027089799999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        interacting_spins = [J[3,i,j,k], J[4,i,site_nbr,k]]
        if J[5,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum([J[d,i,site_nbr,k] for d in [3,4]])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin - sum([J[d,i,site_nbr,k] for d in [3,4]])
  return(priorities)


#score: {'data3D.txt': -0.2206062}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        interacting_spins = [J[3,i,j,k], J[4,i,j,k]]
        if np.sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin + J[5,i,j,k]
  return(priorities)


#score: {'data3D.txt': 0.0012713999999999991}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin
        
        site_nbr2 = (i + ((k+1)%2 - 1)) % N
        if J[0][site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 1
        else:
          priorities[i*N*j+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': -0.006884599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
   site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
   total_spin = 0
   if h[site_nbr][k%N][k//N%N] > 0:
     total_spin += 1
   else:
     total_spin -= 1

   for l in range(6):
    if J[l][site_nbr][k%N][k//N%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
   priorities[k][0] = -total_spin
   
   if h[site_nbr][k%N][k//N%N] > 0:
     priorities[k][1] -= 2
   else:
     priorities[k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0009226000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  # Calculate total spin and priority for each site
  for k in range(N**3):
    i, j, l = (k // N) % N, (k // (N*N)) % N, k % N
    total_spin = 0
    for m in range(6): 
      site_nbr = ((l-1)%2 - 1) % N
      if J[m][site_nbr][j][i] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[k][0] = total_spin

  # Add the interactions between the site and its nearest neighbors
  for k in range(N**3):
    i, j, l = (k // N) % N, (k // (N*N)) % N, k % N
    site_nbr = ((l-1)%2 - 1) % N
    if J[0][site_nbr][j][i] > 0:
      priorities[k][1] -= 1
    else:
      priorities[k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.08604220000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + (pos_interactions + J[4,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] -= neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - (neg_interactions + J[4,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] += pos_interactions + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.30893699999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
        
  return(priorities)


#score: {'data3D.txt': -0.23085980000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(3)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
        
  return(priorities)


#score: {'data3D.txt': -0.3176741999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] + 3*J[3,i,(i+(k-1)%2 - 1)%N,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
        
  return(priorities)


#score: {'data3D.txt': 0.0014769999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)
        
        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = total_spin + N**2 * 3
          priorities[i*N*j+k][1] = -total_spin - N**2 * 3
        else:
          priorities[i*N*j+k][0] = total_spin - N**2 * 3
          priorities[i*N*j+k][1] = -total_spin + N**2 * 3
  
  return(priorities)


#score: {'data3D.txt': 0.001219799999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0

        # calculate site interactions
        for l in range(6):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if J[l][site_nbr][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)

        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = total_spin + N**2 * 2
          priorities[i*N*j+k][1] = -total_spin - N**2 * 2
        else:
          priorities[i*N*j+k][0] = total_spin - N**2 * 2
          priorities[i*N*j+k][1] = -total_spin + N**2 * 2

  return(priorities)


#score: {'data3D.txt': -0.0006718000000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)
        
        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin - N**2 * 2
          priorities[i*N*j+k][1] = total_spin + N**2 * 2
        else:
          priorities[i*N*j+k][0] = -total_spin + N**2 * 2
          priorities[i*N*j+k][1] = total_spin - N**2 * 2
  
  return(priorities)


#score: {'data3D.txt': 0.0014745999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)
        
        # update priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin + N**2 * 3
          priorities[i*N*j+k][1] = total_spin - N**2 * 3
        else:
          priorities[i*N*j+k][0] = total_spin - N**2 * 3
          priorities[i*N*j+k][1] = -total_spin + N**2 * 3
  
  return(priorities)


#score: {'data3D.txt': 0.0007818000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    total_spin = h[site[0]][site[1]][site[2]]
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        total_spin += -J[l][site[0]][site[1]][site[2]] * interacting_spins[l][site[0]][site[1]][site[2]]
    
    priorities[k][0] = -total_spin
    priorities[k][1] = 1 - 2 * (total_spin > 0)
  
  return priorities


#score: {'data3D.txt': -0.0642746}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        for d in [0,1,2]:
          if (i+d)%N == i:
            interacting_spins.append(J[d,i,j,k])
          if (j+d)%N == j:
            interacting_spins.append(J[3+d,i,j,k])
          if (k+d)%N == k:
            interacting_spins.append(J[5+d,(i+d)%N,(j+d)%N,(k+d)%N])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0458814}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                  J[3,(i+1)%N,j,k], J[4,i,j,k],
                  J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        interacting_spins.sort()
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(val for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += total_spin + sum(val for val in interacting_spins if val < 0)
  
  return(priorities)


#score: {'data3D.txt': 0.20007979999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                  J[3,(i+1)%N,j,k], J[4,i,j,k],
                  J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_priority = abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        magnetism_priority = h[i][j][k]
        
        if total_spin >= 0:
          priorities[i*N*N+j*N+k][1] -= spin_priority + magnetism_priority
          priorities[i*N*N+j*N+k][0] += spin_priority - magnetism_priority
        else:
          priorities[i*N*N+j*N+k][0] -= spin_priority - magnetism_priority
          priorities[i*N*N+j*N+k][1] += spin_priority + magnetism_priority
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - pos_interactions
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + neg_interactions
  
  return(priorities)


#score: {'data3D.txt': -0.30523659999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
        
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        # Calculate the priority based on the magnetism and interaction strength
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + 2*pos_interactions + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + 2*neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + 2*pos_interactions + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + 2*neg_interactions - J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.00013700000000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    total_spin = h[site[0]][site[1]][site[2]]
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        interacting_spin = 1 - 2 * (h[(site[0] + ((l-1)%3 - 1)) % N][site[1]][site[2]])
        total_spin += -J[l][site[0]][site[1]][site[2]] * interacting_spin

    priorities[k][0] = -total_spin
    priorities[k][1] = 1 - 2 * (total_spin > 0)

  return priorities


#score: {'data3D.txt': -0.0016745999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    total_spin = h[site[0]][site[1]][site[2]]
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        total_spin += -J[l][site[0]][site[1]][site[2]] * interacting_spins[l][site[0]][site[1]][site[2]]
    
    priorities[k][0] = -total_spin
    if total_spin > 0:
      priorities[k][1] = 1
    elif total_spin < 0:
      priorities[k][1] = -1
    else:
      priorities[k][1] = np.random.choice([-1, 1])
  
  return priorities


#score: {'data3D.txt': -5.099999999999993e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    total_spin = 0
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        total_spin += -J[l][site[0]][site[1]][site[2]] * h[(site[0] + ((l // 4) % 2) - 1) % N][site[1]][site[2]]
    
    priorities[k][0] = -total_spin
    priorities[k][1] = 1 - 2 * (total_spin > 0)
  
  return priorities


#score: {'data3D.txt': -0.0030266000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N+j*k][0] = -sum(sum(J[:,i,j,k]*interacting_spins[:,i,j,k]) for l in range(6))
        else:
          priorities[i*N+j*k][1] = -sum(sum(J[:,i,j,k]*interacting_spins[:,i,j,k]) for l in range(6)) 
  return(priorities)


#score: {'data3D.txt': -0.2656042}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,N,2))
  for k in range(N):
    site_nbr = (k + ((k-1)%2 - 1)) % N
    for i in range(N):
      for j in range(N):
        total_spin[i,j,k][0] += h[site_nbr][i][j]
        if h[i][j][k] > 0:
          total_spin[i,j,k][0] -= 1
          total_spin[i,j,k][1] += 1
        else:
          total_spin[i,j,k][0] += 1
          total_spin[i,j,k][1] -= 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i,j,k][0] += 1
          priorities[i,j,k][1] -= 1
        else:
          priorities[i,j,k][0] -= 1
          priorities[i,j,k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if interacting_spins[l,i,j,k] > 0:
            priorities[i,j,k][0] -= J[l,i,j,k]
            priorities[i,j,k][1] += 2*J[l,i,j,k]
          else:
            priorities[i,j,k][0] += J[l,i,j,k]
            priorities[i,j,k][1] -= 2*J[l,i,j,k]

  return(priorities.flatten().reshape(N*N*N,2))


#score: {'data3D.txt': -0.0604254}
program:
def priority(N, h, J):
  priorities = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] if j < N//2 else -h[site_nbr][N-j-1]
        if h[i][j][k] > 0:
          priorities[i,j,k][0] += 1
          priorities[i,j,k][1] -= 1
        else:
          priorities[i,j,k][0] -= 1
          priorities[i,j,k][1] += 1
        
        for l in range(6):
          site_nbr = ((i + (k-1)%2 - 1)) % N if l < 3 else ((i + ((l-4)%2 - 1)) % N)
          total_spin += h[site_nbr][j] if j < N//2 else -h[site_nbr][N-j-1]
          if h[i][j][k] > 0:
            priorities[i,j,k][0] -= J[l,i,j,k]
            priorities[i,j,k][1] += 2*J[l,i,j,k]
          else:
            priorities[i,j,k][0] += J[l,i,j,k]
            priorities[i,j,k][1] -= 2*J[l,i,j,k]
  return(priorities.flatten().reshape(N*N*N,2))


#score: {'data3D.txt': -0.0008606000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    
    total_spin_plus = 0
    total_spin_minus = 0
    
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        total_spin_plus += -J[l][site[0]][site[1]][site[2]] * h[(site[0] + ((l // 4) % 2) - 1) % N][site[1]][site[2]]
        total_spin_minus -= J[l][site[0]][site[1]][site[2]] * h[(site[0] + ((l // 4) % 2) - 1) % N][site[1]][site[2]]
    
    priorities[k][0] = -total_spin_plus
    priorities[k][1] = total_spin_minus
  
  return priorities


#score: {'data3D.txt': -5.099999999999993e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    total_spin = 0
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        site_nbr = (site[0] + ((l // 4) % 2) - 1) % N
        total_spin += -J[l][site[0]][site[1]][site[2]] * h[site_nbr][site[1]][site[2]]
    
    priorities[k][0] = -total_spin
    priorities[k][1] = 1 - 2 * (total_spin > 0)
  
  return priorities


#score: {'data3D.txt': -0.0010114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N**3):
    site = tuple(k // (N ** i) % N for i in range(3))
    
    total_spin = 0
    for l in range(6):
      if J[l][site[0]][site[1]][site[2]]:
        total_spin += -J[l][site[0]][site[1]][site[2]] * h[(site[0] + ((l // 4) % 2) - 1) % N][site[1]][site[2]]
    
    site_nbr = (site[0] + ((k%N-1)%2 - 1)) % N
    if total_spin > 0:
      priorities[k][0] += 1
      priorities[k][1] -= 1
    else:
      priorities[k][0] -= 1
      priorities[k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.005219000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        for dir, site_nbr in zip(['x', 'y', 'z'], [site_nbr_i, site_nbr_j, site_nbr_k]):
          if h[site_nbr][j//2**(N-1)][k//2**(N-1)] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N**2+j+k][0] = -total_spin*2
        
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N**2+j+k][1] = -1 - total_spin
      else:
        priorities[i*N**2+j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2811634000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [3,4,5]) + h[i][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(val for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum(val for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': 0.20085660000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins])
          priorities[i*N*N+j*N+k][1] -= np.sum([val for val in interacting_spins]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([-val for val in interacting_spins])
          priorities[i*N*N+j*N+k][1] += np.sum([val for val in interacting_spins]) + J[3,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.1115886}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += 2
        
        for l in range(6):
          site_nbr = (i + ((l-1)%3 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N + j*N + k][0] -= J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] += 2*J[l,i,j,k]
          else:
            priorities[i*N*N + j*N + k][0] += J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] -= 2*J[l,i,j,k]
        
  return priorities


#score: {'data3D.txt': -0.0058557999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= 2
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += 2
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N*N + j*N + k][0] -= 2*J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] += J[l,i,j,k]
          else:
            priorities[i*N*N + j*N + k][0] += 2*J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] -= J[l,i,j,k]
  return priorities


#score: {'data3D.txt': 0.21433660000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        # Calculate the priority based on the magnetism and interaction strength
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + 2*pos_interactions
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) - neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + 2*pos_interactions
          priorities[i*N*N+j*N+k][1] += abs(total_spin) - neg_interactions
  
  return(priorities)


#score: {'data3D.txt': 0.05173099999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        # Calculate the priority based on the magnetism and interaction strength
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        # Calculate the priority based on the magnetism and interaction strength
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + 2*pos_interactions
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + 2*neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + 2*pos_interactions
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + 2*neg_interactions
        
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        # Calculate the priority based on the magnetism and interaction strength
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + 2*pos_interactions + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + 2*neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + 2*pos_interactions + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + 2*neg_interactions - J[4,i,site_nbr,k]

  return(priorities)


#score: {'data3D.txt': 0.0033686}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N
          
          if h[site_nbr1][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr2][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if h[site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N
      
      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.005122600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        for l in range(6):
          site_nbr1 = (i + ((l%2-1) % N)) % N
          site_nbr2 = (j + ((l//2)%2-1)) % N
          site_nbr3 = (k + ((l//2)%2-1)) % N
          
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          priorities[i*N*j+k][0] = -total_spin*3
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -2-total_spin
        else:
          priorities[i*N*j+k][1] = 2+total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0011426000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        
        if h[site_nbr_i][j][k] > 0:
          total_spin += 3
        else:
          total_spin -= 3
          
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        if h[site_nbr_i][j][k] > 0:
          total_spin += 3
        else:
          total_spin -= 3
          
        if h[i][site_nbr_j][k] > 0:
          total_spin += 3
        else:
          total_spin -= 3
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': 0.0033686}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin += h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N
          
          if h[site_nbr1][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if h[site_nbr2][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if h[site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = -total_spin*2
        
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N
      
      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2840654000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0]) + J[3,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + len([val for val in interacting_spins if val > 0]) - J[3,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr,k]
  return(priorities)


#score: {'data3D.txt': -0.14998100000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.3176741999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
  return(priorities)


#score: {'data3D.txt': -0.0637054}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= 2 * np.sum([J[l, i, j, k] for l in [0, 3]])
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += 2 * np.sum([J[l, i, j, k] for l in [1, 4]])
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] -= np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N*N + j*N + k][1] += J[5, i, j, k]
        else:
          priorities[i*N*N + j*N + k][0] += np.sum([J[l, i, j, k] for l in [0, 3]])
          priorities[i*N*N + j*N + k][1] -= J[5, i, j, k]
  return priorities


#score: {'data3D.txt': -0.0084578}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= 3
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += 3
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N*N + j*N + k][0] -= 2*J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] += J[l,i,j,k]
          else:
            priorities[i*N*N + j*N + k][0] += 2*J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] -= J[l,i,j,k]
  return priorities


#score: {'data3D.txt': -0.27729620000000044}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)]) 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6
  return(priorities)


#score: {'data3D.txt': -0.002577}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [0,1,2]]
      total_spin = sum([h[site_nbr][j][k] for site_nbr, k in zip(site_nbrs, [0,1,2])]) + h[i][j][0]
      if h[i][j][0] > 0:
        priorities[i*N*N + j*N + 0][0] += total_spin
        priorities[i*N*N + j*N + 0][1] -= 3
      else:
        priorities[i*N*N + j*N + 0][0] -= total_spin
        priorities[i*N*N + j*N + 0][1] += 3
      for l in range(6):
        if J[l,i,j,0] > 0:
          priorities[i*N*N + j*N + 0][0] -= 2*J[l,i,j,0]
          priorities[i*N*N + j*N + 0][1] += J[l,i,j,0]
        else:
          priorities[i*N*N + j*N + 0][0] += 2*J[l,i,j,0]
          priorities[i*N*N + j*N + 0][1] -= J[l,i,j,0]
  return priorities


#score: {'data3D.txt': -0.3972190000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for p in [0,1,2]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.3284425999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)]) 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.0288666}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)]) 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i+1)%N, (i+N-1)%N]
        total_spin = h[i][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[p][j][k] for p in site_nbrs]) 
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6
  
  return(priorities)


#score: {'data3D.txt': 0.03144979999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k] 
        if J[5, i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 * sum([J[l, i, j, k] for l in [1, 4]])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 2 * sum([J[l, i, j, k] for l in [0, 3]])
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(i+1)%N, (i+N-1)%N]
        site_nbrs_z = [(j + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = h[i][j][k] + sum([J[l,i,j,k] for l in [5]]) + sum([h[site_nbr][j][k] for site_nbr in site_nbrs_y]) + sum([h[site_nbr][j][k] for site_nbr in site_nbrs_x]) + sum([h[site_nbr][j][k] for site_nbr in site_nbrs_z])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 8
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 8
  return(priorities)


#score: {'data3D.txt': -0.056504599999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = h[i][j][k] + sum([J[d,i,j,k] for d in [0,1,2]])
        for p in site_nbrs:
          total_spin += h[p][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= sum([J[l,i,j,k] for l in [0,3]])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += sum([J[l,i,j,k] for l in [1,4]])
  return priorities


#score: {'data3D.txt': -0.0286166}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin + np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N*N + j*N + k][1] -= 2 * np.sum([J[l, i, j, k] for l in [0, 3]]) - J[5, i, j, k]
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin + np.sum([J[l, i, j, k] for l in [1, 4]])
          priorities[i*N*N + j*N + k][1] += 2 * np.sum([J[l, i, j, k] for l in [0, 3]]) + J[5, i, j, k]
  return priorities


#score: {'data3D.txt': 0.06614780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[0,i,site_nbr,j], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  # Symmetrize the priority values
  priorities[:,0] = (priorities[:,0] + priorities[:,1]) / 2
  priorities[:,1] = (priorities[:,0] - priorities[:,1]) / 2
  
  return(priorities)


#score: {'data3D.txt': -0.001162199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[0,i,site_nbr,j], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.0006889999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.012601}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N

        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2
        
  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N

      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.001401000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[site_nbr_i][j][k]

        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N

        if h[site_nbr1][i][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        if h[site_nbr2][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        if h[site_nbr3][i][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2

  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N

      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin

  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N

      if h[i][site_nbr_i][k] > 0:
        priorities[i*N*j+k][1] -= 1
      else:
        priorities[i*N*j+k][1] += 1

      if h[j][site_nbr_j][k] > 0:
        priorities[i*N*j+k][1] -= 1
      else:
        priorities[i*N*j+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0020142000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # calculate site interactions
        for l in range(6):
          site_nbr_i = (i + ((l-1)%3 - 1)) % N
          site_nbr_j = (j + ((l-2)%3 - 1)) % N
          site_nbr_k = (k + ((l-3)%3 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += h[site_nbr_i][site_nbr_j][site_nbr_k]
          else:
            total_spin -= h[site_nbr_i][site_nbr_j][site_nbr_k]
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.003438200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((l-1)%2 - 1)) % N for l in [0, 1, 2, 4, 5]]
        total_spin = sum(h[site_nbr][j][k] for site_nbr in site_nbrs)
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin
        else:
          priorities[i*N*j+k][1] = total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0021482}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((l-1)%2 - 1)) % N
          site_nbr_j = (j + ((l-2)%2 - 1)) % N
          site_nbr_k = (k + ((l-3)%2 - 1)) % N
            
          total_spin += J[l][site_nbr_i][site_nbr_j][site_nbr_k] * h[site_nbr_i][site_nbr_j][site_nbr_k]
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin
          priorities[i*N*j+k][1] -= total_spin
        else:
          priorities[i*N*j+k][0] = total_spin
          priorities[i*N*j+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.005910200000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
            
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            priorities[i*N*j+k][0] += 1
            priorities[i*N*j+k][1] -= 1
          else:
            priorities[i*N*j+k][0] -= 1
            priorities[i*N*j+k][1] += 1
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.0007298000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        for l in range(6):
          site_nbr_i_2 = (i + ((l%3-1)%N)) % N
          site_nbr_j_2 = (j + ((k-1)%2 - 1)) % N
          site_nbr_k_2 = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin

        for l in range(6):
          site_nbr_i_3 = (i + ((l%3-1)%N)) % N
          site_nbr_j_3 = (j + ((k-1)%2 - 1)) % N
          site_nbr_k_3 = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i_3][site_nbr_j_3][site_nbr_k_3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][1] = -total_spin - h[site_nbr_i][j][k]

  return(priorities)


#score: {'data3D.txt': 0.0010937999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # calculate site interactions
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # magnetism based prioritization
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.007886200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # calculate site interactions
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
          
          if J[l][i][j][k] > 0:
            priorities[i*N*j+k][0] -= 1
            priorities[i*N*j+k][1] += 1
          else:
            priorities[i*N*j+k][0] += 1
            priorities[i*N*j+k][1] -= 1
        
        # calculate magnetism contribution
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] += 1
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][0] -= 1
          priorities[i*N*j+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.0045366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_sum = 0

        # calculate site interactions
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          site_nbr_sum += h[site_nbr][j][k]
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        # calculate magnetism contribution
        total_spin += h[i][j][k]

        priorities[i*N*j+k][0] = -total_spin*2
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.13898060000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[d,i,site_nbr,j] for d in range(6) if abs(d-k) == 1 or abs(d-k) == 5]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[k,i,site_nbr,j]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[k,i,site_nbr,j]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.13898060000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[d,i,site_nbr,j] for d in range(6) if abs(d-k) == 1 or abs(d-k) == 5]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        site_h = h[i][j][k]
        if site_h > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[k,i,site_nbr,j]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[k,i,site_nbr,j]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.13898060000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        interacting_spins = [J[d,i,site_nbr,j] for d in range(6) if abs(d-k) == 1 or abs(d-k) == 5]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        spin_magnetism = h[i][j][k]
        if spin_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[k,i,site_nbr,j]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[k,i,site_nbr,j]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.09832540000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) 
        for p in range(3):
          if h[(p+1)%N][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] = total_spin + 6
  return(priorities)


#score: {'data3D.txt': -0.34340179999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)]) 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) 
        neighbors_spin_sum = sum([h[(p+1)%N][j][k] for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + neighbors_spin_sum
          priorities[i*N*N+j*N+k][1] -= 6 - neighbors_spin_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - neighbors_spin_sum
          priorities[i*N*N+j*N+k][1] += 6 + neighbors_spin_sum
  return(priorities)


#score: {'data3D.txt': -0.1519334}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[site_nbr][j][k]
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.4118022000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[site_nbr][j][k]
        interacting_spins = [J[l,site_nbr,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.3391809999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for p in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6
  return(priorities)


#score: {'data3D.txt': -0.33898499999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[site_nbr][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) for p in range(3)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': 0.0071946}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N

          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        for l in range(6):
          site_nbr_i_3 = (i + ((l%3-1)%N)) % N
          site_nbr_j_3 = (j + ((k-1)%2 - 1)) % N
          site_nbr_k_3 = (k + ((i-1)%2 - 1)) % N

          if J[l][site_nbr_i_3][site_nbr_j_3][site_nbr_k_3] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = total_spin

        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin

  return(priorities)


#score: {'data3D.txt': 0.006193400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        for l in range(N):
          site_nbr_l = (l + ((i-1)%2 - 1)) % N
          if J[5][site_nbr_i][site_nbr_l][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[5][i][j][site_nbr_l] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.006893000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0060134}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[site_nbr_i][j][k] > 0:
          priorities[i*N*j+k][1] -= 4 * total_spin
        else:
          priorities[i*N*j+k][1] += 4 * total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.001629800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate the total spin for each axis
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr = (i + ((l-1)%2 - 1)) % N
          total_spin += h[site_nbr][j][k]
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': 0.0006977999999999997}
program:
def priority(N, h, J):
  N_half = N//2
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]

        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = total_spin

        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.0014490000000000006}
program:
def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        site_nbr = (i + ((j-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr][k][i] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        site_nbr = (j + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.3075509999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin + interacting_spins
          priorities[i*N*N + j*N + k][1] = -6 + interacting_spins
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin - interacting_spins
          priorities[i*N*N + j*N + k][1] = 6 - interacting_spins
  return priorities


#score: {'data3D.txt': -0.003274200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= J[5, i, j, k]
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += J[5, i, j, k]
  for site in range(N**3):
    site_nbrs = [(site // (N**2) + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
    total_spin = sum([h[site_nbr][site % (N**2) // N][site % N] for site_nbr in site_nbrs])
    if h[site // (N**2)][site % (N**2) // N][site % N] > 0:
      priorities[site][0] += total_spin
      priorities[site][1] -= J[5, site // (N**2), site % (N**2) // N, site % N]
    else:
      priorities[site][0] -= total_spin
      priorities[site][1] += J[5, site // (N**2), site % (N**2) // N, site % N]
  return priorities


#score: {'data3D.txt': -0.3413105999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l, i, j, k] for l in [0, 1, 4]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return priorities


#score: {'data3D.txt': 0.0015034000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = 0
        total_spin = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if h[site_nbr][j][k] > 0:
            total_spin += 3
            site_nbr_sum += 1
          else:
            total_spin -= 3
            site_nbr_sum -= 1
        
        priorities[i*N*j+k][0] = -total_spin + site_nbr_sum
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2

  return(priorities)


#score: {'data3D.txt': 0.0009850000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = 0
        total_spin = 0
        
        if h[i][j][k] > 0:
          total_spin += 1
          site_nbr_sum += 3 + sum(J[l][i][j][k] for l in range(6))
        else:
          total_spin -= 1
          site_nbr_sum -= 3 - sum(J[l][i][j][k] for l in range(6))
        
        priorities[i*N*j+k][0] = -total_spin + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0098458}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_sum = 0
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if h[site_nbr][j][k] > 0:
            total_spin += 1
            site_nbr_sum += 1
          else:
            total_spin -= 1
            site_nbr_sum -= 1
        
        for l in range(6):
          site_nbr = (i + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] += -total_spin + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        total_spin = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0009702000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = np.sum(J[:, i, j, k])

        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -total_spin + N**2 * 2
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = total_spin - N**2 * 2

  return(priorities)


#score: {'data3D.txt': -0.001132600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = h[site_nbr_i][j][k]

        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)

        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N

        if h[site_nbr1][i][k] > 0:
          total_spin += np.sum(J[:,site_nbr1,:,k].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,site_nbr1,:,k].sum(axis=1, keepdims=True).T)

        if h[site_nbr2][j][k] > 0:
          total_spin += np.sum(J[:,:,site_nbr2,k].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,:,site_nbr2,k].sum(axis=1, keepdims=True).T)

        if h[site_nbr3][i][j] > 0:
          total_spin += np.sum(J[:,i,:,site_nbr3].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,i,:,site_nbr3].sum(axis=1, keepdims=True).T)

        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.0016078000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N

        total_spin = h[site_nbr1][i][k] + h[i][site_nbr2][j] + h[j][site_nbr3][k]

        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)

        priorities[i*N*j+k][0] = -total_spin*2

        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin

  for i in range(N):
    site_nbr_i = (i + ((N-1)%2 - 1)) % N
    if h[site_nbr_i][i][0] > 0:
      priorities[i*N*i+0][0] -= 1
      priorities[i*N*i+0][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.0026986000000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        if h[site_nbr1][i][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        if h[i][site_nbr2][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        if h[site_nbr3][i][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2

  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N

      if h[i][j][k] > 0:
        priorities[i*N*j+k][1] = -1 - total_spin
      else:
        priorities[i*N*j+k][1] = 1 + total_spin

  for i in range(N):
    for j in range(N):
      site_nbr_i = (i + ((k-1)%2 - 1)) % N
      site_nbr_j = (j + ((k-1)%2 - 1)) % N

      if h[i][site_nbr_i][k] > 0:
        priorities[i*N*j+k][1] -= 1
      else:
        priorities[i*N*j+k][1] += 1

      if h[j][site_nbr_j][k] > 0:
        priorities[i*N*j+k][1] -= 1
      else:
        priorities[i*N*j+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.2994202}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[::,i,j,k] if val > 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum - sum(J[::,site_nbr,j,k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[::,i,j,k] if val < 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum - sum(J[::,site_nbr,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.3107865999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3257394000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0]) - sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.4276926000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] += abs(sum([val for val in interacting_spins]))
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins]) - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.3646078000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0) + J[4,i,site_nbr,k]
  return(priorities)


#score: {'data3D.txt': -0.2862358000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[0,i,j,k] for _ in range(6)) + J[3,i,site_nbr,k]
        interacting_spins = [val for val in J[[0,1,2],i,j,k] if val != 0]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr,k]
        
  return(priorities)


#score: {'data3D.txt': -0.14866660000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(spin for spin in interacting_spins if spin > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(spin for spin in interacting_spins if spin > 0) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.1244402}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                      J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(spin for spin in interacting_spins if spin < 0) - sum(spin for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.29402220000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        for neighbor in [(i+1)%N, (j+1)%N, (k+1)%N, ((i+1)%N + (j+1)%N + (k+1)%N) % N]:
          site_nbr = (neighbor//N, neighbor%N)
          interacting_spins.append(h[site_nbr][0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.0013301999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][0] = total_spin * (h[site_nbr][j][k] > 0) + J[0][i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': 0.00020299999999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbrs = []
        
        for l in [(i+1)%N, (i+N-1)%N, (j+1)%N, (j+N-1)%N, (k+1)%N, (k+N-1)%N]:
          site_nbrs.append(l)
        
        for site_nbr in site_nbrs:
          if J[0][site_nbr][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0056222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = total_spin
        if h[site_nbr][j][k] > 0:
          priorities[i*N*j+k][1] -= 2
        else:
          priorities[i*N*j+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0036650000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N**3):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    total_spin = 0
    
    if h[site_nbr][k%N][k//N%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for l in range(6):
      total_spin += np.sum(np.where(J[l][:,k%N,k//N%N] > 0, 1, -1))
    
    priorities[k][0] = -total_spin*2
    
    if h[site_nbr][k%N][k//N%N] > 0:
      priorities[k][1] -= 4
    else:
      priorities[k][1] += 4
  
  return(priorities)


#score: {'data3D.txt': -0.0039342000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N**3):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][k%N][k//N%N]
    
    for l in range(6):
      total_spin += np.sum(J[l][site_nbr][k%N][k//N%N] * h[tuple(np.unravel_index(l, (N, N, N)))])
    
    priority = -total_spin*2
    priorities[k][0] = priority
    if h[site_nbr][k%N][k//N%N] > 0:
      priorities[k][1] -= 2
    else:
      priorities[k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.0047878}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(N):
    for i in range(N):
      for j in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        if J[0][i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        if J[1][site_nbr_i][site_nbr_j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        if J[2][i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        if J[3][site_nbr_i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        if J[4][i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        if J[5][site_nbr_i][site_nbr_j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0046934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][site_nbr_j][site_nbr_k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          site_nbr1 = (site_nbr_i + ((l-1)%2 - 1)) % N
          site_nbr2 = (site_nbr_j + ((l-1)%2 - 1)) % N
          
          if J[l][i][j][k] > 0:
            total_spin += h[site_nbr1][site_nbr2][k]
          else:
            total_spin -= h[site_nbr1][site_nbr2][k]
            
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': 0.0016022000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin * 2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin - 1
        else:
          priorities[i*N*j+k][1] = total_spin + 1
  
  return(priorities)


#score: {'data3D.txt': -0.0049894}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.2797686000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin - sum(abs(val) for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.33477659999999976}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.11718860000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += sum(J[3,site_nbr,l,k] for l in range(N))
        interacting_spins.append(sum(J[4,i,site_nbr,k] for _ in range(N)))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(abs(val) for val in interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(abs(val) for val in interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin - sum(abs(val) for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': 0.30283140000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(val for val in interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin - sum(abs(val) for val in interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0026746}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = 0
        total_spin = 0

        for l in range(6):
          site_nbr_i = (i + ((k-1)%2 - 1)) % N
          site_nbr_j = (j + ((l%3-1)%N)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N

          if h[site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
            site_nbr_sum += 1
          else:
            total_spin -= 1
            site_nbr_sum -= 1

        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N

          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin + site_nbr_sum
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * (total_spin + site_nbr_sum)
        else:
          priorities[i*N*j+k][1] += 2 * (total_spin + site_nbr_sum)

  return(priorities)


#score: {'data3D.txt': -0.0014010000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = 0
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          site_nbr_sum += site_nbr_i * site_nbr_j * site_nbr_k
        
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][0] = total_spin + site_nbr_sum
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0010989999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # Calculate the interactions with nearest neighbors
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          total_spin += J[l][site_nbr_i][j][k]
        
        # Calculate the interactions with second-nearest neighbors
        site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
        site_nbr_j_2 = (j + ((l%3-1)%N)) % N
        site_nbr_k_2 = (k + ((l//3-1)%N)) % N
        
        for l in range(6):
          total_spin += J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2]
        
        # Calculate the interactions with magnetism
        total_spin += h[i][j][k]
        
        priorities[i*N*j+k][0] = -total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0011966000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = 0
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          site_nbr_sum += site_nbr_i * site_nbr_j * site_nbr_k
        
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][0] = site_nbr_sum + total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0011966000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_sum = 0
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          site_nbr_sum += site_nbr_i * site_nbr_j * site_nbr_k
        
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        for l in range(6):
          site_nbr_i = (i + ((l%3-1)%N)) % N
          site_nbr_j = (j + ((k+1)%2 - 1)) % N
          site_nbr_k = (k + ((i+1)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][0] = total_spin + site_nbr_sum
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.21085060000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[3,i,j,k], J[4,i,j,k], J[5,i,j,k]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3432617999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        total_spin = 0
        h_sum = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          h_sum += abs(h[site_nbr][j][k])
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= 1*h_sum/h_sum.sum()
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += 1*h_sum/h_sum.sum()
  return(priorities)


#score: {'data3D.txt': -0.00015060000000000117}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = 0
        
        # Calculate magnetism contribution
        if h[i][j][k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        # Calculate interaction contribution
        for l in range(6):
          site_nbr_i = (i + ((l-1)%2 - 1)) % N
          site_nbr_j = (j + ((l-2)%2 - 1)) % N
          site_nbr_k = (k + ((l-3)%2 - 1)) % N
          
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2*total_spin
        else:
          priorities[i*N*j+k][1] += 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0021482}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  
  # Calculate site interactions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        for l in range(6):
          site_nbr_i = (i + ((l-1)%2 - 1)) % N
          site_nbr_j = (j + ((l-2)%2 - 1)) % N
          site_nbr_k = (k + ((l-3)%2 - 1)) % N
          
          total_spin += J[l][site_nbr_i][site_nbr_j][site_nbr_k] * h[site_nbr_i][site_nbr_j][site_nbr_k]
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin
          priorities[i*N*j+k][1] -= total_spin
        else:
          priorities[i*N*j+k][0] = total_spin
          priorities[i*N*j+k][1] += total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0017346000000000006}
program:
def priority(N, h, J):
  N_half = N//2
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin - sum(J[l][i][j][k] for l in range(6))
        else:
          priorities[i*N*j+k][1] = total_spin + sum(J[l][i][j][k] for l in range(6))
  
  return(priorities)


#score: {'data3D.txt': 0.00022900000000000066}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        
        for l in range(6):
          if J[l][site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin
        priorities[i*N*j+k][1] = -2*total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.013239}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N

        total_spin = h[site_nbr1][j][k]

        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2
        
        site_nbr4 = (k + ((k-1)%2 - 1)) % N
        if h[site_nbr4][i][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N*j+k][1] = -total_spin-1 if h[i][j][k] > 0 else total_spin+1
        
  return(priorities)


#score: {'data3D.txt': -0.012875399999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((j-1)%2 - 1)) % N

        total_spin = h[site_nbr1][j][k]
        
        for l in range(6):
          if J[l][site_nbr1][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr3][i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2
        
        for l in range(6):
          site_nbr4 = (k + ((l-1)%2 - 1)) % N
          if J[l][site_nbr1][j][site_nbr4] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
        priorities[i*N*j+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0027982000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N

        total_spin = h[i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr_i_site_nbr_j = (site_nbr_i + ((j-1)%2 - 1)) % N
          site_nbr_i_site_nbr_k = (site_nbr_i + ((k-1)%2 - 1)) % N

          if J[l][i][site_nbr_i_site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr_i][site_nbr_i_site_nbr_k][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0038598000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        total_spin = h[i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr = (l // 2) % N
          if l % 2 == 0:
            if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
          else:
            if J[l][i][j][k] > 0:
              total_spin += 1
            else:
              total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin * 2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -total_spin - 1
        else:
          priorities[i*N*j+k][1] = total_spin + 1
  
  return(priorities)


#score: {'data3D.txt': 0.0003425999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        for l in range(3):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N

          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = total_spin
        priorities[i*N*j+k][1] = -total_spin - h[i][j][k]

  return(priorities)


#score: {'data3D.txt': -0.00017940000000000067}
program:
def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N

        total_spin = 0
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][0] = total_spin

        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N

          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1

        priorities[i*N*j+k][1] = -total_spin - h[site_nbr_i][j][k]

  return(priorities)


#score: {'data3D.txt': -0.0021766000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          total_spin += J[l][site_nbr_i][j][k]
          total_spin -= J[l][i][site_nbr_j][k]
          total_spin -= J[l][i][j][site_nbr_k]
        
        priorities[i*N*j+k][0] = total_spin
        priorities[i*N*j+k][1] = -total_spin - h[site_nbr_i][j][k]
  
  return(priorities)


#score: {'data3D.txt': -0.00017940000000000067}
program:
def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = total_spin
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][1] = -total_spin - h[site_nbr_i][j][k]
  
  return(priorities)


#score: {'data3D.txt': -0.3337449999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] * (h[site_nbr][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.33477659999999976}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.31735179999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] * h[site_nbr][j][k] for d in [0,1,2]) + J[3,i,j,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                       J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) + J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - J[5,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.0007038000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i_2 = (i + ((k-1)%2 - 1)) % N
          site_nbr_j_2 = (j + ((l%3-1)%N)) % N
          site_nbr_k_2 = (k + ((l//3-1)%N)) % N
          
          if J[l][site_nbr_i_2][site_nbr_j_2][site_nbr_k_2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        for l in range(6):
          site_nbr_i_3 = (i + ((l%2-1)%N)) % N
          site_nbr_j_3 = (j + ((l//2-1)%N)) % N
          
          if J[l][site_nbr_i_3][site_nbr_j_3][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        priorities[i*N*j+k][0] = -total_spin*2
        
        for l in range(N):
          site_nbr_l = (l + ((i-1)%2 - 1)) % N
          if J[5][site_nbr_i][site_nbr_l][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[5][i][j][site_nbr_l] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] -= 2 * total_spin
        else:
          priorities[i*N*j+k][1] += 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0033694000000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # Calculate spin priority based on magnetism and nearest neighbors
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          site_nbr2 = (j + ((k-1)%2 - 1)) % N
          site_nbr3 = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr2][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr3][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        # Adjust spin priority based on magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.006935}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][i][site_nbr_j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][i][j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr1][site_nbr_i][j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr2][i][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
          if J[l][site_nbr3][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        # Adjust spin priority based on magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0033694000000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        
        # Calculate spin priority based on magnetism and nearest neighbors
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr1][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr2][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
          
          if J[l][site_nbr3][site_nbr_i][site_nbr_j] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        # Adjust spin priority based on magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.13643700000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        total_spin = 0
        h_sum = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          h_sum += abs(h[site_nbr][j][k])
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += 1
          priorities[i*N**2+j*N+k][1] -= (total_spin+h_sum.sum())/(h_sum.sum())
        else:
          priorities[i*N**2+j*N+k][0] -= 1
          priorities[i*N**2+j*N+k][1] += (total_spin-h_sum.sum())/(h_sum.sum())
  return(priorities)


#score: {'data3D.txt': -0.001132600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)
        
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        if h[site_nbr1][i][k] > 0:
          total_spin += np.sum(J[:,site_nbr1,:,k].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,site_nbr1,:,k].sum(axis=1, keepdims=True).T)

        if h[site_nbr2][j][k] > 0:
          total_spin += np.sum(J[:,:,site_nbr2,k].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,:,site_nbr2,k].sum(axis=1, keepdims=True).T)

        if h[site_nbr3][i][j] > 0:
          total_spin += np.sum(J[:,i,:,site_nbr3].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,i,:,site_nbr3].sum(axis=1, keepdims=True).T)

        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0025262}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        # Combine site interactions and magnetism
        for l in range(6):
          site_nbr_i = (i + ((l-1)%2 - 1)) % N
          site_nbr_j = (j + ((l-1)%2 - 1)) % N
          site_nbr_k = (k + ((i-1)%2 - 1)) % N
          
          if J[l][site_nbr_i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)

        # Adjust priorities based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.001132600000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((i-1)%2 - 1)) % N
        
        total_spin = h[site_nbr_i][j][k]
        
        for l in range(6):
          if J[l][i][j][k] > 0:
            total_spin += np.sum(J[l].sum(axis=1, keepdims=True).T)
          else:
            total_spin -= np.sum(J[l].sum(axis=1, keepdims=True).T)
        
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        
        if h[site_nbr1][i][k] > 0:
          total_spin += np.sum(J[:,site_nbr1,:,k].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,site_nbr1,:,k].sum(axis=1, keepdims=True).T)

        if h[site_nbr2][j][k] > 0:
          total_spin += np.sum(J[:,:,site_nbr2,k].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,:,site_nbr2,k].sum(axis=1, keepdims=True).T)

        if h[site_nbr3][i][j] > 0:
          total_spin += np.sum(J[:,i,:,site_nbr3].sum(axis=1, keepdims=True).T)
        else:
          total_spin -= np.sum(J[:,i,:,site_nbr3].sum(axis=1, keepdims=True).T)

        if h[i][j][k] > 0:
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][0] = total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.4276926000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] += abs(sum([val for val in interacting_spins]))
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins]) - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.29151100000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = 0
          priorities[i*N*N+j*N+k][1] = sum([abs(val) for val in interacting_spins])
  return priorities


#score: {'data3D.txt': -0.07014540000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]])
        for p in range(3):
          if h[(p+1)%N][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        interacting_spins = [h[site_nbr][j][k]]
        for d in [0,1,2]:
          interacting_spins.append(J[d,i,j,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum([val if val > 0 else -abs(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin - sum([val if val < 0 else -abs(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][1] = total_spin + 6
  return(priorities)


#score: {'data3D.txt': -0.29050100000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] = total_spin + 6
  return(priorities)


#score: {'data3D.txt': -0.3242265999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin - interacting_spins
          priorities[i*N*N + j*N + k][1] = -7 + interacting_spins
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin + interacting_spins
          priorities[i*N*N + j*N + k][1] = 7 - interacting_spins
  return priorities


#score: {'data3D.txt': -0.3306669999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] if p!=i else 0 for p in range(3)])
        interacting_spins = [J[l,site_nbr,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.08652100000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        
        for d in range(6):
          site = (i + ((d-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]
        
        # Add the contribution of the neighboring sites
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
        
  return(priorities)


#score: {'data3D.txt': 0.05173099999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)


#score: {'data3D.txt': 0.0009889999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k]
        
        if h[i][j][k] > 0:
          for l in range(6):
            site_nbr1 = (i + ((l-1)%2 - 1)) % N
            site_nbr2 = (j + ((l-1)%2 - 1)) % N
            site_nbr3 = (k + ((l-1)%2 - 1)) % N
            
            if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
              total_spin += 1
            else:
              total_spin -= 1
          
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          for l in range(6):
            site_nbr1 = (i + ((l-1)%2 - 1)) % N
            site_nbr2 = (j + ((l-1)%2 - 1)) % N
            site_nbr3 = (k + ((l-1)%2 - 1)) % N
            
            if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
              total_spin -= 1
            else:
              total_spin += 1
          
          priorities[i*N*j+k][0] = -total_spin*2
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.005011799999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for l in range(6):
          site_nbr1 = (i + ((l-1)%2 - 1)) % N
          site_nbr2 = (j + ((l-1)%2 - 1)) % N
          site_nbr3 = (k + ((l-1)%2 - 1)) % N
          
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  for i in range(N**3):
    if priorities[i][0] > priorities[i][1]:
      priorities[i] = [1, 0]
    elif priorities[i][0] < priorities[i][1]:
      priorities[i] = [-1, 0]
  
  return(priorities)


#score: {'data3D.txt': -0.0025482000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j].sum()
      
      for k in range(N):
        site_nbr_i = (i + ((k-1)%2 - 1)) % N
        site_nbr_j = (j + ((k-1)%2 - 1)) % N
        site_nbr_k = (k + ((k-1)%2 - 1)) % N
        
        for l in range(6):
          if J[l][site_nbr_i][site_nbr_j][site_nbr_k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[i][j][k] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
      
  return(priorities)


#score: {'data3D.txt': -0.0011834000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((j-1)%2 - N//2)) % N
        site_nbr2 = (j + ((k-1)%2 - N//2)) % N
        site_nbr3 = (k + ((i-1)%2 - N//2)) % N
        
        total_spin = h[site_nbr1][site_nbr2][site_nbr3]
        
        for l in range(6):
          if J[l][site_nbr1][site_nbr2][site_nbr3] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priorities[i*N*j+k][0] = -total_spin*2
        
        if h[site_nbr1][site_nbr2][site_nbr3] > 0:
          priorities[i*N*j+k][1] = -1 - total_spin
        else:
          priorities[i*N*j+k][1] = 1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for site in range(N**3):
    site_nbrs = [(site // (N**2) + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
    total_spin = sum([h[site_nbr][site % (N**2) // N][site % N] for site_nbr in site_nbrs])
    if h[site // (N**2)][site % (N**2) // N][site % N] > 0:
      priorities[site][0] += total_spin + sum([J[l, site // (N**2), site % (N**2) // N, site % N] for l in [4]])
      priorities[site][1] -= 6 - sum([np.sign(h[(p+1)%N][site % (N**2) // N][site % N]) for p in range(3)])
    else:
      priorities[site][0] -= total_spin + sum([J[l, site // (N**2), site % (N**2) // N, site % N] for l in [4]])
      priorities[site][1] += 6 + sum([np.sign(h[(p+1)%N][site % (N**2) // N][site % N]) for p in range(3)])
  return priorities


#score: {'data3D.txt': -0.3406829999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return priorities


#score: {'data3D.txt': -0.0030529999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr, k in zip(site_nbrs, [0,1,2])]) + h[i][j][0]
        if h[i][j][0] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= 3
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += 3
        for l in range(6):
          if J[l,i,j,k] > 0:
            priorities[i*N*N + j*N + k][0] -= 2*J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] += J[l,i,j,k]
          else:
            priorities[i*N*N + j*N + k][0] += 2*J[l,i,j,k]
            priorities[i*N*N + j*N + k][1] -= J[l,i,j,k]
  return priorities


#score: {'data3D.txt': -0.013841799999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [0,1,2]]
      total_spin = sum([h[site_nbr][j][k] for site_nbr, k in zip(site_nbrs, [0,1,2])]) + h[i][j][0]
      if h[i][j][0] > 0:
        priorities[i*N*N + j*N + 0][0] += total_spin
        priorities[i*N*N + j*N + 0][1] -= 3
      else:
        priorities[i*N*N + j*N + 0][0] -= total_spin
        priorities[i*N*N + j*N + 0][1] += 3
      for k in range(N):
        if J[0,i,j,k] > 0:
          priorities[i*N*N + j*N + k][0] += 2*J[0,i,j,k]
          priorities[i*N*N + j*N + k][1] -= J[0,i,j,k]
        else:
          priorities[i*N*N + j*N + k][0] -= 2*J[0,i,j,k]
          priorities[i*N*N + j*N + k][1] += J[0,i,j,k]
  return priorities


#score: {'data3D.txt': -0.0032274000000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - abs(sum([J[3,i,site_nbr,k] for site_nbr in range(N)]))
          priorities[i*N*N+j*N+k][1] -= total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) - abs(sum([J[3,i,site_nbr,k] for site_nbr in range(N)]))
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.43299140000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.1924622}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.4481838}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum([val for val in interacting_spins if val > 0]) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.28403059999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.1781798000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]] 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.29896499999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.276841}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.18357940000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        total_spin += sum([val * (1 if val > 0 else -1) for val in interacting_spins])
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': 0.3235309999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        h_sum = 0
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          h_sum += abs(h[site_nbr][j][k])
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] = -total_spin/h_sum.sum()
          priorities[i*N**2+j*N+k][1] = 1
        else:
          priorities[i*N**2+j*N+k][0] = total_spin/h_sum.sum()
          priorities[i*N**2+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[site_nbr][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) for p in range(3)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6
  return(priorities)


#score: {'data3D.txt': -0.3419269999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) for p in range(3)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.3365729999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': 0.0014717999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        total_spin = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += total_spin
          priorities[i*N**2+j*N+k][1] -= -total_spin
        else:
          priorities[i*N**2+j*N+k][0] -= total_spin
          priorities[i*N**2+j*N+k][1] += -total_spin
  for i in range(N):
    for j in range(N):
      if h[i][j][k] > 0:
        priorities[i*N**2+j*N+k][0] = -priorities[i*N**2+j*N+k][1]
      else:
        priorities[i*N**2+j*N+k][1] = -priorities[i*N**2+j*N+k][0]
  return(priorities)


#score: {'data3D.txt': -0.001142200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        total_spin = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N**2+j*N+k][0] += total_spin
          priorities[i*N**2+j*N+k][1] -= total_spin
        else:
          priorities[i*N**2+j*N+k][0] -= total_spin
          priorities[i*N**2+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': 0.07185660000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N, (k+1)%N, (k-1+N)%N]
        total_spin = 0
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        if np.sum(h[i][j]) > 0:
          priorities[i*N**2+j*N+k][0] = -total_spin
          priorities[i*N**2+j*N+k][1] = total_spin
        else:
          priorities[i*N**2+j*N+k][0] = -np.sum(h[i][j])
          priorities[i*N**2+j*N+k][1] = np.sum(h[i][j])
  return(priorities)


#score: {'data3D.txt': -0.23539860000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                       J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val > 0) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.43299140000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins[:3])
          priorities[i*N*N+j*N+k][1] -= total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins[:3])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.23539860000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                      J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val > 0) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.33127939999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) + abs(J[3,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) - abs(J[3,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 1
  
  return(priorities)


#score: {'data3D.txt': -0.27729620000000044}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        
  return priorities


#score: {'data3D.txt': -0.27729620000000044}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.15286820000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [J[0,i,j,k], 
                   J[1,i,(j+1)%N,k], 
                   J[2,i,j,(k+1)%N],
                   J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr_x,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr_x,k]
  
  return(priorities)


#score: {'data3D.txt': -0.15681740000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,(k+1)%N],
                    J[2,i,(j+1)%N,k], J[4,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val < 0) + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': 0.06593700000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(1 for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum(1 for val in interacting_spins if val < 0)
  
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2499682000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.38598140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.38598140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.3593982000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)


#score: {'data3D.txt': -0.38598140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[:,i,j,k] if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in J[:,i,j,k] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[:,i,j,k] if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in J[:,i,j,k] if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.1709853999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[site_nbr][j][k]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 1
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[:,i,j,k] if val < 0]) - 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 1
          priorities[i*N*N+j*N+k][1] += len([val for val in J[:,i,j,k] if val > 0]) + 1
  return(priorities)


#score: {'data3D.txt': -0.11305660000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3615846000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][0]
    if total_spin > 0:
      priorities[i][0] += abs(total_spin) + 1
      priorities[i][1] -= len([val for val in interacting_spins if val < 0])
    else:
      priorities[i][0] -= abs(total_spin) - 1
      priorities[i][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3773030000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%N - N//2)) % N
      total_spin = h[i][j][0]
      for k in range(N):
        total_spin += J[3,i,j,k] * h[i][j][k]
      if total_spin > 0:
        priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)
        priorities[i*N*N+j*N+k][1] -= sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
      else:
        priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
        priorities[i*N*N+j*N+k][1] += sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3112993999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        priority_sum = sum(abs(val) for val in interacting_spins)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + priority_sum
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + priority_sum
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.32353939999999964}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.28546660000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.36598620000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[:,i,j,k] if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in J[:,i,j,k] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[:,i,j,k] if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in J[:,i,j,k] if val > 0)

        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[site_nbr][i][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[:,i,j,k] if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in J[:,i,j,k] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[:,i,j,k] if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in J[:,i,j,k] if val > 0)

        site_nbr = (j + ((k-1)%2 - 1)) % N
        if h[site_nbr][i][j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[:,i,j,k] if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in J[:,i,j,k] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[:,i,j,k] if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in J[:,i,j,k] if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3646114000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.36651380000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.23706220000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        interacting_spin_sum = sum(interacting_spins)
        total_spin += 6 * np.sign(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + interacting_spin_sum
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - interacting_spin_sum
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.34167219999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        interaction_sum = sum([abs(val) for val in interacting_spins])
        spin_product = np.prod([np.sign(val) for val in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + interaction_sum
          priorities[i*N*N+j*N+k][1] = -6 + spin_product
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - interaction_sum
          priorities[i*N*N+j*N+k][1] = 6 - spin_product
  return(priorities)


#score: {'data3D.txt': -0.34335819999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        priority_total = total_spin + sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.2694030000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.1896198}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.2806450000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.14986620000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.035852999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] if d%2 == 0 else -J[d-1,i,(j+1)%N,k] for d in range(6)])
        total_spin += h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = abs(total_spin) + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = -sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] = -abs(total_spin) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.36761260000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][0]
    if total_spin > 0:
      priorities[i][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
      priorities[i][1] -= sum(1 for val in interacting_spins if val < 0)
    else:
      priorities[i][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
      priorities[i][1] += sum(1 for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.36761260000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][0]
    if total_spin > 0:
      priorities[i][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
      priorities[i][1] -= len([val for val in interacting_spins if val < 0])
    else:
      priorities[i][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
      priorities[i][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.19079380000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        for x in range(-1,2):
          for y in range(-1,2):
            for z in range(-1,2):
              if (x == 0 and y == 0) or (i+x >= N) or (j+y >= N) or (k+z >= N):
                continue
              interacting_spins.append(J[(x+1)%3 + 3*(y+1)%3 + 9*(z+1)%3, i+x, j+y, k+z])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.005707000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                  J[3,(i+1)%N,j,k], J[4,i,j,k],
                  J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[4,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        for di in range(3):
          for dj in range(3):
            for dk in range(3):
              site_nbr = (i+di)%N,(j+dj)%N,(k+dk)%N
              if site_nbr != ((i,j,k)):
                interacting_spins.append(J[di,i,j,k])
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.25977780000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[3,i,j,k], J[4,i,j,k], J[5,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.24030980000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) + J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) + J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - J[4,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.2962462000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        interacting_spins.sort(reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.1944622}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                      J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins) + J[3,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins) + J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.1901946}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] if d%2 == 0 else J[d,site_nbr,j,k] for d in range(6)]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] -= sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] += sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.32031139999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] if d%2 == 0 else J[d,site_nbr,j,k] for d in range(6)]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[d,i,j,k] for d in range(6)] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[d,i,j,k] for d in range(6)] if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.09276740000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] if d%2 == 0 else -J[d-1,site_nbr,j,k] for d in range(6)]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = abs(total_spin) + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = -sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] = -abs(total_spin) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.21770300000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins_sum = sum(J[::,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,i,j,k], J[1,i,j,(k+1)%N], J[2,i,(j+1)%N,k]] if val > 0]) - len([val for val in [J[4,i,site_nbr,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in [J[0,i,j,k], J[1,i,j,(k+1)%N], J[2,i,(j+1)%N,k]] if val < 0) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i,j,(k+1)%N], J[2,i,(j+1)%N,k]] if val > 0]) + len([val for val in [J[4,i,site_nbr,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] += sum(1 for val in [J[0,i,j,k], J[1,i,j,(k+1)%N], J[2,i,(j+1)%N,k]] if val < 0) + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': 0.06862940000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins_sum = sum(J[::,i,j,k])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - len([val for val in J[::,i,j,k] if val < 0]) + max(1, abs(interacting_spins_sum))
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in J[::,i,j,k] if val > 0]) + max(-1, abs(interacting_spins_sum))
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum
  
  return(priorities)


#score: {'data3D.txt': -0.0528366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum(J[::,i,j,k]) + J[3,i,site_nbr,k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in J[::,i,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] -= interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in J[::,i,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] += interacting_spins_sum
  
  return(priorities)


#score: {'data3D.txt': 0.0023010000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_sum = sum([J[4,i,l,k] for l in range(N)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in J[::,i,j,k] if val > 0]) + interacting_spins_sum
          priorities[i*N*N+j*N+k][1] -= sum([val for val in J[::,i,j,k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in J[::,i,j,k] if val < 0]) - interacting_spins_sum
          priorities[i*N*N+j*N+k][1] += sum([val for val in J[::,i,j,k] if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.31860180000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        if h[site_nbrs[0]][i][j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3413342000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,i//N, i%N, 0] for d in range(6))
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(total_spin) + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)
      priorities[i][1] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
    else:
      priorities[i][0] -= abs(total_spin) - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
      priorities[i][1] = total_spin + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)

  return(priorities)


#score: {'data3D.txt': -0.3513482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[site_nbr][i][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

        site_nbr = (j + ((k-1)%2 - 1)) % N
        if h[site_nbr][i][j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.3697682000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] += -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.0026861999999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr_x][j][k]
        if J[5,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.08440180000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        if J[5,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0]) - abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0]) + abs(total_spin)
  return(priorities)


#score: {'data3D.txt': 0.0859002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr_x][i][k] + h[site_nbr_y][j][k]
        interacting_spins_x = [J[3,i,j,k], J[3,(i+1)%N,j,k], J[3,(i+1)%N,(j+1)%N,k]]
        interacting_spins_y = [J[4,i,j,k], J[4,(i+1)%N,j,k], J[4,(i+1)%N,(j+1)%N,k]]
        
        if sum([val for val in interacting_spins_x if val > 0]) + h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.004130599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        if J[5,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * (len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0]) + 1)
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * (len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0]) + 1)
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,i,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2541666000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.21451420000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3110157999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site = h[site_nbr][j][k]
        if total_spin_site > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_site
          priorities[i*N*N+j*N+k][1] -= total_spin_site
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_site
          priorities[i*N*N+j*N+k][1] += total_spin_site
  return priorities


#score: {'data3D.txt': -0.31472219999999973}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.0604682}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
  return priorities


#score: {'data3D.txt': -0.3244889999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] += abs(sum([val for val in interacting_spins]))
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins]) - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.3127185999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] += abs(sum([val for val in interacting_spins])) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.32353939999999964}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.2994014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[4,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[5,i,j,k]
            priorities[i*N*N+j*N+k][1] += J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
          
  return(priorities)


#score: {'data3D.txt': -0.30523659999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,(i + ((k-1)%2 - 1)) % N,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
        
  return(priorities)


#score: {'data3D.txt': -0.13424060000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(sum(J[d,i//N, i%N, 0] for d in range(6)))
      priorities[i][1] -= sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= abs(sum(J[d,i//N, i%N, 0] for d in range(6)))
      priorities[i][1] += -sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.36785020000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,i//N, i%N, 0] for d in range(6)]
    total_spin = sum(J[d,i//N, i%N, 0] for d in range(6))
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
      priorities[i][1] -= sum(1 for val in interacting_spins if val < 0)
    else:
      priorities[i][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
      priorities[i][1] += sum(1 for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3747226000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += total_spin + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -total_spin + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.24643939999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + total_spin
      priorities[i][1] -= 1 - total_spin
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] = -1 + total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 * total_spin
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * total_spin
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

  return(priorities)


#score: {'data3D.txt': -0.0052194}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbrs = [(i // N**2 % N + ((i//N-1)%2 - 1)) % N]
    if h[site_nbrs[0]][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site_nbrs[0]][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site_nbrs[0]][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.025330199999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        if h[site_nbrs[0]][i][j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.10888780000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
  for i, site in enumerate(site_nbrs):
    if h[site][i][0] > 0:
      priorities[i*N*N+i][0] += 1
      priorities[i*N*N+i][1] -= 1
    else:
      priorities[i*N*N+i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3413342000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,i//N, i%N, 0] for d in range(6))
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(total_spin) + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)
      priorities[i][1] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
    else:
      priorities[i][0] -= abs(total_spin) - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
      priorities[i][1] = total_spin + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)

  return(priorities)


#score: {'data3D.txt': -0.3413342000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,i//N, i%N, 0] for d in range(6))
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(total_spin) + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)
      priorities[i][1] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
    else:
      priorities[i][0] -= abs(total_spin) - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
      priorities[i][1] = total_spin + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)

  return(priorities)


#score: {'data3D.txt': -0.3052418000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 2
  return(priorities)


#score: {'data3D.txt': -0.2590146000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.06407779999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

        site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
        for site in site_nbrs:
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1

  return(priorities)


#score: {'data3D.txt': -0.22925740000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (k + ((k-1)%2 - 1)) % N]
        site_interactions = [J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6)]
        total_spin = sum(J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6))
        if h[site_nbrs[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in site_interactions if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in site_interactions if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in site_interactions if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in site_interactions if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.11658500000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%N - N//2)) % N
      total_spin = h[i][j][0]
      for k in range(N):
        total_spin += J[3,i,j,k] * h[i][j][k]
      if total_spin > 0:
        priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)
        priorities[i*N*N+j*N+k][1] -= sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
      else:
        priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
        priorities[i*N*N+j*N+k][1] += sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3773030000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%N - N//2)) % N
      total_spin = h[i][j][0]
      for k in range(N):
        total_spin += J[3,i,j,k] * h[i][j][k]
      if total_spin > 0:
        priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)
        priorities[i*N*N+j*N+k][1] -= sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
      else:
        priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
        priorities[i*N*N+j*N+k][1] += sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.2808718000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.09754980000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site = h[site_nbr][j][k]
        if total_spin_site > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin_site)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_site)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.29896499999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.11367020000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i, site_nbr in enumerate([(i + ((k-1)%2 - 1)) % N for k in range(N)]):
    if h[site_nbr][i][0] > 0:
      priorities[i*N*N+i][0] += 1
      priorities[i*N*N+i][1] -= 1
    else:
      priorities[i*N*N+i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.18333820000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
  for i, site in enumerate(site_nbrs):
    if h[site][i][0] > 0:
      priorities[i*N*N+i][0] += 1
      priorities[i*N*N+i][1] -= 1
    else:
      priorities[i*N*N+i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1]) + len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1]) - len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])

  return(priorities)


#score: {'data3D.txt': 0.03641419999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        interacting_spins.sort()
        total_spin += sum([np.sign(h[site_nbr][j][k]) * np.sign(val) for site_nbr, val in zip(site_nbrs, interacting_spins)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3271301999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.34222539999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(3)]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 3
  return priorities


#score: {'data3D.txt': -0.43299140000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins[:3]) - min(0, total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins[:3]) + min(0, total_spin)
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.4175514000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins[:3])
          priorities[i*N*N+j*N+k][1] -= total_spin - min(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins[:3])
          priorities[i*N*N+j*N+k][1] += total_spin + max(interacting_spins)
        
  return(priorities)


#score: {'data3D.txt': -0.43299140000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins[:3]) - total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins[:3]) + total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.23663540000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] + 3*J[3,(i+(k-1)%2 - 1)%N,j,k] for d in range(6)]
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + pos_interactions
          priorities[i*N*N+j*N+k][1] -= total_spin + neg_interactions
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - pos_interactions
          priorities[i*N*N+j*N+k][1] += total_spin + neg_interactions
  return(priorities)


#score: {'data3D.txt': -0.1538302}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((d-1)%2 - 1)) % N for d in [0,1,2]]
        total_spin = sum(J[d][site_nbrs[0]][j,k] for d in [0,1])
        interacting_spins = [J[0][site_nbrs[0]][j,k], J[1][site_nbrs[0]][(j+1)%N,k], J[2][i][k,(k+1)%N]]
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.15286820000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [J[0,i,j,k], 
                    J[1,i,(j+1)%N,k], 
                    J[2,i,j,(k+1)%N],
                    J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        
        interacting_spins.sort(reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr_x,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr_x,k]
  
  return(priorities)


#score: {'data3D.txt': -0.3072693999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [(d,i,j,k) for d in range(6)]
        
        interacting_spins.sort(key=lambda x: abs(sum([J[d,xi,xj,xd] for d, xi, xj, xd in [x]])), reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for val in interacting_spins if all(J[d,i,j,k] <= 0 for d in range(6)))
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if any(J[d,i,j,k] < 0 for d in range(6))])
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for val in interacting_spins if all(J[d,i,j,k] >= 0 for d in range(6)))
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if any(J[d,i,j,k] > 0 for d in range(6))])
  
  return(priorities)


#score: {'data3D.txt': -0.19904940000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [(J[0,i,j,k], i, j, k),
                   (J[1,i,(j+1)%N,k], i, (j+1)%N, k),
                   (J[2,i,j,(k+1)%N], i, j, (k+1)%N),
                   (J[4,i,site_nbr_x,k], site_nbr_x, j, k)]
        
        interacting_spins.sort(key=lambda x: x[0], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [x[0] for x in interacting_spins] if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([x[0] for x in interacting_spins if x[0] < 0]) - J[4,i,site_nbr_x,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [x[0] for x in interacting_spins] if val > 0)
          priorities[i*N*N+j*N+k][1] += len([x[0] for x in interacting_spins if x[0] < 0]) + J[4,i,site_nbr_x,k]
  
  return(priorities)


#score: {'data3D.txt': -0.15286820000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [J[0,i,j,k], 
                    J[1,i,(j+1)%N,k], 
                    J[2,i,j,(k+1)%N],
                    J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        
        interacting_spins.sort(reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr_x,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr_x,k]
  
  return(priorities)


#score: {'data3D.txt': -0.014399}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6): 
    for i in range(N):
      for j in range(N):
        site_nbr_x = (i + ((j-1)%2 - 1)) % N
        site_nbr_y = (i + ((k-1)%2 - 1)) % N
        site_nbr_z = (i + ((int((k/3)-0.333)%2) - 1)) % N
        
        total_spin_x = sum(J[k,i,site_nbr_x,j] for _ in range(N))
        total_spin_y = sum(J[k,i,site_nbr_y,j] for _ in range(N))
        total_spin_z = sum(J[k,i,site_nbr_z,j] for _ in range(N))
        
        interacting_spins_x = [J[d,i,site_nbr_x,j] for d in range(6) if abs(d-k) == 1 or abs(d-k) == 5]
        interacting_spins_y = [J[d,i,site_nbr_y,j] for d in range(6) if abs(d-k) == 2 or abs(d-k) == 4]
        interacting_spins_z = [J[d,i,site_nbr_z,j] for d in range(6) if abs(d-k) == 0 or abs(d-k) == 3]
        
        spin_interaction_x = sum(spin for spin in interacting_spins_x if spin > 0) - sum(spin for spin in interacting_spins_x if spin < 0)
        spin_interaction_y = sum(spin for spin in interacting_spins_y if spin > 0) - sum(spin for spin in interacting_spins_y if spin < 0)
        spin_interaction_z = sum(spin for spin in interacting_spins_z if spin > 0) - sum(spin for spin in interacting_spins_z if spin < 0)
        
        spin_magnetism = h[i][j][k]
        if spin_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z) + spin_interaction_x + spin_interaction_y + spin_interaction_z
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[k,i,site_nbr_x,j], J[k,i,site_nbr_y,j], J[k,i,site_nbr_z,j]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z) - spin_interaction_x - spin_interaction_y - spin_interaction_z
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[k,i,site_nbr_x,j], J[k,i,site_nbr_y,j], J[k,i,site_nbr_z,j]] if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.34324739999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,(i+1)%N,(j+1)%N,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,(i+1)%N,j,k], J[3,(i+1)%N,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[4,(i+1)%N,j,k], J[4,(i+1)%N,(j+1)%N,k]]
        
        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += sum(J[d,i,site_nbr,k] for d in [0,1])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins_x if val > 0]) + sum([val for val in interacting_spins_y if val > 0]) + sum([val for val in interacting_spins_z if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[d,i,site_nbr,k] for d in [0,1]] if val > 0]) + len([val for val in [J[5,i,j,k], J[5,(i+1)%N,j,k], J[5,(i+1)%N,(j+1)%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum([val for val in interacting_spins_x if val < 0]) - sum([val for val in interacting_spins_y if val < 0]) - sum([val for val in interacting_spins_z if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[d,i,site_nbr,k] for d in [0,1]] if val < 0]) + len([val for val in [J[5,i,j,k], J[5,(i+1)%N,j,k], J[5,(i+1)%N,(j+1)%N,k]] if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.3421569999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for p in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  return priorities


#score: {'data3D.txt': -0.42432900000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = 0
  return priorities


#score: {'data3D.txt': -0.0023638}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins])
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += sum([abs(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] = 0
          priorities[i*N*N+j*N+k][1] = sum([abs(val) for val in interacting_spins])
  return priorities


#score: {'data3D.txt': -0.21589620000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(3)]
        interacting_spins.sort(reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr_x,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr_x,k]
        
        # Additional priority term based on the interaction with the site's neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= sum(J[d,site_nbr_x,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][1] += sum(J[d,site_nbr_x,j,k] for d in [0,1,2])
        
  return(priorities)


#score: {'data3D.txt': -0.031893}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(3)]
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val > 0) + J[4,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[3,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(1 for val in interacting_spins if val > 0) + J[4,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[3,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.18549460000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(3)]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.12748660000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((0)%2 - 1)) % N
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr_x,k]
        
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(3)]
        interacting_spins.sort(reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0) - (len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr_x,k])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr_x,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0) - (len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr_x,k])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr_x,k]
  
  return(priorities)


#score: {'data3D.txt': -0.15681740000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,(k+1)%N],
                  J[2,i,(j+1)%N,k], J[4,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val < 0) + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.0010618}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins_sum = sum(val for val in J[[0,1,2,4],i,j,k] if val > 0) - sum(val for val in J[[0,1,2,4],i,site_nbr,k] if val < 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + interacting_spins_sum
          priorities[i*N*N+j*N+k][1] -= -2*abs(total_spin) - interacting_spins_sum
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - interacting_spins_sum
          priorities[i*N*N+j*N+k][1] += 2*abs(total_spin) + interacting_spins_sum
  
  return(priorities)


#score: {'data3D.txt': -0.15681740000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,(k+1)%N],
                   J[2,i,(j+1)%N,k], J[4,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val < 0) + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.3820126000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        interacting_spins = [J[3,i,j,k], J[4,i,(j+1)%N,k], J[5,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(val for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin + sum(val for val in interacting_spins)
        
  return(priorities)


#score: {'data3D.txt': -0.0136894}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        for d in [0,1,2]:
          site_nbr = (i + ((d-1)%3 - 1)) % N
          interacting_spins.append(J[d,i,site_nbr,k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.0106342}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += total_spin + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3432813999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.12546939999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
        site_nbr = (i + ((k+1)%2 - 1)) % N
        total_spin += sum(J[d,i,j,k] for d in [3,4,5]) + h[i][j][site_nbr]
        priorities[i*N*N+j*N+k][0] -= len([val for val in [J[3,i,j,k], J[4,site_nbr,j,k], J[5,i-1%N,j,k]] if val < 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in [J[3,i,j,k], J[4,site_nbr,j,k], J[5,i-1%N,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.21112300000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.34413619999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((d-1)%2 - 1)) % N for d in [0,1,2]]
        total_spin = sum(J[d][site_nbrs[0]][j,k] * h[site_nbrs[0]][j,k] for d in range(3))
        interacting_spins = [J[0][i][j,k], J[1][i,(j+1)%N,k], J[2][i,j,(k+1)%N],
                   J[3][(i+1)%N,j,k], J[4][i,j,k],
                   J[5][(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(spin * h[i][j][k] for spin in interacting_spins if spin > 0) - sum(spin * h[i][j][k] for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.040910600000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        spin_interaction = sum(abs(val) for val in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.12227060000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (h[(i+d)%N][j][k] if d%3 == 0 else h[i][(j+d)%N][k] if d%3 == 1 else h[i][j][(k+d)%N]) for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,(k+1)%N]]
        interacting_spins_count = sum([val for val in interacting_spins if val > 0] + [val for val in interacting_spins if val < 0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + abs(interacting_spins_count)
          priorities[i*N*N+j*N+k][1] -= total_spin - interacting_spins_count
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + abs(interacting_spins_count)
          priorities[i*N*N+j*N+k][1] += total_spin - interacting_spins_count
  return(priorities)


#score: {'data3D.txt': -0.226633}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((d-1)%2 - 1)) % N for d in [0,1,2]]
        total_spin = sum(J[d][site_nbrs[0]][j,k] for d in [0,1])
        interacting_spins = []
        if i > 0:
          interacting_spins.append(J[3][(i-1)%N][j][k])
        if j > 0:
          interacting_spins.append(J[4][i][(j-1)%N][k])
        if k > 0:
          interacting_spins.append(J[5][i][j][(k-1)%N])
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.009042200000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.1697177999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        if h[(i + ((k-1)%2 - 1)) % N][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.16681299999999982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(sum(J[d,i//N, i%N, 0] for d in range(6)))
      priorities[i][1] -= sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= abs(sum(J[d,i//N, i%N, 0] for d in range(6)))
      priorities[i][1] += -sum(J[d,i//N, i%N, 0] for d in range(6))
  return(priorities)


#score: {'data3D.txt': -0.14616940000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[(i + ((k-1)%2 - 1)) % N][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in J[:,i,j,k] if val < 0]) - 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += len([val for val in J[:,i,j,k] if val > 0]) + 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        # Calculate the priority based on the magnetism and interaction strength
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + 2*pos_interactions + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + 2*neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + 2*pos_interactions + J[4,i,site_nbr,k]
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + 2*neg_interactions - J[4,i,site_nbr,k]
        
  return(priorities)


#score: {'data3D.txt': -0.2351678}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)


#score: {'data3D.txt': -0.2245994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[3,i,j,k], J[4,i,site_nbr,k]], reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - sum(val for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(val for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - sum(val for val in interacting_spins if val > 0)
        
  return(priorities)


#score: {'data3D.txt': -0.17801619999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,i,site_nbr,k], J[3,i,j,k]]
        interacting_spins.sort(reverse=True)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(val for val in interacting_spins if val > 0) + len([val for val in interacting_spins if val >= 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= sum(val for val in interacting_spins if val < 0) - len([val for val in interacting_spins if val <= 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
          
  return(priorities)


#score: {'data3D.txt': -0.19436540000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(6):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [(k+3)%6, (k+4)%6]]
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= spin_interaction - sum(J[k,i,site_nbr,j] for _ in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] += spin_interaction - sum(J[k,i,site_nbr,j] for _ in range(N))
  
  return(priorities)


#score: {'data3D.txt': -0.1990554000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        if k < 3:
          interacting_spins.extend([J[d,i,site_nbr,j] for d in [0,1,2]])
        else:
          interacting_spins.extend([J[5,i,site_nbr,(j+1)%N], J[4,i,j,(k-3)%N+1]])
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= sum(abs(spin) for spin in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += sum(abs(spin) for spin in interacting_spins)
  
  return(priorities)


#score: {'data3D.txt': -0.17610100000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        if k < 3:
          interacting_spins.extend([J[d,i,site_nbr,j] for d in [0,1,2]])
        else:
          interacting_spins.extend([J[5,i,site_nbr,(j+1)%N], J[4,i,j,(k-3)%N+1]])
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0]) - (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.18324220000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for k in range(6):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = []
        if k < 3:
          interacting_spins.extend([J[d,i,site_nbr,j] for d in [0,1,2]])
        else:
          interacting_spins.extend([J[5,i,site_nbr,(j+1)%N], J[4,i,j,(k-3)%N+1]])
        total_spin = sum(J[k,i,site_nbr,j] for _ in range(N))
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= spin_interaction - sum(J[k,i,site_nbr,(n+1)%N] for n in range(N))
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0]) + (h[site_nbr][j][k] > 0)
          priorities[i*N*N+j*N+k][1] += spin_interaction - sum(J[k,i,site_nbr,(n+1)%N] for n in range(N))
  
  return(priorities)


#score: {'data3D.txt': -0.1811066}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
  for i, site in enumerate(site_nbrs):
    if h[site][i][0] > 0:
      priorities[i*N*N+i][0] += 1
      priorities[i*N*N+i][1] -= 1
    else:
      priorities[i*N*N+i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1]) + len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1]) - len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])

  site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(N)]
  for i, site in enumerate(site_nbrs):
    for j in range(N):
      if h[site][j][0] > 0:
        priorities[i*N+N+j][0] += 1
        priorities[i*N+N+j][1] -= 1
      else:
        priorities[i*N+N+j][0] -= 1

  return(priorities)


#score: {'data3D.txt': -0.12696420000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] if d == 0 else J[5-d,i,j,k] for d in range(6)])
        
        interacting_spins = [J[d,i,j,k] for d in range(3)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
  for i, site in enumerate(site_nbrs):
    if h[site][i][0] > 0:
      priorities[i*N*N+i][0] += 1
      priorities[i*N*N+i][1] -= 1
    else:
      priorities[i*N*N+i][0] -= 1

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1]) + len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1]) - len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.2867918}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  total_priority = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_spin = h[site_nbr][j][k]
        total_priority[i*N*N+j*N+k][0] += abs(site_spin) + sum(1 for val in interacting_spins if val > 0)
        total_priority[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)

  return priorities + total_priority


#score: {'data3D.txt': -0.36761260000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][0]
    if total_spin > 0:
      priorities[i][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
      priorities[i][1] -= len([val for val in interacting_spins if val < 0])
    else:
      priorities[i][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
      priorities[i][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3841554000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  site_nbr_sum = np.zeros(N)
  for i in range(N):
    total_spin = h[i][0][0]
    if total_spin > 0:
      site_nbr_sum[i] = abs(total_spin) + 1
    else:
      site_nbr_sum[i] = -abs(total_spin) + 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += site_nbr_sum[site_nbr]
    priorities[i][1] -= len([val for val in interacting_spins if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.2548906000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.14423340000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.22557780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j-1%N,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j-1%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j-1%N,k]] if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.22557780000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.1916562}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0]) - 1
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0]) + 1
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3747226000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += total_spin + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -total_spin + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.3574634000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins_z = [J[d,i//N, i%N, k] for d in range(6) for k in range(N)]
    total_spin_z = sum(J[d,i//N, i%N, k] for d in range(6) for k in range(N))
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(total_spin_z) + sum(1 for val in interacting_spins_z if val > 0)
      priorities[i][1] -= sum(1 for val in interacting_spins_z if val < 0)
    else:
      priorities[i][0] -= abs(total_spin_z) - sum(1 for val in interacting_spins_z if val < 0)
      priorities[i][1] += sum(1 for val in interacting_spins_z if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3433773999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.20351020000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0,site_nbr,j,k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if J[1,i,(j+1)%N,k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if J[2,i,j,(k+1)%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin - len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] = -total_spin + len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin + len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] = total_spin - len([val for val in [J[0,i,j,k], J[1,site_nbr,j,k], J[2,i,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.34328339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j-1%N,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j-1%N,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j-1%N,k]] if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= abs(sum([val for val in interacting_spins]))
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += abs(sum([val for val in interacting_spins]))
        else:
          priorities[i*N*N+j*N+k][0] = sum([abs(val) for val in interacting_spins]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -sum([abs(val) for val in interacting_spins]) + len([val for val in interacting_spins if val < 0])
  return priorities


#score: {'data3D.txt': -0.3110157999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site = h[site_nbr][j][k]
        if total_spin_site > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_site
          priorities[i*N*N+j*N+k][1] -= total_spin_site
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_site
          priorities[i*N*N+j*N+k][1] += total_spin_site
  return priorities


#score: {'data3D.txt': -0.31053219999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins])
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][j][k] for j in range(N) for k in range(N)]) + h[i][0][0]
    if total_spin > 0:
      priorities[i*N*N+0*4+0][0] += abs(total_spin)
      priorities[i*N*N+0*4+0][1] -= sum([abs(val) for val in [J[l,i,0,0] for l in range(6)]])
    elif total_spin < 0:
      priorities[i*N*N+0*4+0][0] -= abs(total_spin)
      priorities[i*N*N+0*4+0][1] += sum([abs(val) for val in [J[l,i,0,0] for l in range(6)]])
  return priorities


#score: {'data3D.txt': 0.14771179999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val > 0) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(1 for val in interacting_spins if val > 0) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.08897620000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.22749740000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + \
               sum(J[d,site_nbr,j,k] for d in [3,4,5])
        interacting_spins = sorted([J[3,i,j,k], J[4,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                      J[0,(i+1)%N,j,k], J[5,i,j,k], J[1,i,j,(k+1)%N]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.3231389999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        
        for d in range(3):
          if h[i][j][k] > 0:
            interacting_spins.extend([-J[d,i,j,k], -J[d,(i+1)%N,j,k], -J[d,i,(k+1)%N,k]])
          else:
            interacting_spins.extend([J[d,i,j,k], J[d,(i+1)%N,j,k], J[d,i,(k+1)%N,k]])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += sum(J[3,site_nbr,j,k] for _ in range(N))
        
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        total_energy = total_spin + spin_interaction
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_energy) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_energy) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] += abs(sum([val for val in interacting_spins]))
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins]) - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        neighbor_spin_sum = sum([h[neighbor][j][k] if h[neighbor][j][k] > 0 else -1*h[neighbor][j][k] for neighbor in site_nbrs])
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_spin_sum)
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins]) - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': 0.00944900000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        priority_total = np.zeros((8,))
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin += h[site_nbr][j][k]
            priority_total[1] += 1
            priority_total[7] -= 1
          else:
            total_spin -= h[site_nbr][j][k]
            priority_total[1] -= 1
            priority_total[7] += 1
        for l in range(6):
          if J[l,i,j,k] > 0:
            priority_total[2+l//3*3+((l)%3)-1] += 1
            priority_total[5-l//3*3-((l)%3)+1] -= 1
          else:
            priority_total[2+l//3*3+((l)%3)-1] -= 1
            priority_total[5-l//3*3-((l)%3)+1] += 1
        priorities[i*N*N+j*N+k][0] = np.sum(np.where(priority_total >= 4, 1, -1))
        priorities[i*N*N+j*N+k][1] = np.sum(np.where(priority_total <= -4, 1, -1))
  return priorities


#score: {'data3D.txt': -0.023016199999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - abs(sum([1 if val < 0 else 0 for val in interacting_spins]))
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0]) - abs(sum([1 if val > 0 else 0 for val in interacting_spins]))
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.2619426000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.231579}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        priority_up = np.sum(np.maximum(0, interacting_spins)) - np.sum(np.minimum(0, interacting_spins))
        priority_down = 2 * (1 if h[i][j][k] > 0 else -1)
        priorities[i*N*N+j*N+k][0] += total_spin + priority_up
        priorities[i*N*N+j*N+k][1] -= total_spin + priority_down
  return priorities


#score: {'data3D.txt': -0.0019481999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        if J[3,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 1 - J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[4,i,j,k]] if val < 0]) + J[5,i,j,k]
        elif J[3,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 1 - J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[4,i,j,k]] if val > 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 * J[5,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': 0.0001933999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        
        if J[3,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin - abs(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] -= 1
        elif J[3,i,j,k] < 0:
          priorities[i*N*N+j*N+k][0] -= total_spin + abs(h[site_nbr][j][k])
          priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)


#score: {'data3D.txt': 0.016846599999999858}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = []
        if i > 0:
          interacting_spins.append(J[3,(i-1)%N,j,k])
        if j > 0:
          interacting_spins.append(J[4,i,(j-1)%N,k])
        if k > 0:
          interacting_spins.append(J[5,(i+1)%N,(j+1)%N,(k-1)%N])
        interacting_spins += [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val < 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] = total_spin - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val < 0]) + J[5,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.09669340000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] if d%2 == 0 else -J[d-1,site_nbr,j,k] for d in range(6)]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum([1 if J[d,i,j,k] > 0 else -1 for d in [0,2]])
          priorities[i*N*N+j*N+k][1] = -(total_spin + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)]))
        else:
          priorities[i*N*N+j*N+k][0] = -(total_spin + sum([1 if J[d,i,j,k] > 0 else -1 for d in [0,2]]))
          priorities[i*N*N+j*N+k][1] = total_spin + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
  return(priorities)


#score: {'data3D.txt': 0.17853100000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([J[d,i,j,k] if d%2 == 0 else -J[(d+1)%6,site_nbr,j,k] for d in range(6)]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = -total_spin - sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = total_spin + sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
  return(priorities)


#score: {'data3D.txt': 0.038701800000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] if d%2 == 0 else -J[(d-1)%6, (i + ((k-1)%2 - 1)) % N, j,k] for d in range(6)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[0,i,j,k] > 0:
          total_spin += 1
        elif J[0,i,j,k] < 0:
          total_spin -= 1
        if J[1,i,(j+1)%N,k] > 0:
          total_spin += 1
        elif J[1,i,(j+1)%N,k] < 0:
          total_spin -= 1
        if J[2,i,j,(k+1)%N] > 0:
          total_spin += 1
        elif J[2,i,j,(k+1)%N] < 0:
          total_spin -= 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = abs(total_spin) + sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = -sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] = -abs(total_spin) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(3)])
          priorities[i*N*N+j*N+k][1] = sum([1 if J[d,i,j,k] < 0 else -1 for d in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.0078434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + (pos_interactions * 2 + J[4,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] -= neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - (neg_interactions * 2 + J[4,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] += pos_interactions + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.0570486}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + pos_interactions - (neg_interactions // 2)
          priorities[i*N*N+j*N+k][1] -= neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - neg_interactions - (pos_interactions // 2)
          priorities[i*N*N+j*N+k][1] += pos_interactions + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.3423153999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        
        # Calculate the number of positive and negative interactions
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + (pos_interactions + J[4,i,site_nbr,k]) * h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= neg_interactions - J[4,i,site_nbr,k] * h[i][j][k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - (neg_interactions + J[4,i,site_nbr,k]) * h[i][j][k]
          priorities[i*N*N+j*N+k][1] += pos_interactions + J[4,i,site_nbr,k] * h[i][j][k]
  
  return(priorities)


#score: {'data3D.txt': -0.08604220000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + J[3,i,site_nbr,k]
        
        # Calculate the number of positive and negative interactions
        interacting_spins = [(d==i)*J[0,i,j,k] + (d==j)*J[1,i,j,k] + (d==k)*J[2,i,j,k] for d in range(6)]
        pos_interactions = sum(val > 0 for val in interacting_spins)
        neg_interactions = len(interacting_spins) - pos_interactions
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + (pos_interactions + J[4,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] -= neg_interactions - J[4,i,site_nbr,k]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - (neg_interactions + J[4,i,site_nbr,k])
          priorities[i*N*N+j*N+k][1] += pos_interactions + J[4,i,site_nbr,k]
  
  return(priorities)


#score: {'data3D.txt': -0.22749740000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) +\
            sum(J[d,site_nbr,j,k] for d in [3,4,5])
        interacting_spins = sorted([J[3,i,j,k], J[4,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[0,(i+1)%N,j,k], J[5,i,j,k], J[1,i,j,(k+1)%N]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.14128260000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + \
                sum(J[3,(i+((k-1)%2 - 1)) % N,j,k] for _ in range(6))
        interacting_spins = sorted([J[3,i,j,k], J[4,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                       J[0,(i+1)%N,j,k], J[5,i,j,k], J[1,i,j,(k+1)%N]])
        spin_interaction = sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) + spin_interaction
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) - spin_interaction
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.22116820000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) +\
            sum(J[3,i,j,k] for _ in [0]) +\
            sum(J[4,site_nbr,j,k] for _ in [0])
        interacting_spins = sorted([J[3,i,j,k], J[4,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                       J[0,(i+1)%N,j,k], J[5,i,j,k], J[1,i,j,(k+1)%N]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.31735179999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] * h[site_nbr][j][k] for d in [0,1,2]) + J[3,i,j,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                      J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) + J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - J[5,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.3180813999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] * h[site_nbr][j][k] for d in [0,1,2]) + J[3,i,j,k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) + J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - J[5,i,j,k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(val for val in interacting_spins if val > 0) - J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - J[5,i,j,k]
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum(val for val in interacting_spins if val < 0) + J[4,i,j,k]
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - J[5,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.2747434000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        interacting_spins = [J[3,i,j,k], J[4,i,j,k], J[5,i,j,k]]
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.1244402}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [(J[0,i,j,k], 0), (J[1,i,(j+1)%N,k], 1), (J[2,i,j,(k+1)%N], 2),
                   (J[3,(i+1)%N,j,k], 3), (J[4,i,j,k], 4), (J[5,(i+1)%N,(j+1)%N,(k+1)%N], 5)]
        interacting_spins.sort(key=lambda x: x[0], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(spin[0] for spin in interacting_spins if spin[0] > 0) - sum(spin[0] for spin in interacting_spins if spin[0] < 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val, _ in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(spin[0] for spin in interacting_spins if spin[0] < 0) - sum(spin[0] for spin in interacting_spins if spin[0] > 0)
          priorities[i*N*N+j*N+k][1] += len([val for val, _ in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.1244402}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = sorted([J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                     J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,(k+1)%N]], reverse=True)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(spin for spin in interacting_spins if spin > 0) - sum(spin for spin in interacting_spins if spin < 0)
          priorities[i*N*N+j*N+k][1] = -(len([val for val in interacting_spins if val > 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(spin for spin in interacting_spins if spin < 0) - sum(spin for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.34267539999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.34390139999999964}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3435253999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0]) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.15875739999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) + len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[0,site_nbr,j,k], J[1,i,j-1%N,k], J[2,i-1%N,j,k]] if val > 0]) - 3
  return(priorities)


#score: {'data3D.txt': -0.3210581999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        # Add the magnetism contribution
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 * (h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += 2 * (h[i][j][k])
  return priorities


#score: {'data3D.txt': 0.09638340000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k] 
        interacting_spins_sum = sum([J[l, i, j, k] for l in [0, 1, 2, 3, 4]])
        if J[5, i, j, k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + interacting_spins_sum
          priorities[i*N*N+j*N+k][1] -= sum([J[l, i, j, k] for l in [2, 4]])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - interacting_spins_sum
          priorities[i*N*N+j*N+k][1] += sum([J[l, i, j, k] for l in [0, 3]])
  return priorities


#score: {'data3D.txt': -0.30348820000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k] 
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3673254000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][0]
    if total_spin > 0:
      priorities[i][0] += abs(total_spin) + sum(1 for val in [J[d,i//N, i%N, 0] for d in range(6)] if val > 0)
      priorities[i][1] -= len([val for val in [J[d,i//N, i%N, 0] for d in range(6)] if val < 0])
    else:
      priorities[i][0] -= abs(total_spin) - sum(1 for val in [J[d,i//N, i%N, 0] for d in range(6)] if val < 0)
      priorities[i][1] += len([val for val in [J[d,i//N, i%N, 0] for d in range(6)] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.3413342000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[d,i//N, i%N, 0] for d in range(6))
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += abs(total_spin) + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)
      priorities[i][1] -= total_spin - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
    else:
      priorities[i][0] -= abs(total_spin) - sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] < 0)
      priorities[i][1] = total_spin + sum(J[d,i//N, i%N, 0] for d in range(6) if J[d,i//N, i%N, 0] > 0)

  return(priorities)


#score: {'data3D.txt': 0.09399060000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        site_nbrs_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        priorities[i*N*N+j*N+k][0] += site_nbrs_spin + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
  return priorities


#score: {'data3D.txt': -0.3616826000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.30348820000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k] 
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        interacting_spins.sort(key=lambda x: abs(x))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3306057999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 2
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.445989}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.10580460000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i-1)%N, i, (i+1)%N]
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        priority_total = np.zeros((2,))
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            priority_total[0] += 1
            priority_total[1] -= 1
          else:
            priority_total[0] -= 1
            priority_total[1] += 1
        priorities[i*N*N+j*N+k][0] = -total_spin + len([val for val in interacting_spins if val > 0]) + priority_total[0]
        priorities[i*N*N+j*N+k][1] = total_spin + len([val for val in interacting_spins if val < 0]) + priority_total[1]
  return(priorities)


#score: {'data3D.txt': -0.3306057999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          total_spin = np.sum(total_spin)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 2
        else:
          total_spin = np.sum(total_spin)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 2
  return(priorities)


#score: {'data3D.txt': -0.3432289999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[d,i,j,k] for d in range(3)] + [J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                   J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                   J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin[0] += h[i][j][k]
        if h[i][j][k] > 0:
          total_spin[1] -= 1
        else:
          total_spin[1] += 1
        for d in [0,1,2]:
          site = (i + ((d-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        for d in [3,4,5]:
          site = (i + ((d-3)%2 - 1)) % N
          if h[i][site][k] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        for d in [6,7,8]:
          site = (j + ((d-6)%2 - 1)) % N
          if h[i][j][site] > 0:
            total_spin[0] += 1
          else:
            total_spin[0] -= 1
        priorities[i*N*N+j*N+k][0] = -total_spin[0]
        priorities[i*N*N+j*N+k][1] = -total_spin[0]
  return(priorities)


#score: {'data3D.txt': -0.22836620000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.2534254000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - min(abs(total_spin),len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + min(abs(total_spin),len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3707866000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N][0]
    if total_spin > 0:
      priorities[i][0] += abs(total_spin) + sum(1 for val in [J[d,i//N, i%N, 0] for d in range(6)] if val > 0)
      priorities[i][1] -= len([val for val in [J[d,i//N, i%N, 0] for d in range(6)] if val < 0])
    else:
      priorities[i][0] -= abs(total_spin) - sum(1 for val in [J[d,i//N, i%N, 0] for d in range(6)] if val < 0)
      priorities[i][1] = total_spin + sum(1 for val in [J[d,i//N, i%N, 0] for d in range(6)] if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.19726540000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0][site_nbr][j][k], J[1][site_nbr][j][k], J[2][site_nbr][j][k]]
        total_spin = sum(h[site_nbr][j][k] for _ in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.33956939999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 2
  return(priorities)


#score: {'data3D.txt': -0.3428193999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 2
  return(priorities)


#score: {'data3D.txt': 0.35987899999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] + sum(J[d,i,j,k] for d in [0,1,2])
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        if J[1,i,j,k] > 0:
          total_spin += h[site_nbr][j]
          if J[1,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
        if J[2,i,j,k] > 0:
          total_spin += h[site_nbr][j]
          if J[2,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[i][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6
  return(priorities)


#score: {'data3D.txt': -0.3348566000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - sum([J[d,i,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) + sum([J[d,i,j,k] for d in [0,1,2]])
          priorities[i*N*N+j*N+k][1] = total_spin + 6
  return(priorities)


#score: {'data3D.txt': -0.30543220000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] += total_spin + 6
  return(priorities)


#score: {'data3D.txt': 0.34049260000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          spin_bias = abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
        else:
          spin_bias = -abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
        priorities[i*N*N+j*N+k][0] = spin_bias
        priorities[i*N*N+j*N+k][1] = -spin_bias
  return(priorities)


#score: {'data3D.txt': -0.3240678}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + 1) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in interacting_spins if val < 0]) + sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0]) - sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + 3
  return(priorities)


#score: {'data3D.txt': -0.375431}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [J[d,i,j,k] for d in range(6)] if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in [J[d,i,j,k] for d in range(6)] if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [J[d,i,j,k] for d in range(6)] if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in [J[d,i,j,k] for d in range(6)] if val > 0)

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.34635900000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(i+1)%N, (i+N-1)%N]
        site_nbrs_z = [(j + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs_y + site_nbrs_x + site_nbrs_z])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.2534254000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val == 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
  return(priorities)


#score: {'data3D.txt': -0.41857620000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + 3*len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        spin_magnetism = h[i][j][k]
        if spin_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2873458000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (k + ((k-1)%2 - 1)) % N]
        site_interactions = [J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6)]
        total_spin = sum(J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6))
        interacting_spins = [J[d,site_nbrs[0],site_nbrs[1],k] for d in range(3)] + [J[d,i,j,k] for d in range(3)]
        if h[site_nbrs[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in site_interactions + interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in site_interactions + interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in site_interactions + interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in site_interactions + interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.23641420000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (k + ((k-1)%2 - 1)) % N]
        site_interactions = [J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6)]
        total_spin = sum(J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6))
        interacting_spins = [J[d,site_nbrs[0],site_nbrs[1],site_nbrs[2]] for d in range(6)]
        if h[site_nbrs[0]][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  # Add an additional term based on the magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%N - N//2)) % N
      total_spin = h[i][j][0]
      for k in range(N):
        total_spin += J[3,i,j,k] * h[i][j][k]
      if total_spin > 0:
        priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)
        priorities[i*N*N+j*N+k][1] -= sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
      else:
        priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [J[d,i,j,k] for d in range(3)] if val < 0)
        priorities[i*N*N+j*N+k][1] += sum(1 for val in [J[d,i,j,k] for d in range(3)] if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.17948780000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3192638}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) 
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.044319800000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - 2
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] += total_spin + 2
  return(priorities)


#score: {'data3D.txt': 0.04404980000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin + 6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) + len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin - 6
  return(priorities)


#score: {'data3D.txt': -0.20584100000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) + len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0])
          priorities[i*N*N+j*N+k][1] += total_spin + 6
  return(priorities)


#score: {'data3D.txt': -0.3013398000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        priority_up = np.sum(np.maximum(0, interacting_spins)) - np.sum(np.minimum(0, interacting_spins))
        priority_down = 2 * (1 if h[i][j][k] > 0 else -1)
        total_priority_up = sum([np.sign(h[(p+1)%N][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        total_priority_down = 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        priorities[i*N*N+j*N+k][0] += total_spin + priority_up + total_priority_up
        priorities[i*N*N+j*N+k][1] -= total_spin + priority_down - total_priority_down
  return priorities


#score: {'data3D.txt': -0.058693000000000294}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin - interacting_spins
          priorities[i*N*N + j*N + k][1] = -(total_spin - interacting_spins)
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin + interacting_spins
          priorities[i*N*N + j*N + k][1] = 7 - (total_spin + interacting_spins)
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 1
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 1
          priorities[i*N*N+j*N+k][1] += 2
        for d in [0,1,2]:
          site = (i + ((d-1)%2 - 1)) % N
          total_spin += h[site][j][k]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[d,i,j,k], J[d,site,j,k]] if val > 0]) - 3
            priorities[i*N*N+j*N+k][1] -= len([val for val in [J[d,i,j,k], J[d,site,j,k]] if val < 0]) + 2
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[d,i,j,k], J[d,site,j,k]] if val < 0]) + 3
            priorities[i*N*N+j*N+k][1] += len([val for val in [J[d,i,j,k], J[d,site,j,k]] if val > 0]) + 2
  return(priorities)


#score: {'data3D.txt': -0.33896059999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[:,site_nbr,j,k] if val > 0]) - len([val for val in J[:,site_nbr,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in J[:,site_nbr,j,k] if val > 0]) - len([val for val in J[:,site_nbr,j,k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[:,site_nbr,j,k] if val < 0]) + len([val for val in J[:,site_nbr,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in J[:,site_nbr,j,k] if val > 0]) + len([val for val in J[:,site_nbr,j,k] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.1651782000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] = 1 - abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 - len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.23532700000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3092517999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(i+1)%N, (i+N-1)%N]
        site_nbrs_z = [(j + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs_y + site_nbrs_x + site_nbrs_z])
        interacting_spins_up = [J[l, i, j, k] for l in range(6) if h[i][j][k] * J[l, i, j, k] > 0]
        interacting_spins_down = [J[l, i, j, k] for l in range(6) if h[i][j][k] * J[l, i, j, k] < 0]
        priority_up = np.sum(interacting_spins_up)
        priority_down = -np.sum(interacting_spins_down)
        priorities[i*N*N+j*N+k][0] += total_spin + priority_up
        priorities[i*N*N+j*N+k][1] -= total_spin + priority_down
  return priorities


#score: {'data3D.txt': -0.34635900000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(i+1)%N, (i+N-1)%N]
        site_nbrs_z = [(j + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs_y + site_nbrs_x + site_nbrs_z])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3

  # Add some more calculations here to improve the algorithm
  return priorities


#score: {'data3D.txt': -0.0027370000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(i+1)%N, (i+N-1)%N]
        site_nbrs_z = [(j + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs_y + site_nbrs_x + site_nbrs_z])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.23349220000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.30316179999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([h[l][j][k] if l != i else 0 for l in range(N)])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.015337}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        total_spin += sum([val * (1 if val > 0 else -1) for val in interacting_spins])
        priority_total = np.zeros((N, N, N, 2))
        for p in range(N):
          site_nbr = (i + ((p-1)%2 - 1)) % N
          total_spin_site = h[site_nbr][j][k]
          if total_spin_site > 0:
            priority_total[i][j][k][0] += total_spin_site
            priority_total[i][j][k][1] -= total_spin_site
          else:
            priority_total[i][j][k][0] -= total_spin_site
            priority_total[i][j][k][1] += total_spin_site
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([priority_total[site_nbr][j][k][0] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([priority_total[site_nbr][j][k][0] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3747574000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((N-1)%2 - 1)) % N
      if h[site_nbr][j][0] > 0:
        priorities[i*N+j*N+0][0] += abs(total_spin) + sum(J[d,i,j,0] for d in range(6))
        priorities[i*N+j*N+0][1] -= sum(J[d,i,j,0] for d in range(6) if J[d,i,j,0] < 0)
      else:
        priorities[i*N+j*N+0][0] -= abs(total_spin) - sum(J[d,i,j,0] for d in range(6) if J[d,i,j,0] < 0)
        priorities[i*N+j*N+0][1] = -1 + sum(J[d,i,j,0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.3646114000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))
  
  return(priorities)


#score: {'data3D.txt': -0.16705299999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(val for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(val for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.3775186000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  total_priority = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_priority[i*N+j][0] += h[site_nbr][j][0]
      if h[site_nbr][j][0] > 0:
        total_priority[i*N+j][0] += 1
        total_priority[i*N+j][1] -= 1
      else:
        total_priority[i*N+j][0] -= 1
        total_priority[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      total_priority[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      total_priority[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      total_priority[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      total_priority[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return np.maximum(total_priority, priorities)


#score: {'data3D.txt': -0.025133}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbrs[0]][i][j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.445989}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3112993999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        priority_sum = sum(abs(val) for val in interacting_spins)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + priority_sum
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + priority_sum
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3112993999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = np.array([J[l,i,j,k] for l in range(6)])
        priority_sum = np.sum(np.abs(interacting_spins))
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + priority_sum
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + priority_sum
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return(priorities)


#score: {'data3D.txt': 0.0723898}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': 0.09815259999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i + ((j-1)%2 - 1)) % N, (j + ((k-1)%2 - 1)) % N]
        for site in site_nbrs:
          if h[site][i][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1

        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.34324099999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        total_spin = sum(J[d,i,j,k] for d in range(3)) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k],
                   J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                   J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                   J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return(priorities)


#score: {'data3D.txt': -0.3432289999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[d,i,j,k] for d in range(3)] + [J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                    J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                    J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return(priorities)


#score: {'data3D.txt': -0.3236674000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[d,i,j,k] for d in range(3)] + [J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                    J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                    J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3291885999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] + [J[d,site_nbrs[0],j,k] for d in range(3)] + [J[0,i,site_nbrs[1],k] for _ in range(3)] + [J[0,i,j,site_nbrs[2]] for _ in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 9
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) + 4
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 9
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 4
  return(priorities)


#score: {'data3D.txt': -0.34332219999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_energy = abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_energy
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_energy
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.32703099999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.31194059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        # Add the magnetism contribution
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 * (h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += 2 * (h[i][j][k])
  return priorities


#score: {'data3D.txt': -0.32786539999999975}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        # Add the magnetism contribution
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 * (h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += 2 * (h[i][j][k])
  return priorities


#score: {'data3D.txt': -0.14221979999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k],
                    J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,i,j,(k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin - len([val for val in interacting_spins if val > 0]) + 3
          priorities[i*N*N+j*N+k][1] = total_spin + len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin + len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] = total_spin - len([val for val in interacting_spins if val > 0]) - 3
  return(priorities)


#score: {'data3D.txt': -0.29948940000000046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = []
        for d in range(6):
          if J[d,i,j,k] > 0:
            interacting_spins.append(1)
          elif J[d,i,j,k] < 0:
            interacting_spins.append(-1)
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val == 1])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val == -1]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val == -1]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val == 1])
  return(priorities)


#score: {'data3D.txt': -0.29987339999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 2
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.34094139999999973}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[d,i,j,k] for d in range(3)] + [J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                    J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                    J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        spin_energy = -h[i][j][k]*total_spin
        interacting_energy = sum(val*abs(val) for val in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + interacting_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - interacting_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) + 2
  return(priorities)


#score: {'data3D.txt': 0.19271100000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 3
  return(priorities)


#score: {'data3D.txt': -0.3195465999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.2730894}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Add a correction term based on the site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.22860660000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        if h[i][site_nbr2][k] > 0:
          priorities[i*N*N+site_nbr2*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+site_nbr2*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+site_nbr2*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+site_nbr2*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.36598620000000004}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[site_nbr][i][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

        site_nbr = (j + ((k-1)%2 - 1)) % N
        if h[site_nbr][i][j] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.3691730000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(J[d,i,j,0] for d in range(6))
      interacting_spins = [J[d,i,j,0] for d in range(6)]
      if h[site_nbr][i][0] > 0:
        priorities[i*N*N+j][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
        priorities[i*N*N+j][1] -= sum(1 for val in interacting_spins if val < 0)
      else:
        priorities[i*N*N+j][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
        priorities[i*N*N+j][1] += sum(1 for val in interacting_spins if val > 0)

  return priorities


#score: {'data3D.txt': -0.3646114000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return priorities


#score: {'data3D.txt': -0.3646114000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N][0] > 0:
      priorities[i][0] += 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] -= 1 - sum(J[d,i//N, i%N, 0] for d in range(6))
    else:
      priorities[i][0] -= 1 + sum(J[d,i//N, i%N, 0] for d in range(6))
      priorities[i][1] = -1 + sum(J[d,i//N, i%N, 0] for d in range(6))

  return(priorities)


#score: {'data3D.txt': -0.11874020000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4]) - J[5,i,j,k]
        interacting_spins = []
        for d in range(6):
          if J[d,i,j,k] > 0:
            interacting_spins.append(1)
          elif J[d,i,j,k] < 0:
            interacting_spins.append(-1)
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val == 1]) - 2*abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val == -1])
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val == -1]) + 2*abs(total_spin)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val == 1])
  return(priorities)


#score: {'data3D.txt': -0.09836700000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = []
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + abs(total_spin) + sum(1 for val in J[::3,i,j,k] if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in J[::3,i,j,k] if val < 0) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - abs(total_spin) - sum(1 for val in J[::3,i,j,k] if val < 0) + 2
          priorities[i*N*N+j*N+k][1] += sum(1 for val in J[::3,i,j,k] if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.2307170000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.38566900000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.4534178000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - sum([abs(val) for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]))
  return priorities


#score: {'data3D.txt': -0.30385019999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_magnetism = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_magnetism = abs(total_spin) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_magnetism
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.18848580000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': 0.0761122}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])

  # Calculate the priority based on the magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N+N-1][0] += sum(h[i][j])
        priorities[i*N*N+j*N+N-1][1] -= sum(h[i][j])
      else:
        priorities[i*N*N+j*N+N-1][0] -= sum(h[i][j])
        priorities[i*N*N+j*N+N-1][1] += sum(h[i][j])

  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(3)]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = abs(total_spin) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= 1 - total_spin
          priorities[i*N*N+j*N+k][1] += 1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37556020000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        spin_magnetism = h[i][j][k]
        if spin_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3373321999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': 0.24541379999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])

  site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
  for i, site in enumerate(site_nbrs):
    total_spin = h[site][i][0]
    if total_spin > 0:
      priorities[i*N+N+i][0] += abs(total_spin) + len([val for val in J[3,i,N-1] if val > 0])
      priorities[i*N+N+i][1] -= len([val for val in J[3,i,N-1] if val < 0])
    else:
      priorities[i*N+N+i][0] -= abs(total_spin) - len([val for val in J[3,i,N-1] if val > 0])
      priorities[i*N+N+i][1] += len([val for val in J[3,i,N-1] if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.3163285999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k],
                   J[0,(i+1)%N,j,k], J[1,(i+1)%N,j,k], J[2,(i+1)%N,j,k],
                   J[0,i,(j+1)%N,k], J[1,i,(j+1)%N,k], J[2,i,(j+1)%N,k],
                   J[0,i,j,(k+1)%N], J[1,i,j,(k+1)%N], J[2,i,j,(k+1)%N]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 2
  return(priorities)


#score: {'data3D.txt': -0.3236674000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[d,i,j,k] for d in range(3)] + [J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                  J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                  J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3236674000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[d,i,j,k] for d in range(3)] + [J[0,site_nbrs[0],j,k], J[1,site_nbrs[0],j,k], J[2,site_nbrs[0],j,k],
                    J[0,i,site_nbrs[1],k], J[1,i,site_nbrs[1],k], J[2,i,site_nbrs[1],k],
                    J[0,i,j,site_nbrs[2]], J[1,i,j,site_nbrs[2]], J[2,i,j,site_nbrs[2]]]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        magnetism = h[i][j][k]
        spin_energy = -magnetism*total_spin
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.32587899999999975}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k] + sum([J[d,i,j,k] for d in [0,1,2]]) + sum([h[(p+1)%N][j][k] if p!=i else 0 for p in range(3)])
        interacting_spins = [J[l,site_nbr,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        total_spin += sum([h[(i+(p-1))%N][j][k] if p!=2 else 0 for p in [1,2]]) 
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return priorities


#score: {'data3D.txt': -0.2894874000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[l,site_nbr,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
          interacting_spins = [J[l,site_nbr,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
          total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] += 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.33950139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbr = (i + ((2-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in [J[l,i,j,k] for l in range(6)]])
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] += sum([abs(val) for val in [J[l,i,j,k] for l in range(6)]])
  return priorities


#score: {'data3D.txt': -0.31053219999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins])
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][j][k] for j in range(N) for k in range(N)]) + h[i][0][0]
    if total_spin > 0:
      priorities[i*N*N+0*4+0][0] += abs(total_spin)
      priorities[i*N*N+0*4+0][1] -= sum([abs(val) for val in [J[l,i,0,0] for l in range(6)]])
    elif total_spin < 0:
      priorities[i*N*N+0*4+0][0] -= abs(total_spin)
      priorities[i*N*N+0*4+0][1] += sum([abs(val) for val in [J[l,i,0,0] for l in range(6)]])
  return priorities


#score: {'data3D.txt': -0.32298019999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i%N,j%N,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.33932339999999966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.23426100000000039}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[3,i-1%N,j,k], J[4,i,j-1%N,k], J[5,i,j,k-1%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(site_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(site_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        spin_magnetism = h[i][j][k]
        if spin_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.33896059999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        interacting_spins = J[:,site_nbr,j,k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + np.count_nonzero(interacting_spins > 0) - np.count_nonzero(interacting_spins < 0)
          priorities[i*N*N+j*N+k][1] = -np.count_nonzero(interacting_spins > 0) - np.count_nonzero(interacting_spins < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - np.count_nonzero(interacting_spins < 0) + np.count_nonzero(interacting_spins > 0)
          priorities[i*N*N+j*N+k][1] = np.count_nonzero(interacting_spins > 0) + np.count_nonzero(interacting_spins < 0)
  return(priorities)


#score: {'data3D.txt': -0.3227273999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[:,site_nbr,j,k] if val > 0]) - len([val for val in J[:,site_nbr,j,k] if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in J[:,site_nbr,j,k] if val > 0]) - len([val for val in J[:,site_nbr,j,k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[:,site_nbr,j,k] if val < 0]) + len([val for val in J[:,site_nbr,j,k] if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in J[:,site_nbr,j,k] if val > 0]) + len([val for val in J[:,site_nbr,j,k] if val < 0])
        site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,i,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[:,site_nbr,i,k] if val > 0]) - len([val for val in J[:,site_nbr,i,k] if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in J[:,site_nbr,i,k] if val > 0]) - len([val for val in J[:,site_nbr,i,k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[:,site_nbr,i,k] if val < 0]) + len([val for val in J[:,site_nbr,i,k] if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in J[:,site_nbr,i,k] if val > 0]) + len([val for val in J[:,site_nbr,i,k] if val < 0])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr,j,N-1-k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[:,site_nbr,j,N-1-k] if val > 0]) - len([val for val in J[:,site_nbr,j,N-1-k] if val < 0])
          priorities[i*N*N+j*N+k][1] = -len([val for val in J[:,site_nbr,j,N-1-k] if val > 0]) - len([val for val in J[:,site_nbr,j,N-1-k] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[:,site_nbr,j,N-1-k] if val < 0]) + len([val for val in J[:,site_nbr,j,N-1-k] if val > 0])
          priorities[i*N*N+j*N+k][1] = len([val for val in J[:,site_nbr,j,N-1-k] if val > 0]) + len([val for val in J[:,site_nbr,j,N-1-k] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.03210820000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(val < 0 for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(val > 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(val < 0 for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.3174309999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 2
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.1316190000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(3))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 2
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 2
  return(priorities)


#score: {'data3D.txt': -0.09458500000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = h[(i + ((k-1)%2 - 1)) % N][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)

  for i in range(N**3):
    site_nbr = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site_nbr][i%N**2 % N][1])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
    else:
      priorities[i][0] -= abs(h[site_nbr][i%N**2 % N][1])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.1697177999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.06270580000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j][k]
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= sum(abs(val) for val in interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += sum(abs(val) for val in interacting_spins)
  site_nbrs = [(i + ((k-1)%2 - 1)) % N for i in range(N)]
  for i, site in enumerate(site_nbrs):
    if h[site][i][0] > 0:
      priorities[i*N*N+i][0] += 1
      priorities[i*N*N+i][1] -= 1
    else:
      priorities[i*N*N+i][0] -= 1
  for i in range(N**3):
    site = (i // N**2 % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N**2 % N][0] > 0:
      priorities[i][0] += abs(h[site][i%N**2 % N][1]) + len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
      priorities[i][1] -= len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])
    else:
      priorities[i][0] -= abs(h[site][i%N**2 % N][1]) - len([val for val in J[3,i//N**2,i%N**2 % N] if val < 0])
      priorities[i][1] += len([val for val in J[3,i//N**2,i%N**2 % N] if val > 0])

  return(priorities)


#score: {'data3D.txt': 0.13775939999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 3
        # Add the magnetism of the site itself to the total spin energy
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= h[i][j][k]
  return(priorities)


#score: {'data3D.txt': 0.19271100000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k],
                    J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 3
  return(priorities)


#score: {'data3D.txt': -0.22486580000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                   J[3,(i+1)%N,j,k], J[4,i,j,k],
                   J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        site_energy = -h[i][j][k]*total_spin
        edge_energy = sum([J[d,i,j,k] + J[d,i,(j+1)%N,k] if h[i][j][k] * (i != j) else 0 for d in [0,2]])
        corner_energy = sum([-J[5,i,(j+1)%N,k] if h[i][j][k] and i == N-1 and j == N-1 else 0 for _ in range(4)])
        spin_energy = site_energy + edge_energy + corner_energy
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 3
  return(priorities)


#score: {'data3D.txt': 0.19271100000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N],
                    J[3,(i+1)%N,j,k], J[4,i,j,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,2,4])
        spin_energy = -h[i][j][k]*total_spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + len([val for val in interacting_spins if val > 0]) - 6
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - len([val for val in interacting_spins if val < 0]) + 6
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - 3
  return(priorities)


#score: {'data3D.txt': -0.20411820000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) + sum([a for a in interacting_spins if a > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - sum([a for a in interacting_spins if a < 0])
  return(priorities)


#score: {'data3D.txt': -0.19912500000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([a*b for a, b in zip(interacting_spins, [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]])])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([a*b for a, b in zip(interacting_spins, [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]])])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.18848580000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return(priorities)


#score: {'data3D.txt': -0.19614260000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site = h[site_nbr][j][k]
        if total_spin_site > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_site
          priorities[i*N*N+j*N+k][1] -= total_spin_site
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_site
          priorities[i*N*N+j*N+k][1] += total_spin_site
  return(priorities)


#score: {'data3D.txt': -0.3210501999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin - interacting_spins
          priorities[i*N*N + j*N + k][1] = -7 + interacting_spins
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin + interacting_spins
          priorities[i*N*N + j*N + k][1] = 7 - interacting_spins
  
  # Add a term to make the priority for 1 and -1 more distinct
  for i in range(N**3):
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0] += np.exp(priorities[i][0] - priorities[i][1])
    else:
      priorities[i][1] += np.exp(-priorities[i][0] + priorities[i][1])
  
  return priorities


#score: {'data3D.txt': -0.04324460000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = sum([J[l, i, j, k] for l in range(6)])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += total_spin
          priorities[i*N*N + j*N + k][1] -= interacting_spins
        else:
          priorities[i*N*N + j*N + k][0] -= total_spin
          priorities[i*N*N + j*N + k][1] += interacting_spins
  return priorities


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.33480660000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_sum = abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_sum
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin - priority_sum
        else:
          priority_sum = abs(total_spin) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_sum
          priorities[i*N*N+j*N+k][1] = -2 * total_spin + priority_sum
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.29302020000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3394857999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.015337}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site][j][k] for site in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        total_spin += sum([val * (1 if val > 0 else -1) for val in interacting_spins])
        priority_total = np.zeros((N, N, N, 2))
        for p in range(N):
          site_nbr = (i + ((p-1)%2 - 1)) % N
          total_spin_site = h[site_nbr][j][k]
          if total_spin_site > 0:
            priority_total[i][j][k][0] += total_spin_site
            priority_total[i][j][k][1] -= total_spin_site
          else:
            priority_total[i][j][k][0] -= total_spin_site
            priority_total[i][j][k][1] += total_spin_site
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([priority_total[site_nbr][j][k][0] for site_nbr in site_nbrs])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([priority_total[site_nbr][j][k][0] for site_nbr in site_nbrs])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.26605300000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
        interacting_spins = np.array([J[l,i,j,k] for l in range(6)])
        total_spin += sum(interacting_spins)
        priority_total = np.zeros((N, N, N, 2))
        for p in range(N):
          site_nbr = (i + ((p-1)%2 - 1)) % N
          total_spin_site = h[site_nbr][j][k]
          if total_spin_site > 0:
            priority_total[i][j][k][0] += total_spin_site
            priority_total[i][j][k][1] -= total_spin_site
          else:
            priority_total[i][j][k][0] -= total_spin_site
            priority_total[i][j][k][1] += total_spin_site
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([priority_total[site_nbr][j][k][0] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([priority_total[site_nbr][j][k][0] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] -= sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
          priorities[i*N*N+j*N+k][1] += sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) + 3
  return priorities


#score: {'data3D.txt': -0.3428873999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        priority_total = abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3 + abs(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3 - abs(h[i][j][k])
  return priorities


#score: {'data3D.txt': -0.3427125999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin += sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = sorted([J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)])
        priority_total = total_spin + sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        # Add the magnetism contribution
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 * (h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += 2 * (h[i][j][k])
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        for site_nbr in site_nbrs:
          total_spin += h[site_nbr][j][k]
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        priority_total = abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return(priorities)


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.28075059999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4933266000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.20743219999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)


#score: {'data3D.txt': -0.3192645999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        priority_up = abs(total_spin) + sum([val for val in interacting_spins if val > 0])
        priority_down = -abs(total_spin) - sum([val for val in interacting_spins if val < 0])
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priorities[i*N*N+j*N+k][0] -= priority_down
          priorities[i*N*N+j*N+k][1] += priority_up
  return priorities


#score: {'data3D.txt': -0.16844780000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + sum(interacting_spins)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.28682700000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        site_nbrs = [(i+((p-1)%2 - 1)) % N for p in range(6)]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        priorities[i*N*N+j*N+k][0] += abs(total_spin)
  return priorities


#score: {'data3D.txt': 0.09399060000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((k-1)%2 - 1)) % N]])
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        priorities[i*N*N+j*N+k][0] += site_nbrs_spin + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
  return priorities


#score: {'data3D.txt': 0.08613660000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [np.sign(J[l, i, (j + ((l-1)%2 - 1)) % N, (k + ((l-1)%2 - 1)) % N]) for l in range(6)]
        site_nbrs_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((k-1)%2 - 1)) % N]])
        priorities[i*N*N+j*N+k][0] += site_nbrs_spin + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
  return priorities


#score: {'data3D.txt': -0.13303060000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate priority for each site based on interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]])
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        
        # Assign spins based on priority
        if site_nbrs_spin + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  
  return priorities


#score: {'data3D.txt': -0.2697154}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((k-1)%2 - 1)) % N]
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        site_nbrs_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins.sort()
        priorities[i*N*N+j*N+k][0] += site_nbrs_spin + np.sum(interacting_spins[:len(interacting_spins)//2]) - len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
  return priorities


#score: {'data3D.txt': -0.3881702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - (abs(total_spin)-len([val for val in interacting_spins if val > 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = total_spin + (abs(total_spin)-len([val for val in interacting_spins if val > 0]))
  return(priorities)


#score: {'data3D.txt': -0.15647220000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) + min(len([val for val in interacting_spins if val > 0]),3)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + max(len([val for val in interacting_spins if val < 0]),-3)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3985362}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 1 - total_spin - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2689810000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2808718000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.2590178000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.2945974}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.abs(total_spin) + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= np.abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3397729999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin_site = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + total_spin_site + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - total_spin_site - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.3316489999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        total_spin_priority = np.sign(total_spin)
        interacting_spins_priority = [np.sign(val) for val in interacting_spins]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin_priority + sum(interacting_spins_priority)
          priorities[i*N*N+j*N+k][1] = -6 + sum(interacting_spins_priority)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin_priority - sum(interacting_spins_priority)
          priorities[i*N*N+j*N+k][1] = 6 - sum(interacting_spins_priority)
  return(priorities)


#score: {'data3D.txt': -0.34335819999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] = -total_spin - sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': 0.010812199999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        total_spin += sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val < 0]) + 3
        else:
          priorities[i*N*N+j*N+k][0] = total_spin
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0]) + 3
  return(priorities)


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Sort the priority values for each site and store them in a new list
  sorted_priorities = [sorted(priorities[i*N*N+j*N+k], reverse=True) for i in range(N) for j in range(N) for k in range(N)]

  return sorted_priorities


#score: {'data3D.txt': 0.053854599999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])

        # Calculate the priority based on the magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += abs(h[i][j][k])

  return(priorities)


#score: {'data3D.txt': -0.14355180000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the total spin and interacting spins for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        
        # Calculate the priority based on the magnetism and interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': 0.0688834}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])

  # Calculate the priority based on the magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N+N-1][0] += sum(h[i][j])
        priorities[i*N*N+j*N+N-1][1] -= sum(h[i][j])
      else:
        priorities[i*N*N+j*N+N-1][0] -= sum(h[i][j])
        priorities[i*N*N+j*N+N-1][1] += sum(h[i][j])

  # Calculate the priority based on the interaction with neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])

  return(priorities)


#score: {'data3D.txt': -0.24747580000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate the site interactions with its nearest neighbors
        site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        site_interaction_strength = sum([abs(val) for val in site_interactions])

        # Update the priorities based on the site interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= site_interaction_strength
        else:
          priorities[i*N*N+j*N+k][0] -= site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -site_interaction_strength

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Sort the priority values for each site and store them in a new list
  sorted_priorities = [sorted(priorities[i*N*N+j*N+k], reverse=True) for i in range(N) for j in range(N) for k in range(N)]

  return(sorted_priorities)


#score: {'data3D.txt': -0.2761949999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.4462934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0]) 
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors_down = len([val for val in interacting_spins if val > 0]) 
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + min(num_neighbors_down, num_neighbors_up)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.021357799999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        site_nbr3 = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,site_nbr1,j,k] for d in [0,1,2]) + sum(J[d,i,site_nbr2,k] for d in [0,1,2]) + sum(J[d,i,j,site_nbr3] for d in [0,1,2])
        interacting_spins = list(set([J[0,site_nbr1,j,k], J[1,site_nbr1,j,k], J[2,site_nbr1,j,k]])) + list(set([J[0,i,site_nbr2,k], J[1,i,site_nbr2,k], J[2,i,site_nbr2,k]])) + list(set([J[0,i,j,site_nbr3], J[1,i,j,site_nbr3], J[2,i,j,site_nbr3]]))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -sum(1 for spin in interacting_spins if spin < 0) + sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][1] = sum(1 for spin in interacting_spins if spin > 0) + sum(1 for spin in interacting_spins if spin < 0)
        else:
          priorities[i*N*N+j*N+k][0] = sum(1 for spin in interacting_spins if spin < 0) - sum(1 for spin in interacting_spins if spin > 0)
          priorities[i*N*N+j*N+k][1] = sum(1 for spin in interacting_spins if spin > 0) + sum(1 for spin in interacting_spins if spin < 0)
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        spin_magnetism = h[i][j][k]
        if spin_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val > 0) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val < 0) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3030962000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 3 * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 3 * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.48546180000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.27132540000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([J[5,i,j,k] for i in [(i+1)%N] if (j+1)%N != N])
          priorities[i*N*N+j*N+k][1] -= 6 - sum([np.sign(h[p][j][k]) for p in range(3)]) + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([J[5,i,j,k] for i in [(i+1)%N] if (j+1)%N != N])
          priorities[i*N*N+j*N+k][1] += 6 + sum([np.sign(h[p][j][k]) for p in range(3)]) - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        priority = [total_spin, -6]
        priorities[i*N*N+j*N+k] = [(p + v) % 2 for p,v in zip(priorities[i*N*N+j*N+k],priority)]
  return priorities


#score: {'data3D.txt': -0.24892700000000043}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        total_spin += sum([np.sign(h[p][j][k]) * np.sign(interacting_spins[p]) for p in range(3)])
        interacting_sum = sum([abs(val) for val in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + interacting_sum
          priorities[i*N*N+j*N+k][1] -= 6 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - interacting_sum
          priorities[i*N*N+j*N+k][1] += 6 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
  return priorities


#score: {'data3D.txt': -0.24747580000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Update the priority based on the site's magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.24747580000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Calculate the sum of h values for each site and store them in a new list
  sum_h_values = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        sum_h_values[i*N*N+j*N+k][0] += h[i][j][k]
        sum_h_values[i*N*N+j*N+k][1] -= h[i][j][k]

  # Add the sum of h values to the priority values
  for i in range(N**3):
    priorities[i][0] += sum_h_values[i][0]
    priorities[i][1] = -sum_h_values[i][1]

  return(priorities)


#score: {'data3D.txt': -0.4713706}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += spin_energy * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= spin_energy * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs_x = [(i + ((k-1)%2 - 1)) % N]
        site_nbrs_y = [(i+1)%N, (i+N-1)%N]
        site_nbrs_z = [(j + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = h[i][j][k] + sum([J[l,i,j,k] for l in [5]]) + sum([h[site_nbr][j][k] for site_nbr in site_nbrs_y]) + sum([h[site_nbr][j][k] for site_nbr in site_nbrs_x]) + sum([h[site_nbr][j][k] for site_nbr in site_nbrs_z])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] = -8
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = 8
  return(priorities)


#score: {'data3D.txt': -0.0010213999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[l][j][k] if l == i else 0 for l in range(N)]) + h[i][j][k]
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += sum([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= sum([abs(val) for val in interacting_spins])
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += sum([abs(val) for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] = 0
          priorities[i*N*N+j*N+k][1] = sum([abs(val) for val in interacting_spins])
  return priorities


#score: {'data3D.txt': -0.40531940000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4933266000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          total_spin_sign = -1 if total_spin > 0 else 1
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          total_spin_sign = 1 if total_spin < 0 else -1
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin + 1 if spin >= 0 else -1 + 1 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + spin_product
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - spin_product
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_product = np.prod([spin + 1 if spin < 0 else -1 + 1 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - spin_product
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - spin_product
  return(priorities)


#score: {'data3D.txt': -0.28075059999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors_up
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors_down = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors_down
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4473474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.09538820000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * np.mean([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) * np.mean([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3403222000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': 0.17865499999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_flip_probability = (len([val for val in interacting_spins if val > 0]) + num_neighbors) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + spin_flip_probability
          priorities[i*N*N+j*N+k][1] -= 2 * (1 - total_spin) - spin_flip_probability
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_flip_probability = (len([val for val in interacting_spins if val < 0]) + num_neighbors) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - spin_flip_probability
          priorities[i*N*N+j*N+k][1] = 2 * (1 - total_spin) - spin_flip_probability
  return(priorities)


#score: {'data3D.txt': 0.222367}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= (2 * total_spin - 1) - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = -(2 * total_spin - 1) + sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.2516798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.49796460000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2801114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.17453739999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.48232980000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val < 0]) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val > 0]) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.48232980000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val < 0]) > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val > 0]) > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * np.sign(total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) * np.sign(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val < 0]) > N**2/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val > 0]) > N**2/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.050782199999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': 0.0659434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if sum(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.21202540000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) 
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = -5 + sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) + np.sum(np.sign(J[:,i,j,k]))
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] = 5 - sum([np.sign(h[(p+1)%N][j][k]) for p in range(3)]) - np.sum(np.sign(J[:,i,j,k]))
  return(priorities)


#score: {'data3D.txt': -0.3348057999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        total_interacting_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.abs(total_spin) + total_interacting_spin
          priorities[i*N*N+j*N+k][1] = -(np.abs(total_spin) + total_interacting_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.abs(total_spin) - total_interacting_spin
          priorities[i*N*N+j*N+k][1] = np.abs(total_spin) + total_interacting_spin
  return priorities


#score: {'data3D.txt': -0.31426099999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] = -sum([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= np.abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = sum([val for val in interacting_spins if val > 0]) + 3
  return priorities


#score: {'data3D.txt': -0.3099901999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if l < 3 else J[l-3,i,(l+1)%3,k] for l in range(6)]
        priority = np.abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] = -(priority + 2 * abs(h[i][j][k]))
        else:
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = priority - 2 * abs(h[i][j][k])
  return priorities


#score: {'data3D.txt': -0.3210581999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l, i, j, k] if l < 3 else J[l-3, i, (l+1)%3, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3
        # Add the magnetism contribution
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= 2 * (h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] += 2 * (h[i][j][k])
  return priorities


#score: {'data3D.txt': -0.3355702000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.28314300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = (abs(total_spin) + num_neighbors + hamming_distance) ** 2
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 4*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = (abs(total_spin) - num_neighbors - hamming_distance) ** 2
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -4*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34302139999999964}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0])
          priority = total_spin + num_neighbors + min(abs(total_spin) / max(len(interacting_spins), 1), 1)
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0])
          priority = total_spin - num_neighbors + min(-abs(total_spin) / max(len(interacting_spins), 1), 1)
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3281510000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + num_neighbors + hamming_distance - sum([J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - num_neighbors - hamming_distance - sum([J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0988522}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin += sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*abs(total_spin) - hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin -= sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -2*abs(total_spin) + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.3226662}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        # Add this line to further improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i < N-1:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and j > 0:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.23706220000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d,i,j,k] for d in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        interacting_spin_sum = sum(interacting_spins)
        total_spin += 6 * np.sign(h[i][j][k])
        interacting_spin_signs = [np.sign(val) for val in interacting_spins]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin + interacting_spin_sum)
          priorities[i*N*N+j*N+k][1] = -6 + sum(interacting_spin_signs)
        else:
          priorities[i*N*N+j*N+k][0] -= (total_spin - interacting_spin_sum)
          priorities[i*N*N+j*N+k][1] = 6 - sum(interacting_spin_signs)
  return(priorities)


#score: {'data3D.txt': -0.3424993999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[d,i,j,k] if d < 3 else J[(d+3)%6,i,(d+1)%3,k] for d in range(6)]
        priority_total = abs(total_spin) + sum([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) - 3)
        spin_diff = h[i][j][k]
        if spin_diff > 0:
          priorities[i*N*N+j*N+k][0] += priority_total + spin_diff
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - 3 + abs(spin_diff)
        else:
          priorities[i*N*N+j*N+k][0] -= priority_total + spin_diff
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + 3 - abs(spin_diff)
  return priorities


#score: {'data3D.txt': -0.3455373999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]] + [(h[(p+1)%N][j][k]) if p != 2 else (h[p%3][i-1//N][j] if i > 0 else 0) for p in range(3)]
        interacting_spin_sum = sum(interacting_spins)
        total_spin += 6 * np.sign(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + abs(interacting_spin_sum)
          priorities[i*N*N+j*N+k][1] = -6 + sum([np.sign(val) for val in interacting_spins]) - np.sign(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - abs(interacting_spin_sum)
          priorities[i*N*N+j*N+k][1] = 6 - sum([np.sign(val) for val in interacting_spins]) + np.sign(h[i][j][k])
  return(priorities)


#score: {'data3D.txt': -0.2914598000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for p in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = [val for val in interacting_spins if val > 0]
          interacting_spin_count = len(interacting_spin)
          priority_total += sum([val for val in interacting_spin]) - interacting_spin_count
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  return priorities


#score: {'data3D.txt': -0.34218939999999964}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for p in [0,1,2]]) + h[i][j][k]
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 0
  return priorities


#score: {'data3D.txt': -0.34218899999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for p in [0,1,2]]) 
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.33271099999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority = abs(total_spin) + np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          priority = -abs(total_spin) - np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': 0.30027019999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors
          priorities[i*N*N+j*N+k][1] = -2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.3373321999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.3373321999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,(j+1)%N,k], J[2,i,(k+1)%N,j]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0]) - total_spin
        site_nbr2 = (i + ((j-1)%2 - 1)) % N
        site_nbr3 = (k + ((i-1)%2 - 1)) % N
        priorities[i*N*N+j*N+k][0] += abs(h[site_nbr][j][k]) * len([val for val in interacting_spins if val < 0])
        priorities[i*N*N+j*N+k][1] -= abs(h[site_nbr][j][k]) * len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.13258140000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) + site_nbr * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = 1 - total_spin - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) - site_nbr * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = 1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3985362}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 1 - total_spin - sum([1 if val > 0 else 0 for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 1 + total_spin - sum([1 if val > 0 else 0 for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': 0.11091779999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) - 3*len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] = 1 - total_spin - len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val < 0]) + 3*len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
          priorities[i*N*N+j*N+k][1] = 1 + total_spin - len([val for val in [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]] if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.3262962000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the total spin and interacting spins for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + sum([J[l,i,j,k] for l in range(6)])
          priorities[i*N*N+j*N+k][1] -= len([val for val in [J[l,i,j,k] for l in range(6)] if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + sum([J[l,i,j,k] for l in range(6)])
          priorities[i*N*N+j*N+k][1] += len([val for val in [J[l,i,j,k] for l in range(6)] if val > 0])

  return(priorities)


#score: {'data3D.txt': -0.14225380000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the total spin and interacting spins for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        
        # Calculate the total magnetism and interactions
        total_magnetism = sum([h[site_nbr][j][k] for site_nbr in site_nbrs]) + h[i][j][k]
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        
        # Calculate the priority based on the magnetism and interactions
        if total_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_magnetism) + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        elif total_magnetism < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_magnetism) + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] += abs(sum([a*b for a, b in zip(interacting_spins, site_nbrs)])) - (len([val for val in interacting_spins if val < 0]) - 3)
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) + 3
  
  return(priorities)


#score: {'data3D.txt': -0.10846259999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [np.sign(J[l,i,j,k]) for l in range(6)]
        
        # Calculate the priority based on the magnetism and interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - (total_spin > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([a*b for a, b in zip(interacting_spins, site_nbrs)])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) - (total_spin < 0)
  
  return(priorities)


#score: {'data3D.txt': -0.0190954}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.5009866000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (sum(J[d,i,j,k] for d in [0,1,2]) > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (sum(J[d,i,j,k] for d in [0,1,2]) < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.45448980000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.049741}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val < 0]) > N**2/2) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val > 0]) > N**2/2) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.11091779999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum([1 for val in interacting_spins if val < 0]) - 3*sum([1 for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 1 - total_spin - sum([1 for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum([1 for val in interacting_spins if val < 0]) + 3*sum([1 for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 1 + total_spin - sum([1 for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.013824999999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = len([val for val in interacting_spins if val < 0]) - 3
          priorities[i*N*N+j*N+k][1] = 2 + total_spin - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] = 2 - total_spin + len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.20158340000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] = -len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': 0.20371380000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) - 3*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 1 - total_spin - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val < 0]) - 3*len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = 1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2747546}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin += sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*abs(total_spin) - hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin -= sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -2*abs(total_spin) + total_spin
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0:
            previous_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,previous_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i < N-1:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.1307766}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin += sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*abs(total_spin) - hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin -= sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -2*abs(total_spin) + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        if k > 0 and i < N-1 and j < N-1:
          previous_previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i+1][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = -1
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = 1
  return(priorities)


#score: {'data3D.txt': -0.45448980000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3394857999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.3394857999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.3208773999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i-1)%N,j,k], J[2,i,(j-1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j-1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.1964994000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin_site = sum(J[d,site_nbr,j,k] for d in range(6))
        priorities[i*N*N+j*N+k][0] += abs(total_spin_site) + len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val > 0]) - 3
        priorities[i*N*N+j*N+k][1] -= len([val for val in [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]] if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.3054466}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i-1)%N,j,k], J[2,i,(j-1)%N,k], 
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(J[d,i,j,k] for d in [0,3,4,5])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 2
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 2
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.26283420000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i-1%N,j,k], J[2,i,j-1%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += 2 * len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2701350000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - 2 * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 3 + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - sum([val for val in interacting_spins if val > 0]) + 2 * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 3 - len([val for val in interacting_spins if val < 0])
  return priorities


#score: {'data3D.txt': -0.32732859999999975}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -7 + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 7 - len([val for val in interacting_spins if val > 0])
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0, 1, 2]]
        total_spin = sum([h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] for l in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] = -(total_spin + len([val for val in interacting_spins if val < 0])) - 6
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] = -(total_spin - len([val for val in interacting_spins if val > 0])) + 6
  return priorities


#score: {'data3D.txt': -0.3275877999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val > 0]) - 3
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val < 0]) + 3
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
        interacting_neighbors = [J[4,i,j,k], J[5,i,j,k]]
        site_spin = total_spin + sum(interacting_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(site_spin) - len([val for val in interacting_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(site_spin) + len([val for val in interacting_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_neighbors if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.2632538000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6) if (d==0 and i>0) or (d==1 and j>0) or (d==2 and k>0) or (d==3 and i<(N-1)) or (d==4 and j<(N-1)) or (d==5 and k<(N-1))]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.2240421999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k] for l in range(6)]
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  return priorities


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.49796460000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.47255140000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[0,i,j,k:3] if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
        
  return priorities


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.14744580000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in interacting_spins])
          
          if h[site_nbr][j][k] > 0:
            priority_total += interacting_spin
          elif h[site_nbr][j][k] < 0:
            priority_total -= interacting_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[i][j][k] if h[i][j][k] > 0 else -1*h[i][j][k] for l in range(6)])
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.22969260000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          spin_energy *= total_spin
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          spin_energy *= total_spin
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3997690000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.06303900000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += spin_energy - np.log2(np.exp(-spin_energy) + np.exp(spin_energy))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= spin_energy + np.log2(np.exp(-spin_energy) + np.exp(spin_energy))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3293782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_energy = abs(total_spin) + (1 + hamming_distance) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_energy = abs(total_spin) - (1 + hamming_distance) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34222139999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[d,i,j,k] if J[d,i,j,k] > 0 else -1*J[d,i,j,k]) for d in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priority_total += sum([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          elif h[site_nbr][j][k] < 0:
            priority_total -= sum([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = (total_spin + priority_total) * 2
          priorities[i*N*N+j*N+k][1] = -1 * (total_spin + priority_total)
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -(total_spin + priority_total)
          priorities[i*N*N+j*N+k][1] = total_spin + priority_total
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.32945420000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = 2*total_spin + sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.30347100000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = 2 + total_spin - sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(1 for val in interacting_spins if val < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = total_spin - sum(1 for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.09538820000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.mean([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += total_spin + spin_energy * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.mean([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= total_spin + spin_energy * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1463766}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.2754306000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_flip_cost = abs(total_spin) + sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_flip_cost
          priorities[i*N*N+j*N+k][1] -= 2*spin_flip_cost
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_flip_cost = abs(total_spin) - sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_flip_cost
          priorities[i*N*N+j*N+k][1] = 2*spin_flip_cost
  return(priorities)


#score: {'data3D.txt': -0.3356589999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = total_spin + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = total_spin - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4460322000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = 2*total_spin + sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.4192174}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (sum(J[d,i,j,k] for d in [0,1,2]) > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (sum(J[d,i,j,k] for d in [0,1,2]) < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # added this line to make it deterministic
        if sum(J[d,i,j,k] for d in [0,1,2]) > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= (total_spin < 0)
  return(priorities)


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5009866000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy_gain * (sum(J[d,i,j,k] for d in [0,1,2]) > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy_loss = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy_loss * (sum(J[d,i,j,k] for d in [0,1,2]) < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2089358}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm
        if k < N-1 and (i+j)%2 == k%3:
          next_site_nbr = (i + ((k+1)%2 - 1)) % N
          if h[i][j][k+1] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 1
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.10224420000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1

        # Add this line to further improve the algorithm
        for d in [0,1,2]:
          if k > 0 and i + ((k-1)%2 - 1) % N == previous_site_nbr:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 1
          elif k < N-1 and i + ((k+1)%2 - 1) % N == site_nbr:
            priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': 0.16355099999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm further
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] = -1
        
  return(priorities)


#score: {'data3D.txt': -0.21152859999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm further
        if i > 0 and k > 0:
          previous_previous_site_nbr = (i-1 + ((k-2)%2 - 1)) % N
          if h[i-1][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)


#score: {'data3D.txt': -0.3228425999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        # Add this line to further improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i < N-1:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and j > 0:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.3027166}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = 2 - total_spin

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and j < N-1:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i < N-1:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and j > 0:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.19890500000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0:
            neighbor_site_nbr = (i - 1 + ((k-1)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1
          
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5009866000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1072858}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * 0.5 + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          spin_energy = abs(total_spin) * 0.5 - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.2528442000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < 0)
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > 0)
  return(priorities)


#score: {'data3D.txt': -0.4169774000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4192174}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # added this line to make it deterministic
        if sum(J[d,i,j,k] for d in [0,1,2]) > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= (total_spin < 0)
  return(priorities)


#score: {'data3D.txt': -0.2528442000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += spin_energy_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= spin_energy_down * (total_spin < 0)
        else:
          spin_energy_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= spin_energy_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += spin_energy_down * (total_spin > 0)

  return(priorities)


#score: {'data3D.txt': 0.004698600000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          energy_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += energy_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= energy_down * (total_spin < 0)
        else:
          energy_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          energy_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= energy_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += energy_down * (total_spin > 0)

        # New priority terms based on nearest neighbor interactions
        for d in [0,1,2]:
          for l in [(i+1)%N, i-1]:
            if h[l][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += 2 * J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] -= 2 * J[d,l,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= 2 * J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] += 2 * J[d,l,j,k]

  return(priorities)


#score: {'data3D.txt': -0.2747546}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin += sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*abs(total_spin) - hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin -= sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -2*abs(total_spin) + total_spin

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0:
            previous_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,previous_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i > 0 and j < N-1:
            neighbor_site_nbr = (i - 1 + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

        # Add this line to further improve the algorithm
        for d in range(3):
          if k > 0 and i < N-1:
            neighbor_site_nbr = (i + ((k-2)%2 - 1)) % N
            if J[d,neighbor_site_nbr,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] += 1
            else:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': 0.035121}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin += sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] = -total_spin * (hamming_distance + len([val for val in interacting_spins if val > 0])) + hamming_distance
          priorities[i*N*N+j*N+k][1] = total_spin * (2*hamming_distance + len([val for val in interacting_spins if val < 0]))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin -= sum(h[s][j][k] for s in range(N) if J[3,s,j,k] > 0)
          priorities[i*N*N+j*N+k][0] = total_spin * (hamming_distance + len([val for val in interacting_spins if val < 0])) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -total_spin * (2*hamming_distance + len([val for val in interacting_spins if val > 0]))
  return(priorities)


#score: {'data3D.txt': -0.22850220000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down) + hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if i > 0:
          previous_site_nbr = (i-1) % N
          if h[i-1][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.2592754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        if k > 0:
          previous_site_nbr = (i + ((k-2)%2 - 1)) % N
          if h[i][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k-1] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
        
  return(priorities)


#score: {'data3D.txt': -0.23711739999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add this line to improve the algorithm
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.10305780000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.1479038000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[0,i,j,k:3] if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = -sum(1 for val in interacting_spins if val > 0)
        
  return(priorities)


#score: {'data3D.txt': -0.47255140000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[0,i,j,k:3] if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3415134}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.286739}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            spin_weight = 2 * (total_spin > 0) - 1
            priorities[i*N*N+j*N+k][0] += spin_weight
            priorities[i*N*N+j*N+k][1] -= spin_weight
          else:
            spin_weight = 2 * (total_spin < 0) - 1
            priorities[i*N*N+j*N+k][0] -= spin_weight
            priorities[i*N*N+j*N+k][1] = spin_weight
        
  return(priorities)


#score: {'data3D.txt': -0.3398014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin += sum(1 for val in J[0,i,j,k:3] if val > 0) - sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.4164858}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.14744580000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in interacting_spins])
          
          if h[site_nbr][j][k] > 0:
            priority_total += interacting_spin
          elif h[site_nbr][j][k] < 0:
            priority_total -= interacting_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.0115038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]])
          
          if h[i][j][k] > 0:
            priority_total += interacting_spin
          elif h[i][j][k] < 0:
            priority_total -= interacting_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.19131100000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) + len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 4*priority_total
        else:
          priority_total = abs(total_spin) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -4*priority_total + total_spin
  return(priorities)


#score: {'data3D.txt': -0.28314300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = (abs(total_spin) + num_neighbors + hamming_distance) ** 2
          priorities[i*N*N+j*N+k][0] += priority * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 4*priority * (total_spin < 0)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = (abs(total_spin) - num_neighbors - hamming_distance) ** 2
          priorities[i*N*N+j*N+k][0] -= priority * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -4*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0979354}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority = (abs(total_spin) + num_neighbors + hamming_distance) ** 2
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 4*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority = (abs(total_spin) - num_neighbors - hamming_distance) ** 2
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -4*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_total = total_spin + np.sum(np.where(J[0:i+3,:,k], 1, -1))
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -total_spin + np.sum(np.where(J[0:i+3,:,k], -1, 1))
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.1470706000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = sum(1 for val in interacting_spins if val != h[i][j][k]) / max(len(interacting_spins), 1)
          spin_flip_cost = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) * (hamming_distance ** 2)
          priorities[i*N*N+j*N+k][0] += spin_flip_cost
          priorities[i*N*N+j*N+k][1] -= 2*spin_flip_cost
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = sum(1 for val in interacting_spins if val != -h[i][j][k]) / max(len(interacting_spins), 1)
          spin_flip_cost = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) * (hamming_distance ** 2)
          priorities[i*N*N+j*N+k][0] -= spin_flip_cost
          priorities[i*N*N+j*N+k][1] = 2*spin_flip_cost
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = 2 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.23380340000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_flip_cost = abs(total_spin) + sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_flip_cost
          priorities[i*N*N+j*N+k][1] -= 2*spin_flip_cost
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_flip_cost = abs(total_spin) - sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_flip_cost
          priorities[i*N*N+j*N+k][1] = 2*spin_flip_cost
        if i > 0 and j > 0:
          top_left_spin = J[0, i-1, j-1, k]
          top_left_neighbor = [val for val in interacting_spins if val == top_left_spin]
          if len(top_left_neighbor) > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
        if i < N-1 and j < N-1:
          bottom_right_spin = J[5, i+1, j+1, k]
          bottom_right_neighbor = [val for val in interacting_spins if val == bottom_right_spin]
          if len(bottom_right_neighbor) > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.4644846000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + (1 + hamming_distance) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - (1 + hamming_distance) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': 0.4266454}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetization_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_energy = (magnetization_energy + sum(abs(J[d,i,j,k]) for d in [0,1,2])) * total_spin
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetization_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_energy = (magnetization_energy + sum(abs(J[d,i,j,k]) for d in [0,1,2])) * -total_spin
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.33867219999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus_one = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy_plus_one
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy_minus_one = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy_minus_one
          priorities[i*N*N+j*N+k][1] = 1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4169774000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.abs(total_spin) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        spin_energy = abs(total_spin) - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > N**3/2)
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2954742}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        interacting_spin_sum = sum([val if val > 0 else -1*val for val in interacting_spins])
        
        priority_total = total_spin + abs(interacting_spin_sum) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - interacting_spin_sum / (6 * abs(h[i][j][k]))
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = 1 + interacting_spin_sum / (6 * abs(h[i][j][k]))
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.14744580000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])

        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]

        priority_total = total_spin
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in interacting_spins])

          if h[site_nbr][j][k] > 0:
            priority_total += interacting_spin
          elif h[site_nbr][j][k] < 0:
            priority_total -= interacting_spin

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0

  return priorities


#score: {'data3D.txt': -0.3424093999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        interacting_spin_sum = sum([val if val > 0 else -1*val for val in interacting_spins])
        
        priority_total = total_spin + (interacting_spin_sum / max(len(interacting_spins), 1))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(priority_total) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - priority_total
        else:
          priorities[i*N*N+j*N+k][0] -= abs(priority_total) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + priority_total
  
  return priorities


#score: {'data3D.txt': -0.30154500000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          priority = abs(total_spin) + num_neighbors + hamming_distance - sum([J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]) - (total_spin > 0)
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          priority = abs(total_spin) - num_neighbors - hamming_distance - sum([J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]) - (total_spin < 0)
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.14414700000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_spin_1 = abs(total_spin) + num_neighbors + hamming_distance - sum([J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] += priority_spin_1
          priorities[i*N*N+j*N+k][1] -= 2*priority_spin_1
          site_nbr_spin = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += abs(site_nbr_spin)
            priorities[i*N*N+j*N+k][1] -= 2*abs(site_nbr_spin)
          else:
            priorities[i*N*N+j*N+k][0] -= abs(site_nbr_spin)
            priorities[i*N*N+j*N+k][1] = -2*abs(site_nbr_spin)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_spin_1 = abs(total_spin) - num_neighbors - hamming_distance - sum([J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]])
          priorities[i*N*N+j*N+k][0] -= priority_spin_1
          priorities[i*N*N+j*N+k][1] = 2*priority_spin_1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.10199700000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += energy_gain + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy_loss = sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= energy_loss - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3617234000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = (len(interacting_spins) - max(num_neighbors_up, num_neighbors_down)) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2 * priority
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = (len(interacting_spins) - max(num_neighbors_up, num_neighbors_down)) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2 * priority + total_spin
  return(priorities)


#score: {'data3D.txt': 0.2881886000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          spin_energy = total_spin - min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][0] += abs(spin_energy) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2*spin_energy
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          spin_energy = total_spin + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][0] -= abs(spin_energy) - spin_energy
          priorities[i*N*N+j*N+k][1] = -2*spin_energy + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2754306000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) - (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority + total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) + (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = 2*priority - total_spin
  return(priorities)


#score: {'data3D.txt': 0.0032757999999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + min(num_neighbors_up, num_neighbors_down)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        if i > 0 and j > 0 and k > 0:
          site_nbr_opp = (i-1) % N * N*N + (j-1) % N * N + k
          priorities[site_nbr_opp][0] -= min(num_neighbors_up, num_neighbors_down)
          priorities[site_nbr_opp][1] += 2 - total_spin
        if i < N-1 and j > 0 and k > 0:
          site_nbr_opp = (i+1) % N * N*N + (j-1) % N * N + k
          priorities[site_nbr_opp][0] -= min(num_neighbors_up, num_neighbors_down)
          priorities[site_nbr_opp][1] += 2 - total_spin
        if i > 0 and j < N-1 and k > 0:
          site_nbr_opp = (i-1) % N * N*N + (j+1) % N * N + k
          priorities[site_nbr_opp][0] -= min(num_neighbors_up, num_neighbors_down)
          priorities[site_nbr_opp][1] += 2 - total_spin
        if i > 0 and j > 0 and k < N-1:
          site_nbr_opp = (i-1) % N * N*N + (j-1) % N * N + (k+1) % N
          priorities[site_nbr_opp][0] -= min(num_neighbors_up, num_neighbors_down)
          priorities[site_nbr_opp][1] += 2 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy_down = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy_down * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.029311000000000118}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += spin_energy_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= spin_energy_down * (total_spin < 0)
        else:
          spin_energy_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= spin_energy_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += spin_energy_down * (total_spin > 0)

        for d in range(3):
          site_nbr_d = ((i+d)%N + ((k-1)%2 - 1)) % N
          if h[site_nbr_d][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.5165330000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.4460322000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][1] = 2*total_spin + sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.1183434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin_magnetism = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][0] += total_spin_magnetism
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_magnetism
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin_magnetism = abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= total_spin_magnetism
          priorities[i*N*N+j*N+k][1] = -1 + total_spin_magnetism
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)


#score: {'data3D.txt': -0.36208019999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          hamming_distance = len([val for val in J[0,site_nbr,j,k:3] if val < 0]) / max(len(J[0,site_nbr,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,site_nbr,j,k:3] if val > 0]) / max(len(J[0,site_nbr,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4738778000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin += sum(1 for val in J[0,i,j,k:3] if val > 0) * (hamming_distance + 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin -= sum(1 for val in J[0,i,j,k:3] if val < 0) * (hamming_distance - 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.22969260000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] += priority_up + priority_down
          priorities[i*N*N+j*N+k][1] -= 2 * priority_down
        else:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up + priority_down
          priorities[i*N*N+j*N+k][1] += 2 * priority_down
  return(priorities)


#score: {'data3D.txt': -0.2790666000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin ** 2
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > 0) + priority_down * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin ** 2
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < 0) + priority_down * (total_spin > -N**3/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.3273105999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[1,i,j,k], J[1,i,(j+1)%N,k]]
        interacting_spins_z = [J[2,i,j,k], J[2,(i+1)%N,(j+1)%N,k]]
        total_spin_x = sum(J[0,i,j,k] for i in range(N))
        total_spin_y = sum(J[1,i,j,k] for j in range(N))
        total_spin_z = sum(J[2,i,j,k] for k in range(N))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin_x) + len([val for val in interacting_spins_x if val < 0]) / max(len(interacting_spins_x), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin_y) + len([val for val in interacting_spins_y if val < 0]) / max(len(interacting_spins_y), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin_z) + len([val for val in interacting_spins_z if val < 0]) / max(len(interacting_spins_z), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin_x
          priorities[i*N*N+j*N+k][1] -= total_spin_y
          priorities[i*N*N+j*N+k][1] -= total_spin_z
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_x) - len([val for val in interacting_spins_x if val > 0]) / max(len(interacting_spins_x), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_y) - len([val for val in interacting_spins_y if val > 0]) / max(len(interacting_spins_y), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin_z) - len([val for val in interacting_spins_z if val > 0]) / max(len(interacting_spins_z), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin_x
          priorities[i*N*N+j*N+k][1] = -total_spin_y
          priorities[i*N*N+j*N+k][1] = -total_spin_z
  return(priorities)


#score: {'data3D.txt': 0.2482141999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.45068300000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin += sum(1 for val in J[0,i,j,k:3] if val > 0) - sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][0] = abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] = -abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.1230826}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin += sum(1 for val in J[0, i, j, k:3] if val > 0) - sum(1 for val in J[0, i, j, k:3] if val < 0)
          priorities[i*N*N+j*N+k][0] = abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1
        else:
          total_spin -= sum(1 for val in J[0, i, j, k:3] if val > 0) - sum(1 for val in J[0, i, j, k:3] if val < 0)
          priorities[i*N*N+j*N+k][0] = -abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          if J[d, i, j, k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1

  return(priorities)


#score: {'data3D.txt': -0.3301754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))
          priorities[i*N*N+j*N+k][1] = -1 + sum(J[d,site_nbr,j,k] for d in [0,1,2])
  
  return(priorities)


#score: {'data3D.txt': -0.11223579999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin += sum(1 for val in J[0,i,j,k:3] if val > 0) - sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)


#score: {'data3D.txt': -0.3997690000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.40178660000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.38218060000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val > 0])
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.2480450000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * (total_spin > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = 2 * (total_spin < 0)

  return(priorities)


#score: {'data3D.txt': -0.2754306000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority_up = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) - (num_neighbors_up + num_neighbors_down) / 2
          priority_down = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) + (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] += max(priority_up, priority_down)
          priorities[i*N*N+j*N+k][1] -= 2*max(priority_up, priority_down) + total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority_up = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) + (num_neighbors_up + num_neighbors_down) / 2
          priority_down = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) - (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] -= max(priority_up, priority_down)
          priorities[i*N*N+j*N+k][1] = 2*max(priority_up, priority_down) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.2501018000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) - (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority + total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) + (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = 2*priority - total_spin
        
        # Add this line to improve the algorithm
        if sum(J[d,i,j,k] for d in range(6)) > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.1998526000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority = abs(total_spin) + min(num_neighbors_up, num_neighbors_down) - (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority + total_spin
        else:
          num_neighbors_up = len([val for val in interacting_spins if val > 0])
          num_neighbors_down = len([val for val in interacting_spins if val < 0])
          hamming_distance = sum(1 for val in interacting_spins if val == 0) / max(len(interacting_spins), 1)
          priority = abs(total_spin) - min(num_neighbors_up, num_neighbors_down) + (num_neighbors_up + num_neighbors_down) / 2
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = 2*priority - total_spin
        
        # Add this line to improve the algorithm
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -2
        
        # Add this line to improve the algorithm
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.21349220000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < N**3/2)
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > N**3/2)
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < -N**3/2)
        else:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > -N**3/2)
  return(priorities)


#score: {'data3D.txt': -0.053995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < 0)
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > 0)
        if i > 0:
          priorities[i*N*N+j*N+k][0] += abs(J[2,i-1,j,k]) - abs(J[0,i-1,j,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[2,i-1,j,k]) + abs(J[0,i-1,j,k])
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += abs(J[0,i+1,j,k]) - abs(J[2,i+1,j,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[0,i+1,j,k]) + abs(J[2,i+1,j,k])
        if j > 0:
          priorities[i*N*N+j*N+k][0] += abs(J[1,i,(j-1)%N,k]) - abs(J[2,i,j-1%N,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[1,i,(j-1)%N,k]) + abs(J[2,i,j-1%N,k])
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += abs(J[1,i,(j+1)%N,k]) - abs(J[2,i,j+1%N,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[1,i,(j+1)%N,k]) + abs(J[2,i,j+1%N,k])
  return(priorities)


#score: {'data3D.txt': -0.36974420000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-total_spin**2 / (hamming_distance + 1e-6))
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-total_spin**2 / (hamming_distance + 1e-6))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-total_spin * total_spin / (2 * N**3))
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-total_spin * total_spin / (2 * N**3))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.20040140000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in J[0,i,j,k:3] if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in J[0,i,j,k:3] if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val > 0) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for val in interacting_spins if val < 0) - total_spin
          priorities[i*N*N+j*N+k][1] = -sum(1 for val in interacting_spins if val > 0) + total_spin
        
        site_nbr1 = (i + ((k-2)%2 - 1)) % N
        site_nbr2 = (j + ((k-2)%2 - 1)) % N
        site_nbr3 = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[site_nbr1][j][k]) + abs(h[site_nbr2][i][k]) + abs(h[site_nbr3][i][j])
          priorities[i*N*N+j*N+k][1] -= 1 - h[site_nbr1][j][k] - h[site_nbr2][i][k] - h[site_nbr3][i][j]
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[site_nbr1][j][k]) + abs(h[site_nbr2][i][k]) + abs(h[site_nbr3][i][j])
          priorities[i*N*N+j*N+k][1] = -1 + h[site_nbr1][j][k] + h[site_nbr2][i][k] + h[site_nbr3][i][j]
        
  return(priorities)


#score: {'data3D.txt': -0.42750540000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        total_spin += sum(1 for val in interacting_spins if val > 0) * (hamming_distance + 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3991326}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3991326}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.3301754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))
          priorities[i*N*N+j*N+k][1] -= 1 - sum(J[d,site_nbr,j,k] for d in [0,1,2])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(sum(J[d,site_nbr,j,k] for d in [0,1,2]))
          priorities[i*N*N+j*N+k][1] = -1 + sum(J[d,site_nbr,j,k] for d in [0,1,2])
  
  return(priorities)


#score: {'data3D.txt': -0.09998700000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for J_val in J[0,i,j,k:3] if J_val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for J_val in J[0,i,j,k:3] if J_val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_nbr_spin = sum(h[site_nbr][j][k] for k in range(N)) * (sum(J[d,site_nbr,j,k] for d in [0,1,2]))
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(site_nbr_spin) + sum(1 for J_val in J[0,site_nbr,j,k:3] if J_val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - site_nbr_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(site_nbr_spin) - sum(1 for J_val in J[0,site_nbr,j,k:3] if J_val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + site_nbr_spin
        
  return(priorities)


#score: {'data3D.txt': -0.025718200000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin_neighbors = sum(sum(J[d,site_nbr,m,l] for d in [0,1,2]) for m in range(N) for l in range(N))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin_neighbors = sum(sum(J[d,site_nbr,m,l] for d in [0,1,2]) for m in range(N) for l in range(N))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.10817859999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
        for d in range(3):
          if J[d,site_nbr,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(sum(J[dd,site_nbr,j,k] for dd in [0,1,2]))
            priorities[i*N*N+j*N+k][1] -= 1 - sum(J[dd,site_nbr,j,k] for dd in [0,1,2])
          else:
            priorities[i*N*N+j*N+k][0] -= abs(sum(J[dd,site_nbr,j,k] for dd in [0,1,2]))
            priorities[i*N*N+j*N+k][1] = -1 + sum(J[dd,site_nbr,j,k] for dd in [0,1,2])
        
  return(priorities)


#score: {'data3D.txt': -0.4738994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_diff = sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * energy_diff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy_diff = sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * energy_diff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.43212100000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.358171}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3055310000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority = total_spin + num_neighbors + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2*priority
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority = -total_spin - num_neighbors - hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2*priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2474374000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors = len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_factor = np.sign(total_spin) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] += num_neighbors + hamming_distance + magnetism_factor
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        else:
          num_neighbors = len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_factor = -np.sign(total_spin) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= num_neighbors + hamming_distance + magnetism_factor
          priorities[i*N*N+j*N+k][1] = 2*total_spin + sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.33867219999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > N**3/2)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < -N**3/2)
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < N**3/2)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > -N**3/2)
  return(priorities)


#score: {'data3D.txt': -0.395445}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (spin_energy * (len([val for val in interacting_spins if val < 0]) > N**2/2) + total_spin) // 2
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (spin_energy * (len([val for val in interacting_spins if val > 0]) > N**2/2) + total_spin) // 2
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.064257}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] = total_spin - abs(total_spin) * len([val for val in interacting_spins if val > 0])
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else -1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -total_spin + abs(total_spin) * len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.4738994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus = sum(1 if val < 0 else 0 for val in interacting_spins) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] += energy_plus + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy_minus = sum(1 if val > 0 else 0 for val in interacting_spins) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= energy_minus + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.38126980000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = priority_energy + (1 + hamming_distance) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = priority_energy - (1 + hamming_distance) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.4262066000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0101514}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin_neighbors = sum(sum(J[d,site_nbr,m,l] for d in [0,1,2]) for m in range(N) for l in range(N))
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + total_spin_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          total_spin_neighbors = sum(sum(J[d,site_nbr,m,l] for d in [0,1,2]) for m in range(N) for l in range(N))
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - total_spin_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = 1
        
  return(priorities)


#score: {'data3D.txt': -0.025672999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val < 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin_neighbors = sum(sum(J[d,site_nbr,m,l] for d in [0,1,2]) for m in range(N) for l in range(N))
          hamming_distance_neighbors = len([val for val in J[0,site_nbr,i,k:3] if val < 0]) / max(len(J[0,site_nbr,i,k:3]), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + total_spin_neighbors + hamming_distance_neighbors
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in J[0,i,j,k:3] if val > 0]) / max(len(J[0,i,j,k:3]), 1)
          total_spin_neighbors = sum(sum(J[d,site_nbr,m,l] for d in [0,1,2]) for m in range(N) for l in range(N))
          hamming_distance_neighbors = len([val for val in J[0,site_nbr,i,k:3] if val > 0]) / max(len(J[0,site_nbr,i,k:3]), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - total_spin_neighbors - hamming_distance_neighbors
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.40531940000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          num_neighbors_up = len([val for val in interacting_spins if val < 0])
          priority = abs(total_spin) + num_neighbors_up
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 2 * priority
        else:
          num_neighbors_down = len([val for val in interacting_spins if val > 0])
          priority = abs(total_spin) - num_neighbors_down
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2 * priority + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2954742}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        interacting_spin_sum = sum([val if val > 0 else -1*val for val in interacting_spins])
        
        priority_total = abs(total_spin) + abs(interacting_spin_sum) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - interacting_spin_sum / (6 * abs(h[i][j][k]))
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = 1 + interacting_spin_sum / (6 * abs(h[i][j][k]))
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.2954742}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        interacting_spin_sum = sum([val if val > 0 else -1*val for val in interacting_spins])
        
        priority_total = total_spin + abs(interacting_spin_sum) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - interacting_spin_sum / (6 * abs(h[i][j][k]))
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = 1 + interacting_spin_sum / (6 * abs(h[i][j][k]))
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
        
  return priorities


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Apply a small correction to the priority values
  priorities[:,0] += 0.05 * np.random.rand(N**3)
  priorities[:,1] -= 0.01 * np.random.rand(N**3)

  return(priorities)


#score: {'data3D.txt': -0.5160982000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0115038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]])
          
          if h[i][j][k] > 0:
            priority_total += interacting_spin
          elif h[i][j][k] < 0:
            priority_total -= interacting_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = priority_total + total_spin + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif h[i][j][k] < 0:
          priorities[i*N*N+j*N+k][0] = -1 * (priority_total - total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = 0
  
  return priorities


#score: {'data3D.txt': -0.3264937999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]])
          
          if h[i][j][k] > 0:
            priority_total += interacting_spin
          elif h[i][j][k] < 0:
            priority_total -= interacting_spin
        
        priorities[i*N*N+j*N+k][0] = priority_total + total_spin
        priorities[i*N*N+j*N+k][1] = -priority_total
  
  return priorities


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])

        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]

        priority_up = np.sum([abs(val) for val in interacting_spins])
        priority_down = total_spin

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (priority_up + abs(total_spin)) / (1 + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= (1 - total_spin) / (1 + abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= (priority_up + abs(total_spin)) / (1 + abs(total_spin))
          priorities[i*N*N+j*N+k][1] += (1 - total_spin) / (1 + abs(total_spin))

  return priorities


#score: {'data3D.txt': -0.4267518}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.05984379999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        site_nbrs = [(i, j, k)]
        for x in range(max(0, i-1), min(N, i+2)):
          for y in range(max(0, j-1), min(N, j+2)):
            for z in range(max(0, k-1), min(N, k+2)):
              site_nbrs.append((x, y, z))
        for x, y, z in set(site_nbrs):
          interacting_spins = [J[0,x,y,z], J[1,(x+1)%N,y,z], J[2,x,(y+1)%N,z]]
          total_spin = sum(J[d,x,y,z] for d in [0,1,2])
          if h[x][y][z] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.053995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < 0)
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > 0)

        # Add interactions with neighbors
        if i > 0:
          priorities[i*N*N+j*N+k][0] += abs(J[2,i-1,j,k]) - abs(J[0,i-1,j,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[2,i-1,j,k]) + abs(J[0,i-1,j,k])
        if i < N-1:
          priorities[i*N*N+j*N+k][0] += abs(J[0,i+1,j,k]) - abs(J[2,i+1,j,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[0,i+1,j,k]) + abs(J[2,i+1,j,k])

        if j > 0:
          priorities[i*N*N+j*N+k][0] += abs(J[1,i,(j-1)%N,k]) - abs(J[2,i,j-1%N,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[1,i,(j-1)%N,k]) + abs(J[2,i,j-1%N,k])
        if j < N-1:
          priorities[i*N*N+j*N+k][0] += abs(J[1,i,(j+1)%N,k]) - abs(J[2,i,j+1%N,k])
          priorities[i*N*N+j*N+k][1] -= abs(J[1,i,(j+1)%N,k]) + abs(J[2,i,j+1%N,k])
  return(priorities)


#score: {'data3D.txt': -0.0026654}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += priority_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= priority_down * (total_spin < 0)
        else:
          priority_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += priority_down * (total_spin > 0)
        for d in [0,1,2]:
          if i > 0:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i-1,j,k]) - abs(J[d,i-1,j,k])
            priorities[i*N*N+j*N+k][1] -= abs(J[d,i-1,j,k]) + abs(J[d,i-1,j,k])
          if i < N-1:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i+1,j,k]) - abs(J[d,i+1,j,k])
            priorities[i*N*N+j*N+k][1] -= abs(J[d,i+1,j,k]) + abs(J[d,i+1,j,k])
          if j > 0:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i,(j-1)%N,k]) - abs(J[d,i,j-1%N,k])
            priorities[i*N*N+j*N+k][1] -= abs(J[d,i,(j-1)%N,k]) + abs(J[d,i,j-1%N,k])
          if j < N-1:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i,(j+1)%N,k]) - abs(J[d,i,j+1%N,k])
            priorities[i*N*N+j*N+k][1] -= abs(J[d,i,(j+1)%N,k]) + abs(J[d,i,j+1%N,k])
  return(priorities)


#score: {'data3D.txt': -0.05984379999999999}
program:
def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        site_nbrs = [(i, j, k)]
        for x in range(max(0, i-1), min(N, i+2)):
          for y in range(max(0, j-1), min(N, j+2)):
            for z in range(max(0, k-1), min(N, k+2)):
              site_nbrs.append((x, y, z))
        for x, y, z in set(site_nbrs):
          interacting_spins = [J[0,x,y,z], J[1,(x+1)%N,y,z], J[2,x,(y+1)%N,z]]
          total_spin = sum(J[d,x,y,z] for d in [0,1,2])
          if h[x][y][z] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.470837}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        magnetism_coeff = np.exp(-abs(total_spin))
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val != h[i][j][k]]) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance < 0.5) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.41698219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4040634}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          interacting_spins.sort()
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          interacting_spins.sort(reverse=True)
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.2546578000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = sum(abs(val) for val in interacting_spins)
          spin_gain = total_spin
          priorities[i*N*N+j*N+k][0] += energy_gain + spin_gain
          priorities[i*N*N+j*N+k][1] -= 2 - (energy_gain + spin_gain)
        else:
          energy_loss = sum(abs(val) for val in interacting_spins)
          spin_loss = total_spin
          priorities[i*N*N+j*N+k][0] -= energy_loss - spin_loss
          priorities[i*N*N+j*N+k][1] = -2 + (energy_loss + spin_loss)
  return(priorities)


#score: {'data3D.txt': -0.10199700000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins)) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.10199700000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = sum(abs(val) for val in interacting_spins)
          spin_bias = abs(total_spin) if total_spin > 0 else -abs(total_spin)
          priorities[i*N*N+j*N+k][0] += energy_gain + spin_bias
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy_loss = sum(abs(val) for val in interacting_spins)
          spin_bias = abs(total_spin) if total_spin < 0 else -abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= energy_loss + spin_bias
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.41236820000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[i][j][k]
        if h[i][j][k] > 0:
          interacting_spins.sort()
          priority_up = len([val for val in interacting_spins if val < 0])
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] += priority_up + priority_down
          priorities[i*N*N+j*N+k][1] -= 2 - 2*priority_down
        else:
          interacting_spins.sort(reverse=True)
          priority_up = len([val for val in interacting_spins if val > 0])
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] -= priority_up + priority_down
          priorities[i*N*N+j*N+k][1] += 2*priority_down
  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] += priority_up + priority_down
          priorities[i*N*N+j*N+k][1] -= 2 * priority_down
        else:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin
          if site_nbr == i and j == 0:  # edge case for the first layer
            priorities[i*N*N+j*N+k][0] -= (priority_up + priority_down)
            priorities[i*N*N+j*N+k][1] += 2 * priority_down
          else:
            priorities[i*N*N+j*N+k][0] -= priority_up + priority_down
            priorities[i*N*N+j*N+k][1] += 2 * priority_down
  return(priorities)


#score: {'data3D.txt': -0.3906686000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += priority_up + priority_down
          priorities[i*N*N+j*N+k][1] -= 2 * (1 + priority_down)
        else:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= priority_up + priority_down
          priorities[i*N*N+j*N+k][1] += 2 * (1 - priority_down)
  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] += (priority_up + priority_down)**2
          priorities[i*N*N+j*N+k][1] -= 4 * priority_down
        else:
          priority_up = abs(total_spin) / max(len(interacting_spins), 1)
          priority_down = total_spin
          priorities[i*N*N+j*N+k][0] -= (priority_up + priority_down)**2
          priorities[i*N*N+j*N+k][1] += 4 * priority_down
  return(priorities)


#score: {'data3D.txt': -0.395445}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.22572180000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy = abs(total_spin)
          spin_energy = max(energy/abs(h[i][j][k]), 1e-6) # avoid division by zero
          priorities[i*N*N+j*N+k][0] += spin_energy * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy = abs(total_spin)
          spin_energy = max(energy/abs(h[i][j][k]), 1e-6) 
          priorities[i*N*N+j*N+k][0] -= spin_energy * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3790398000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
        else:
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] = 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] -= 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2957553999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.11662380000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]])
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        total_priority = abs(total_spin) + sum([val if val > 0 else -1*val for val in interacting_spins]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_priority + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * abs(total_spin) - sum([val if val > 0 else -1*val for val in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= total_priority - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 * abs(total_spin) + sum([val if val < 0 else -1*val for val in interacting_spins])
        
  return priorities


#score: {'data3D.txt': -0.01234300000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          energy_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += energy_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= energy_down * (total_spin < 0)
        else:
          energy_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          energy_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= energy_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += energy_down * (total_spin > 0)

        # New priority terms based on nearest neighbor interactions
        for d in [0,1,2]:
          for l in [(i+1)%N, i-1]:
            if h[l][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += 4 * J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] -= 4 * J[d,l,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= 4 * J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] += 4 * J[d,l,j,k]

        # New priority terms based on magnetism
        for d in range(N):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(h[i][d][k])
            priorities[i*N*N+j*N+k][1] -= h[i][d][k]
          else:
            priorities[i*N*N+j*N+k][0] -= abs(h[i][d][k])
            priorities[i*N*N+j*N+k][1] += h[i][d][k]

  return(priorities)


#score: {'data3D.txt': -0.018220599999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        interacting_spin_sum = sum([val if val > 0 else -1*val for val in interacting_spins])
        
        priority_total = total_spin + (interacting_spin_sum / max(len(interacting_spins), 1))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(priority_total) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - priority_total
        else:
          priorities[i*N*N+j*N+k][0] -= abs(priority_total) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + priority_total
        
        # New priority terms based on nearest neighbor interactions
        for d in [0,1,2]:
          for l in [(i+1)%N, i-1]:
            if h[l][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += 2 * J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] -= 2 * J[d,l,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= 2 * J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] += 2 * J[d,l,j,k]
  
  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]])
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        total_priority_up = abs(total_spin) + sum([val if val > 0 else -1*val for val in interacting_spins])
        total_priority_down = total_spin
        
        priorities[i*N*N+j*N+k][0] += total_priority_up
        priorities[i*N*N+j*N+k][1] -= total_priority_down
        
  return priorities


#score: {'data3D.txt': -0.0028226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]])
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        total_priority_up = abs(total_spin) + sum([val if val > 0 else -1*val for val in interacting_spins]) / max(len(interacting_spins), 1)
        total_priority_down = -2 * abs(total_spin) + sum([val if val < 0 else -1*val for val in interacting_spins])
        
        priorities[i*N*N+j*N+k][0] += total_priority_up
        priorities[i*N*N+j*N+k][1] -= total_priority_down
  
  return priorities


#score: {'data3D.txt': -0.3433833999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        interacting_spins = [J[l][site_nbrs[0],j,k] if J[l][site_nbrs[0],j,k] > 0 else -1*J[l][site_nbrs[0],j,k] for l in range(6)]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        priority_up = abs(total_spin) + sum([val if val > 0 else -1*val for val in interacting_spins]) / max(len(interacting_spins), 1)
        priority_down = total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_up + priority_down
          priorities[i*N*N+j*N+k][1] -= 2 * priority_down
        else:
          priorities[i*N*N+j*N+k][0] -= priority_up + priority_down
          priorities[i*N*N+j*N+k][1] += 2 * priority_down
        
  return(priorities)


#score: {'data3D.txt': -0.0026974}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        interacting_spins = [J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k] for l in range(6)]
        
        site_priority = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs]) / len(site_nbrs)
        
        total_priority = abs(sum(interacting_spins)) + site_priority
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= 2 * abs(sum(interacting_spins))
        else:
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -2 * abs(sum(interacting_spins))
  
  return priorities


#score: {'data3D.txt': -0.49844700000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(-1 if val < 0 else 1 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + sum(1 if val > 0 else -1 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.499259}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]
  return(priorities)


#score: {'data3D.txt': -0.1016914000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  # Add a term that favors the same spin as the nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for _ in range(N) if J[(_+1)%3,i,site_nbr,k] < 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for _ in range(N) if J[(_+1)%3,i,site_nbr,k] > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for _ in range(N) if J[(_+1)%3,i,site_nbr,k] < 0)
          priorities[i*N*N+j*N+k][1] = -sum(1 for _ in range(N) if J[(_+1)%3,i,site_nbr,k] > 0)
        
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        priority_up = np.sum([abs(val) for val in interacting_spins])
        priority_down = total_spin
        site_nbr_energy = sum([h[site_nbr][j][k] * (total_spin >= 0) for site_nbr in site_nbrs])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (priority_up + abs(total_spin)) / (1 + abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= (1 - total_spin) / (1 + abs(total_spin))
        else:
          priorities[i*N*N+j*N+k][0] -= (priority_up + abs(total_spin)) / (1 + abs(total_spin))
          priorities[i*N*N+j*N+k][1] += (1 - total_spin) / (1 + abs(total_spin))
  return priorities


#score: {'data3D.txt': -0.0632466}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * (total_spin > N**3/2)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 * (total_spin < N**3/2)

  return(priorities)


#score: {'data3D.txt': 0.4351218}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        spin_energy = abs(total_spin) - sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 * (total_spin > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= spin_energy - total_spin
          priorities[i*N*N+j*N+k][1] = -2 * (total_spin < 0)
  return(priorities)


#score: {'data3D.txt': -0.4701474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.07079899999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin = int(np.sign(total_spin)) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin = int(np.sign(-total_spin)) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37775220000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4216878}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_diff = sum(val for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + 0.5 * spin_diff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_diff = sum(val for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - 0.5 * spin_diff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add additional conditions based on the site interactions and magnetism
        for d in [0,1,2]:
          for l in [(i+1)%N,i-1,(j+1)%N,j-1,(k+1)%N,k-1]:
            if 0 <= l < N:
              priorities[i*N*N+j*N+k][0] += abs(J[d,l,j,k]) + sum(1 if val < 0 else 0 for val in [J[0,l,j,k], J[1,i,l,k], J[2,i,j,l]])
              priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,l,j,k]
  
  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]
  
  return(priorities)


#score: {'data3D.txt': -0.40672900000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]
  return(priorities)


#score: {'data3D.txt': -0.40672900000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]

  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.481967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          magnetism_term = np.exp(-total_spin**2 / (hamming_distance + 1e-6))
          priorities[i*N*N+j*N+k][0] += spin_energy * magnetism_term * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          magnetism_term = np.exp(-total_spin**2 / (hamming_distance + 1e-6))
          priorities[i*N*N+j*N+k][0] -= spin_energy * magnetism_term * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3384738}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-np.abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-np.abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-spin_energy * (total_spin > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-spin_energy * (total_spin < 0))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4943238}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48630060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20950899999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.0058542000000000646}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_up = magnetism_coeff * (hamming_distance > 0.5)
          priority_down = -magnetism_coeff
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
  return(priorities)


#score: {'data3D.txt': -0.4943238}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4427366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += priority_coeff * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.17040460000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k]]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_nbr_neighbors if val > 0]) / max(len(site_nbr_neighbors), 1)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.34849220000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 1 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]
  return(priorities)


#score: {'data3D.txt': -0.40672900000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]

  return(priorities)


#score: {'data3D.txt': -0.0232702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy * (len([val for val in interacting_spins if val < 0]) > N**2/2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy * (len([val for val in interacting_spins if val > 0]) > N**2/2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate the site interactions with its nearest neighbors
        site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        site_interaction_strength = sum([abs(val) for val in site_interactions])

        # Update the priorities based on the site interactions
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += site_interaction_strength * (len([val for val in site_interactions if val < 0]) > N/2)
          priorities[i*N*N+j*N+k][1] -= site_interaction_strength
        else:
          priorities[i*N*N+j*N+k][0] -= site_interaction_strength * (len([val for val in site_interactions if val > 0]) > N/2)
          priorities[i*N*N+j*N+k][1] = -site_interaction_strength

  return(priorities)


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_interaction_strength
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + site_interaction_strength

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val < 0]) > N**2/2) + site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_interaction_strength
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val > 0]) > N**2/2) - site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + site_interaction_strength

  return(priorities)


#score: {'data3D.txt': 0.2533505999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]] if val < 0)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]] if val > 0)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return priorities


#score: {'data3D.txt': 0.25112339999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,i,j,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.3264937999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        priority_total = total_spin
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          interacting_spin = sum([val if val > 0 else -1*val for val in [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,k]]])
          
          if h[i][j][k] > 0:
            priority_total += interacting_spin
          elif h[i][j][k] < 0:
            priority_total -= interacting_spin
        
        priorities[i*N*N+j*N+k][0] = priority_total + total_spin + sum(1 for val in interacting_spins if val < 0)
        priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] + [J[l,site_nbr,j,k] if l > 0 and (l-1)//3 == i else -1*J[l,site_nbr,j,k] for l in range(4) for site_nbr in site_nbrs]
        total_spin = sum([val if val > 0 else -1*val for val in interacting_spins])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.04043499999999991}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy_up = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy_down = 1 - total_spin
          priorities[i*N*N+j*N+k][0] += spin_energy_up * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= spin_energy_down * (total_spin < 0)
        else:
          spin_energy_up = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy_down = 1 + total_spin
          priorities[i*N*N+j*N+k][0] -= spin_energy_up * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += spin_energy_down * (total_spin > 0)

        for d in range(3):
          site_nbr_d = ((i+d)%N + ((k-1)%2 - 1)) % N
          if h[site_nbr_d][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -1

        if sum(J[d,i,j,k] for d in [0,1,2]) > 0:
          priorities[i*N*N+j*N+k][0] += (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= (total_spin < 0)

  return(priorities)


#score: {'data3D.txt': -0.49472220000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20429540000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_neighbor = (i + ((k-2)%2 - 1)) % N
        if h[site_nbr_neighbor][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34507460000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = -np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37775220000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          bias = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += bias * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          bias = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= bias * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37775220000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0632466}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) - len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 2 * (total_spin > N**3/2)
        else:
          priority_total = abs(total_spin) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -2 * (total_spin < N**3/2)

  return(priorities)


#score: {'data3D.txt': -0.2063734}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = abs(sum(val for val in interacting_spins if val < 0))
          spin_gain = total_spin * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += energy_gain + spin_gain
          priorities[i*N*N+j*N+k][1] -= 2 - (energy_gain + spin_gain)
        else:
          energy_loss = abs(sum(val for val in interacting_spins if val > 0))
          spin_loss = total_spin * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= energy_loss - spin_loss
          priorities[i*N*N+j*N+k][1] = -2 + (energy_loss + spin_loss)
  return(priorities)


#score: {'data3D.txt': -0.4389186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.1324326}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # New addition: Calculate the absolute difference between neighboring spins
        for d in [0,1,2]:
          neighbor_spins = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]]
          abs_diff = sum(1 if val < 0 else -1 for val in neighbor_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * abs_diff
          priorities[i*N*N+j*N+k][1] -= abs_diff

  return(priorities)


#score: {'data3D.txt': -0.4943238}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48630060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.45206460000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48630060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # Calculate the priority for each possible spin assignment based on site interactions and magnetism.
  return(priorities)


#score: {'data3D.txt': -0.2399170000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_term = np.sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_term
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_term = np.sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) * abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_term
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3407385999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.sum([abs(val) for val in interacting_spins]) * max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (total_spin > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_energy = np.sum([abs(val) for val in interacting_spins]) * max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (total_spin < -0.5)
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3290986000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.033170200000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 - total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 - total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.18476220000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.23148740000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin > 0) - total_spin
            priorities[i*N*N+j*N+k][1] = 2 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin < 0) + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.32028020000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  for d in range(3):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -J[d,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.2004798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 0.5
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) - 0.5
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37775220000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5))
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2560510000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in [0,1,2]]
        total_spin = sum([h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs])
        
        interacting_spins = [(J[l,i,j,k] if J[l,i,j,k] > 0 else -1*J[l,i,j,k]) for l in range(6)]
        
        interacting_spin_sum = sum(interacting_spins)
        interacting_spin_avg = interacting_spin_sum / len(interacting_spins)
        
        priority_total = total_spin + interacting_spin_avg
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total + 1 - interacting_spin_avg
          priorities[i*N*N+j*N+k][1] -= 2 - 2*priority_total
        else:
          priorities[i*N*N+j*N+k][0] -= priority_total - 1 + interacting_spin_avg
          priorities[i*N*N+j*N+k][1] = -2 + 2*priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.3942222000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbrs = [(i + ((p-1)%2 - 1)) % N for p in range(3)]
        site_magnetism = sum(h[site_nbr][j][k] if h[site_nbr][j][k] > 0 else -1*h[site_nbr][j][k] for site_nbr in site_nbrs)
        
        priority_total = total_spin + site_magnetism
        interacting_spins.sort()
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - 2*priority_total
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) - priority_total
          priorities[i*N*N+j*N+k][1] = -2 + 2*priority_total
  return(priorities)


#score: {'data3D.txt': -0.4040634}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[l,i,j,k] for l in [0,1,2])
        if h[i][j][k] > 0:
          interacting_spins.sort()
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          interacting_spins.sort(reverse=True)
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.024948999999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = abs(total_spin) * (hamming_distance > 0.5)
          priority_coeff = np.exp(-total_spin_coeff)
          priorities[i*N*N+j*N+k][0] += priority_coeff * total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = abs(total_spin) * (hamming_distance < 0.5)
          priority_coeff = np.exp(total_spin_coeff)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin

  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-spin_energy - hamming_distance)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-spin_energy + hamming_distance)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.1875926}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin

  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.31419859999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spin_sum = sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len(interacting_spins) + interacting_spin_sum
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          interacting_spin_sum = sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len(interacting_spins) + interacting_spin_sum
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (spin_energy + total_spin) // 2
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (spin_energy + total_spin) // 2
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.286661}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin / max(len(interacting_spins), 1) * sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin - (total_spin > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin / max(len(interacting_spins), 1) * sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -total_spin + (total_spin < 0)
  return(priorities)


#score: {'data3D.txt': -0.19343780000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = sum(abs(val) for val in interacting_spins)
          spin_gain = total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] += energy_gain + spin_gain
          priorities[i*N*N+j*N+k][1] -= 2 - (energy_gain + spin_gain)
        else:
          energy_loss = sum(abs(val) for val in interacting_spins)
          spin_loss = total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= energy_loss - spin_loss
          priorities[i*N*N+j*N+k][1] = -2 + (energy_loss + spin_loss)
  return(priorities)


#score: {'data3D.txt': 0.04242939999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_gain = sum(abs(val) for val in interacting_spins)
          spin_gain = total_spin
          priorities[i*N*N+j*N+k][0] += energy_gain * (total_spin > 0) + spin_gain
          priorities[i*N*N+j*N+k][1] -= 2 - (energy_gain + spin_gain)
        else:
          energy_loss = sum(abs(val) for val in interacting_spins)
          spin_loss = total_spin
          priorities[i*N*N+j*N+k][0] -= energy_loss * (total_spin < 0) - spin_loss
          priorities[i*N*N+j*N+k][1] = -2 + (energy_loss + spin_loss)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Add additional conditions based on the site interactions and magnetism
        for d in [0,1,2]:
          for l in [(i+1)%N,i-1,(j+1)%N,j-1,(k+1)%N,k-1]:
            if 0 <= l < N:
              priorities[i*N*N+j*N+k][0] += abs(J[d,l,j,k]) + sum(1 if val < 0 else 0 for val in [J[0,l,j,k], J[1,i,l,k], J[2,i,j,l]])
              priorities[i*N*N+j*N+k][1] -= 2 - 2*J[d,l,j,k]
        
        # Add the total magnetism of the neighboring sites
        for d in [0,1,2]:
          for l in [(i+1)%N,i-1,(j+1)%N,j-1,(k+1)%N,k-1]:
            if 0 <= l < N:
              priorities[i*N*N+j*N+k][0] += abs(h[l][j][k]) + sum(1 if val < 0 else 0 for val in [h[(i+1)%N][j][k], h[i-1][j][k], h[i][j-1][k], h[i][k-1][k]])
              priorities[i*N*N+j*N+k][1] -= 2 - 2*h[l][j][k]
  
  total_polarization = np.sum(h, axis=(1,2))
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] += total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] -= total_polarization[i]
      else:
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][0] -= total_polarization[i]
        priorities[i*N*N+j*N:N*(i+1)*N+j*N+N-1][1] = -total_polarization[i]
  
  return(priorities)


#score: {'data3D.txt': -0.2689846}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priority_down = np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] += total_spin + priority_up
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + priority_down
        else:
          priority_up = np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priority_down = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] -= total_spin + priority_up
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + priority_down
  return(priorities)


#score: {'data3D.txt': -0.33059619999999973}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
  return(priorities)


#score: {'data3D.txt': 0.14401379999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= total_spin + (sum(val for val in interacting_spins) % 2)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -total_spin + (sum(val for val in interacting_spins) % 2)
  return(priorities)


#score: {'data3D.txt': -0.26453820000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3047318}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          if total_spin < 0:
            priorities[i*N*N+j*N+k][1] += 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.2848050000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate the priority for the site and its neighbors
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.08526379999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_diff = np.sum([val * (np.sign(val) == 1) for val in interacting_spins]) + total_spin
          priorities[i*N*N+j*N+k][0] += abs(energy_diff)
          priorities[i*N*N+j*N+k][1] -= np.sign(total_spin) * abs(total_spin)
        else:
          energy_diff = np.sum([val * (np.sign(val) == -1) for val in interacting_spins]) + total_spin
          priorities[i*N*N+j*N+k][0] -= abs(energy_diff)
          priorities[i*N*N+j*N+k][1] = -np.sign(total_spin) * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.4922190000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus = np.sum([spin * abs(spin) for spin in interacting_spins]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] += energy_plus + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy_minus = np.sum([spin * abs(spin) for spin in interacting_spins]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= energy_minus + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2788582000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 0.5
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) - 0.5
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate the priority for the site and its neighbors
        for d in range(3):
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2788582000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 0.5
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) - 0.5
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate the priority for the site and its neighbors
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2004798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          spin_bias = np.tanh(abs(total_spin) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (spin_bias + 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_bias = -np.tanh(abs(total_spin) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (spin_bias - 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0532642}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 0.5
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          for d in range(3):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += 1 + total_spin
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= 1 + total_spin
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) - 0.5
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          for d in range(3):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr][j][k] > 0:
              priorities[i*N*N+j*N+k][0] -= 1 + total_spin
              priorities[i*N*N+j*N+k][1] += 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] += 1 + total_spin
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy * (total_spin > 0))
          priorities[i*N*N+j*N+k][0] += priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy * (total_spin < 0))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (hamming_distance > 0.5) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5031270000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-spin_energy * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += priority_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = np.exp(-spin_energy * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4653002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-spin_energy * (total_spin > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-spin_energy * (total_spin < 0))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      if h[i][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += np.exp(-np.abs(sum(J[d,i,j,0] for d in [0,1,2])) * (sum(J[d,i,j,0] for d in [0,1,2]) > 0))
        priorities[i*N*N+j*N+0][1] -= 1 - sum(J[d,i,j,0] for d in [0,1,2])
      else:
        priorities[i*N*N+j*N+0][0] -= np.exp(-np.abs(sum(J[d,i,j,0] for d in [0,1,2])) * (sum(J[d,i,j,0] for d in [0,1,2]) < 0))
        priorities[i*N*N+j*N+0][1] = -1 + sum(J[d,i,j,0] for d in [0,1,2])
      
      site_nbr = (j + ((2)%2 - 1)) % N
      if h[i][0][k] > 0:
        priorities[i*N+j*N+k][0] += np.exp(-np.abs(sum(J[d,i,0,k] for d in [0,1,2])) * (sum(J[d,i,0,k] for d in [0,1,2]) > 0))
        priorities[i*N+j*N+k][1] -= 1 - sum(J[d,i,0,k] for d in [0,1,2])
      else:
        priorities[i*N+j*N+k][0] -= np.exp(-np.abs(sum(J[d,i,0,k] for d in [0,1,2])) * (sum(J[d,i,0,k] for d in [0,1,2]) < 0))
        priorities[i*N+j*N+k][1] = -1 + sum(J[d,i,0,k] for d in [0,1,2])
      
  return priorities


#score: {'data3D.txt': -0.45509980000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.358171}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus_one = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy_plus_one
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy_minus_one = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy_minus_one
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.24747580000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus_one = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy_plus_one
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          energy_minus_one = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy_minus_one
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        # Add a small bias to favor the magnetization
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])
  return(priorities)


#score: {'data3D.txt': -0.1714922000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus_one = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy_plus_one
          priorities[i*N*N+j*N+k][1] -= total_spin - (2*len([val for val in interacting_spins if val > 0]))/max(len(interacting_spins), 1)
        else:
          energy_minus_one = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy_minus_one
          priorities[i*N*N+j*N+k][1] = total_spin + (2*len([val for val in interacting_spins if val < 0]))/max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus_one = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += energy_plus_one
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          energy_minus_one = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= energy_minus_one
          priorities[i*N*N+j*N+k][1] = 1 + total_spin

        # Additional optimization based on the sign of the magnetism at the site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5063122000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for sites with high magnetism and low hamming distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] *= 2
            
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
            priorities[i*N*N+j*N+k][1] *= 2
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
            priorities[i*N*N+j*N+k][1] *= 2
  
  return(priorities)


#score: {'data3D.txt': 0.3484338000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_up = magnetism_coeff * (hamming_distance > 0.5) * (total_spin > 0)
          priority_down = -magnetism_coeff
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_down = -priority_up
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_down = -priority_up
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
  return(priorities)


#score: {'data3D.txt': -0.27333060000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # add interaction with more distant sites
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.43768500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.36109939999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.4059202000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins))) * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins))) * (priority_up < priority_down) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48630060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.050568200000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_up = magnetism_coeff * (hamming_distance > 0.5)
          priority_down = -magnetism_coeff
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += priority_up + 1
          priorities[i*N*N+j*N+k][1] -= priority_down - 2
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= priority_up - 1
          priorities[i*N*N+j*N+k][1] += priority_down + 1
        else:
          priorities[i*N*N+j*N+k][0] += priority_up - 1
          priorities[i*N*N+j*N+k][1] = -1 + priority_down
        
  return(priorities)


#score: {'data3D.txt': 0.4329270000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = magnetism_coeff * (total_spin > 0)
          priority_down = -magnetism_coeff
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] -= priority_down
  return(priorities)


#score: {'data3D.txt': 0.0058542000000000646}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_up = magnetism_coeff * (hamming_distance > 0.5)
          priority_down = -magnetism_coeff
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] -= priority_down
  return(priorities)


#score: {'data3D.txt': 0.4329270000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = magnetism_coeff * (total_spin > 0)
          priority_down = -magnetism_coeff
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= spin_energy
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.18677820000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= (abs(total_spin) - 1) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = - (abs(total_spin) - 1) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.321931}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= total_spin + 1
        else:
          priority_total = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = total_spin - 1
  return(priorities)


#score: {'data3D.txt': -0.210881}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_energy = abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.10199700000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_energy = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_energy - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.39708140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.08221339999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy = abs(total_spin)
          spin_energy = max(energy/abs(h[i][j][k]), 1e-6) 
          interacting_spins_count = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += energy * (interacting_spins_count + total_spin)
          priorities[i*N*N+j*N+k][1] -= energy - total_spin
        else:
          energy = abs(total_spin)
          spin_energy = max(energy/abs(h[i][j][k]), 1e-6) 
          interacting_spins_count = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= energy * (interacting_spins_count - total_spin)
          priorities[i*N*N+j*N+k][1] = -energy + total_spin
  return(priorities)


#score: {'data3D.txt': -0.39708140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3524782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.44689340000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_energy >= 0)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (spin_energy < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_energy >= 0)
          priorities[i*N*N+j*N+k][1] += magnetism_coeff * (spin_energy < 0)

  return(priorities)


#score: {'data3D.txt': -0.4821934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
  
  return(priorities)


#score: {'data3D.txt': -0.3931354000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.5030834000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if i == 0:
            priorities[i*N*N+j*N+k][0] *= 2
          elif j == 0:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif k == 0:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if i == N-1:
            priorities[i*N*N+j*N+k][0] *= 2
          elif j == N-1:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif k == N-1:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.45509980000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
        
  return(priorities)


#score: {'data3D.txt': -0.3524782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += priority_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.13815220000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.028633799999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_bias = np.tanh(abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * spin_bias
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_bias = np.tanh(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.2289414000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          spin_bias = np.tanh(abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          spin_bias = -np.tanh(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.43612220000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.2004798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_bias = np.tanh(abs(total_spin) * (np.mean([val for val in interacting_spins if val < 0]) > 0.5)) + 0.5
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          spin_bias = np.tanh(-abs(total_spin) * (np.mean([val for val in interacting_spins if val > 0]) > 0.5)) - 0.5
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.47928780000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.3676166}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val < 0)

        # Additional term to favor aligning spins with the overall magnetization
        total_magnetism = np.sum(h)
        priorities[i*N*N+j*N+k][0] += (total_spin + total_magnetism) / N**3 * sum(1 for val in interacting_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= (total_spin + total_magnetism) / N**3 * sum(1 for val in interacting_spins if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.17498020000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-spin_energy * (total_spin > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-spin_energy * (total_spin < 0))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            spin_energy = np.abs(sum(J[e,i,j,k] for e in [0,1,2]) - J[d,i,j,k])
            priorities[i*N*N+j*N+k][0] += np.exp(-spin_energy * (sum(J[e,i,j,k] for e in [0,1,2]) > J[d,i,j,k]))
            priorities[i*N*N+j*N+k][1] -= 1 - sum(J[e,i,j,k] for e in [0,1,2])
          else:
            spin_energy = np.abs(sum(J[e,i,j,k] for e in [0,1,2]) + J[d,i,j,k])
            priorities[i*N*N+j*N+k][0] -= np.exp(-spin_energy * (sum(J[e,i,j,k] for e in [0,1,2]) < J[d,i,j,k]))
            priorities[i*N*N+j*N+k][1] = -1 + sum(J[e,i,j,k] for e in [0,1,2])
        
  return priorities


#score: {'data3D.txt': -0.4942934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          if i == 0 or j == 0 or k == 0:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          if i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
  
  return(priorities)


#score: {'data3D.txt': -0.03704980000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the sign of total spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff if total_spin >= 0 else -magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + (1 if total_spin > 0 else -1)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the sign of total spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff if total_spin >= 0 else -magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -abs(total_spin) + (1 if total_spin > 0 else -1)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.2540862000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.4738994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) + total_spin
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) + total_spin
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.46214459999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.377101}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Increase priority when site has high magnetism and low hamming distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Decrease priority when site has high magnetism and high hamming distance
          elif h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Increase priority when site has low magnetism and high hamming distance
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff / 2
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.5142266}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.4405742000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.17006819999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)

  return(priorities)


#score: {'data3D.txt': 0.10852659999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 3*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 3*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 3*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -3*(1 + total_spin)

  # Add interactions from other directions
  for i in range(N):
    for j in range(N):
      if (i+2)%N != 0:
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[3,i,j,k], J[4,(i+1)%N,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [3,4])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= 2*np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)

  for i in range(N):
    for j in range(N):
      if (j+2)%N != 0:
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[5,i,j,k], J[0,(i+1)%N,j,k]]
        total_spin = sum(J[d,i,j,k] for d in [5,0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= 2*np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)

  return(priorities)


#score: {'data3D.txt': -0.15641700000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.3017177999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3290986000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += priority_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= priority_energy + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2957553999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.where([val for val in interacting_spins if val < 0], 1, 0))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.where([val for val in interacting_spins if val > 0], 1, 0))
          priorities[i*N*N+j*N+k][1] = 2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.26310620000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priority_energy = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.2783126000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spin_sum = np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len(interacting_spins) + interacting_spin_sum
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          interacting_spin_sum = np.sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len(interacting_spins) + interacting_spin_sum
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.4883274}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional improvement: consider the interaction with next layer
        site_nbr_3d = (i, j, ((k-1)%N - 1) % N)
        interacting_spins_3d = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins_3d if val < 0]) / max(len(interacting_spins_3d), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins_3d if val > 0]) / max(len(interacting_spins_3d), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.006394599999999934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= (1 - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -(1 + total_spin)

  return(priorities)


#score: {'data3D.txt': -0.48290540000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.38218060000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + sum(1 if val < 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_energy
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin + len([val for val in interacting_spins if val > 0])
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val > 0])
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + sum(1 if val > 0 else 0 for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_energy
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin - len([val for val in interacting_spins if val < 0])
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val < 0])

  return(priorities)


#score: {'data3D.txt': -0.4821934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)

  return(priorities)


#score: {'data3D.txt': -0.4787538}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate magnetism coefficient based on total spin and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
          elif hamming_distance > 0.7:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * 0.5
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
          elif hamming_distance > 0.7:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * 0.5
  
  return(priorities)


#score: {'data3D.txt': -0.4700170000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the number of nearest neighbors with same spin
          same_spin_neighbors = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (same_spin_neighbors > 1)
          
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the number of nearest neighbors with same spin
          same_spin_neighbors = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (same_spin_neighbors > 1)
          
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.22728340000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)

  return(priorities)


#score: {'data3D.txt': -0.2876486000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)
        
        interacting_spins = [J[3,(i+1)%N,(j-1)%N,k], J[4,(i-1)%N,j,k], J[5,i,j,(k-1)%N]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.1573678000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)

  # Add a term to prioritize the direction of magnetization
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += np.exp(-abs(total_spin) * (site_nbr < N//2))
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (site_nbr < N//2))

  return(priorities)


#score: {'data3D.txt': -0.15641700000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 4*(1 - total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -4*(1 + total_spin)
  
  return(priorities)


#score: {'data3D.txt': 0.2061477999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] = - (abs(total_spin) - 1) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
  return(priorities)


#score: {'data3D.txt': 0.06945860000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = - (abs(total_spin) - 2 + sum(1 for d in [0,1,2] if J[d,i,j,k] > 0)) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = - (abs(total_spin) + 2 - sum(1 for d in [0,1,2] if J[d,i,j,k] > 0)) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34082339999999967}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy = abs(total_spin)
          interacting_spins_count = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += energy * (interacting_spins_count + total_spin) + max(energy/abs(h[i][j][k]), 1e-6)
          priorities[i*N*N+j*N+k][1] -= energy - total_spin
        else:
          energy = abs(total_spin)
          interacting_spins_count = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= energy * (interacting_spins_count - total_spin) + max(energy/abs(h[i][j][k]), 1e-6)
          priorities[i*N*N+j*N+k][1] = -energy + total_spin
  return(priorities)


#score: {'data3D.txt': -0.41363420000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) + (abs(total_spin)-1)/sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) + (abs(total_spin)-1)/sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.08221339999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy = abs(total_spin)
          interacting_spins_count = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += energy * (interacting_spins_count + total_spin)
          priorities[i*N*N+j*N+k][1] -= energy - total_spin
        else:
          energy = abs(total_spin)
          interacting_spins_count = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= energy * (interacting_spins_count - total_spin)
          priorities[i*N*N+j*N+k][1] = -energy + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4701474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.08431620000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias * (total_spin > 0)
          hamiltonian_energy = -sum(val for val in interacting_spins) + total_spin
          if hamiltonian_energy < 0:
            priorities[i*N*N+j*N+k][1] -= 1 + np.exp(-hamiltonian_energy)
          else:
            priorities[i*N*N+j*N+k][1] += 1 + np.exp(hamiltonian_energy)
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias * (total_spin < 0)
          hamiltonian_energy = -sum(val for val in interacting_spins) + total_spin
          if hamiltonian_energy < 0:
            priorities[i*N*N+j*N+k][1] += 1 + np.exp(-hamiltonian_energy)
          else:
            priorities[i*N*N+j*N+k][1] -= 1 + np.exp(hamiltonian_energy)
  return(priorities)


#score: {'data3D.txt': -0.027367800000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        spin_bias = np.tanh(abs(total_spin) * (sum(1 for val in interacting_spins if val < 0) > 0.5))
        priorities[i*N*N+j*N+k][0] *= spin_bias
        priorities[i*N*N+j*N+k][1] *= -spin_bias
  return(priorities)


#score: {'data3D.txt': -0.17040460000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.abs(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.abs(total_spin) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k]]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_nbr_neighbors if val > 0]) / max(len(site_nbr_neighbors), 1)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.07822499999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
  
  return(priorities)


#score: {'data3D.txt': -0.2540862000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          # Increase priority when site has high magnetism and low hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          # Decrease priority when site has low magnetism and high hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.45590020000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Adjust priority based on site's location (edge or corner)
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          
  return(priorities)


#score: {'data3D.txt': -0.47281619999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.47128539999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4541026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0027934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 8*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2*(1 - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= 8*np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2*(1 + total_spin)

      return(priorities)


#score: {'data3D.txt': -0.25339020000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (total_spin < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] += magnetism_coeff * (total_spin < 0)

  return(priorities)


#score: {'data3D.txt': -0.35773060000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) - 1
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) - 1
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.23779899999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # add interaction with more distant sites
        for d in range(3):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # add interaction with the site below
        if i < N-1:
          interacting_spins = [J[3,i+1,j,k], J[4,(i+2)%N,j,k]]
          total_spin = sum(J[d,i+1,j,k] for d in [3,4])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        # add interaction with the site above
        if i > 0:
          interacting_spins = [J[3,i-1,j,k], J[4,(i-2)%N,j,k]]
          total_spin = sum(J[d,i-1,j,k] for d in [3,4])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.36553019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.23959180000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for d in range(6):
          site_nbr = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.42997299999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] += priority_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4427366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) + hamming_distance
          priority_coeff = np.exp(-spin_energy) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += priority_coeff * len([val for val in interacting_spins if val < 0]) / (1 + np.sum(np.square(h[i][j])) / N**3)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = abs(total_spin) - hamming_distance
          priority_coeff = np.exp(-spin_energy) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= priority_coeff * len([val for val in interacting_spins if val > 0]) / (1 + np.sum(np.square(h[i][j])) / N**3)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0435278}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) + sum(J[d,i,j,k] for d in [0,1,2]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5) + sum(J[d,i,j,k] for d in [0,1,2]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
        
  return(priorities)


#score: {'data3D.txt': -0.07822499999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance < 0.5) + site_interaction_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
  
  return(priorities)


#score: {'data3D.txt': -0.07822499999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5) * np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
        
  return(priorities)


#score: {'data3D.txt': -0.0032146000000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
  
  return(priorities)


#score: {'data3D.txt': -0.45476379999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0) + sum(1 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]] if val > 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0) - sum(1 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]] if val < 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins))) * (priority_up > priority_down)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0) - sum(1 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]] if val > 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0) + sum(1 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]] if val < 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins))) * (priority_up > priority_down)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0891314}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        for d in range(3):
          if neighbor_spins[d] > 0:
            priorities[i*N*N+j*N+k][0] += sum(J[d,i,j,k] for j in range(N) for k in range(N)) * (neighbor_spins[0] + neighbor_spins[1] + neighbor_spins[2])
          else:
            priorities[i*N*N+j*N+k][1] -= sum(J[d,i,j,k] for j in range(N) for k in range(N)) * (neighbor_spins[0] + neighbor_spins[1] + neighbor_spins[2])

  return(priorities)


#score: {'data3D.txt': -0.3518442}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional terms to favor aligning spins with neighbors and the overall magnetization
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val < 0)

        # Additional term to favor aligning spins with the overall magnetization
        total_magnetization = np.sum(h.flatten())
        total_magnetism_coeff = np.exp(-abs(total_spin) * (total_magnetization / N**3))
        priorities[i*N*N+j*N+k][0] += total_magnetism_coeff * (total_magnetization > 0)
        priorities[i*N*N+j*N+k][1] -= total_magnetism_coeff * (total_magnetization < 0)

  return(priorities)


#score: {'data3D.txt': -0.338101}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val < 0)

        # Additional term to favor aligning spins with diagonal neighbors
        diagonal_spins = [h[(i+1)%N][(j+1)%N][k], h[(i-1)%N][(j-1)%N][k]]
        diagonal_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in diagonal_spins) / len(diagonal_spins)))
        priorities[i*N*N+j*N+k][0] += diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.232433}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = -np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # add a bias term based on the current state of the system
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.10773060000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = -np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.30483500000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_bias = (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val == 0])) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          spin_bias = (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val == 0])) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34507460000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = -np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48857460000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(total_spin)
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += (priority_total + hamming_distance/2) 
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = np.sum(total_spin)
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= (priority_total + hamming_distance/2) 
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0023050000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = -total_spin
          neighbor_spins = [J[d,i,j,(k+1)%N] for d in range(6)] + \
                    [J[d,site_nbr,N-1,k] for d in range(6)]
          if any(val > 0 for val in interacting_spins) and all(val < 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= spin_energy
          elif any(val < 0 for val in interacting_spins) and all(val > 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] += spin_energy
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = total_spin
          neighbor_spins = [J[d,i,j,(k+1)%N] for d in range(6)] + \
                    [J[d,site_nbr,N-1,k] for d in range(6)]
          if any(val < 0 for val in interacting_spins) and all(val > 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] += spin_energy
          elif any(val > 0 for val in interacting_spins) and all(val < 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= spin_energy

  return(priorities)


#score: {'data3D.txt': -0.2473482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = -total_spin
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_energy >= 0) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (spin_energy < 0) * (hamming_distance > 0.5)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = total_spin
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_energy >= 0) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] += magnetism_coeff * (spin_energy < 0) * (hamming_distance > 0.5)

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (total_spin < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] += magnetism_coeff * (total_spin < 0)

  return(priorities)


#score: {'data3D.txt': -0.3474838000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_energy >= 0)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (spin_energy < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_energy = total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_energy >= 0)
          priorities[i*N*N+j*N+k][1] += magnetism_coeff * (spin_energy < 0)

        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.286661}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
        
        # Prioritize spins based on site interactions and magnetism
        if total_spin >= 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * abs(total_spin) / (abs(total_spin) + 1e-6)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 2 - 2 * abs(total_spin) / (abs(total_spin) + 1e-6)
        
  return(priorities)


#score: {'data3D.txt': -0.1392166000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.2569514000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * (total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * (total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)))
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.0030865999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[1,(i-1)%N,j,k], 
                              J[2,i,(j+1)%N,k], J[2,i,(j-1)%N,k], J[3,(i+1)%N,(j+1)%N,k], 
                              J[3,(i+1)%N,(j-1)%N,k], J[4,(i-1)%N,(j+1)%N,k], J[4,(i-1)%N,(j-1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4])
        
        site_nbrs = []
        if i > 0: site_nbrs.append((i-1 + ((k-1)%2 - 1)) % N)
        if i < N-1: site_nbrs.append((i+1 + ((k-1)%2 - 1)) % N)
        if j > 0: site_nbrs.append((i + ((j-1)%N - N//2)) % N)
        if j < N-1: site_nbrs.append((i + ((j+1)%N - N//2)) % N)
        if k > 0: site_nbrs.append((i + ((k-1)%2 - 1)) % N)
        if k < N-1: site_nbrs.append((i + ((k+1)%2 - 1)) % N)
        
        for site_nbr in site_nbrs:
          if h[site_nbr][j][k] > 0:
            hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            
          else:
            hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        return(priorities)


#score: {'data3D.txt': -0.45590020000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Adjust priority based on site's location (edge or corner)
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          
  return(priorities)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[site_nbr][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[site_nbr][j][k])


#score: {'data3D.txt': -0.46214459999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

          # Adjust priority based on site's magnetization and nearest neighbor
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

          # Adjust priority based on site's magnetization and nearest neighbor
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.45590020000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Adjust priority based on site's location (edge or corner)
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          
  return(priorities)


#score: {'data3D.txt': -0.49623379999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism_coeff = magnetism_coeff + abs(h[i][j][k]) * (2 * hamming_distance - len(interacting_spins)) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] += total_magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism_coeff = magnetism_coeff - abs(h[i][j][k]) * (2 * hamming_distance - len(interacting_spins)) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= total_magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.0989578}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin + len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - len([val for val in interacting_spins if val > 0])
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin - len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + len([val for val in interacting_spins if val > 0])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = -np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin - len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -1 - total_spin + len([val for val in interacting_spins if val < 0])
          else:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin + len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] = -1 - total_spin - len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': 0.24821739999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          total_spin += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = -np.tanh(-abs(total_spin) * (hamming_distance > 0.5)) + 2 * abs(total_spin) * hamming_distance
          total_spin += h[site_nbr][j][k]
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.27262699999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val < 0)

        # Additional term to favor aligning spins with diagonal neighbors
        diagonal_spins = [h[(i+1)%N][(j+1)%N][k], h[(i-1)%N][(j-1)%N][k]]
        diagonal_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in diagonal_spins) / len(diagonal_spins)))
        priorities[i*N*N+j*N+k][0] += diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val < 0)

        # Additional term to favor aligning spins with neighbors and diagonal neighbors
        neighbor_diagonal_spins = [h[site_nbr][j][k], h[(i+1)%N][(j+1)%N][k], h[(i-1)%N][(j-1)%N][k]]
        neighbor_diagonal_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_diagonal_spins) / len(neighbor_diagonal_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_diagonal_magnetism_coeff * sum(1 for val in neighbor_diagonal_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_diagonal_magnetism_coeff * sum(1 for val in neighbor_diagonal_spins if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.17913739999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]) / len([h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]])))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin + neighbor_magnetism_coeff * sum(1 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]] if val > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          neighbor_magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]) / len([h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]])))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin - neighbor_magnetism_coeff * sum(1 for val in [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]] if val < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with diagonal neighbors
        diagonal_spins = [h[(i+1)%N][(j+1)%N][k], h[(i-1)%N][(j-1)%N][k]]
        diagonal_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in diagonal_spins) / len(diagonal_spins)))
        priorities[i*N*N+j*N+k][0] += diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff * sum(1 for val in neighbor_spins if val < 0)

        # Additional term to favor aligning spins with diagonal neighbors
        diagonal_spins = [h[(i+1)%N][(j+1)%N][k], h[(i-1)%N][(j-1)%N][k]]
        diagonal_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in diagonal_spins) / len(diagonal_spins)))
        priorities[i*N*N+j*N+k][0] += diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val > 0)
        priorities[i*N*N+j*N+k][1] -= diagonal_magnetism_coeff * sum(1 for val in diagonal_spins if val < 0)

  # Additional term to favor aligning spins with the global magnetization
  total_magnetization = np.sum(h)
  priorities[:, 0] += np.exp(-abs(total_spin) * (total_magnetization > 0)) * sum(1 for val in h.flatten() if val > 0)
  priorities[:, 1] -= np.exp(abs(total_spin) * (total_magnetization < 0)) * sum(1 for val in h.flatten() if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.051942999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          spin_bias = np.tanh(abs(total_spin))
          site_magnetism = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias + (2*total_spin - site_magnetism)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          spin_bias = -np.tanh(-abs(total_spin))
          site_magnetism = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias + (2*total_spin - site_magnetism)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.2289414000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          spin_bias = np.tanh(abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          spin_bias = -np.tanh(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1
        
  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          spin_bias = np.tanh(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_bias = -np.tanh(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.22515020000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Favor spins that align with the site's magnetization
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 2
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Favor spins that align with the site's magnetization
          if np.sum(priorities[i*N*N+j*N+k]) < 0:
            priorities[i*N*N+j*N+k][0] -= 2
            priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.48111260000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        site_nbr_3d = (i, j, ((k-1)%N - 1) % N)
        interacting_spins_3d = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in interacting_spins_3d if val < 0]) / max(len(interacting_spins_3d), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin) * len([val for val in interacting_spins_3d if val > 0]) / max(len(interacting_spins_3d), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4881026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional improvement: consider the interaction with next layer
        site_nbr_3d = (i, j, ((k-1)%N - 1) % N)
        interacting_spins_3d = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins_3d if val < 0]) / max(len(interacting_spins_3d), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins_3d if val > 0]) / max(len(interacting_spins_3d), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional improvement: consider the interaction with previous layer
        site_nbr_prev = (i, j, ((k+1)%N - 1) % N)
        interacting_spins_prev = [J[0,i,j,k], J[1,(i-1)%N,j,k], J[2,i,(j-1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins_prev if val < 0]) / max(len(interacting_spins_prev), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins_prev if val > 0]) / max(len(interacting_spins_prev), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.41335659999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array(interacting_spins) < 0)
          spin_energy = abs(total_spin) + np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = np.exp(-spin_energy)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array(interacting_spins) > 0)
          spin_energy = abs(total_spin) + np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = np.exp(-spin_energy)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.4883274}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val < 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_energy = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (priority_energy + total_spin) // 2
          if len([val for val in interacting_spins if val > 0]) > N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional improvement: consider the interaction with next layer
        site_nbr_3d = (i, j, ((k-1)%N - 1) % N)
        interacting_spins_3d = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins_3d if val < 0]) / max(len(interacting_spins_3d), 1)
          if total_spin > N**2/2:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins_3d if val > 0]) / max(len(interacting_spins_3d), 1)
          if total_spin < -N**2/2:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5160982000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * np.mean([spin < 0 for spin in interacting_spins]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * np.mean([spin > 0 for spin in interacting_spins]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1824934000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Add a bonus term to favor spins aligned with the nearest neighbor
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(J[:,site_nbr,j,k])
          priorities[i*N*N+j*N+k][1] -= np.sum(J[:,i,site_nbr,k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(J[:,site_nbr,j,k])
          priorities[i*N*N+j*N+k][1] = -np.sum(J[:,i,site_nbr,k])

  return(priorities)


#score: {'data3D.txt': -0.3111666}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance + site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance - site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3314973999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] += site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_interaction_strength
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] -= site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + site_interaction_strength

  return(priorities)


#score: {'data3D.txt': -0.3033090000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          energy_plus = np.sum([spin * abs(spin) for spin in interacting_spins]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] += energy_plus + total_spin
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] += site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_interaction_strength
        else:
          energy_minus = np.sum([spin * abs(spin) for spin in interacting_spins]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= energy_minus + total_spin
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] -= site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + site_interaction_strength
  return(priorities)


#score: {'data3D.txt': -0.3314973999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + hamming_distance
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] += site_interaction_strength
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_interaction_strength
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - hamming_distance
          site_interactions = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
          site_interaction_strength = sum([abs(val) for val in site_interactions])
          priorities[i*N*N+j*N+k][0] -= site_interaction_strength
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + site_interaction_strength
  return(priorities)


#score: {'data3D.txt': -0.3562250000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != h[i][j][k]]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if i == 0 or j == 0 or k == 0 or i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if i == 0 or j == 0 or k == 0 or i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
  
  return(priorities)


#score: {'data3D.txt': -0.5151654000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1))
        
        # Calculate priority for sites with high magnetism and hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(0.5, 1 - hamming_distance)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(0.5, 1 - hamming_distance)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Adjust priority for edge or corner sites and sites with high hamming distance
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] *= max(2, 4 * (hamming_distance > 0.7))
  
  return(priorities)


#score: {'data3D.txt': -0.35090980000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        priorities[i*N*N+j*N+k][0] += priority_total[0]
        priorities[i*N*N+j*N+k][1] += priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.4886222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)

  return(priorities)


#score: {'data3D.txt': -0.5009298000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

          # Adjust priority for sites with high magnetism and low hamming distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance < 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1287598}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
          if all(val > 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          elif any(val < 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] = -1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
          if all(val < 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          elif any(val > 0 for val in neighbor_spins):
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.45206460000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4052714}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_up = sum(1 for val in interacting_spins if val < 0) + (sum(J[d,site_nbr,j,k] for d in [0,1,2]) - total_spin)
          priority_down = len(interacting_spins) - sum(1 for val in interacting_spins if val > 0) - (sum(J[d,site_nbr,j,k] for d in [0,1,2]) + total_spin)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (priority_up > priority_down)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_up = sum(1 for val in interacting_spins if val < 0) + (sum(J[d,site_nbr,j,k] for d in [0,1,2]) + total_spin)
          priority_down = len(interacting_spins) - sum(1 for val in interacting_spins if val > 0) - (sum(J[d,site_nbr,j,k] for d in [0,1,2]) - total_spin)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (priority_up > priority_down)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3941826000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += 1 + total_spin
            priority_total[1] -= 1 - total_spin
          else:
            priority_total[0] -= 1 + total_spin
            priority_total[1] = -1 + total_spin
        
        priorities[i*N*N+j*N+k][0] += priority_total[0]
        priorities[i*N*N+j*N+k][1] += priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.2702474000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
          
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total[0]
        priorities[i*N*N+j*N+k][1] -= priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.13732300000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total[0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][0] += priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priority_total[0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][0] -= priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.27079740000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
        # Adjust priority based on magnetism and hamming distance
        site_nbr_magnetism = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr_magnetism][j][k] > 0:
          priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
        else:
          priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
        
  return(priorities)


#score: {'data3D.txt': -0.2702474000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.3748062000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0177226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += spin_energy * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          spin_energy = np.sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= spin_energy * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        site_nbr_neighbors = [J[0,site_nbr,j,k], J[1,i,(j+1)%N,k]]
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in site_nbr_neighbors if val < 0]) / max(len(site_nbr_neighbors), 1)
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in site_nbr_neighbors if val > 0]) / max(len(site_nbr_neighbors), 1)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.050906999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  return(priorities)


#score: {'data3D.txt': -0.06819820000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-sum(1 for val in neighbor_spins if val < 0))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(sum(1 for val in neighbor_spins if val > 0))

  # Additional term to favor aligning spins with global magnetism
  global_magnetism = sum(h.flatten())
  if global_magnetism > 0:
    priorities[:,0] += np.exp(-abs(global_magnetism))
  else:
    priorities[:,1] -= np.exp(abs(global_magnetism))

  return(priorities)


#score: {'data3D.txt': -0.34044060000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  return(priorities)


#score: {'data3D.txt': -0.055254199999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  # Additional term to favor aligning spins with neighboring planes
  for d in range(3):
    for i in range(N):
      for j in range(N):
        if h[i][j][0] > 0:
          priorities[i*N*N+j*N+0][0] += J[d,i,j,0]
          priorities[i*N*N+j*N+0][1] -= J[d,i,j,0]
        else:
          priorities[i*N*N+j*N+0][0] -= J[d,i,j,0]
          priorities[i*N*N+j*N+0][1] = -J[d,i,j,0]

  return(priorities)


#score: {'data3D.txt': -0.3386630000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
          for d in [0,1,2]:
            neighbor_spins = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]]
            abs_diff = sum(1 if val < 0 else -1 for val in neighbor_spins)
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.abs(abs_diff) / 2)
            priorities[i*N*N+j*N+k][1] -= abs_diff
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.4119278000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
          for d in [0,1,2]:
            neighbor_spins = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]]
            abs_diff = sum(1 if val < 0 else -1 for val in neighbor_spins)
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * abs_diff
            priorities[i*N*N+j*N+k][1] -= 2 * total_spin + 2 * abs_diff
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.39975420000000045}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.exp(-abs(total_spin))
          priority_total += abs(sum(val < 0 for val in interacting_spins) / len(interacting_spins))
          priorities[i*N*N+j*N+k][0] += 2 * priority_total
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priority_total = np.exp(abs(total_spin))
          priority_total += abs(sum(val > 0 for val in interacting_spins) / len(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= 2 * priority_total
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  return(priorities)


#score: {'data3D.txt': 0.065287}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_bias = np.tanh(abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # New addition: Calculate the absolute difference between neighboring spins
        for d in [0,1,2]:
          neighbor_spins = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]]
          abs_diff = sum(1 if val < 0 else -1 for val in neighbor_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * abs_diff
          priorities[i*N*N+j*N+k][1] -= abs_diff
        
        # New addition: Calculate the absolute difference between spins and its nearest neighbors
        for d in [0,1,2]:
          neighbor_spins = [J[d,(i+1)%N,j,k], J[d,i,(j+1)%N,k], J[d,i,j,(k+1)%N]]
          abs_diff = sum(1 if val < 0 else -1 for val in neighbor_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * abs_diff
          priorities[i*N*N+j*N+k][1] -= abs_diff
        
  return(priorities)


#score: {'data3D.txt': -0.28679700000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
        
        # Calculate the magnetism coefficient based on the site interaction and total spin
        magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in interacting_spins if val < 0) > N/2))
        
        # Update the priorities with the magnetism coefficient
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.33059619999999973}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(total_spin) * len([val for val in interacting_spins if val < 0])
          priority_down = np.exp(-total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0])
          priority_down = np.exp(total_spin) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)


#score: {'data3D.txt': -0.33059619999999973}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_down = np.exp(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.43768500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.43768500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.198153}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_momentum = -total_spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_momentum
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_momentum = -total_spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_momentum
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.042572999999999944}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(J[:,i,j,k])) / max(np.sum(np.abs(interacting_spins)), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(J[:,i,j,k])) / max(np.sum(np.abs(interacting_spins)), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          if sum([val for val in interacting_spins if val < 0]) == 3:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          elif sum([val for val in interacting_spins if val > 0]) == 3:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          if sum([val for val in interacting_spins if val < 0]) == 3:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          elif sum([val for val in interacting_spins if val > 0]) == 3:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.34328219999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        # Calculate site interactions along the x, y, and z axes
        for d in range(3):
          site_nbr_x = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr_x][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          if h[i][site_nbr_y][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          site_nbr_z = (k + ((d-1)%2 - 1)) % N
          if h[i][j][site_nbr_z] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * (total_spin <= 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        # Adjust priority for edge or corner sites
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] *= 2
          priorities[i*N*N+j*N+k][1] *= 2
  return(priorities)


#score: {'data3D.txt': -0.11773940000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spins = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spins[i*N*N+j*N+k][0] += 1
          total_spins[i*N*N+j*N+k][1] -= 1
          
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += hamming_distance > 0.5
          priorities[i*N*N+j*N+k][1] -= total_spin
          
        else:
          total_spins[i*N*N+j*N+k][0] -= 1
          total_spins[i*N*N+j*N+k][1] += 1
          
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= hamming_distance < 0.5
          priorities[i*N*N+j*N+k][1] += total_spin
          
  return priorities


#score: {'data3D.txt': -0.5054514}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.3319366}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2848050000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(total_spin) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(total_spin) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate the priority for the site and its neighbors
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2569514000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * (total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)))
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * (total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)))
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.2540862000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + hamming_distance * abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + hamming_distance * abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.38553980000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        total_magnetism = abs(h[i][j][k])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  return(priorities)


#score: {'data3D.txt': -0.4018386}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.3747754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # Additional term to favor aligning spins with global magnetization
        global_spin = sum(sum(h[i][j][k] for j in range(N)) for i in range(N))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (global_spin / N**2))
        else:
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin) * (global_spin / N**2))

  return(priorities)


#score: {'data3D.txt': -0.41981260000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in neighbor_spins) / len(neighbor_spins)))
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= neighbor_magnetism_coeff

        # Additional term to favor aligning spins with the global magnetization
        global_spin = sum(h[d][i][j] for d in [0,1,2])
        if global_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * abs(global_spin))
        elif global_spin < 0:
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * abs(global_spin))

  return(priorities)


#score: {'data3D.txt': -0.10292699999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= 2 * magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.48630060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(1 for val in neighbor_spins) / len(neighbor_spins)))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * (sum(1 for val in neighbor_spins) / len(neighbor_spins)))

  return(priorities)


#score: {'data3D.txt': -0.439019}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.05793659999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

  return(priorities)


#score: {'data3D.txt': -0.323191}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.07012379999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        # Add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_x,k]

        for d in range(3):
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_y]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_y]

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2907322}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          elif any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          elif any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.1263145999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] -= 2
          elif any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          if all(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
            priorities[i*N*N+j*N+k][1] += 2
          elif any(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.323191}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.26691099999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.15712620000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = [total_spin+1, -total_spin-1]
        else:
          priority_total = [-total_spin-1, total_spin+1]

        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

        for d in range(3):
          site_nbr_z = (i + ((k-1)%2 - 1)) % N
          priority_total[0] += J[d,i,j,site_nbr_z]
          priority_total[1] -= J[d,i,j,site_nbr_z]

        priorities[i*N*N+j*N+k][0] = priority_total[0] * magnetism_coeff
        priorities[i*N*N+j*N+k][1] = priority_total[1] * magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.06568619999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

        # add interaction with neighboring sites in x and y directions
        for d in range(3):
          site_nbr_x = (i + ((j-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_y]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_y]

  return(priorities)


#score: {'data3D.txt': -0.10645220000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 3 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 3 * (hamming_distance > 0.5)

  return(priorities)


#score: {'data3D.txt': -0.14215580000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif hamming_distance > 0.7:
            priorities[i*N*N+j*N+k][0] += np.exp(-2*total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif hamming_distance > 0.7:
            priorities[i*N*N+j*N+k][0] -= np.exp(-2*total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site's priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner or hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner or hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.4541026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.2890062}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization, hamming distance and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Add neighbor's priority based on hamming distance and site's magnetization
          if i < N-1:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[(i+1)%N][j][k]
            priorities[i*N*N+j*N+k][1] -= 1 - J[2,i,j,k]

          if j < N-1:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[i][(j+1)%N][k]
            priorities[i*N*N+j*N+k][1] -= 1 - J[1,i,j,k]

          if k < N-1:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[i][j][(k+1)%N]
            priorities[i*N*N+j*N+k][1] -= 1 - J[2,i,j,k]

        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization, hamming distance and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Add neighbor's priority based on hamming distance and site's magnetization
          if i < N-1:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[(i+1)%N][j][k]
            priorities[i*N*N+j*N+k][1] = -1 + J[2,i,j,k]

          if j < N-1:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[i][(j+1)%N][k]
            priorities[i*N*N+j*N+k][1] = -1 + J[1,i,j,k]

          if k < N-1:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[i][j][(k+1)%N]
            priorities[i*N*N+j*N+k][1] = -1 + J[2,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.159341}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization, its neighbors and the sum of interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - abs(total_spin)
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization, its neighbors and the sum of interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * total_spin
          priorities[i*N*N+j*N+k][1] = -2 + abs(total_spin)
          
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0,1,2]:
          for x in [(i-1)%N,i,(i+1)%N]:
            for y in [(j-1)%N,j,(j+1)%N]:
              for z in [(k-1)%N,k,(k+1)%N]:
                interacting_spins.append(J[d,x,y,z])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.027264599999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  # Additional term to favor aligning spins with the global magnetism
  global_magnetism = sum(sum(h[i][j]) for i in range(N) for j in range(N))
  if global_magnetism > 0:
    priorities[:, 0] += np.exp(-abs(global_magnetism))
  else:
    priorities[:, 1] -= np.exp(abs(global_magnetism))

  return(priorities)


#score: {'data3D.txt': -0.23820460000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(total_spin) * sum(1 for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.09877419999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.13732300000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += priority_total[0] + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= priority_total[0] + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.002077400000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

        # add interaction with sites in x and y directions
        for d in range(2):
          site_nbr_xy = (i + ((k-1)%2 - 1)) % N
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_xy,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_xy,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_xy]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_xy]

  return(priorities)


#score: {'data3D.txt': 0.12856740000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

        for d in range(3):
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.2536018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][1] += 1 - total_spin

  return(priorities)


#score: {'data3D.txt': 0.24094220000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([np.exp(abs(J[d,i,j,k])) * J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][1] -= np.sum([np.exp(-abs(J[d,i,j,k])) * (J[d,i,j,k] + 1) for d in range(6) if J[d,i,j,k] > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([np.exp(abs(J[d,i,j,k])) * J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][1] += np.sum([np.exp(-abs(J[d,i,j,k])) * (J[d,i,j,k] + 1) for d in range(6) if J[d,i,j,k] > 0])
  return(priorities)


#score: {'data3D.txt': -0.36553019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.06568619999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
        
        # add interaction with neighboring sites in x and y directions
        for d in range(3):
          site_nbr_x = (i + ((j-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_y]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_y]
        
  return(priorities)


#score: {'data3D.txt': 0.004517400000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
        
        # add interaction with neighboring sites in x and y directions
        for d in range(3):
          site_nbr_x = (i + ((j-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_y]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_y]
        
        # add interaction with diagonal neighboring sites
        for d in range(3):
          site_nbr_x = (i + ((j-1)%2 - 1)) % N
          site_nbr_y = (k + ((j-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_x,k]
          priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_y]
          priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_y]
        
  return(priorities)


#score: {'data3D.txt': 0.06323780000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]
        
        # add interaction with sites in x and y directions
        for d in range(2):
          site_nbr_xy = (i + ((k-1)%2 - 1)) % N
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_xy,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_xy,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_xy]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_xy]

        # add interaction with sites in z direction
        for d in range(3):
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[2,i,j,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[2,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.01873379999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

        # add interaction with sites in x and y directions
        for d in range(2):
          site_nbr_xy = (i + ((k-1)%2 - 1)) % N
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_xy,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_xy,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_xy]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_xy]

        # add interaction with sites in z direction
        for d in range(2):
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[3,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[3,i,j,site_nbr_z]
          else:
            priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[3,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.018848199999999978}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]
          elif d == 1:
            priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_y,k]
          else:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_x]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_x]

  return(priorities)


#score: {'data3D.txt': -0.43768500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.36753539999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N].sum() > 0:
      for j in range(N):
        site_nbr = (j % N + ((i+N*N-j-1)%2 - 1)) % N
        if h[site_nbr][j].sum() > 0:
          priorities[i*N*N+j][0] += len([val for val in h[site_nbr][j] if val > 0]) / max(len(h[site_nbr][j]), 1)
          priorities[i*N*N+j][1] -= 1 - np.sum(h[site_nbr][j])
        else:
          priorities[i*N*N+j][0] -= len([val for val in h[site_nbr][j] if val < 0]) / max(len(h[site_nbr][j]), 1)
          priorities[i*N*N+j][1] = -1 + np.sum(h[site_nbr][j])
          
  return(priorities)


#score: {'data3D.txt': -0.003601}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  # Add additional priority based on neighboring sites
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(priorities[site_nbr*N*N:(site_nbr+1)*N*N], axis=(0,1))
          priorities[i*N*N+j*N+k][1] -= 2 * (np.sum(priorities[site_nbr*N*N:(site_nbr+1)*N*N], axis=(0,1)).sum())
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(priorities[site_nbr*N*N:(site_nbr+1)*N*N], axis=(0,1))
          priorities[i*N*N+j*N+k][1] = -2 * (np.sum(priorities[site_nbr*N*N:(site_nbr+1)*N*N], axis=(0,1)).sum())
  
  return(priorities)


#score: {'data3D.txt': -0.26515819999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val < 0]) > N//2:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val > 0]) > N//2:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.026632999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

        for d in range(3):
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[3,i,j,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[3,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.0472294}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (k + ((i-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        for d in range(3):
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]
          
          priorities[i*N*N+j*N+k][0] += J[3,i,j,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[3,i,j,site_nbr_z]
  
  return(priorities)


#score: {'data3D.txt': 0.036435}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

        for d in range(3):
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[3,i,j,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[3,i,j,site_nbr_z]

        for d in range(3):
          site_nbr_xy = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_xy,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_xy,j,k]

  return(priorities)


#score: {'data3D.txt': -0.32628020000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins_negative = [spin for spin in interacting_spins if spin < 0]
          interacting_spins_positive = [spin for spin in interacting_spins if spin > 0]
          priority_coeff = np.sum([np.exp(-abs(spin)) * spin for spin in interacting_spins_negative]) + np.sum([np.exp(abs(spin)) * (spin + 1) for spin in interacting_spins_positive])
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          interacting_spins_negative = [spin for spin in interacting_spins if spin < 0]
          interacting_spins_positive = [spin for spin in interacting_spins if spin > 0]
          priority_coeff = np.sum([np.exp(-abs(spin)) * (spin + 1) for spin in interacting_spins_negative]) + np.sum([np.exp(abs(spin)) * spin for spin in interacting_spins_positive])
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.26515819999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val < 0]) > N//2:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val > 0]) > N//2:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  # Add some more advanced logic here to further improve the algorithm.
  return(priorities)


#score: {'data3D.txt': 0.18449220000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([np.exp(abs(J[d,i,j,k])) * J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= np.sum([np.exp(-abs(J[d,i,j,k])) * (J[d,i,j,k] + 1) for d in range(6) if J[d,i,j,k] > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([np.exp(abs(J[d,i,j,k])) * J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += np.sum([np.exp(-abs(J[d,i,j,k])) * (J[d,i,j,k] + 1) for d in range(6) if J[d,i,j,k] > 0])
  return(priorities)


#score: {'data3D.txt': -0.4918754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,site_nbr_x,j,k] for site_nbr_x in [(i + ((k-1)%2 - 1)) % N]]
        interacting_spins_y = [J[1,i,site_nbr_y,k] for site_nbr_y in [(j + ((k-1)%2 - 1)) % N]]
        interacting_spins_z = [J[2,i,j,site_nbr_z] for site_nbr_z in [(k + ((i-1)%2 - 1)) % N]]
        
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin_x + total_spin_y + total_spin_z))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - (total_spin_x + total_spin_y + total_spin_z)
        else:
          magnetism_coeff = np.exp(-abs(total_spin_x + total_spin_y + total_spin_z))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + (total_spin_x + total_spin_y + total_spin_z)
        
  return(priorities)


#score: {'data3D.txt': 0.044923000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]
          
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[2,i,site_nbr_y,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[2,i,site_nbr_y,site_nbr_z]
          elif d == 1:
            priorities[i*N*N+j*N+k][0] += J[1,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[1,i,j,site_nbr_z]
          else:
            priorities[i*N*N+j*N+k][0] += J[0,i,site_nbr_x,site_nbr_y]
            priorities[i*N*N+j*N+k][1] -= J[0,i,site_nbr_x,site_nbr_y]

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
        hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len(interacting_spins) / 2))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len(interacting_spins) / 2))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.005399000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,i%N,int(np.floor(i/N))][int((i+1)%N)] 
               for d in range(6)]
    
    total_spin = sum(interacting_spins)
    
    if h[site_nbr][int(np.floor(i/N))][int((i+1)%N)] > 0:
      priority_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
      
      priorities[i][0] += magnetism_coeff
      priorities[i][1] -= 1 - total_spin
    else:
      priority_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
      
      priorities[i][0] -= magnetism_coeff
      priorities[i][1] = -1 + total_spin
  
  for i in range(N):
    site_nbr = i
    interacting_spins = [J[d,i,N-1][N-1] for d in range(6)]
    
    total_spin = sum(interacting_spins)
    
    if h[i][0][2] > 0:
      priority_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
      
      priorities[i*N**2:N*(i+1)*N**2].sum(axis=0)[0] += magnetism_coeff
      priorities[i*N**2:N*(i+1)*N**2].sum(axis=0)[1] -= 1 - total_spin
    else:
      priority_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
      
      priorities[i*N**2:N*(i+1)*N**2].sum(axis=0)[0] -= magnetism_coeff
      priorities[i*N**2:N*(i+1)*N**2].sum(axis=0)[1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.4018386}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr1 = (i + ((k-1)%2 - 1)) % N
        site_nbr2 = (j + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.36553019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) * (total_spin > 0))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) * (total_spin < 0))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37679219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2890062}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

          # Adjust priority based on site's magnetization, hamming distance and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

          # Add neighbor's priority based on hamming distance and site's magnetization
          if i < N-1:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[(i+1)%N][j][k]
            priorities[i*N*N+j*N+k][1] -= 1 - J[2,i,j,k]

          if j < N-1:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[i][(j+1)%N][k]
            priorities[i*N*N+j*N+k][1] -= 1 - J[1,i,j,k]

          if k < N-1:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[i][j][(k+1)%N]
            priorities[i*N*N+j*N+k][1] -= 1 - J[2,i,j,k]

        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

          # Adjust priority based on site's magnetization, hamming distance and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

          # Add neighbor's priority based on hamming distance and site's magnetization
          if i < N-1:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[(i+1)%N][j][k]
            priorities[i*N*N+j*N+k][1] = -1 + J[2,i,j,k]

          if j < N-1:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[i][(j+1)%N][k]
            priorities[i*N*N+j*N+k][1] = -1 + J[1,i,j,k]

          if k < N-1:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[i][j][(k+1)%N]
            priorities[i*N*N+j*N+k][1] = -1 + J[2,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val < 0]) > N//2:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val > 0]) > N//2:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin

        for d in range(3):
          site_nbr_x = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr_x][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          if h[i][site_nbr_y][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          site_nbr_z = (k + ((d-1)%2 - 1)) % N
          if h[i][j][site_nbr_z] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.15750419999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val < 0]) > N//2:
            priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val > 0]) > N//2:
            priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin

  return(priorities)


#score: {'data3D.txt': -0.23355700000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val < 0]) > N//2:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          if len([val for val in interacting_spins if val > 0]) > N//2:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr_x = (i + ((0-1)%2 - 1)) % N
        if h[site_nbr_x][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr_y = (j + ((0-1)%2 - 1)) % N
        if h[i][site_nbr_y][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr_z = (k + ((0-1)%2 - 1)) % N
        if h[i][j][site_nbr_z] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr_x][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          if h[i][site_nbr_y][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        for d in range(3):
          site_nbr_z = (k + ((d-1)%2 - 1)) % N
          if h[i][j][site_nbr_z] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] = -1

        # Additional priority for the site's current state (up or down)
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4083186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.26515819999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          elif any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          elif any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.19980179999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.4083186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          if total_spin > 0.5:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          if total_spin < -0.5:
            priorities[i*N*N+j*N+k][0] -= priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += priority_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.15751820000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == 0) | (j == 0) | (k == 0):
            priorities[i*N*N+j*N+k][0] *= 2
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == N-1) | (j == N-1) | (k == N-1):
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == 0 and j > N//2) or (j == 0 and i > N//2) or (k == 0):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == N-1 and j > N//2) or (j == N-1 and i > N//2) or (k == N-1):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.1558530000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if i == 0:
            priorities[i*N*N+j*N+k][0] *= 3
          elif j == 0:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif k == 0:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if i == N-1:
            priorities[i*N*N+j*N+k][0] *= 3
          elif j == N-1:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif k == N-1:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.0005241999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate the probability of flipping each spin based on its interaction with its neighbors and its own magnetization
        flip_prob = hamming_distance * total_spin + magnetism_coeff
        
        # If the site is at an edge or corner, adjust the flip probability accordingly
        if is_edge_or_corner:
          flip_prob *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        priorities[i*N*N+j*N+k][0] += flip_prob
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        
  return(priorities)


#score: {'data3D.txt': 0.0004966000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  total_spin = np.zeros(2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
        
      for d in range(2):
        priorities[i*N*N+j*N+k][d] = total_spin[d]
        
  return(priorities)


#score: {'data3D.txt': -0.0071154000000000234}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_priority
          total_spin = (total_spin + 2) / 4
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_priority
          total_spin = (total_spin - 2) / 4
        
        if i > 0:
          site_nbr = (i-1)%N
        else:
          site_nbr = N-1
          
        for d in range(3):
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
          else:
            total_spin -= J[d,site_nbr,j,k]
        
        priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.1243706}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        h_nbrs = [h[site_nbrs[0],j,k], h[i,site_nbrs[1],k], h[i,j,site_nbrs[2]]]
        
        if all(h_nbr > 0 for h_nbr in h_nbrs):
          total_spin += sum(h_nbrs)
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * spin_priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        elif all(h_nbr < 0 for h_nbr in h_nbrs):
          total_spin -= sum(h_nbrs)
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * spin_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0028245999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        
        if h[i][j][k] > 0:
          priority_total = [total_spin, -1 - total_spin]
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in priority_total])
          priorities[i*N*N+j*N+k][1] -= np.max(priority_total)
        else:
          priority_total = [-total_spin, 1 + total_spin]
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in priority_total])
          priorities[i*N*N+j*N+k][1] += np.min(priority_total)
  
  return(priorities)


#score: {'data3D.txt': -0.1706982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          magnetism_coeff = np.exp(-abs(total_spin)) * (1 + spin_priority / abs(spin_priority))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          
        else:
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          magnetism_coeff = np.exp(-abs(total_spin)) * (1 + spin_priority / abs(spin_priority))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([np.sign(val) * abs(val) ** 0.5 for val in interacting_spins])
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([np.sign(val) * abs(val) ** 0.5 for val in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.0004966000000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin = np.zeros(2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
        
      for d in range(2):
        priorities[i*N*N+j*N+k][d] = total_spin[d]
      
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.0729086}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.17622140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        if k < N//2:
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.1789982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          site_nbr_z = (site_nbr_x + ((site_nbr_y-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.23300820000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        if k < N//2:
          # add interaction with neighboring sites in z-direction
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  # add interaction with neighboring sites in x and y directions
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if i < N//2:
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[0,i,j,site_nbr_x]
          priorities[i*N*N+j*N+k][1] -= J[0,i,j,site_nbr_x]

        if j < N//2:
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[1,i,j,site_nbr_y]
          priorities[i*N*N+j*N+k][1] -= J[1,i,j,site_nbr_y]

  return(priorities)


#score: {'data3D.txt': -0.4308538}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.30462900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] += priority_coeff * total_spin
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= priority_coeff * total_spin
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] -= priority_coeff * total_spin
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += priority_coeff * total_spin
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.12671100000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Check the majority of spins on each side along the diagonal
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Check the majority of spins on each side along the diagonal
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return priorities


#score: {'data3D.txt': -0.19980179999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        else:
          priority_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          # Check the majority of spins on each side
          for d in range(6):
            site_nbr = (i + ((k-1)%2 - 1)) % N
            side_spin = sum(J[d,i,j,k] for k in range(N))
            if side_spin > 0:
              priorities[i*N*N+j*N+k][0] -= priority_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += priority_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.37679219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] += 4 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] -= 4 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.37679219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2660294}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] += 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          
        else:
          priority_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = (hamming_distance > 0.5) * priority_coeff
          
          priorities[i*N*N+j*N+k][0] -= 2 * magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        for d in range(6):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
            priorities[i*N*N+j*N+k][1] -= abs(J[d,i,j,k])
  
  return(priorities)


#score: {'data3D.txt': -0.325157}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.006960200000000302}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] += 2
        
        # Additional term to account for magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]])) + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]])) + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.026109399999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_spin = sum(interacting_spins) + h[i][j][k]
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))
          priorities[i*N*N+j*N+k][1] += 2
        
  # Additional improvements to the algorithm
  site_interactions = []
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins) + h[i][j][k]
        site_interactions.append((total_spin, np.sum(np.array([[1, -1], [-1, 1]]) * np.array([J[d,i,j,k] for d in [3,4]]))))
  
  sorted_sites = sorted(site_interactions, reverse=True)
  for i in range(N**3):
    site_spin, interaction = sorted_sites[i]
    if site_spin > 0:
      priorities[i][1] -= 2
    else:
      priorities[i][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.4375122}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2,4,5]]
        
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.1706982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          magnetism_coeff = np.exp(-abs(total_spin)) * (1 + spin_priority / abs(spin_priority))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          
        else:
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          magnetism_coeff = np.exp(-abs(total_spin)) * (1 + spin_priority / abs(spin_priority))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3807718}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Increase priority when site has high magnetism and low hamming distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 * sum(1 for val in interacting_spins if val < 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          # Decrease priority when site has high magnetism and high hamming distance
          elif h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 * sum(1 for val in interacting_spins if val < 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          
          # Increase priority when site has low magnetism and high hamming distance
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff / 2 * sum(1 for val in interacting_spins if val > 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.377101}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Increase priority when site has high magnetism and low hamming distance
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 * (total_spin > 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Decrease priority when site has high magnetism and high hamming distance
          elif h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 * (total_spin < 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Increase priority when site has low magnetism and high hamming distance
          if h[site_nbr][j][k] < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff / 2 * (total_spin > 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.5048918000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          
          # Increase priority when site has high magnetism and low hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          
          # Increase priority when site has low magnetism and high hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff / 2
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.10769699999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          spin_bias = np.tanh(abs(total_spin))
          site_magnetism = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (2*total_spin - site_magnetism)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          spin_bias = -np.tanh(-abs(total_spin))
          site_magnetism = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (2*total_spin - site_magnetism)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.08509420000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          site_magnetism = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + (2*total_spin - site_magnetism)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          magnetism_coeff = np.exp(abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          site_magnetism = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + (2*total_spin - site_magnetism)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.159495}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          spin_bias = np.tanh(abs(total_spin))
          site_magnetism = h[site_nbr][j][k]
          neighbor_sum = sum(J[d,(i+1)%N,j,k] for d in [0,1,2]) + sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias + (total_spin - site_magnetism) + (neighbor_sum / 6)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          spin_bias = -np.tanh(-abs(total_spin))
          site_magnetism = h[site_nbr][j][k]
          neighbor_sum = sum(J[d,(i+1)%N,j,k] for d in [0,1,2]) + sum(J[d,i,(j+1)%N,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias + (total_spin - site_magnetism) + (neighbor_sum / 6)
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': 0.056199400000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          for dd in range(3):
            if d == 0:
              if dd == 0:
                priorities[i*N*N+j*N+k][0] += J[0,site_nbr_x,j,k]
                priorities[i*N*N+j*N+k][1] -= J[0,site_nbr_x,j,k]
              elif dd == 1:
                priorities[i*N*N+j*N+k][0] += J[2,i,site_nbr_y,site_nbr_z]
                priorities[i*N*N+j*N+k][1] -= J[2,i,site_nbr_y,site_nbr_z]
              else:
                priorities[i*N*N+j*N+k][0] += J[1,(i+1)%N,j,k]
                priorities[i*N*N+j*N+k][1] -= J[1,(i+1)%N,j,k]
            elif d == 1:
              if dd == 0:
                priorities[i*N*N+j*N+k][0] += J[2,i,site_nbr_x,site_nbr_y]
                priorities[i*N*N+j*N+k][1] -= J[2,i,site_nbr_x,site_nbr_y]
              elif dd == 1:
                priorities[i*N*N+j*N+k][0] += J[1,i,j,site_nbr_z]
                priorities[i*N*N+j*N+k][1] -= J[1,i,j,site_nbr_z]
              else:
                priorities[i*N*N+j*N+k][0] += J[0,i,site_nbr_x,site_nbr_y]
                priorities[i*N*N+j*N+k][1] -= J[0,i,site_nbr_x,site_nbr_y]
            else:
              if dd == 0:
                priorities[i*N*N+j*N+k][0] += J[2,i,j,k]
                priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
              elif dd == 1:
                priorities[i*N*N+j*N+k][0] += J[1,i,site_nbr_x,site_nbr_y]
                priorities[i*N*N+j*N+k][1] -= J[1,i,site_nbr_x,site_nbr_y]
              else:
                priorities[i*N*N+j*N+k][0] += J[0,site_nbr_x,j,k]
                priorities[i*N*N+j*N+k][1] -= J[0,site_nbr_x,j,k]

  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_map = np.zeros((N, N, N, 2), dtype=int)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # update total spin map for neighboring sites
        total_spin_map[i,j,k,0] += J[0,i,j,k]
        total_spin_map[i,j,k,1] -= J[0,i,j,k]

  return priorities


#score: {'data3D.txt': -0.09930340000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          if d == 0:
            site_nbr_x = i
            site_nbr_y = j
            site_nbr_z = k
          elif d == 1:
            site_nbr_x = (i+1)%N if i < N-1 else 0
            site_nbr_y = j
            site_nbr_z = k
          else:
            site_nbr_x = i
            site_nbr_y = (j+1)%N if j < N-1 else 0
            site_nbr_z = k

          for dd in range(3):
            if dd == 0:
              priorities[i*N*N+j*N+k][0] += J[0,site_nbr_x,j,k]
              priorities[i*N*N+j*N+k][1] -= J[0,site_nbr_x,j,k]
            elif dd == 1:
              priorities[i*N*N+j*N+k][0] += J[2,i,site_nbr_y,site_nbr_z]
              priorities[i*N*N+j*N+k][1] -= J[2,i,site_nbr_y,site_nbr_z]
            else:
              priorities[i*N*N+j*N+k][0] += J[1,(i+1)%N,j,k]
              priorities[i*N*N+j*N+k][1] -= J[1,(i+1)%N,j,k]

  return priorities


#score: {'data3D.txt': -0.031971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          if d == 0:
            site_nbr_x = i
            site_nbr_y = j
            site_nbr_z = k
          elif d == 1:
            site_nbr_x = (i+1)%N
            site_nbr_y = j
            site_nbr_z = k
          else:
            site_nbr_x = i
            site_nbr_y = (j+1)%N
            site_nbr_z = k

          for dd in range(3):
            if dd == 0:
              priorities[i*N*N+j*N+k][0] += J[0,site_nbr_x,site_nbr_y,site_nbr_z]
              priorities[i*N*N+j*N+k][1] -= J[0,site_nbr_x,site_nbr_y,site_nbr_z]
            elif dd == 1:
              priorities[i*N*N+j*N+k][0] += J[2,i,site_nbr_x,site_nbr_z]
              priorities[i*N*N+j*N+k][1] -= J[2,i,site_nbr_x,site_nbr_z]
            else:
              priorities[i*N*N+j*N+k][0] += J[1,(i+1)%N,j,k]
              priorities[i*N*N+j*N+k][1] -= J[1,(i+1)%N,j,k]

  return priorities


#score: {'data3D.txt': -0.2672210000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] = 1 + total_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] = -1 + total_spin
          priorities[i*N*N+j*N+k][1] = 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.11450980000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
            
  return(priorities)


#score: {'data3D.txt': 0.03718900000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 - total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 - total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 - total_spin
            priorities[i*N*N+j*N+k][1] = 1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1426186}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        total_spin = sum(interacting_spins)
        
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        h_nbrs = [h[site_nbrs[0],j,k], h[i,site_nbrs[1],k], h[i,j,site_nbrs[2]]]
        
        if all(h_nbr > 0 for h_nbr in h_nbrs):
          total_spin += sum(h_nbrs)
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * spin_priority
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        elif all(h_nbr < 0 for h_nbr in h_nbrs):
          total_spin -= sum(h_nbrs)
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * spin_priority
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.27523339999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          if total_spin >= 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          if total_spin <= 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.1243706}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [(i+1)%N, (j+1)%N, (k+1)%N]
        
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        h_nbrs = [h[site_nbrs[0],j,k], h[i,site_nbrs[1],k], h[i,j,site_nbrs[2]]]
        
        if all(h_nbr > 0 for h_nbr in h_nbrs):
          total_spin += sum(h_nbrs)
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * spin_priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        elif all(h_nbr < 0 for h_nbr in h_nbrs):
          total_spin -= sum(h_nbrs)
          spin_priority = np.sum([np.sign(val) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * spin_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.018677000000000235}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(-total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          priority_up = np.exp(-total_spin) * sum(1 for val in interacting_spins if val < 0)
          priority_down = np.exp(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down
        
        # Calculate the magnetism coefficient based on the site interaction and total spin
        magnetism_coeff = np.exp(-abs(total_spin) * (sum(1 for val in interacting_spins if val < 0) / len(interacting_spins)))
        
        # Update the priorities with the magnetism coefficient
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_up
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - priority_down
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + priority_up
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - priority_down
  
  return(priorities)


#score: {'data3D.txt': 0.0534498}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = magnetism_coeff * (total_spin > 0)
          priority_down = -magnetism_coeff
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
        
        # Calculate the site interaction with nearest neighbors
        neighbor_interactions = []
        if i > 0:
          neighbor_interactions.append(J[1, i-1, j, k])
        if i < N-1:
          neighbor_interactions.append(J[1, i+1, j, k])
        if j > 0:
          neighbor_interactions.append(J[2, i, j-1, k])
        if j < N-1:
          neighbor_interactions.append(J[2, i, j+1, k])
        if k > 0:
          neighbor_interactions.append(J[0, i, j, k-1])
        if k < N-1:
          neighbor_interactions.append(J[0, i, j, k+1])
        
        # Update the priorities based on the site interaction and total spin
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_up + sum(1 for val in neighbor_interactions if val < 0)
          priorities[i*N*N+j*N+k][1] -= priority_down - sum(1 for val in neighbor_interactions if val > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= priority_up + sum(1 for val in neighbor_interactions if val < 0)
          priorities[i*N*N+j*N+k][1] += priority_down - sum(1 for val in neighbor_interactions if val > 0)
        
  return(priorities)


#score: {'data3D.txt': 0.4329270000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = magnetism_coeff * (total_spin > 0)
          priority_down = -magnetism_coeff
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (sum(val > 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -magnetism_coeff
          priority_down = magnetism_coeff
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] -= priority_down
  
  return(priorities)


#score: {'data3D.txt': -0.15839260000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          edge_penalty = int((i == 0) | (j == 0) | (k == 0)) + int((i == N-1) | (j == N-1) | (k == N-1))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * sum(1 for val in interacting_spins if val < 0) + edge_penalty
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          edge_penalty = int((i == 0) | (j == 0) | (k == 0)) + int((i == N-1) | (j == N-1) | (k == N-1))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * sum(1 for val in interacting_spins if val > 0) + edge_penalty
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.1451826000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == 0) | (j == 0) | (k == 0):
            priorities[i*N*N+j*N+k][0] *= 3
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == N-1) | (j == N-1) | (k == N-1):
            priorities[i*N*N+j*N+k][0] *= 3
  
  return(priorities)


#score: {'data3D.txt': -0.5054514}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.19110539999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / len(interacting_spins)))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20950899999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20950899999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            total_spin += J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] += 1 + total_spin
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            total_spin -= J[d,site_nbr,j,k]
            priorities[i*N*N+j*N+k][0] -= 1 + total_spin
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34025300000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          site_nbr_z = (site_nbr_x + ((site_nbr_y-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,site_nbr_z]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,site_nbr_z]

        for d in [0,1,2]:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.1753150000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (site_nbr_x + ((site_nbr_y-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          if h[site_nbr_x][site_nbr_y][0] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] = -J[d,site_nbr_x,site_nbr_y,k]

  return(priorities)


#score: {'data3D.txt': -0.3366685999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([np.exp(-abs(J[d,site_nbr_x,site_nbr_y,k])) for d in [0,1,2]])
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([np.exp(abs(J[d,site_nbr_x,site_nbr_y,k])) for d in [0,1,2]])
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.0025302000000000514}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        if h[i][j][k] > 0:
          site_interaction_coeff = max(1 - abs(total_spin), 0)
        else:
          site_interaction_coeff = max(abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
        
  return(priorities)


#score: {'data3D.txt': -0.0032146000000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
        
  return(priorities)


#score: {'data3D.txt': -0.008336999999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        for d in range(3):
          site_nbr_dd = (site_nbr + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += sum(J[e,site_nbr_dd,(j+k)%N,k] for e in [0,1,2])
            priority_total[1] -= sum(J[e,site_nbr_dd,(j+k)%N,k] for e in [0,1,2])
          else:
            priority_total[0] -= sum(J[e,site_nbr_dd,(j+k)%N,k] for e in [0,1,2])
            priority_total[1] = -1 + sum(J[e,site_nbr_dd,(j+k)%N,k] for e in [0,1,2])
        
        priorities[i*N*N+j*N+k][0] += priority_total[0]
        priorities[i*N*N+j*N+k][1] += priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0131154}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

        # Additional term to favor aligning spins with neighboring planes
        plane_spins = [h[i][j][0], h[(i+1)%N][j][0], h[i][(j+1)%N][0]]
        if all(val > 0 for val in plane_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in plane_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  return(priorities)


#score: {'data3D.txt': -0.0557042}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

        # Additional term to favor aligning spins with neighboring planes
        if h[i][j][0] > 0:
          priorities[i*N*N+j*N+0][0] += J[0,i,j,0]
          priorities[i*N*N+j*N+0][1] -= J[0,i,j,0]
        else:
          priorities[i*N*N+j*N+0][0] -= J[0,i,j,0]
          priorities[i*N*N+j*N+0][1] = -J[0,i,j,0]

  return(priorities)


#score: {'data3D.txt': -0.05344379999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_down = -total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_up = -total_spin - sum(1 for val in interacting_spins if val < 0)
          priority_down = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * (priority_up > priority_down) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Additional term to favor aligning spins with neighbors
        neighbor_spins = [h[site_nbr][j][k], h[(i+1)%N][j][k], h[i][(j+1)%N][k]]
        if all(val > 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif any(val < 0 for val in neighbor_spins):
          priorities[i*N*N+j*N+k][1] -= np.exp(abs(total_spin))

  # Additional term to favor aligning spins with neighboring planes
  for d in range(3):
    for i in range(N):
      for j in range(N):
        if h[i][j][0] > 0:
          priorities[i*N*N+j*N+0][0] += J[d,i,j,0]
          priorities[i*N*N+j*N+0][1] -= J[d,i,j,0]
        else:
          priorities[i*N*N+j*N+0][0] -= J[d,i,j,0]
          priorities[i*N*N+j*N+0][1] = -J[d,i,j,0]

  # Additional term to favor aligning spins with neighboring layers
  for i in range(N):
    for j in range(N):
      if h[0][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += J[2,0,j,k]
        priorities[i*N*N+j*N+k][1] -= J[2,0,j,k]
      else:
        priorities[i*N*N+j*N+k][0] -= J[2,0,j,k]
        priorities[i*N*N+j*N+k][1] = -J[2,0,j,k]

  return(priorities)


#score: {'data3D.txt': -0.3820054000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] += total_spin + 2 * priority_up
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin - 2 * priority_up
        else:
          priority_down = np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] -= total_spin + 2 * priority_down
          priorities[i*N*N+j*N+k][1] = -2 + total_spin + 2 * priority_down
  return(priorities)


#score: {'data3D.txt': 0.1273482000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = J[[0,1,2], i%N, j%N, k]
        if h[i][j][k] > 0:
          priority_up = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priority_down = -np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] += total_spin + priority_up
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + priority_down
        else:
          priority_up = -np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priority_down = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] -= total_spin + priority_up
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + priority_down
  return(priorities)


#score: {'data3D.txt': -0.16263580000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priority_down = np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] += total_spin + priority_up
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + priority_down
        else:
          priority_up = np.sum([x*y for x,y in zip(interacting_spins, [1 if v > 0 else 0 for v in interacting_spins])])
          priority_down = np.sum([x*y for x,y in zip(interacting_spins, [1 if v < 0 else 0 for v in interacting_spins])])
          priorities[i*N*N+j*N+k][0] -= total_spin + priority_up
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + priority_down

        # Additional priority based on the magnetism at the site
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.050266600000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= -total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          if d == 0:
            site_nbr_x = (i + ((k-1)%2 - 1)) % N
          elif d == 1:
            site_nbr_y = (j + ((k-1)%2 - 1)) % N
          else:
            site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr,d,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr,d,k]

  return(priorities)


#score: {'data3D.txt': -0.25258860000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          if d == 0:
            site_nbr_y = j
            site_nbr_z = k
          elif d == 1:
            site_nbr_y = (j+1)%N
            site_nbr_z = k
          else:
            site_nbr_x = (i+1)%N
            site_nbr_y = j
            site_nbr_z = k

          if h[site_nbr_x][site_nbr_y][site_nbr_z] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.011191400000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          site_nbr_z = (k + ((i-1)%2 - 1)) % N

          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

          elif d == 1:
            priorities[i*N*N+j*N+k][0] += J[d,i,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr_y,k]

          else:
            priorities[i*N*N+j*N+k][0] += J[3,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[3,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.22201300000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        if k < N//2:
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
  
  return(priorities)


#score: {'data3D.txt': 0.28171019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(h[site_nbr], axis=0)
          priorities[i*N*N+j*N+k][0] += np.sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priority_total = -np.sum(h[site_nbr], axis=0)
          priorities[i*N*N+j*N+k][0] -= np.sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][1] = -total_spin
        if k < N//2:
          site_nbr_z = (i + ((k-1)%2 - 1)) % N
          for d in range(3):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.31808180000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k]]
        interacting_spins_y = [J[1,i,j,k], J[1,i,(j+1)%N,k]]
        interacting_spins_z = [J[2,i,j,k], J[2,i,j,(k+1)%N]]
        
        # calculate total magnetism
        total_spin_x = sum(J[0,i,j,k] for i in [i, (i+1)%N])
        total_spin_y = sum(J[1,i,j,k] for j in [j, (j+1)%N])
        total_spin_z = sum(J[2,i,j,k] for k in [k, (k+1)%N])
        
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((i-1)%2 - 1)) % N
        site_nbr_z = (k + ((j-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff_x = np.exp(-abs(total_spin_x) * (len([val for val in interacting_spins_x if val < 0]) / max(len(interacting_spins_x), 1)))
          magnetism_coeff_y = np.exp(-abs(total_spin_y) * (len([val for val in interacting_spins_y if val < 0]) / max(len(interacting_spins_y), 1)))
          magnetism_coeff_z = np.exp(-abs(total_spin_z) * (len([val for val in interacting_spins_z if val < 0]) / max(len(interacting_spins_z), 1)))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff_x + magnetism_coeff_y + magnetism_coeff_z
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin_x - total_spin_y - total_spin_z
          
        else:
          magnetism_coeff_x = np.exp(-abs(total_spin_x) * (len([val for val in interacting_spins_x if val > 0]) / max(len(interacting_spins_x), 1)))
          magnetism_coeff_y = np.exp(-abs(total_spin_y) * (len([val for val in interacting_spins_y if val > 0]) / max(len(interacting_spins_y), 1)))
          magnetism_coeff_z = np.exp(-abs(total_spin_z) * (len([val for val in interacting_spins_z if val > 0]) / max(len(interacting_spins_z), 1)))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff_x + magnetism_coeff_y + magnetism_coeff_z
          priorities[i*N*N+j*N+k][1] = -1 + total_spin_x + total_spin_y + total_spin_z
          
  return(priorities)


#score: {'data3D.txt': -0.22975900000000032}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2.5 + (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * 2.5 - (total_spin > 0)
          priorities[i*N*N+j*N+k][1] += 1 - total_spin
        
        if k < N//2:
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.2534254000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + (1 - total_spin) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] -= np.abs(total_spin) if total_spin != 0 else 0
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0) + (1 - total_spin) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = np.abs(total_spin) if total_spin != 0 else 0
  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)

        # Calculate magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin / abs(total_spin) - magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.0032146000000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance < 0.5) + site_interaction_coeff - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
        
  return(priorities)


#score: {'data3D.txt': -0.003708600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)

        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))

        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)

        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff

        # Check if the site is at an edge or corner
        is_edge_or_corner = ((i == 0) | (i == N-1)) and ((j == 0) | (j == N-1)) and ((k == 0) | (k == N-1))

        # Adjust priority based on edge or corner
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])

  return(priorities)


#score: {'data3D.txt': 0.0933566}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)

        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

        site_interaction_coeff = max(1 - abs(total_spin), 0)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) - total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff

        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
        elif i == N-1 or j == N-1 or k == N-1:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))

  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + (1 - total_spin) * (total_spin < 0)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= np.sum([np.exp(-abs(val)) for val in interacting_spins])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0) + (1 - total_spin) * (total_spin > 0)
          if total_spin < 0:
            priorities[i*N*N+j*N+k][1] = np.sum([np.exp(-abs(val)) for val in interacting_spins])
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          magnetism_coeff = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.37485219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.3075590000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total[0]
        priorities[i*N*N+j*N+k][1] -= priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.21717180000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
        # Add a term to the priority based on the site magnetism
        priorities[i*N*N+j*N+k][0] += h[i][j][k] * (np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0])
        priorities[i*N*N+j*N+k][1] -= h[i][j][k] * (-priority_total[1])
        
  return(priorities)


#score: {'data3D.txt': -0.27082420000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
        site_magnetism = h[i][j][k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total[0] + site_magnetism
          priorities[i*N*N+j*N+k][1] -= priority_total[1] - site_magnetism
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total[0] + site_magnetism
          priorities[i*N*N+j*N+k][1] = -priority_total[1] - site_magnetism
        
  return(priorities)


#score: {'data3D.txt': -0.3075590000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val < 0 and h[i][j][k] > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val > 0 and h[i][j][k] < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3075590000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_coeff = 0
  magnetism_coeff = 0
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3713610000000003}
program:
def priority(N, h, J):
  def get_messages(i, j, k):
    interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
    total_spin = sum(J[d,i,j,k] for d in [0,1,2])
    hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
    magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
    total_spin_coeff = 1 - abs(total_spin)
    return magnetism_coeff + total_spin_coeff, -1 + total_spin

  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          message_up, message_down = get_messages(i, j, k)
          priorities[i*N*N+j*N+k][0] += message_up + message_down
          priorities[i*N*N+j*N+k][1] -= 1 - (message_up + message_down)
        else:
          message_up, message_down = get_messages(i, j, k)
          priorities[i*N*N+j*N+k][0] -= message_up + message_down
          priorities[i*N*N+j*N+k][1] = -1 + (message_up + message_down)

  return priorities


#score: {'data3D.txt': -0.38343220000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priority_coeff = np.exp(h[i][j][k] * (total_spin > 0)) if h[i][j][k] > 0 else np.exp(-h[i][j][k] * (total_spin < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priority_coeff = np.exp(h[i][j][k] * (total_spin < 0)) if h[i][j][k] < 0 else np.exp(-h[i][j][k] * (total_spin > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.013039400000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2)

  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate edge and corner priority
        edge_or_corner_priority = -np.exp(-2*abs(total_spin))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff + edge_or_corner_priority
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff + edge_or_corner_priority
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == 0 and j > N//2) or (j == 0 and i > N//2) or (k == 0):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif (i == N-1 and j > N//2) or (j == N-1 and i > N//2) or (k == N-1):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == 0 and j > N//2) or (j == 0 and i > N//2) or (k == 0):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          elif (i == N-1 and j > N//2) or (j == N-1 and i > N//2) or (k == N-1):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.16233540000000013}
program:
def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N**3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == 0 and j > N//2) or (j == 0 and i > N//2) or (k == 0):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
          
          # Adjust priority for edge or corner sites
          if (i == N-1 and j > N//2) or (j == N-1 and i > N//2) or (k == N-1):
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.5009866000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Use a more robust priority calculation
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + hamming_distance) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Use a more robust priority calculation
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin - hamming_distance) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.022435400000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2

  return(priorities)


#score: {'data3D.txt': -0.2853202}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Calculate the spin flip energy
        delta_energy = sum(2 * J[d,i,j,k] * h[i][j][k] for d in [0,1,2])

        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * delta_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * delta_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4183938000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.2534254000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_energy = total_spin ** 2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - spin_energy
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_energy = total_spin ** 2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + spin_energy

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val != h[i][j][k]]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          spin_coeff = h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          spin_coeff = -h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.12561500000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 * magnetism_coeff * total_spin_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 * magnetism_coeff * total_spin_coeff

  return(priorities)


#score: {'data3D.txt': -0.29257460000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

        priority_total = np.array([1 - total_spin, 1 + total_spin])
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]

        priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * priority_total[0]
        priorities[i*N*N+j*N+k][1] -= priority_total[1]

  return priorities


#score: {'data3D.txt': -0.27081540000000043}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_magnetism = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr_magnetism][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
  
  return priorities


#score: {'data3D.txt': -0.46268420000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if (i == 0 or i == N-1) or (j == 0 or j == N-1) or (k == 0 or k == N-1):
          # Adjust priority based on boundary conditions
          priorities[i*N*N+j*N+k][0] += 2 * h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 * h[i][j][k]
  
  return priorities


#score: {'data3D.txt': -0.022414999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(6):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          site_nbr_z = (k + ((i-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,j,k]
          priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,j,k]

        # add interaction with sites in x and y directions
        for d in range(2):
          if d == 0:
            site_nbr_xy = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[3,i,site_nbr_xy,k]
            priorities[i*N*N+j*N+k][1] -= J[3,i,site_nbr_xy,k]
          else:
            site_nbr_xy = (j + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[4,i,j,site_nbr_xy]
            priorities[i*N*N+j*N+k][1] -= J[4,i,j,site_nbr_xy]

        # add interaction with sites in z direction
        for d in range(2):
          if d == 0:
            site_nbr_z = (k + ((i-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[5,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,site_nbr_z]
          else:
            site_nbr_z = (k + ((j-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[3,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.1600498}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # add interaction with neighboring sites in x, y and z directions
        for d in range(6):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          site_nbr_z = (k + ((i-1)%2 - 1)) % N

          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[3,site_nbr_x,j,k]
            priorities[i*N*N+j*N+k][1] -= J[3,site_nbr_x,j,k]

          elif d == 1:
            priorities[i*N*N+j*N+k][0] += J[4,i,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[4,i,site_nbr_y,k]

          elif d == 2:
            priorities[i*N*N+j*N+k][0] += J[5,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,site_nbr_z]

        # add interaction with sites in x and y directions
        for d in range(2):
          site_nbr_xy = (i + ((k-1)%2 - 1)) % N

          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[3,i,site_nbr_xy,k]
            priorities[i*N*N+j*N+k][1] -= J[3,i,site_nbr_xy,k]

          else:
            priorities[i*N*N+j*N+k][0] += J[4,i,j,site_nbr_xy]
            priorities[i*N*N+j*N+k][1] -= J[4,i,j,site_nbr_xy]

  return(priorities)


#score: {'data3D.txt': -0.3705242}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + 1
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.08273540000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff + hamming_distance) / 2
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff - hamming_distance) / 2
          priorities[i*N*N+j*N+k][1] = total_spin

  return(priorities)


#score: {'data3D.txt': -0.16202100000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2835858000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / max(abs(total_spin), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) - total_spin / max(abs(total_spin), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.3892034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          total_spin += 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          total_spin -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.38343220000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priority_coeff = np.exp(h[i][j][k] * (total_spin > 0)) if h[i][j][k] > 0 else np.exp(-h[i][j][k] * (total_spin < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priority_coeff = np.exp(h[i][j][k] * (total_spin < 0)) if h[i][j][k] < 0 else np.exp(-h[i][j][k] * (total_spin > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4570274}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

          # Adjust priority based on site's neighbor sites and its interaction
          for d in [0,1,2]:
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[(i+1)%N][j][k]
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            elif J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[(i+1)%N][j][k]
              priorities[i*N*N+j*N+k][1] = -1 + total_spin

        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

          # Adjust priority based on site's neighbor sites and its interaction
          for d in [0,1,2]:
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[(i+1)%N][j][k]
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            elif J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[(i+1)%N][j][k]
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  return(priorities)


#score: {'data3D.txt': -0.4610042}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Prioritize spins based on site interactions and magnetism for edge or corner sites
          if (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1):
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.4634474}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Use a more robust priority calculation
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (total_spin + hamming_distance) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Use a more robust priority calculation
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (total_spin - hamming_distance) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.5141642000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(h[i][j][k] * total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-h[i][j][k] * total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.21107780000000032}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.23608220000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.003036600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])

        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]

        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          for d in range(3):
            if J[d,i,j,k] < 0:
              priority_total[0] += 1
              priority_total[1] -= 1
            elif J[d,i,j,k] > 0:
              priority_total[0] -= 1
              priority_total[1] += 1
        else:
          for d in range(3):
            if J[d,i,j,k] < 0:
              priority_total[0] -= 1
              priority_total[1] += 1
            elif J[d,i,j,k] > 0:
              priority_total[0] += 1
              priority_total[1] -= 1

        priorities[i*N*N+j*N+k][0] = priority_total[0]
        priorities[i*N*N+j*N+k][1] = priority_total[1]

  return(priorities)


#score: {'data3D.txt': -0.13732300000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total[0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][0] = np.sum(np.exp(np.array([-np.abs(total_spin)])) * np.array([[1, -1]]))
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        else:
          priority_total[0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][0] = -np.sum(np.exp(np.array([-np.abs(total_spin)])) * np.array([[1, -1]]))
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.22135100000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin]) * (h[site_nbr][j][k] > 0)
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin]) * (h[site_nbr][j][k] < 0)
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        priorities[i*N*N+j*N+k] = priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.46214459999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priority_total = np.array([magnetism_coeff * h[site_nbr][j][k], -1 + total_spin])
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priority_total = np.array([-magnetism_coeff * h[site_nbr][j][k], -1 + total_spin])

        priorities[i*N*N+j*N+k] = priority_total

  return(priorities)


#score: {'data3D.txt': -0.09081140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add a correction term to prioritize the direction of spin alignment
        if sum(J[d,i,j,k] for d in [0,1,2]) > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.27348619999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          total_spin += h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          total_spin += -h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.tanh(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - spin_energy
        else:
          spin_energy = np.tanh(total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + spin_energy

  return(priorities)


#score: {'data3D.txt': -0.38343220000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priority_coeff = np.exp(h[i][j][k] * (total_spin > 0)) if h[i][j][k] > 0 else np.exp(-h[i][j][k] * (total_spin < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          priority_coeff = np.exp(h[i][j][k] * (total_spin < 0)) if h[i][j][k] < 0 else np.exp(-h[i][j][k] * (total_spin > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.05822059999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.007812200000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.38534219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = 2 * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff + 1)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = 2 * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff - 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.06522860000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.21396860000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + 2*abs(magnetism_coeff)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin - 2*abs(magnetism_coeff)

  return(priorities)


#score: {'data3D.txt': -0.3347334000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*total_spin + 1
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)


#score: {'data3D.txt': -0.33514140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + 2*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + 2*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.12438739999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.22459620000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_coeff = np.exp(-abs(total_spin))
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) * spin_coeff + (1 - total_spin) * (-hamming_distance > 0.5) * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= priority_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_coeff = np.exp(-abs(total_spin))
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) * spin_coeff + (1 - total_spin) * (-hamming_distance > 0.5) * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + priority_coeff

  return(priorities)


#score: {'data3D.txt': -0.2182225999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.030891}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Add the effect of neighboring spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(h[site_nbr:(site_nbr+1),j,k])
          priorities[i*N*N+j*N+k][1] -= np.sum(h[i,site_nbr:(site_nbr+1),k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(h[site_nbr:(site_nbr+1),j,k])
          priorities[i*N*N+j*N+k][1] = -np.sum(h[i,site_nbr:(site_nbr+1),k])

  return(priorities)


#score: {'data3D.txt': -0.2182225999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          site_energy = hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_energy
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          site_energy = hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2182225999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          hamming_magnetism = hamming_distance * magnetism_coeff
          priorities[i*N*N+j*N+k][0] += hamming_magnetism * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          hamming_magnetism = hamming_distance * magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= hamming_magnetism * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.02039939999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val < 0 and h[i][j][k] > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          spin_coeff = h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val > 0 and h[i][j][k] < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          spin_coeff = -h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_coeff = h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_coeff = -h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.1101978}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(6):
          if d == 0:
            site_nbr_xy_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[3,site_nbr_xy_z,j,k]
            priorities[i*N*N+j*N+k][1] -= J[3,site_nbr_xy_z,j,k]

          elif d == 1:
            site_nbr_xy_y = (j + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[4,i,site_nbr_xy_y,k]
            priorities[i*N*N+j*N+k][1] -= J[4,i,site_nbr_xy_y,k]

          elif d == 2:
            site_nbr_xy_x = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[5,i,j,site_nbr_xy_x]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,site_nbr_xy_x]

          elif d == 3:
            site_nbr_y_z = (k + ((i-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[4,i,j,site_nbr_y_z]
            priorities[i*N*N+j*N+k][1] -= J[4,i,j,site_nbr_y_z]

          elif d == 4:
            site_nbr_x_z = (k + ((i-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[3,(i+1)%N,j,site_nbr_x_z]
            priorities[i*N*N+j*N+k][1] -= J[3,(i+1)%N,j,site_nbr_x_z]

          elif d == 5:
            site_nbr_xy_z = (k + ((i-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[5,i,j,site_nbr_xy_z]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,site_nbr_xy_z]

  return(priorities)


#score: {'data3D.txt': -0.11852779999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (k + ((i-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # add interaction with neighboring sites in x, y and z directions
        for d in range(6):
          if d == 0:
            priorities[i*N*N+j*N+k][0] += J[3,site_nbr_x,j,k]
            priorities[i*N*N+j*N+k][1] -= J[3,site_nbr_x,j,k]

          elif d == 1:
            priorities[i*N*N+j*N+k][0] += J[4,i,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[4,i,site_nbr_y,k]

          elif d == 2:
            priorities[i*N*N+j*N+k][0] += J[5,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[5,i,j,site_nbr_z]

          elif d >= 3 and d <= 5:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.28963779999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        if k < N//2:
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]

  return(priorities)


#score: {'data3D.txt': -0.2916990000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = 1 - total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin - hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (-total_spin - hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.05822059999999983}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5) + abs(total_spin) * magnetism_coeff
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5) - abs(total_spin) * magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.016532999999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          hamming_distance2 = len([val for val in interacting_spins if val == 0]) / max(len(interacting_spins), 1)
          priority_coeff += magnetism_coeff * hamming_distance2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          hamming_distance2 = len([val for val in interacting_spins if val == 0]) / max(len(interacting_spins), 1)
          priority_coeff += magnetism_coeff * hamming_distance2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if site_nbr > 0 and site_nbr < N-1:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
            priorities[i*N*N+j*N+k][1] -= priority_total[1]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
            priorities[i*N*N+j*N+k][1] = -priority_total[1]
        elif site_nbr == 0:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
            priorities[i*N*N+j*N+k][1] -= priority_total[1]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
            priorities[i*N*N+j*N+k][1] = -priority_total[1]
        elif site_nbr == N-1:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
            priorities[i*N*N+j*N+k][1] -= priority_total[1]
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
            priorities[i*N*N+j*N+k][1] = -priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.13732300000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total[0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][0] = priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        else:
          priority_total[0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][0] = -priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.34120340000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin + 3*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff + 2*total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 3*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.3225289999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= -total_spin + 2*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 2*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.0030733999999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          edge_penalty = int((i == 0) | (j == 0) | (k == 0)) + int((i == N-1) | (j == N-1) | (k == N-1))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * sum(1 for val in interacting_spins if val < 0) + edge_penalty
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          edge_penalty = int((i == 0) | (j == 0) | (k == 0)) + int((i == N-1) | (j == N-1) | (k == N-1))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * sum(1 for val in interacting_spins if val > 0) + edge_penalty
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)

        # Add an additional term to account for the interactions with nearest neighbors
        for d in range(3):
          for dx, dy, dz in [(-1,0,0), (1,0,0), (0,-1,0), (0,1,0), (0,0,-1), (0,0,1)]:
            x, y, z = i+dx, j+dy, k+dz
            if 0 <= x < N and 0 <= y < N and 0 <= z < N:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,x,y,z])) * (hamming_distance > 0.5) * (J[d,x,y,z] < 0)
              priorities[i*N*N+j*N+k][1] -= 2 - 2 * J[d,x,y,z] / abs(J[d,x,y,z])
  
  return(priorities)


#score: {'data3D.txt': -0.15839260000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          edge_penalty = int((i == 0) | (j == 0) | (k == 0)) + int((i == N-1) | (j == N-1) | (k == N-1))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * sum(1 for val in interacting_spins if val < 0) + edge_penalty
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          edge_penalty = int((i == 0) | (j == 0) | (k == 0)) + int((i == N-1) | (j == N-1) | (k == N-1))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * sum(1 for val in interacting_spins if val > 0) + edge_penalty
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.32821059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 8*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= -total_spin + 4*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 8*magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 4*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.43612220000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += total_spin + 2*magnetism_coeff*max(0, hamming_distance-0.5)
          priorities[i*N*N+j*N+k][1] -= total_spin - 2*magnetism_coeff*min(0, hamming_distance-0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin - 2*magnetism_coeff*min(0, hamming_distance-0.5)
          priorities[i*N*N+j*N+k][1] = -total_spin + 2*magnetism_coeff*max(0, hamming_distance-0.5)

  return(priorities)


#score: {'data3D.txt': -0.3225289999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= -total_spin + 2*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin + 2*magnetism_coeff
  return(priorities)


#score: {'data3D.txt': 0.003036600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        site_nbr_2d = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          for d in range(3):
            if J[d,i,j,k] < 0:
              priority_total[0] += 1
              priority_total[1] -= 1
            elif J[d,i,j,k] > 0:
              priority_total[0] -= 1
              priority_total[1] += 1
        else:
          for d in range(3):
            if J[d,i,j,k] < 0:
              priority_total[0] -= 1
              priority_total[1] += 1
            elif J[d,i,j,k] > 0:
              priority_total[0] += 1
              priority_total[1] -= 1
        
        priorities[i*N*N+j*N+k][0] = priority_total[0]
        priorities[i*N*N+j*N+k][1] = priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': 0.003036600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if h[i][j][k] > 0:
          for d in range(3):
            site_nbr_2d = (i + ((k-1)%2 - 1)) % N
            if J[d,i,j,k] < 0:
              priority_total[0] += 1
              priority_total[1] -= 1
            elif J[d,i,j,k] > 0:
              priority_total[0] -= 1
              priority_total[1] += 1
        else:
          for d in range(3):
            site_nbr_2d = (i + ((k-1)%2 - 1)) % N
            if J[d,i,j,k] < 0:
              priority_total[0] -= 1
              priority_total[1] += 1
            elif J[d,i,j,k] > 0:
              priority_total[0] += 1
              priority_total[1] -= 1
        
        priorities[i*N*N+j*N+k][0] = priority_total[0]
        priorities[i*N*N+j*N+k][1] = priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * np.sum([spin < 0 for spin in interacting_spins]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + np.tanh(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - np.tanh(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * np.sum([spin > 0 for spin in interacting_spins]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + np.tanh(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + np.tanh(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.31124060000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = np.exp(h[i][j][k] * (total_spin > 0))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = np.exp(-h[i][j][k] * (total_spin < 0))
          total_spin_coeff = 1 - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.17578779999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + (1 - total_spin) * (total_spin < 0)
          if len([val for val in interacting_spins if val < 0]) > 2:
            priorities[i*N*N+j*N+k][1] -= np.abs(total_spin) if total_spin != 0 else 0
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0) + (1 - total_spin) * (total_spin > 0)
          if len([val for val in interacting_spins if val > 0]) > 2:
            priorities[i*N*N+j*N+k][1] = np.abs(total_spin) if total_spin != 0 else 0
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= np.abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -np.abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + np.abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (total_spin > 0) - np.abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - np.abs(total_spin)
          priorities[i*N*N+j*N+k][1] = magnetism_coeff * (total_spin < 0) + np.abs(total_spin)

  return(priorities)


#score: {'data3D.txt': 0.12410860000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= -magnetism_coeff if total_spin != 0 else 0
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff if total_spin != 0 else 0
  return(priorities)


#score: {'data3D.txt': -0.11944339999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          total_priority = np.array([1 - total_spin, 1 + total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_priority[0] += J[d,i,j,k]
              total_priority[1] -= J[d,i,j,k]
            else:
              total_priority[0] -= J[d,i,j,k]
              total_priority[1] = -1 + J[d,i,j,k]
            
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * total_priority[0]
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff * total_priority[1]
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          total_priority = np.array([-1 + total_spin, -1 - total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] < 0:
              total_priority[0] -= J[d,i,j,k]
              total_priority[1] += J[d,i,j,k]
            else:
              total_priority[0] += J[d,i,j,k]
              total_priority[1] = -1 + J[d,i,j,k]
            
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * total_priority[0]
          priorities[i*N*N+j*N+k][1] = magnetism_coeff * total_priority[1]
  
  return(priorities)


#score: {'data3D.txt': -0.034265}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])

        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]

        for d in range(3):
          site_nbr_2d = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            if interacting_spins[d] < 0:
              priority_total[0] += 2
              priority_total[1] -= 2
            elif interacting_spins[d] > 0:
              priority_total[0] -= 2
              priority_total[1] += 2
          else:
            if interacting_spins[d] < 0:
              priority_total[0] -= 2
              priority_total[1] += 2
            elif interacting_spins[d] > 0:
              priority_total[0] += 2
              priority_total[1] -= 2

        priorities[i*N*N+j*N+k][0] = priority_total[0]
        priorities[i*N*N+j*N+k][1] = priority_total[1]

  return(priorities)


#score: {'data3D.txt': 0.002907}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 + 2*magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + 2*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= -1 + 2*magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + 2*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': 0.35432540000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -2*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.33514140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + 1.5*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + 1.5*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.4308538}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # update total spin map for neighboring sites
        total_spin_map = np.zeros((N, N, N, 2), dtype=int)
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            total_spin_map[i,j,k,0] += J[0,i,j,k]
            total_spin_map[i,j,k,1] -= J[0,i,j,k]
          else:
            total_spin_map[i,j,k,0] -= J[0,i,j,k]
            total_spin_map[i,j,k,1] = -J[0,i,j,k]

  return priorities


#score: {'data3D.txt': -0.37691139999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        # Calculate the priority based on the magnetism and hamming distance
        if h[i][j][k] > 0:
          priority = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += priority
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.2534254000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + np.abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (total_spin < 0) - np.abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin > 0) + np.abs(total_spin)
          priorities[i*N*N+j*N+k][1] = magnetism_coeff * (total_spin < 0) - np.abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.23429180000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          if all(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += 4
            priorities[i*N*N+j*N+k][1] -= 4
          elif any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 2
        else:
          if all(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= 4
            priorities[i*N*N+j*N+k][1] += 4
          elif any(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= 2
            priorities[i*N*N+j*N+k][1] += 2

  return(priorities)


#score: {'data3D.txt': -0.4459850000000001}
program:
def priority(N, h, J):
  def get_messages(i, j, k):
    interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
    total_spin = sum(J[d,i,j,k] for d in [0,1,2])
    hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
    magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
    total_spin_coeff = 1 - abs(total_spin)
    return magnetism_coeff * total_spin + total_spin_coeff, -1 + total_spin

  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          message_up, message_down = get_messages(i, j, k)
          priorities[i*N*N+j*N+k][0] += message_up + message_down
          priorities[i*N*N+j*N+k][1] -= 1 - (message_up + message_down)
        else:
          message_up, message_down = get_messages(i, j, k)
          priorities[i*N*N+j*N+k][0] -= message_up + message_down
          priorities[i*N*N+j*N+k][1] = -1 + (message_up + message_down)

  return priorities


#score: {'data3D.txt': 0.038542599999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = -np.sign(total_spin) * (magnetism_coeff + np.abs(total_spin))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = -np.sign(total_spin) * (magnetism_coeff - np.abs(total_spin))
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] -= site_priority

  return priorities


#score: {'data3D.txt': -0.0804234}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)

  return(priorities)


#score: {'data3D.txt': 0.20777460000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) - np.exp(-2*total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - 3*np.exp(-2*total_spin)
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 4 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) - np.exp(2*total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin) - 3*np.exp(2*total_spin)
          
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 4 * (hamming_distance > 0.5)

  return(priorities)


#score: {'data3D.txt': -0.26585740000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin**2
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 4 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin**2
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          # Adjust priority for edge or corner sites and sites with high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 4 * (hamming_distance > 0.5)

  return(priorities)


#score: {'data3D.txt': -0.1554554000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)

        # Calculate magnetism coefficient
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)

        # Calculate the difference in energy for each spin state
        delta_energy = total_spin + hamming_distance * (total_spin > 0) - magnetism_coeff

        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) + delta_energy / abs(delta_energy)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5) - delta_energy / abs(delta_energy)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff

  return(priorities)


#score: {'data3D.txt': -0.0435278}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate site interaction coefficient
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2 + site_interaction_coeff * (hamming_distance < 0.5) + sum(J[d,i,j,k] for d in [0,1,2]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) - site_interaction_coeff
        else:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff / 2 + site_interaction_coeff * (hamming_distance < 0.5) + sum(J[d,i,j,k] for d in [0,1,2]) / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -1 + 2 * total_spin / abs(total_spin) - site_interaction_coeff
        
        # Add a term to the priority based on the site magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= h[i][j][k]
        
  return(priorities)


#score: {'data3D.txt': 0.2996846}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        site_interaction_coeff = max(1 - abs(total_spin), 0)
        
        priority_total = np.array([magnetism_coeff, -magnetism_coeff])
        priority_total[0] += site_interaction_coeff * (hamming_distance < 0.5) + sum(J[d,i,j,k] for d in [0,1,2]) / len(interacting_spins)
        priority_total[1] -= priority_total[0]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.2790666000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_coeff = h[i][j][k] * (1 - abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-total_spin)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_coeff = -h[i][j][k] * (1 + abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_coeff = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] += spin_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          spin_coeff = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] -= spin_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.1852506000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (site_nbr_x + ((site_nbr_y-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((d-1)%2 - 1)) % N
          site_nbr_y = (j + ((k-1)%2 - 1)) % N
          if h[site_nbr_x][site_nbr_y][0] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] = -J[d,site_nbr_x,site_nbr_y,k]

  return(priorities)


#score: {'data3D.txt': -0.10855420000000021}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (site_nbr_x + ((site_nbr_y-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          if h[site_nbr_x][site_nbr_y][0] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] = -J[d,site_nbr_x,site_nbr_y,k]

        if k > 0:
          site_nbr_z = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr_z][j][k-1] > 0:
            priorities[i*N*N+j*N+k][0] += J[2,site_nbr_z,j,k-1]
            priorities[i*N*N+j*N+k][1] -= J[2,site_nbr_z,j,k-1]
          else:
            priorities[i*N*N+j*N+k][0] -= J[2,site_nbr_z,j,k-1]
            priorities[i*N*N+j*N+k][1] = -J[2,site_nbr_z,j,k-1]

        if k < N-1:
          site_nbr_z = (i + ((k+1)%2 - 1)) % N
          if h[site_nbr_z][j][k+1] > 0:
            priorities[i*N*N+j*N+k][0] += J[2,site_nbr_z,j,k+1]
            priorities[i*N*N+j*N+k][1] -= J[2,site_nbr_z,j,k+1]
          else:
            priorities[i*N*N+j*N+k][0] -= J[2,site_nbr_z,j,k+1]
            priorities[i*N*N+j*N+k][1] = -J[2,site_nbr_z,j,k+1]

  return(priorities)


#score: {'data3D.txt': -0.4417174000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        site_nbr_z = (site_nbr_x + ((site_nbr_y-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          for d in range(3):
            if J[d,site_nbr_x,site_nbr_y,k] < 0:
              priorities[i*N*N+j*N+k][0] -= abs(J[d,site_nbr_x,site_nbr_y,k])
            else:
              priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,k]
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          for d in range(3):
            if J[d,site_nbr_x,site_nbr_y,k] < 0:
              priorities[i*N*N+j*N+k][0] += abs(J[d,site_nbr_x,site_nbr_y,k])
            else:
              priorities[i*N*N+j*N+k][0] -= J[d,site_nbr_x,site_nbr_y,k]
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.09676660000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr_x = (i + ((k-1)%2 - 1)) % N
        site_nbr_y = (j + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

        for d in range(3):
          site_nbr_x = (i + ((k-1)%2 - 1)) % N
          site_nbr_y = (j + ((d-1)%2 - 1)) % N
          if h[site_nbr_x][site_nbr_y][0] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] -= J[d,site_nbr_x,site_nbr_y,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,site_nbr_x,site_nbr_y,k]
            priorities[i*N*N+j*N+k][1] = -J[d,site_nbr_x,site_nbr_y,k]

  return(priorities)


#score: {'data3D.txt': -0.10625860000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.286661}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin - hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + hamming_distance
          priorities[i*N*N+j*N+k][1] = -2 * total_spin - hamming_distance

  return(priorities)


#score: {'data3D.txt': -0.24672540000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_flip_energy = sum(val for val in interacting_spins if val > 0) - sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 + total_spin) + spin_flip_energy
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_flip_energy = sum(val for val in interacting_spins if val < 0) - sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (-1 + total_spin) - spin_flip_energy
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.38534219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = 2 * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff + 1) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = 2 * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff - 1) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3297406000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+N)%N,j,k], J[4,i,(k+1)%N,k], J[5,(i+N)%N,(j+k)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 3*total_spin + 2
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -3*total_spin + 2

  return(priorities)


#score: {'data3D.txt': -0.25396420000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 4*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2*total_spin - 1
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 4*magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -2*total_spin + 1

  return(priorities)


#score: {'data3D.txt': -0.33514140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbors_with_magnetism = sum(1 for d in [0,1,2] if J[d,i,j,k] > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(4 + 2*neighbors_with_magnetism)
          priorities[i*N*N+j*N+k][1] -= total_spin + 1
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbors_with_magnetism = sum(1 for d in [0,1,2] if J[d,i,j,k] < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(4 + 2*neighbors_with_magnetism)
          priorities[i*N*N+j*N+k][1] = -total_spin + 1

  return(priorities)


#score: {'data3D.txt': -0.4801054000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_sum = magnetism_coeff * (hamming_distance > 0.5) + 1
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_sum = -magnetism_coeff * (hamming_distance > 0.5) - 1
        priorities[i*N*N+j*N+k][0] += priority_sum
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + 1
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * np.sum([spin < 0 for spin in interacting_spins]))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_coeff = h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val > 0 and h[i][j][k] < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          spin_coeff = -h[i][j][k] * total_spin_coeff
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val < 0 and h[i][j][k] > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          spin_coeff = h[i][j][k] * total_spin_coeff
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_coeff = 1 - abs(total_spin)
          hamming_magnetism = len([val for val in interacting_spins if val > 0 and h[i][j][k] < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff *= np.exp(-abs(total_spin) * (hamming_distance + hamming_magnetism > 0.5))
          spin_coeff = -h[i][j][k] * total_spin_coeff
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.3062862}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        # add interaction with sites at the bottom layer
        if k == N//2-1:
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
  return(priorities)


#score: {'data3D.txt': -0.3025354000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr_z][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
              priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            if h[site_nbr_z][j][k] < 0:
              priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
              priorities[i*N*N+j*N+k][1] = 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.2782614000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
            
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + h[i][j][k] + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
            
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + h[i][j][k] + total_spin
          priorities[i*N*N+j*N+k][1] = 1 - total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.19903300000000032}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # calculate total magnetism
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # add interaction with neighboring sites
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + h[i][j][k]
          priorities[i*N*N+j*N+k][1] = 1 - total_spin
        
        if k < N//2:
          for d in range(3):
            site_nbr_z = (i + ((k-1)%2 - 1)) % N
            priorities[i*N*N+j*N+k][0] += J[d,i,j,site_nbr_z]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,site_nbr_z]
  
  return(priorities)


#score: {'data3D.txt': -0.37691139999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        # Calculate the priority based on the magnetism and hamming distance
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(h[site_nbr][:,k], axis=0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = np.sum(h[site_nbr][:,k], axis=0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return priorities


#score: {'data3D.txt': -0.36587379999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                    J[3,(i+1)%N,j,k], J[4,i,(j+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        # Calculate the priority based on the magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust the priority based on the site interactions
          site_interactions = sum([val for val in interacting_spins if val != 0])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(site_interactions) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust the priority based on the site interactions
          site_interactions = sum([val for val in interacting_spins if val != 0])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(site_interactions) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return priorities


#score: {'data3D.txt': -0.0288562}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_nbr_coeff = sum(J[d, i, site_nbr, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + site_nbr_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_nbr_coeff = sum(J[d, i, site_nbr, k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + site_nbr_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add interaction with neighboring sites in x, y and z directions
        for d in range(3):
          if d == 0:
            site_nbr_x = i
            site_nbr_y = j
            site_nbr_z = k
          elif d == 1:
            site_nbr_x = (i+1)%N
            site_nbr_y = j
            site_nbr_z = k
          else:
            site_nbr_x = i
            site_nbr_y = (j+1)%N
            site_nbr_z = k

          for dd in range(3):
            if dd == 0:
              priorities[i*N*N+j*N+k][0] += J[0,site_nbr_x,site_nbr_y,site_nbr_z]
              priorities[i*N*N+j*N+k][1] -= J[0,site_nbr_x,site_nbr_y,site_nbr_z]
            elif dd == 1:
              priorities[i*N*N+j*N+k][0] += J[2,i,site_nbr_x,site_nbr_z]
              priorities[i*N*N+j*N+k][1] -= J[2,i,site_nbr_x,site_nbr_z]
            else:
              priorities[i*N*N+j*N+k][0] += J[1,(i+1)%N,j,k]
              priorities[i*N*N+j*N+k][1] -= J[1,(i+1)%N,j,k]

  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2 * total_spin
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val != h[i][j][k]]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        spin_energy = np.tanh(total_spin)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_energy
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)


#score: {'data3D.txt': 0.286661}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

  return(priorities)


#score: {'data3D.txt': -0.2816538000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          message_up = np.exp(-np.sum(np.sign(interacting_spins)))
          message_down = -1 + total_spin
          priorities[i*N*N+j*N+k][0] += message_up + message_down
          priorities[i*N*N+j*N+k][1] -= 1 - (message_up + message_down)
        else:
          message_up = np.exp(-np.sum(np.sign(interacting_spins)))
          message_down = -1 + total_spin
          priorities[i*N*N+j*N+k][0] -= message_up + message_down
          priorities[i*N*N+j*N+k][1] = -1 + (message_up + message_down)

  return priorities


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add additional priority based on the number of neighbors with same spin
        for d in [0, 1, 2]:
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
          else:
            priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k])

  return(priorities)


#score: {'data3D.txt': 0.0087486}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add the effect of neighboring spins
        for d in range(6):
          for l in [(i+1)%N, (j+1)%N, (k+1)%N]:
            site_nbr = (l + ((d-1)%2 - 1)) % N
            if h[l][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] -= J[d,i,l,k]
            else:
              priorities[i*N*N+j*N+k][0] -= J[d,l,j,k]
              priorities[i*N*N+j*N+k][1] = -J[d,i,l,k]

  return(priorities)


#score: {'data3D.txt': -0.26394500000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[1,(i-1)%N,j,k], J[2,i,(j+1)%N,k], J[2,i,(j-1)%N,k], J[3,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + hamming_distance * abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + hamming_distance * abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
          
  return(priorities)


#score: {'data3D.txt': -0.4541026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] += priority_coeff * h[(i + ((k-1)%2 - 1)) % N][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          priority_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and its neighbors
          priorities[i*N*N+j*N+k][0] -= priority_coeff * h[(i + ((k-1)%2 - 1)) % N][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.2540862000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + hamming_distance * abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + hamming_distance * abs(total_spin)
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
  
  # Perform a second pass to adjust priorities based on site's magnetization and its neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin / abs(total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Adjust priority based on site's hamming distance
        if hamming_distance > 0.5:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4409621999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.47128539999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.48338100000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          interaction_coeff = np.exp(-len([val for val in interacting_spins if val < 0]))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism * interaction_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          interaction_coeff = np.exp(-len([val for val in interacting_spins if val > 0]))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism * interaction_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.009917}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    total_spin = sum(J[d,(i//N)**3%N,(i//100)%N,i%10] for d in range(6))
    if h[(i//1000)%N,(i//100)%N,i%10] > 0:
      priorities[i][0] += abs(total_spin)
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= abs(total_spin)
      priorities[i][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins[:3] if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins[:3] if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4286802}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4286802}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.49796460000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - 1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4286802}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49775620000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0035966000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_total = np.array([1 - total_spin, 1 + total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              priority_total[0] += J[d,i,j,k]
              priority_total[1] -= J[d,i,j,k]
            else:
              priority_total[0] -= J[d,i,j,k]
              priority_total[1] = -1 + J[d,i,j,k]
          
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (priority_total[0] if sum(interacting_spins) > 0 else -priority_total[0])
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff * (priority_total[1] if sum(interacting_spins) > 0 else -priority_total[1])
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] < 0:
              priority_total[0] -= J[d,i,j,k]
              priority_total[1] += J[d,i,j,k]
            else:
              priority_total[0] += J[d,i,j,k]
              priority_total[1] = -1 + J[d,i,j,k]
          
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (priority_total[0] if sum(interacting_spins) < 0 else -priority_total[0])
          priorities[i*N*N+j*N+k][1] = magnetism_coeff * (priority_total[1] if sum(interacting_spins) < 0 else -priority_total[1])
  
  return(priorities)


#score: {'data3D.txt': 0.143977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          total_priority = np.array([1 - total_spin, 1 + total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_priority[0] += J[d,i,j,k]
              total_priority[1] -= J[d,i,j,k]
            else:
              total_priority[0] -= J[d,i,j,k]
              total_priority[1] = -1 + J[d,i,j,k]
          
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_priority[0] += 1 + total_spin
              total_priority[1] -= 1 - total_spin
            else:
              total_priority[0] -= 1 + total_spin
              total_priority[1] = -1 + total_spin
          
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * total_priority[0]
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff * total_priority[1]
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          total_priority = np.array([-1 + total_spin, -1 - total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] < 0:
              total_priority[0] -= J[d,i,j,k]
              total_priority[1] += J[d,i,j,k]
            else:
              total_priority[0] += J[d,i,j,k]
              total_priority[1] = -1 + J[d,i,j,k]
          
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] < 0:
              total_priority[0] -= 1 + total_spin
              total_priority[1] += 1 - total_spin
            else:
              total_priority[0] += 1 + total_spin
              total_priority[1] = -1 + total_spin
          
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * total_priority[0]
          priorities[i*N*N+j*N+k][1] = magnetism_coeff * total_priority[1]
  
  return(priorities)


#score: {'data3D.txt': 0.143977}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / (max(len(interacting_spins), 1)))
          total_priority = np.array([1 - total_spin, 1 + total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_priority[0] += J[d,i,j,k]
              total_priority[1] -= J[d,i,j,k]
            else:
              total_priority[0] -= J[d,i,j,k]
              total_priority[1] = -1 + J[d,i,j,k]
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] > 0:
              total_priority[0] += 1 + total_spin
              total_priority[1] -= 1 - total_spin
            else:
              total_priority[0] -= 1 + total_spin
              total_priority[1] = -1 + total_spin
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (total_priority[0] + np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff * (total_priority[1] + np.sum(-np.sign(interacting_spins)))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / (max(len(interacting_spins), 1)))
          total_priority = np.array([-1 + total_spin, -1 - total_spin])
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] < 0:
              total_priority[0] -= J[d,i,j,k]
              total_priority[1] += J[d,i,j,k]
            else:
              total_priority[0] += J[d,i,j,k]
              total_priority[1] = -1 + J[d,i,j,k]
          for d in range(3):
            site_nbr_d = (i + ((d-1)%2 - 1)) % N
            if h[i][j][k] < 0:
              total_priority[0] -= 1 + total_spin
              total_priority[1] += 1 - total_spin
            else:
              total_priority[0] += 1 + total_spin
              total_priority[1] = -1 + total_spin
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (total_priority[0] + np.sum(np.sign(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = magnetism_coeff * (total_priority[1] + np.sum(-np.sign(interacting_spins)))
  
  return(priorities)


#score: {'data3D.txt': -0.4409621999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
            
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          if total_spin < 0:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.33188059999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))

          spin_energy = total_spin + sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - spin_energy

        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))

          spin_energy = total_spin + sum(J[d,site_nbr,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + spin_energy

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority for sites with high magnetism and low hamming distance
          site_magnetism = abs(h[i][j][k])
          if site_magnetism > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4409621999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priority_magnetism = np.exp(abs(h[i][j][k]))
          priority_spin = np.exp(abs(1 - total_spin))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priority_magnetism = np.exp(abs(h[i][j][k]))
          priority_spin = np.exp(abs(1 - total_spin))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.12316180000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the sign of total spin and hamming distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin >= 0) + 2 * (1 if is_edge_or_corner else 0)
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) - 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the sign of total spin and hamming distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin >= 0) + 2 * (1 if is_edge_or_corner else 0)
          priorities[i*N*N+j*N+k][1] = -abs(total_spin) - 2 * (hamming_distance > 0.5)
  
  return(priorities)


#score: {'data3D.txt': -0.03704980000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the sign of total spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff if total_spin >= 0 else -magnetism_coeff
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Prioritize spins that are aligned with the majority of their neighbors
          same_spin_neighbors = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= abs(total_spin) + (1 if total_spin > 0 else -1)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the sign of total spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff if total_spin >= 0 else -magnetism_coeff
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Prioritize spins that are aligned with the majority of their neighbors
          same_spin_neighbors = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -abs(total_spin) + (1 if total_spin > 0 else -1)
          
  return(priorities)


#score: {'data3D.txt': -0.4652290000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Prioritize spins based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the number of nearest neighbors with same spin
          same_spin_neighbors = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (same_spin_neighbors > 1) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on the number of nearest neighbors with same spin
          same_spin_neighbors = sum(1 for d in [0,1,2] if J[d,i,j,k] == h[i][j][k])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (same_spin_neighbors > 1) + total_spin
          priorities[i*N*N+j*N+k][1] = -abs(total_spin) + (1 if total_spin > 0 else -1)
          
          # Adjust priority for edge or corner sites
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
  
  return(priorities)


#score: {'data3D.txt': -0.0597878}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2)
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) + 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2)
          priorities[i*N*N+j*N+k][1] = -2 * total_spin

  return(priorities)


#score: {'data3D.txt': -0.03765420000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0305046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) * abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= np.count_nonzero([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) * abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -np.count_nonzero([val for val in interacting_spins if val > 0])

  return(priorities)


#score: {'data3D.txt': 0.02832899999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0682674}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (2*total_spin - priority_coeff)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin + priority_coeff)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (2*total_spin - priority_coeff)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.36397660000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * -total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (total_spin <= 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': 0.31317620000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.1348046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 2*magnetism_coeff + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*magnetism_coeff + total_spin

  return(priorities)


#score: {'data3D.txt': -0.22529300000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += 2 + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= 2 - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': 0.3785378000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': 0.37473940000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += -2
              priorities[i*N*N+j*N+k][1] -= 3
            else:
              priorities[i*N*N+j*N+k][0] += 2
              priorities[i*N*N+j*N+k][1] += 3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= -2
              priorities[i*N*N+j*N+k][1] += 3
            else:
              priorities[i*N*N+j*N+k][0] -= 2
              priorities[i*N*N+j*N+k][1] -= 3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': 0.3702962000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] = priority_total * (total_spin > 0)
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -priority_total * (total_spin < 0)

  return(priorities)


#score: {'data3D.txt': -0.3017678}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        # calculate hamming distance
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  return(priorities)


#score: {'data3D.txt': 0.27731020000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * (1 - (sum(abs(val) for val in interacting_spins) / 18))
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = abs(total_spin) * (1 + (sum(abs(val) for val in interacting_spins) / 18))
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': -0.46262620000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        if (i == 0 or i == N-1) or (j == 0 or j == N-1) or (k == 0 or k == N-1):
          # Adjust priority based on boundary conditions
          priorities[i*N*N+j*N+k][0] += 2 * h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 * h[i][j][k]
        
        if (i == N//2 and j == N//2 and k == N//2):
          # Adjust priority for the center site
          priorities[i*N*N+j*N+k][0] += 3 * h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 3 * h[i][j][k]
  
  return priorities


#score: {'data3D.txt': -0.3677646}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Additional adjustments based on site's proximity to boundaries
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += 2 * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 * h[site_nbr][j][k]
        
        if i == N-1 or j == N-1 or k == N-1:
          priorities[i*N*N+j*N+k][0] += 3 * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 3 * h[site_nbr][j][k]
  
  return(priorities)


#score: {'data3D.txt': -0.475207}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        if (i == 0 or i == N-1) or (j == 0 or j == N-1) or (k == 0 or k == N-1):
          # Adjust priority based on boundary conditions
          priorities[i*N*N+j*N+k][0] += 2 * h[i][j][k]
          priorities[i*N*N+j*N+k][1] -= 2 * h[i][j][k]
          
        if i < N//2 and j < N//2:
          # Adjust priority based on center of the grid
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        if i >= N//2 or j >= N//2:
          # Adjust priority based on center of the grid
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return priorities


#score: {'data3D.txt': -0.09284380000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.2528934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + 2
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - 2
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.013437800000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (2 * hamming_distance - 1) + 1
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (2 * (1-hamming_distance) - 1) + 1
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (2 * hamming_distance - 1) - 1
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (2 * (1-hamming_distance) - 1) - 1
            priorities[i*N*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.17555900000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + 1
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][1] = -1 if total_spin > 0 else 1
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) - 1
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + 1
          priorities[i*N*N+j*N+k][1] = -1 if total_spin < 0 else 1

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = 2 * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = 2 * (hamming_distance > 0.5) - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins[:3] if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins[:3] if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.2273086}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) - total_spin

  return(priorities)


#score: {'data3D.txt': -0.1166594000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_sum = np.sum(interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += priority_sum + 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= -total_spin + 3*priority_sum + magnetism_coeff
        else:
          priority_sum = np.sum(interacting_spins)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= priority_sum + 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + 3*priority_sum + magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.03765420000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 * (np.count_nonzero(interacting_spins) - len(interacting_spins)/2) - total_spin

  return(priorities)


#score: {'data3D.txt': -0.1348046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.0795958}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)

        # Additional term to prioritize spins along the edges
        if i == 0 or j == 0 or k == 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)

  return(priorities)


#score: {'data3D.txt': -0.28477100000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.array([1 - total_spin, 1 + total_spin])
        else:
          priority_total = np.array([-1 + total_spin, -1 - total_spin])
        
        for d in range(3):
          site_nbr_d = (i + ((d-1)%2 - 1)) % N
          if h[i][j][k] > 0:
            priority_total[0] += J[d,i,j,k]
            priority_total[1] -= J[d,i,j,k]
          else:
            priority_total[0] -= J[d,i,j,k]
            priority_total[1] = -1 + J[d,i,j,k]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= priority_total[1]
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) * priority_total[0]
          priorities[i*N*N+j*N+k][1] = -priority_total[1]
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * priority_total[0]
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * priority_total[1]
  
  return(priorities)


#score: {'data3D.txt': -0.0804234}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= hamming_distance * total_spin + np.exp(-abs(total_spin) * (hamming_distance > 0.5)) * (is_edge_or_corner or hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin / abs(total_spin) * (1 - is_edge_or_corner and hamming_distance <= 0.5)

  return(priorities)


#score: {'data3D.txt': -0.1995209999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff - 1
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff + 1

  return(priorities)


#score: {'data3D.txt': -0.46223939999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (total_spin > 0) * 2
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (total_spin < 0) * -2
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (total_spin < 0) * -2
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (total_spin > 0) * 2
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          for d in [0,1]:
            priorities[i*N*N+j*N+k][d] += magnetism_coeff * priority_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          for d in [0,1]:
            priorities[i*N*N+j*N+k][d] -= magnetism_coeff * priority_coeff
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 - total_spin) + (1 + total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  for i in range(N**3):
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0] += 2
    elif priorities[i][0] < priorities[i][1]:
      priorities[i][1] -= 2

  return(priorities)


#score: {'data3D.txt': -0.0311258}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Add the effect of neighboring spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(h[site_nbr:(site_nbr+1),j,k])
          priorities[i*N*N+j*N+k][1] -= np.sum(h[i,site_nbr:(site_nbr+1),k])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(h[site_nbr:(site_nbr+1),j,k])
          priorities[i*N*N+j*N+k][1] = -np.sum(h[i,site_nbr:(site_nbr+1),k])

  # Add the effect of the magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(h[i,j,(k+1)%N])
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(h[i,j,(k+1)%N])

  return(priorities)


#score: {'data3D.txt': 0.007272199999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add the effect of neighboring spins
        for d in [0, 1, 2]:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += np.sum(J[d,site_nbr,j,k])
            priorities[i*N*N+j*N+k][1] -= np.sum(J[d,i,site_nbr,k])
          else:
            priorities[i*N*N+j*N+k][0] -= np.sum(J[d,site_nbr,j,k])
            priorities[i*N*N+j*N+k][1] = -np.sum(J[d,i,site_nbr,k])

  return(priorities)


#score: {'data3D.txt': -9.859999999999974e-05}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add the effect of neighboring spins in x, y and z directions
        for dim in range(3):
          for d in [(i-1)%N, (i+1)%N]:
            if h[d][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += J[dim,d,j,k]
              priorities[i*N*N+j*N+k][1] -= J[dim,i,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= J[dim,d,j,k]
              priorities[i*N*N+j*N+k][1] = -J[dim,i,j,k]

          for d in [(j-1)%N, (j+1)%N]:
            if h[i][d][k] > 0:
              priorities[i*N*N+j*N+k][0] += J[2,i,d,k]
              priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= J[2,i,d,k]
              priorities[i*N*N+j*N+k][1] = -J[2,i,j,k]

          for d in [(k-1)%N, (k+1)%N]:
            if h[i][j][d] > 0:
              priorities[i*N*N+j*N+k][0] += J[1,i,j,d]
              priorities[i*N*N+j*N+k][1] -= J[1,i,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= J[1,i,j,d]
              priorities[i*N*N+j*N+k][1] = -J[1,i,j,k]

  return(priorities)


#score: {'data3D.txt': -0.0154222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add the effect of neighboring spins
        for d in range(3):
          for neighbor in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
            if h[neighbor[0]][neighbor[1]][k] > 0:
              priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
              priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
            else:
              priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
              priorities[i*N*N+j*N+k][1] = -J[d,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.017553799999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          priority_coeff = magnetism_coeff * hamming_distance * spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= priority_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          priority_coeff = -magnetism_coeff * hamming_distance * spin_bias - neighbor_bias
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1291482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          local_field = hamming_distance * spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * local_field + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          local_field = hamming_distance * spin_bias - neighbor_bias
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * local_field + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.100671}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          interaction_term = np.mean([abs(J[d,i,j,k]) for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias + neighbor_bias + interaction_term
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          interaction_term = np.mean([abs(J[d,i,j,k]) for d in [0,1,2]])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias + neighbor_bias + interaction_term
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.02039939999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          neighbor_bias = sum((J[d,site_nbr,j,k] if d in [0,2] else J[1,i,site_nbr,k]) for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4768646}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.469971}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_sum = magnetism_coeff * (hamming_distance > 0.5) + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_sum = -magnetism_coeff * (hamming_distance > 0.5) - total_spin
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * abs(total_spin)
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_sum = (magnetism_coeff * (hamming_distance > 0.5) + 1) * abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_sum = (-magnetism_coeff * (hamming_distance > 0.5) - 1) * abs(total_spin)
        priorities[i*N*N+j*N+k][0] += priority_sum
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1617226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_sum = magnetism_coeff * (hamming_distance > 0.5) + 1
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_sum = -magnetism_coeff * (hamming_distance > 0.5) - 1
        site_nbr_spin = [1 if val < 0 else -1 for val in interacting_spins]
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.sum(site_nbr_spin)
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.23602460000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = total_spin * len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.22647860000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.22647860000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': 0.028918599999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
        else:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = priority_total + total_spin

  return(priorities)


#score: {'data3D.txt': 0.34213619999999956}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) + sum([abs(x) for x in interacting_spins])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = abs(total_spin) - sum([abs(x) for x in interacting_spins])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': 0.27864659999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] = -(priority_total+total_spin)
          priorities[i*N*N+j*N+k][1] = (priority_total+total_spin)
        else:
          priority_total = np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][0] = -(priority_total-total_spin)
          priorities[i*N*N+j*N+k][1] = -(priority_total-total_spin)

  return(priorities)


#score: {'data3D.txt': 0.3702962000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.2995286}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          site_nbr_spin = h[site_nbr][j][k]
          if site_nbr_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          site_nbr_spin = h[site_nbr][j][k]
          if site_nbr_spin > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.4025114000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_magnetism = np.exp(abs(h[site_nbr][j][k]))
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          priority_magnetism = np.exp(abs(h[site_nbr][j][k]))
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3318629999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          spin_priority = np.exp(abs(1 - total_spin))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_priority
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          spin_priority = np.exp(abs(1 - total_spin))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.12738420000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_magnetism
          if total_spin > 0:
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][1] += 2
            
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_magnetism = np.exp(abs(h[i][j][k]))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_magnetism
          if total_spin < 0:
            priorities[i*N*N+j*N+k][1] += 2
          else:
            priorities[i*N*N+j*N+k][1] -= 2
            
  return(priorities)


#score: {'data3D.txt': -0.47020899999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Adjust priority based on site's location
        if i % N == 0 or j % N == 0 or k % N == 0:
          priorities[i*N*N+j*N+k][0] *= max(2, 4 * (hamming_distance > 0.7))
  
  return(priorities)


#score: {'data3D.txt': -0.47275900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1))
        
        # Adjust priority for edge or corner sites and sites with high hamming distance
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] *= max(2, 4 * (hamming_distance > 0.7))
          
  return(priorities)


#score: {'data3D.txt': -0.47275900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority based on edge or corner sites and high hamming distance
          if ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1)):
            priorities[i*N*N+j*N+k][0] *= max(2, 4 * (hamming_distance > 0.7))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority based on edge or corner sites and high hamming distance
          if ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1)):
            priorities[i*N*N+j*N+k][0] *= max(2, 4 * (hamming_distance > 0.7))
  
  return(priorities)


#score: {'data3D.txt': -0.47333500000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1) + total_spin / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k] * (len([val for val in interacting_spins if val < 0]) > 1) - total_spin / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Adjust priority for edge or corner sites and sites with high hamming distance
        if ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1)):
          priorities[i*N*N+j*N+k][0] *= max(2, 4 * (hamming_distance > 0.7))
          
  return(priorities)


#score: {'data3D.txt': -0.18944540000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val != 0]) / max(len(interacting_spins), 1)

        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          for d in [0,1,2]:
            if J[d,i,j,k] != 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
              break
        else:
          for d in [0,1,2]:
            if J[d,i,j,k] != 0:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
              break

        # Adjust priority based on site's magnetization and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.12622900000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.10106940000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Adjust priority based on site's magnetization and its neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin / abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4541026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Prioritize spins based on site interactions and magnetism
        priority_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Adjust priority based on site's magnetization and its neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += priority_coeff * h[(i + ((k-1)%2 - 1)) % N][j][k] * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= priority_coeff * h[(i + ((k-1)%2 - 1)) % N][j][k] * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.46223939999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (total_spin > 0) * 2
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (total_spin < 0) * -2
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (total_spin < 0) * -2
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (total_spin > 0) * 2
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
  return priorities


#score: {'data3D.txt': -0.38534219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = (total_spin > 0) * (-2 + len([val for val in interacting_spins if val < 0])) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = (total_spin < 0) * (-2 + len([val for val in interacting_spins if val > 0])) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0028358}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add the effect of neighboring spins
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[d,i,j,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -J[d,i,j,k]

  return(priorities)


#score: {'data3D.txt': 0.016565}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_bias = (total_spin >= 0) * (1 - total_spin) + (total_spin < 0) * (-1 + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Add the effect of neighboring spins
        for d in range(6):
          if d < 3:
            site_nbr = (i + ((d-1)%2 - 1)) % N
          elif d < 4:
            site_nbr = (j + ((d-3)%2 - 1)) % N
          else:
            site_nbr = (k + ((d-5)%2 - 1)) % N
          if h[site_nbr][i][j] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,site_nbr,i,j]
            priorities[i*N*N+j*N+k][1] -= J[d,i,site_nbr,k]
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,site_nbr,i,j]
            priorities[i*N*N+j*N+k][1] = -J[d,i,site_nbr,k]

  return(priorities)


#score: {'data3D.txt': -0.45666059999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        site_nbr = (i + ((k-1)%2 - 1)) % N

        if h[i][j][k] > 0:
          total_spin += 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + h[site_nbr][j][k] * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

        else:
          total_spin -= 1
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) - h[site_nbr][j][k] * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.39622820000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          total_spin += 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          total_spin -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
        
        # Calculate additional priority based on site magnetism and neighbors' spins
        neighbor_spins = [h[(i+1)%N,j,k], h[i,(j+1)%N,k], h[i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(h[i][j][k]) * (hamming_distance > 0.5)) * max(0, min(1, sum(neighbor_spins)))
        
  return(priorities)


#score: {'data3D.txt': -0.4618722}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)))
          
          # Adjust priority based on site's magnetization and interactions
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1))
        
        # Adjust priority for edge or corner sites and high hamming distance
        if is_edge_or_corner:
          priorities[i*N*N+j*N+k][0] *= max(2, 4 * (sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)) > 0.7)
  
  return(priorities)


#score: {'data3D.txt': -0.1995209999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (total_spin >= 0)
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff - 1
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (total_spin <= 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (-1 + total_spin) + (1 - total_spin) * (-hamming_distance > 0.5)
          magnetism_coeff *= hamming_distance
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff + 1

  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.48134660000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x>0) for x in interacting_spins) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x<0) for x in interacting_spins) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.4904230000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins) + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins) - priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.49775620000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.49775620000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.4684418000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + len([x for x in interacting_spins if x > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - len([x for x in interacting_spins if x < 0])
  return(priorities)


#score: {'data3D.txt': -0.43436299999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_sum = sum(1 for x in interacting_spins if x < 0) - len([x for x in interacting_spins if x > 0])
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + total_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_sum = sum(1 for x in interacting_spins if x > 0) - len([x for x in interacting_spins if x < 0])
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + total_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': 0.4372202000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 2 * total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -2 * total_spin - sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': -0.32755100000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        # calculate hamming distance
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.4398722000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.42958019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # adjust priorities based on the sign of the spin and the hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.4216882000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New added logic
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val < 0)
  
  return(priorities)


#score: {'data3D.txt': -0.3187797999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority coefficient based on the number of neighboring spins
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
  
  return(priorities)


#score: {'data3D.txt': 0.04434020000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': 0.19601139999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + len([x for x in interacting_spins if x > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - len([x for x in interacting_spins if x < 0])
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # New calculation to improve priority
        if sum(J[0,i,j,k] for i in range(N)) > 0:
          priorities[i*N*N+j*N+k][0] += len([x for x in interacting_spins if x < 0])
          priorities[i*N*N+j*N+k][1] -= len([x for x in interacting_spins if x > 0])
        elif sum(J[0,i,j,k] for i in range(N)) < 0:
          priorities[i*N*N+j*N+k][0] -= len([x for x in interacting_spins if x > 0])
          priorities[i*N*N+j*N+k][1] = -len([x for x in interacting_spins if x < 0])
  
  return(priorities)


#score: {'data3D.txt': -0.1548810000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + len([x for x in interacting_spins if x > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - len([x for x in interacting_spins if x < 0])
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # Calculate the priority based on the magnetism at each site
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= len([x for x in interacting_spins if x > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -len([x for x in interacting_spins if x < 0])
  
  return(priorities)


#score: {'data3D.txt': 0.29538099999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + 1 - total_spin
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + len([x for x in interacting_spins if x > 0])
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - 1 + total_spin
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - len([x for x in interacting_spins if x < 0])
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = 2*magnetism_coeff + total_spin
          priority_down = -2*magnetism_coeff - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = -2*magnetism_coeff + total_spin
          priority_down = 2*magnetism_coeff - total_spin

        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] -= priority_down

  return(priorities)


#score: {'data3D.txt': -0.33514140000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 3*total_spin + 2*magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 8*magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -3*total_spin + 2*magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.11755460000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          total_spin += sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          total_spin -= sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2
  
  return(priorities)


#score: {'data3D.txt': -0.4183938000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin and hamming distance for each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Check if the site is at an edge or corner
        is_edge_or_corner = (i == 0) | (i == N-1) | (j == 0) | (j == N-1) | (k == 0) | (k == N-1)

        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

          # Adjust priority for edge or corner sites and high hamming distance
          if is_edge_or_corner:
            priorities[i*N*N+j*N+k][0] *= 2

  return(priorities)


#score: {'data3D.txt': -0.0011562}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          # Prioritize spins based on site interactions and magnetism
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * (hamming_distance > 0.5)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1)):
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          # Prioritize spins based on site interactions and magnetism
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * (hamming_distance > 0.5)) - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites and high hamming distance
          if ((i == 0) | (i == N-1)) & ((j == 0) | (j == N-1)) & ((k == 0) | (k == N-1)):
            priorities[i*N*N+j*N+k][0] *= 2

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += 2*total_spin
          priorities[i*N*N+j*N+k][1] -= 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 2*abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2*abs(total_spin)
          
  return(priorities)


#score: {'data3D.txt': -0.48134660000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x>0) for x in interacting_spins) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x<0) for x in interacting_spins) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.014422999999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 4 * total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 2*priority_total
        else:
          priority_total = -4 * total_spin - sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -2*priority_total

  return(priorities)


#score: {'data3D.txt': 0.4395794000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 4 * total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -2 * total_spin - sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': -0.4476726}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) * (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) * (total_spin <= 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
        # Adjust priority for edge or corner sites
        if i == 0 and j > 0:
          priorities[i*N*N+j*N+k][0] *= 2
        elif i > 0 and j == 0:
          priorities[(i-1)*N*N+j*N+k][0] *= 2
        elif k == 0:
          priorities[i*N*N+j*N+k][0] *= 2
        
  return(priorities)


#score: {'data3D.txt': -0.3146118000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != h[i][j][k]]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
          # Adjust priority for edge or corner sites
          if i == 0 or j == 0 or k == 0 or i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
          # Adjust priority for edge or corner sites
          if i == 0 or j == 0 or k == 0 or i == N-1 or j == N-1 or k == N-1:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance > 0.5)
        
        # Calculate priority based on site's magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.0026202}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        # Calculate hamming distance and magnetism coefficient
        hamming_distance = len([val for val in interacting_spins if val != h[i][j][k]]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))

        # Calculate priority based on site interactions and magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin

          # Adjust priority for sites with high magnetism and low hamming distance
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] *= 2 * (hamming_distance < 0.5)

        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  # Apply a global correction to improve the ground state energy
  for i in range(N):
    for j in range(N):
      if h[i][j].mean() > 0:
        priorities[:,0] += np.exp(-abs(total_spin))
        priorities[:,1] -= 1 - total_spin

  return(priorities)


#score: {'data3D.txt': 0.08463419999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -2*magnetism_coeff + total_spin

  return(priorities)


#score: {'data3D.txt': 0.11736419999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 2*np.sum(np.sign(interacting_spins)) + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -2 - 2*np.sum(np.sign(interacting_spins)) + total_spin

  return(priorities)


#score: {'data3D.txt': -0.062859}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 + total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.40151380000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            
            priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x < 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x > 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            
            priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin + sum(1 for val in interacting_spins if val < 0)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New added logic
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val < 0)
  
  return(priorities)


#score: {'data3D.txt': -0.014173}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New added logic
        site_nbrs = [(i+1)%N, (j+1)%N, ((k+1)%3-1)]
        for d in range(3):
          if h[site_nbrs[d]][i][j] > 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= 2
            priorities[i*N*N+j*N+k][1] += 2
  
  return(priorities)


#score: {'data3D.txt': -0.4768646}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.4773842}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * (np.sum(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * (np.sum(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.4052602}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins)
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': 0.1842566}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(total_spin)
          priorities[i*N*N+j*N+k][0] += total_spin * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 * priority_coeff
        else:
          priority_coeff = np.exp(-total_spin)
          priorities[i*N*N+j*N+k][0] -= total_spin * priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2 * priority_coeff
  
  return(priorities)


#score: {'data3D.txt': -0.42958019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        # sort the interacting spins and calculate the hamming distance
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        # adjust priorities based on the sign of the spin, hamming distance, and magnetism
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.42693060000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # adjust priorities based on the sign of the spin and the hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # adjust priority based on the site's magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          
          # Calculate the number of interacting spins
          num_interacting_spins = sum([abs(val) for val in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] = -priority_total + num_interacting_spins
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          
          # Calculate the number of interacting spins
          num_interacting_spins = sum([abs(val) for val in interacting_spins])
          
          priorities[i*N*N+j*N+k][0] = -priority_total + num_interacting_spins
          priorities[i*N*N+j*N+k][1] = -priority_total
          
  return(priorities)


#score: {'data3D.txt': 0.19897499999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.43872500000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.1272793999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in range(6):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -1 + total_spin
            else:
              priorities[i*N*N+j*N+k][0] += magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.07060460000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # Add a bias towards the majority spin on each site
        if np.sum(J[:,i,j,k], axis=0) > 0:
          priorities[i*N*N+j*N+k][0] += 2
        elif np.sum(J[:,i,j,k], axis=0) < 0:
          priorities[i*N*N+j*N+k][1] += 2
  return(priorities)


#score: {'data3D.txt': -0.42433259999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) < 0)
  return(priorities)


#score: {'data3D.txt': -0.09532780000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0]) - (total_spin > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = len([val for val in interacting_spins if val > 0]) - (total_spin > 0)
  return(priorities)


#score: {'data3D.txt': -0.2600190000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.35264819999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.4084282}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) < 0)
  return(priorities)


#score: {'data3D.txt': -0.4084282}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) < 0)
  return(priorities)


#score: {'data3D.txt': -0.022524200000000116}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = [1+total_spin, -1-total_spin]
        else:
          priority_total = [-1+total_spin, 1-total_spin]
        priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': -0.43768500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0258422}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.31605019999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
  
  return(priorities)


#score: {'data3D.txt': -0.3268489999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * (np.sum(interacting_spins) < 0) + np.sum([int(x > 0) for x in interacting_spins])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * (np.sum(interacting_spins) > 0) + np.sum([int(x < 0) for x in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority coefficient based on the number of neighboring spins
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down) + np.sum([int(x > 0) for x in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down) + np.sum([int(x < 0) for x in interacting_spins])
  
  return(priorities)


#score: {'data3D.txt': -0.428619}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])

        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + abs(sum(J[0,i,j,k] > 0 for k in range(N)) - sum(J[1,(i+1)%N,j,k] > 0 for k in range(N)))
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - abs(sum(J[0,i,j,k] > 0 for k in range(N)) - sum(J[1,(i+1)%N,j,k] > 0 for k in range(N)))

  return(priorities)


#score: {'data3D.txt': -0.4524498}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * (np.sum(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + np.count_nonzero(np.array(interacting_spins) < 0)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * (np.sum(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
  
  return(priorities)


#score: {'data3D.txt': -0.3149361999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins[:3] if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins[:3] if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add bias for the site's own magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k])
          priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k])

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins[:3] if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins[:3] if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.3039666}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.22937180000000015}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  total_spins = [0, 0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin + len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*priority_total
        else:
          priority_total = -total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] -= 2 - 2*priority_total
        
  return(priorities)


#score: {'data3D.txt': -0.384717}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] += total_spin + sum([-int(x < 0) for x in interacting_spins]) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
            if abs(total_spin_neighbor) > 0.5:
              magnetism_coeff = np.exp(-abs(total_spin_neighbor))
              priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] += total_spin
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] -= total_spin + sum([int(x > 0) for x in interacting_spins]) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
            if abs(total_spin_neighbor) > 0.5:
              magnetism_coeff = np.exp(-abs(total_spin_neighbor))
              priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= total_spin
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.3039666}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(-int(x < 0) for x in interacting_spins) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x > 0) for x in interacting_spins) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': 0.4261698}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # Priority based on the interaction strength
        for d in range(3):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 2 * J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 2 * J[d,i,j,k]
  
  return(priorities)


#score: {'data3D.txt': -0.014679800000000139}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # Additional calculation to improve priority
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 2
        else:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] = -2
        
  return(priorities)


#score: {'data3D.txt': -0.29022620000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Additional calculation to improve priority
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        elif total_spin < 0:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # Improved priority calculation based on site interactions
        if h[site_nbr][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2664798000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3524782}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3109978}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.383587}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if J[0,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k]) * (np.sum([J[d,i,j,k] for d in [1,2]]) < 0) - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k]) * (np.sum([J[d,i,j,k] for d in [1,2]]) > 0) + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.2869866000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
  
  return(priorities)


#score: {'data3D.txt': -0.3071270000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + sum(int(x>0) for x in interacting_spins) + 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) - sum(int(x<0) for x in interacting_spins) - 1 + total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down) + abs(neighbor_left)
          priorities[i*N*N+j*N+k][1] -= 2*abs(neighbor_up - neighbor_down) + abs(neighbor_left)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down) + abs(neighbor_left)
          priorities[i*N*N+j*N+k][1] = 2*abs(neighbor_up - neighbor_down) - abs(neighbor_left)
  
  return(priorities)


#score: {'data3D.txt': -0.40322780000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          site_up = J[0, i, j, k]
          site_down = J[1, (i+1)%N, j, k]
          site_left = J[2, i, (j+1)%N, k]
          
          if site_up > 0 and site_down < 0:
            priorities[i*N*N+j*N+k][0] += 3
            priorities[i*N*N+j*N+k][1] -= 3
          elif site_up > 0 and site_left < 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 2
          
        else:
          site_up = J[0, i, j, k]
          site_down = J[1, (i+1)%N, j, k]
          site_left = J[2, i, (j+1)%N, k]
          
          if site_up < 0 and site_down > 0:
            priorities[i*N*N+j*N+k][0] -= 3
            priorities[i*N*N+j*N+k][1] += 3
          elif site_up < 0 and site_left > 0:
            priorities[i*N*N+j*N+k][0] -= 2
            priorities[i*N*N+j*N+k][1] += 2
        
  return(priorities)


#score: {'data3D.txt': -0.49796460000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0033538}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5)
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5)
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.34434180000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = magnetism_coeff * (hamming_distance > 0.5) - 0.2
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = -magnetism_coeff * (hamming_distance > 0.5) + 0.2
        priorities[i*N*N+j*N+k][0] += priority_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  return(priorities)


#score: {'data3D.txt': -0.34434180000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if priority_coeff > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if priority_coeff > 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] += 1 - total_spin

  return(priorities)


#score: {'data3D.txt': -0.48335500000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + (total_spin > 0).astype(float)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5) + (total_spin < 0).astype(float)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1597254000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2753070000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.21604180000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(site_energy, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          site_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(site_energy, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.201471}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          num_up = sum(1 for val in interacting_spins if val > 0)
          num_down = sum(1 for val in interacting_spins if val < 0)
          avg_spin = (num_up - num_down) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * ((avg_spin > 0.5) or (priority_coeff > 0.7))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          num_up = sum(1 for val in interacting_spins if val > 0)
          num_down = sum(1 for val in interacting_spins if val < 0)
          avg_spin = (num_up - num_down) / len(interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * ((avg_spin < -0.5) or (priority_coeff > 0.7))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1272822000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = [sum(val < 0 for val in interacting_spins) + total_spin, -sum(val > 0 for val in interacting_spins) - total_spin]
        else:
          priority_total = [-sum(val > 0 for val in interacting_spins) - total_spin, sum(val < 0 for val in interacting_spins) + total_spin]
        priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': -0.37369939999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = [1+total_spin, -1-total_spin]
        else:
          priority_total = [-1+total_spin, 1-total_spin]
        hamming_distance = sum([val > 0 for val in J[:,i,j,k]]) / max(len(J[:,i,j,k]), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.0111854}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = [np.sum([val for val in interacting_spins if val < 0]), -np.sum([val for val in interacting_spins if val > 0])]
        else:
          priority_total = [-np.sum([val for val in interacting_spins if val < 0]), np.sum([val for val in interacting_spins if val > 0])]
        priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': -0.008989}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += (magnetism_coeff + total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= (magnetism_coeff + total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.049482599999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
        if h[i][j][k] > 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if hamming_distance < 0.5:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] += total_spin
  return(priorities)


#score: {'data3D.txt': -0.2573426000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.3906114000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(np.sign(interacting_spins))
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(np.sign(interacting_spins)) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = np.sum(np.sign(interacting_spins))
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(np.sign(interacting_spins)) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.417467}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # adjust priorities based on the sign of the spin and the hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # adjust priority based on the site's magnetism and hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k]) * (hamming_distance < 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k]) * (hamming_distance < 0.5)
  
  return(priorities)


#score: {'data3D.txt': -0.3941826000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3778546}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = 1 - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += total_spin * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = 1 - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= total_spin * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.056781}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.1348046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.21604180000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          site_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(np.array(interacting_spins) < 0) > N/4))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(site_energy, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          site_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(np.array(interacting_spins) > 0) > N/4))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(site_energy, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.46746060000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = total_spin + sum(int(x>0) for x in interacting_spins)
          magnetism_coeff = np.exp(-abs(spin_energy))
          priorities[i*N*N+j*N+k][0] += spin_energy + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          spin_energy = total_spin + sum(int(x<0) for x in interacting_spins)
          magnetism_coeff = np.exp(-abs(spin_energy))
          priorities[i*N*N+j*N+k][0] -= spin_energy + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.440553}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          if abs(total_spin) > 0.5:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
            if hamming_distance > 0.5:
              magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][0] += total_spin + sum([-int(x < 0) for x in interacting_spins]) - magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
              if abs(total_spin_neighbor) > 0.5:
                magnetism_coeff = np.exp(-abs(total_spin_neighbor))
                priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
                priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
              else:
                priorities[i*N*N+j*N+k][0] += total_spin
                priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          if abs(total_spin) > 0.5:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
            if hamming_distance > 0.5:
              magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][0] -= total_spin + sum([int(x > 0) for x in interacting_spins]) - magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            else:
              total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
              if abs(total_spin_neighbor) > 0.5:
                magnetism_coeff = np.exp(-abs(total_spin_neighbor))
                priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
                priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
              else:
                priorities[i*N*N+j*N+k][0] -= total_spin
                priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.47387700000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if abs(total_spin_neighbor) > 0.5:
            priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if abs(total_spin_neighbor) > 0.5:
            priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.47422620000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if abs(total_spin + total_spin_neighbor) > 0.5:
            priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            hamming_distance_neighbor = len([val for val in [J[0,site_nbr,j,k], J[1,site_nbr,(j+1)%N,k], J[2,site_nbr,i,(k+1)%N]] if val < 0]) / max(len([J[0,site_nbr,j,k], J[1,site_nbr,(j+1)%N,k], J[2,site_nbr,i,(k+1)%N]]), 1)
            magnetism_coeff_neighbor = np.exp(-abs(total_spin_neighbor) * (hamming_distance_neighbor > 0.5))
            priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x>0) for x in interacting_spins) + magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - 2*magnetism_coeff_neighbor
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if abs(total_spin + total_spin_neighbor) > 0.5:
            priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            hamming_distance_neighbor = len([val for val in [J[0,site_nbr,j,k], J[1,site_nbr,(j+1)%N,k], J[2,site_nbr,i,(k+1)%N]] if val > 0]) / max(len([J[0,site_nbr,j,k], J[1,site_nbr,(j+1)%N,k], J[2,site_nbr,i,(k+1)%N]]), 1)
            magnetism_coeff_neighbor = np.exp(-abs(total_spin_neighbor) * (hamming_distance_neighbor > 0.5))
            priorities[i*N*N+j*N+k][0] -= total_spin + sum([-int(x < 0) for x in interacting_spins]) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - 2*magnetism_coeff_neighbor

  return(priorities)


#score: {'data3D.txt': -0.0008114000000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      priority_total = np.sum([val for val in interacting_spins if val < 0]) - total_spin
      priorities[i][0] += (priority_total + 1) / 2
      priorities[i][1] -= (priority_total - 1) / 2
    else:
      priority_total = np.sum([val for val in interacting_spins if val > 0]) - total_spin
      priorities[i][0] -= (priority_total + 1) / 2
      priorities[i][1] = -1 + (priority_total - 1) / 2
  return(priorities)


#score: {'data3D.txt': -0.0012478000000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      priority_coeff = np.exp(-abs(total_spin))
      priorities[i][0] += priority_coeff * (np.sum([val for val in interacting_spins if val < 0]) - total_spin)
      priorities[i][1] -= 1 + total_spin
    else:
      priority_coeff = np.exp(abs(total_spin))
      priorities[i][0] -= priority_coeff * (np.sum([val for val in interacting_spins if val > 0]) - total_spin)
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.003775}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) * (-h[i//N%N,(i//100)%N,(i%100)//10])
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) * (-h[i//N%N,(i//100)%N,(i%100)//10])
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.004197000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) + (total_spin > 0)
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) - (total_spin > 0)
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.17009019999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 1 + total_spin
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -1 + total_spin
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + priority_total

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.15615299999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  return(priorities)


#score: {'data3D.txt': 0.27864659999999986}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += sum(1 for d in range(6) if J[d,i,j,k] < 0)
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= sum(1 for d in range(6) if J[d,i,j,k] > 0)
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.15442059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = np.sum([j for j in interacting_spins if j < 0]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.4227950000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = priority_total - magnetism_coeff
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = priority_total + magnetism_coeff
  
  return(priorities)


#score: {'data3D.txt': -0.034495000000000206}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + priority_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff - total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + priority_coeff
  return(priorities)


#score: {'data3D.txt': -0.0255162}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin * spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  
  # Add a global term to the priority
  global_term = np.sum(h, axis=(0,1)) / N**3
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i*N*N+j*N+k][0] += global_term[0]
        priorities[i*N*N+j*N+k][1] -= global_term[0]
  
  return(priorities)


#score: {'data3D.txt': -0.1931006000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-1 - total_spin + hamming_distance)
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff)
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-1 - total_spin + hamming_distance)
  return(priorities)


#score: {'data3D.txt': -0.22829580000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.18063500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.18063500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.23203940000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.25427900000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.02903060000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += site_nbr_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
        site_nbr_spin = h[site_nbr][j][k]
        priorities[i*N*N+j*N+k][1] += -total_spin
  return(priorities)


#score: {'data3D.txt': -0.31605019999999984}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
  return(priorities)


#score: {'data3D.txt': -0.30814339999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
        # New improved term
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
  return priorities


#score: {'data3D.txt': -0.41716300000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= total_spin - abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = total_spin - abs(neighbor_up - neighbor_down)
  
  return(priorities)


#score: {'data3D.txt': -0.3155849999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
  
  return(priorities)


#score: {'data3D.txt': -0.4031538}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (total_spin > 0).astype(float)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (total_spin < 0).astype(float)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.20647620000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + 2
            priorities[i*N*N+j*N+k][1] -= 3 - priority_coeff
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff < 0.5)
            priorities[i*N*N+j*N+k][1] = -1
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff < 0.5) - 2
            priorities[i*N*N+j*N+k][1] = -3 + priority_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5)
            priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.12010740000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          for d in [0,1,2]:
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= 1
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4196130000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3941826000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0032750000000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) * sum(val > 0 for val in J[[0,2],i//N%N,(i//100)%N,(i%100)//10])
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) * sum(val < 0 for val in J[[0,2],i//N%N,(i//100)%N,(i%100)//10])
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0034162}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] += total_priority
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] -= total_priority
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.050802999999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.3341678}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.2844946}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.1597254000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_bias = max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_bias = max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_bias
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.03661219999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          if priority_coeff > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          if priority_coeff > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(-priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = 1 - total_spin - hamming_distance

  return(priorities)


#score: {'data3D.txt': -0.1597254000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.23783259999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # adjust priorities based on the sign of the spin and the hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # adjust priorities based on the absolute value of the interaction energy
        priorities[i*N*N+j*N+k][0] += abs(J[0,i,j,k]) + abs(J[1,(i+1)%N,j,k]) + abs(J[2,i,(j+1)%N,k])
        priorities[i*N*N+j*N+k][1] -= abs(J[0,i,j,k]) + abs(J[1,(i+1)%N,j,k]) + abs(J[2,i,(j+1)%N,k])
  return(priorities)


#score: {'data3D.txt': -0.1689909999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 2 * total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = 2 * total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.4075354}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k]) * (hamming_distance < 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -abs(h[i][j][k]) * (hamming_distance < 0.5)
  
  return(priorities)


#score: {'data3D.txt': -0.4086998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        
        # adjust priorities based on the sign of the spin and the hamming distance
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        # adjust priorities based on the absolute value of the spin and the hamming distance
        priorities[i*N*N+j*N+k][0] += abs(h[i][j][k]) * (hamming_distance > 0.5)
        priorities[i*N*N+j*N+k][1] -= abs(h[i][j][k]) * (hamming_distance < 0.5)
        
  return(priorities)


#score: {'data3D.txt': -0.48335500000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff2 = (sum(J[d,i,j,k] for d in [0,1,2]) > 0).astype(float)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + priority_coeff2
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff2 = (sum(J[d,i,j,k] for d in [0,1,2]) < 0).astype(float)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5) + priority_coeff2
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2566686000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_energy = total_spin * (1 - np.tanh(abs(total_spin)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + site_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_energy = -total_spin * (1 + np.tanh(abs(total_spin)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5) + site_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5042814}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = -np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + (total_spin > 0).astype(float) + spin_moment
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5) + (total_spin < 0).astype(float) - spin_moment
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4476122}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5) + total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0033082000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,4,5]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,4,5])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] += total_priority
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] -= total_priority
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.013828600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//1000%N,(i//10)%N,i%10] for d in [0,1,2,3,4,5]]
    total_spin = sum(J[d,i//1000%N,(i//10)%N,i%10] for d in [0,1,2,3,4,5])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//1000%N,(i//10)%N,i%10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] += total_priority
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] -= total_priority
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0037825999999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,3,4,5]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,3,4,5])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] += total_priority
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      total_priority = (priority_coeff + 1) * magnetism_coeff
      priorities[i][0] -= total_priority
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + (hamming_distance >= len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + (hamming_distance >= len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
  return(priorities)


#score: {'data3D.txt': -0.24798780000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance + np.count_nonzero(np.array(interacting_spins) < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance + np.count_nonzero(np.array(interacting_spins) > 0)
  return(priorities)


#score: {'data3D.txt': -0.4742918000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        # Add interaction between neighboring sites
        for d in range(3):
          site_nbr2 = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.11998099999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_up_parity = total_spin + 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_up_parity > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - spin_up_parity
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_down_parity = total_spin - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_down_parity > 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -1 + spin_down_parity
  return(priorities)


#score: {'data3D.txt': -0.30474459999999987}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * (np.sum(interacting_spins) < 0) + np.sum([int(x > 0) for x in interacting_spins])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * (np.sum(interacting_spins) > 0) + np.sum([int(x < 0) for x in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # Calculate the priority coefficient based on the number of neighboring spins
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down) + np.sum([int(x > 0) for x in interacting_spins])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down) + np.sum([int(x < 0) for x in interacting_spins])
        
        # Add a term based on the number of neighbors with opposite spin
        opposites = sum([x for x in interacting_spins if x * h[i][j][k] < 0])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += opposites
          priorities[i*N*N+j*N+k][1] -= opposites
        else:
          priorities[i*N*N+j*N+k][0] -= opposites
          priorities[i*N*N+j*N+k][1] = opposites
  
  return(priorities)


#score: {'data3D.txt': -0.26887340000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.20507820000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          spin_value = 1
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          spin_value = -1
        if h[site_nbr][j][k] == spin_value:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2596506000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.20401020000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': 0.1648494}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if np.mean(interacting_spins) > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.3051342000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.abs(J[:,i,j,k])) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.abs(J[:,i,j,k])) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.004687800000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.4884498000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New added logic
        if h[i][j][k] > 0:
          spin_sum = sum(1 for val in interacting_spins if val < 0)
          if spin_sum >= N//2:
            priorities[i*N*N+j*N+k][0] += N - 2*spin_sum
            priorities[i*N*N+j*N+k][1] -= 2*(N - spin_sum)
        else:
          spin_sum = sum(1 for val in interacting_spins if val > 0)
          if spin_sum >= N//2:
            priorities[i*N*N+j*N+k][0] -= 2*spin_sum
            priorities[i*N*N+j*N+k][1] += N - 2*spin_sum
        
  return(priorities)


#score: {'data3D.txt': -0.29769979999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_sum = sum(1 for x in interacting_spins if x < 0) - len([x for x in interacting_spins if x > 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (1 + total_sum)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_sum = sum(1 for x in interacting_spins if x > 0) - len([x for x in interacting_spins if x < 0])
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (1 + total_sum)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.42107500000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_sum = sum(1 for x in interacting_spins if x < 0) - len([x for x in interacting_spins if x > 0])
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_sum + 2)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (2 - 2*total_spin)
        else:
          total_sum = sum(1 for x in interacting_spins if x > 0) - len([x for x in interacting_spins if x < 0])
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_sum + 2)
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff * (2 - 2*total_spin)
  return(priorities)


#score: {'data3D.txt': -0.3929266}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += priority_coeff * (sum(1 for x in interacting_spins if x < 0) - len([x for x in interacting_spins if x > 0]))
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (2 - 2*total_spin)
        else:
          priority_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (sum(1 for x in interacting_spins if x > 0) - len([x for x in interacting_spins if x < 0]))
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (2 - 2*total_spin)
  return(priorities)


#score: {'data3D.txt': -0.45489700000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_sum = sum(1 for x in interacting_spins if x < 0) - len([x for x in interacting_spins if x > 0])
          hamming_distance = sum(1 for val in interacting_spins[:3] if val < 0) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + abs(total_spin) + total_sum
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          total_sum = sum(1 for x in interacting_spins if x > 0) - len([x for x in interacting_spins if x < 0])
          hamming_distance = sum(1 for val in interacting_spins[:3] if val > 0) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + abs(total_spin) + total_sum
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.2241358}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          priority_coeff = magnetism_coeff * (hamming_distance > 0.5) + total_spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          priority_coeff = -magnetism_coeff * (hamming_distance > 0.5) + total_spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1970966}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (total_spin > 0).astype(float)
          priority_coeff += np.sum((h[i][j][k] - h[site_nbr][k])**2)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (total_spin < 0).astype(float)
          priority_coeff -= np.sum((h[i][j][k] - h[site_nbr][k])**2)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.30588660000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (total_spin > 0).astype(float)
          site_interaction = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + site_interaction
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priority_coeff = (hamming_distance > 0.5) * (total_spin < 0).astype(float)
          site_interaction = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + site_interaction
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.42552180000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_up = np.exp(-abs(total_spin)) * (1 + sum(1 for x in interacting_spins if x < 0) - len([x for x in interacting_spins if x > 0]))
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_down = np.exp(-abs(total_spin)) * (1 + sum(1 for x in interacting_spins if x > 0) - len([x for x in interacting_spins if x < 0]))
          priorities[i*N*N+j*N+k][0] -= priority_down
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        if site_spin > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= total_spin - abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = total_spin - abs(neighbor_up - neighbor_down)
        
  return(priorities)


#score: {'data3D.txt': -0.4871798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3201642}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for x in interacting_spins if x < 0)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum(1 for x in interacting_spins if x > 0)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.24960260000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins))
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (np.prod([x>0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins))
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
  return(priorities)


#score: {'data3D.txt': -0.004197000000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) + (total_spin > 0)
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) - (total_spin > 0)
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0050934000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,3,4,5]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,3,4,5])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) + total_spin
      priorities[i][1] -= 2 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) - total_spin
      priorities[i][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.006086599999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,3,4,5]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2,3,4,5])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) + (total_spin > 0)
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) - (total_spin > 0)
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.27506340000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[d,i,j,k] for d in [0,1,2])
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += total_spin
        priorities[i*N*N+j*N+k][1] -= 1
      else:
        priorities[i*N*N+j*N+k][0] -= total_spin
        priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.4289306000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_moment = -np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + spin_moment
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_moment = np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin - spin_moment
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = h[i][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_magnetism + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_magnetism = -h[i][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_magnetism + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.15442059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = -np.sum([j for j in interacting_spins if j > 0]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.27143860000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -(priority_total / 3)
          priorities[i*N*N+j*N+k][1] = (priority_total / 3)
        else:
          priority_total = np.sum([j for j in interacting_spins if j < 0]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -(priority_total / 2)
          priorities[i*N*N+j*N+k][1] = (priority_total / 2)
  return(priorities)


#score: {'data3D.txt': -0.15442059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = -np.sum([j for j in interacting_spins if j > 0]) - abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.25956780000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -1
  for i in range(N):
    for j in range(N):
      site_nbr_spin = h[site_nbr][j][k]
      if abs(site_nbr_spin) > 0:
        priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
        priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.3678866}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = max(-abs(total_spin), 0) + total_spin + sum(1 for val in interacting_spins if val > 0)
        else:
          priority_coeff = -max(abs(total_spin), 0) - total_spin + sum(1 for val in interacting_spins if val < 0)
        priorities[i*N*N+j*N+k][0] += max(priority_coeff, 0)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.2852594000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[site_nbr][j][k]))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.065467}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
        else:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = priority_total + total_spin

        # Calculate the hamming distance
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)

        # Apply a correction term based on the magnetism and hamming distance
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][1] -= total_spin

  return(priorities)


#score: {'data3D.txt': -0.014232600000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[d,i,j,k] for k in range(N) for d in [0,1,2])
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      for k in range(N):
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in [0,1,2]:
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
        else:
          priority_total = total_spin
          for d in [0,1,2]:
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = priority_total + total_spin

  return(priorities)


#score: {'data3D.txt': -0.023956200000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = priority_total - total_spin - magnetism_coeff
        else:
          priority_total = abs(total_spin)
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = priority_total + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4216882000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][0] += total_spin + sum(int(x > 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][0] -= total_spin + sum(int(x < 0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        # New added logic
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i*N*N+j*N+k][0] -= sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] += sum(1 for val in interacting_spins if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.45103740000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] += total_spin + sum([-int(x < 0) for x in interacting_spins])
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
            if abs(total_spin_neighbor) > 0.5:
              priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] += total_spin
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][0] -= total_spin + sum([int(x > 0) for x in interacting_spins])
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
            if abs(total_spin_neighbor) > 0.5:
              priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= total_spin
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.384717}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] += total_spin + sum([-int(x < 0) for x in interacting_spins]) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
            if abs(total_spin_neighbor) > 0.5:
              magnetism_coeff = np.exp(-abs(total_spin_neighbor))
              priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] += total_spin
              priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] -= total_spin + sum([int(x > 0) for x in interacting_spins]) - magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
            if abs(total_spin_neighbor) > 0.5:
              magnetism_coeff = np.exp(-abs(total_spin_neighbor))
              priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= total_spin
              priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.47387700000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if abs(total_spin_neighbor) > 0.5:
            priorities[i*N*N+j*N+k][0] += total_spin + total_spin_neighbor
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += total_spin
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_neighbor = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          if abs(total_spin_neighbor) > 0.5:
            priorities[i*N*N+j*N+k][0] -= total_spin + total_spin_neighbor
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= total_spin
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.0244814}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_diff = len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * abs(spin_diff) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          spin_diff = len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * abs(spin_diff) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.35522460000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin

        site_nbr = (j + ((i-1)%N - N//2)) % N
        total_spin += h[site_nbr][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': -0.33614539999999965}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
        # new added logic
        if h[i][j][k] > 0:
          spin_sum = sum(1 for val in interacting_spins if val < 0)
          if spin_sum >= N//2:
            priorities[i*N*N+j*N+k][0] += N - 2*spin_sum
            priorities[i*N*N+j*N+k][1] -= 2*(N - spin_sum)
        else:
          spin_sum = sum(1 for val in interacting_spins if val > 0)
          if spin_sum >= N//2:
            priorities[i*N*N+j*N+k][0] -= N - 2*spin_sum
            priorities[i*N*N+j*N+k][1] = 2*(N - spin_sum)
        
        # new added logic
        neighbor_up_left = sum(J[0, i, j, k] > 0 for (k, j) in zip(range(N), range(j+1, N)))
        neighbor_down_right = sum(J[1, i, j, k] > 0 for (k, j) in zip(range(i+1, N), range(N)))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up_left - neighbor_down_right)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up_left - neighbor_down_right)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up_left - neighbor_down_right)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up_left - neighbor_down_right)
  
  return(priorities)


#score: {'data3D.txt': -0.3155849999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
        if h[i][j][k] > 0:
          spin_sum = sum(1 for val in interacting_spins if val < 0)
          if spin_sum >= N//2:
            priorities[i*N*N+j*N+k][0] += N - 2*spin_sum
            priorities[i*N*N+j*N+k][1] -= 2*(N - spin_sum)
        else:
          spin_sum = sum(1 for val in interacting_spins if val > 0)
          if spin_sum >= N//2:
            priorities[i*N*N+j*N+k][0] -= 2*spin_sum
            priorities[i*N*N+j*N+k][1] += N - 2*spin_sum
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x>0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.prod([x<0 for x in interacting_spins]) + sum(int(x<0) for x in interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        neighbor_up = sum(J[0, i, j, k] > 0 for k in range(N))
        neighbor_down = sum(J[1, i, j, k] > 0 for k in range(N))
        neighbor_left = sum(J[2, i, j, k] > 0 for j in range(N))
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] -= abs(neighbor_up - neighbor_down)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(neighbor_up - neighbor_down)
          priorities[i*N*N+j*N+k][1] = abs(neighbor_up - neighbor_down)
        
        # New added logic
        site_neighbors = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        spin_sum = sum(int(x > 0) for x in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += N - 2*spin_sum
          priorities[i*N*N+j*N+k][1] -= 2*(N - spin_sum)
        else:
          priorities[i*N*N+j*N+k][0] -= N - 2*spin_sum
          priorities[i*N*N+j*N+k][1] = 2*(N - spin_sum)
  
  return(priorities)


#score: {'data3D.txt': -0.27296140000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + 4 * np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_coeff = -total_spin + 4 * np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4603106}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_energy > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_energy > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.38666300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20171859999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_magnetism = total_spin
          if sum(1 for val in interacting_spins if val > 0) > len(interacting_spins) / 2:
            spin_magnetism += 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_magnetism + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_magnetism = -total_spin
          if sum(1 for val in interacting_spins if val < 0) > len(interacting_spins) / 2:
            spin_magnetism -= 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_magnetism + 1)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.33032820000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  for i in range(N**3):
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.4476122}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          if priority_coeff > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0.5) + total_spin_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          if priority_coeff > 0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0.5) + total_spin_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1896074000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          spin_flip_energy = -h[i][j][k] - sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + total_spin_coeff + spin_flip_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          spin_flip_energy = h[i][j][k] - sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + total_spin_coeff + spin_flip_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.13023180000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          interacting_spin_sum = sum(val for val in interacting_spins if val < 0)
          if interacting_spin_sum >= 0:
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff
            priorities[i*N*N+j*N+k][0] += 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          interacting_spin_sum = sum(val for val in interacting_spins if val > 0)
          if interacting_spin_sum >= 0:
            priorities[i*N*N+j*N+k][1] -= magnetism_coeff
            priorities[i*N*N+j*N+k][0] += 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.1348046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - abs(h[i][j][k]))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3993202}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  # normalize the priorities for each site
  for i in range(N**3):
    norm = np.linalg.norm(priorities[i])
    if norm > 0:
      priorities[i] /= norm
  
  return(priorities)


#score: {'data3D.txt': -0.1929694}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          total_spin += np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          total_spin -= np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          priorities[i*N*N+j*N+k][0] = -total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priority_total = total_spin + np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priority_total = total_spin + np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': 0.1917322000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_total = -total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = magnetism_coeff * (priority_total + hamming_distance)
          priorities[i*N*N+j*N+k][1] = -total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -magnetism_coeff * (priority_total - hamming_distance)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.12046379999999982}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20708140000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.24444780000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + hamming_distance

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.022558599999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - 3 * hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - 3 * hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - 2 * sum(1 for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.2861850000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          if hamming_distance > 0.5:
            spin_moment = -np.sum(np.sign(h)) / N**3
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_moment
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            spin_moment = np.sum(np.sign(h)) / N**3
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance < 0.5) + total_spin - spin_moment
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          if hamming_distance < 0.5:
            spin_moment = -np.sum(np.sign(h)) / N**3
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance < 0.5) + total_spin - spin_moment
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            spin_moment = np.sum(np.sign(h)) / N**3
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_moment
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin

  return(priorities)


#score: {'data3D.txt': -0.4907722000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_moment = -np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance + total_spin + spin_moment
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_moment = np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance + total_spin - spin_moment
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_moment = -np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_distance + total_spin + spin_moment
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_moment = np.sum(np.sign(h)) / N**3
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_distance + total_spin - spin_moment
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.18676700000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance

        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin

  return(priorities)


#score: {'data3D.txt': -0.2289222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.2289222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance - site_nbr_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy - site_nbr_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance + site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.14560180000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.14984019999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += 1
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= 1
              priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += 1
              priorities[i*N*N+j*N+k][1] -= 1
            else:
              priorities[i*N*N+j*N+k][0] -= 1
              priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.12635100000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += 1
        priorities[i*N*N+j*N+k][1] -= 1
      else:
        priorities[i*N*N+j*N+k][0] -= 1
        priorities[i*N*N+j*N+k][1] = -1

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j][k] > 0:
      total_spin += 1
    else:
      total_spin -= 1

  return(priorities)


#score: {'data3D.txt': -0.1245962000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          spin_flip_energy = -h[i][j][k] - sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + total_spin_coeff + spin_flip_energy - hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          spin_flip_energy = h[i][j][k] - sum(J[d,i,j,k] for d in [0,1,2])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + total_spin_coeff + spin_flip_energy - hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.16134060000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priority_coeff = sum([val < 0 for val in interacting_spins]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin > 0).astype(float) * 2
          spin_flip_energy = -h[i][j][k] - sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + total_spin_coeff + spin_flip_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priority_coeff = sum([val > 0 for val in interacting_spins]) / max(len(interacting_spins), 1)
          total_spin_coeff = (total_spin < 0).astype(float) * 2
          spin_flip_energy = h[i][j][k] - sum(J[d,i,j,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + total_spin_coeff + spin_flip_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.201471}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          num_up = sum(1 for val in interacting_spins if val > 0)
          num_down = sum(1 for val in interacting_spins if val < 0)
          avg_spin = (num_up - num_down) / len(interacting_spins)
          if avg_spin > 0.5:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * 2
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * (avg_spin + 0.5)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          num_up = sum(1 for val in interacting_spins if val > 0)
          num_down = sum(1 for val in interacting_spins if val < 0)
          avg_spin = (num_up - num_down) / len(interacting_spins)
          if avg_spin < -0.5:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * 2
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (avg_spin - 0.5)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.48630060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.4391798}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          avg_magnetism = np.mean([abs(x) for x in interacting_spins])
          avg_spin = total_spin / len(interacting_spins)
          magnetism_coeff = np.exp(-avg_magnetism)
          priority_coeff = (avg_spin > 0.5) or (magnetism_coeff > 0.8)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          avg_magnetism = np.mean([-x for x in interacting_spins])
          avg_spin = total_spin / len(interacting_spins)
          magnetism_coeff = np.exp(avg_magnetism)
          priority_coeff = (avg_spin < -0.5) or (magnetism_coeff > 0.8)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1644638}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.12405580000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': 0.056159000000000174}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance + priority_coeff * (priority_coeff < 0)
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + priority_coeff * (priority_coeff < 0)
  return(priorities)


#score: {'data3D.txt': -0.002664999999999991}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
          interacting_spins.sort()
          if interacting_spins[1] < 0 and interacting_spins[-2] > 0:
            priorities[i*N*N+j*N+k][0] += 10
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': 0.286661}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.44043420000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][j][k]))
          priority_coeff = np.exp(-abs(sum(x for x in interacting_spins if x < 0)) * len([x for x in interacting_spins if x < 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][j][k]))
          priority_coeff = np.exp(-abs(sum(x for x in interacting_spins if x > 0)) * len([x for x in interacting_spins if x > 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.37172980000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + sum(int(x > 0) for x in interacting_spins)
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + sum(int(x < 0) for x in interacting_spins)
  
  return(priorities)


#score: {'data3D.txt': 0.027992599999999698}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * abs(h[i][site_nbr][k]))
          priority_coeff = 2*np.tanh(np.mean([x for x in interacting_spins if x < 0]))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin) * abs(h[i][site_nbr][k]))
          priority_coeff = 2*np.tanh(np.mean([x for x in interacting_spins if x > 0]))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.0053026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      spin_moment = -np.sum(np.sign(h)) / N**3
      priorities[i][0] += magnetism_coeff * hamming_distance + total_spin + spin_moment
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      spin_moment = np.sum(np.sign(h)) / N**3
      priorities[i][0] -= magnetism_coeff * hamming_distance + total_spin - spin_moment
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0038537999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      spin_moment = -np.sum(np.sign(h)) / N**3
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) * sum(val > 0 for val in J[[0,2],i//N%N,(i//100)%N,(i%100)//10]) + spin_moment
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      spin_moment = np.sum(np.sign(h)) / N**3
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) * sum(val < 0 for val in J[[0,2],i//N%N,(i//100)%N,(i%100)//10]) - spin_moment
      priorities[i][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0031138000000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      spin_moment = -np.sum(np.sign(h)) / N**3
      priorities[i][0] += magnetism_coeff * priority_coeff * total_spin + spin_moment
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      spin_moment = np.sum(np.sign(h)) / N**3
      priorities[i][0] -= magnetism_coeff * priority_coeff * total_spin - spin_moment
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.0025666}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N**3):
    interacting_spins = [J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2]]
    total_spin = sum(J[d,i//N%N,(i//100)%N,(i%100)//10] for d in [0,1,2])
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N%N,(i//100)%N,(i%100)//10] > 0:
      magnetism_coeff = np.exp(-abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
      spin_moment = -np.sum(np.sign(h)) / N**3
      priorities[i][0] += magnetism_coeff * (priority_coeff > 0.5) * sum(val > 0 for val in J[[0,2],i//N%N,(i//100)%N,(i%100)//10]) + total_spin + spin_moment
      priorities[i][1] -= 1 - total_spin
    else:
      magnetism_coeff = np.exp(abs(total_spin))
      priority_coeff = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
      spin_moment = np.sum(np.sign(h)) / N**3
      priorities[i][0] -= magnetism_coeff * (priority_coeff > 0.5) * sum(val < 0 for val in J[[0,2],i//N%N,(i//100)%N,(i%100)//10]) - total_spin + spin_moment
      priorities[i][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_total = [sum(1 if spin < 0 else 0 for spin in interacting_spins), -sum(1 if spin > 0 else 0 for spin in interacting_spins)]
        else:
          priority_total = [-sum(1 if spin > 0 else 0 for spin in interacting_spins), sum(1 if spin < 0 else 0 for spin in interacting_spins)]
        priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': 0.06879540000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k] = np.array([1+total_spin, -1-total_spin])
        else:
          priority_total = [-1+total_spin, 1-total_spin]
          interacting_spins.sort()
          for d in range(6):
            if interacting_spins[d] > 0:
              priority_total[0] += 1
              priority_total[1] -= 2 - total_spin
            else:
              priority_total[0] -= 1
              priority_total[1] = -1 + total_spin
          priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        if h[i][j][k] > 0:
          priority_total = [(priority + total_spin) / max(len(interacting_spins), 1) for priority in (1, -1)]
          priorities[i*N*N+j*N+k] = np.array(priority_total)
        else:
          priority_total = [(-priority + total_spin) / max(len(interacting_spins), 1) for priority in (-1, 1)]
          priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': -0.31668900000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate the interaction energy at each site
  energy_matrix = np.zeros((N, N, N, 6))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in range(6):
          energy_matrix[i][j][k][d] = J[d, (i + ((k-1)%2 - 1)) % N, j, k]
          
  # Calculate the magnetism coefficient and priority coefficients
  magnetism_coeffs = np.exp(-abs(h.flatten()))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = energy_matrix[i][j][k].flatten()
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priority_coeffs = (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
        else:
          priority_coeffs = (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
        
        # Calculate the priority based on the interaction energy and magnetism
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(energy_matrix[i][j][k].flatten())
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeffs[site_nbr]*priority_coeffs*(1+total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeffs[site_nbr]*priority_coeffs*(1+total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.007385799999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], 
                   J[3,(i+N-1)%N,j,k], J[4,i,(k+1)%N,k], J[5,(i+N-1)%N,(j+k)%N,N-1]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = [(np.sum([val for val in interacting_spins if val < 0]) - total_spin), 
                    -(np.sum([val for val in interacting_spins if val > 0]) + total_spin)]
        else:
          priority_total = [-(np.sum([val for val in interacting_spins if val < 0]) - total_spin), 
                    (np.sum([val for val in interacting_spins if val > 0]) + total_spin)]
        priorities[i*N*N+j*N+k] = np.array(priority_total)
  return(priorities)


#score: {'data3D.txt': 0.2888749999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
              priorities[i*N*N+j*N+k][1] += 2
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
              priorities[i*N*N+j*N+k][1] -= 2
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': 0.31317620000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': 0.14208900000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k])
              priorities[i*N*N+j*N+k][1] += 2
        else:
          for d in range(6):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= abs(J[d,i,j,k])
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][0] += abs(J[d,i,j,k])
              priorities[i*N*N+j*N+k][1] -= 2

  return(priorities)


#score: {'data3D.txt': 0.31317620000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          for d in range(6):
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] -= 2
            else:
              priorities[i*N*N+j*N+k][1] += 2
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * abs(total_spin)
        else:
          for d in range(6):
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][1] += 2
            else:
              priorities[i*N*N+j*N+k][1] -= 2
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.19985499999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate additional priority terms based on the interaction with other spins
        for d in [0,1,2]:
          for l in range(3):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,i,j,l]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] = -1 + J[d,i,j,l]

  return(priorities)


#score: {'data3D.txt': -0.17890299999999998}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate additional priority terms based on the interaction with other spins
        for d in [0,1,2]:
          for l in range(3):
            if J[d,i,j,k] > 0:
              hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
              magnetism_coeff = np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][0] += magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,i,j,l]
            else:
              hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
              magnetism_coeff = np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -1 + J[d,i,j,l]

  return([p for p in priorities])


#score: {'data3D.txt': -0.23811340000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate additional priority terms based on the interaction with other spins
        for d in [0,1,2]:
          if J[d,i,j,k] > 0:
            site_priority = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] += site_priority
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            site_priority = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] -= site_priority
            priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.022253400000000128}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] -= 1 - total_spin - J[d,i,j,l]
              else:
                priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] = -1 + total_spin + J[d,i,j,l]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] = -1 + total_spin + J[d,i,j,l]
              else:
                priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] -= 1 - total_spin - J[d,i,j,l]

  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.22400900000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(total_spin > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(total_spin < 0)
          else:
            priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1765038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin - magnetism_coeff
        for d in [0,1,2]:
          for l in range(3):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,i,j,l]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] = -1 + J[d,i,j,l]

  return(priorities)


#score: {'data3D.txt': -0.19985499999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)

        # Calculate additional priority terms based on the interaction with other spins
        for d in [0,1,2]:
          for l in range(3):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,i,j,l]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] = -1 + J[d,i,j,l]

  return(priorities)


#score: {'data3D.txt': -0.3906114000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.4077810000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + magnetism_coeff
        if i > 0:
          site_nbr_x = (i-1)%N
          priorities[i*N*N+j*N+k][0] += J[5,i,j,k]
          priorities[i*N*N+j*N+k][1] -= J[4,i,j,k]
          if j > 0:
            site_nbr_y = (j-1)%N
            priorities[i*N*N+j*N+k][0] += J[3,i,j,k]
            priorities[i*N*N+j*N+k][1] -= J[2,i,j,k]
            if k > 0:
              site_nbr_z = (k-1)%N
              priorities[i*N*N+j*N+k][0] += J[1,i,j,k]
              priorities[i*N*N+j*N+k][1] -= J[0,i,j,k]
  return(priorities)


#score: {'data3D.txt': -0.3906114000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_factor = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin + spin_factor
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - magnetism_coeff - spin_factor
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_factor = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin + spin_factor
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + magnetism_coeff + spin_factor

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.11048540000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        # Calculate priority based on site interactions and magnetism
        for d in [0, 1, 2]:
          for p in [(i-1)%N, (i+1)%N]:
            if h[p][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.48278220000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.46691380000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -total_spin
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] = priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.42715860000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins.sort(reverse=True)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.06253940000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.32755100000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6))
        priority_total = total_spin
        
        if h[i][j][k] > 0:
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
          
        # calculate hamming distance
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin > 0)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total + magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.48278220000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                    J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0611614}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -total_spin
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.16822980000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                    J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.1626754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) - abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.43768500000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins.sort(reverse=True)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          interacting_spins.sort()
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.1559741999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[d,i,j,k] for d in range(6))
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][1] += abs(total_spin) * (total_spin > 0)
      else:
        priorities[i*N*N+j*N+k][1] -= abs(total_spin) * (total_spin < 0)
  return(priorities)


#score: {'data3D.txt': -0.10762100000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  for i in range(N):
    for j in range(N):
      if h[i][j].sum() > 0:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += 1
          priorities[i*N*N+j*N+k][1] -= 1
      else:
        for k in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= 1
          priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin[i][j][k] += h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) > 0.5))
        else:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) > 0.5))

        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -1 + total_spin[i][j][k][0]

  return([p for p in priorities])


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] += magnetism_coeff
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] -= magnetism_coeff
          priorities[i * N * N + j * N + k][1] = -1 + total_spin

  return [[p[0], p[1]] for p in priorities]


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return([p for p in priorities])


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = priority_total - abs(total_spin)
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -priority_total - abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.4352146}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.1897481999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + np.sum([np.sign(J[d,i,j,k]) * np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))) for d in range(6)])
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + np.sum([np.sign(J[d,i,j,k]) * np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))) for d in range(6)])
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.4398722000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        # calculate hamming distance and magnetism coefficient
        interacting_spins.sort()
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + priority_total
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.2735014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.08880300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - sum([J[3,i,j,k] for k in range(N)])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = total_spin - sum([J[3,i,j,k] for k in range(N)])
  
  return(priorities)


#score: {'data3D.txt': -0.05918540000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
  return(priorities)


#score: {'data3D.txt': -0.1913018000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + hamming_distance * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += total_spin - hamming_distance * abs(total_spin)
  
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Calculate priority based on magnetism and total spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Calculate priority based on magnetism and total spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3906114000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 4 * np.exp(-abs(total_spin) / 3)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= 4 * np.exp(-abs(total_spin) / 3)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.056781}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': 0.06491739999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        spin_sum = sum(1 for val in interacting_spins if val > 0)
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + magnetism_coeff * (spin_sum - abs(total_spin) / 2)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - magnetism_coeff * (spin_sum - abs(total_spin) / 2)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.0257634}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  for i in range(N**3):
    if priorities[i][0] > 0:
      priorities[i][0] += sum(priorities[j][1] for j in range(i+1))
    elif priorities[i][0] < 0:
      priorities[i][0] -= sum(priorities[j][1] for j in range(i+1))
  return(priorities)


#score: {'data3D.txt': 0.3468357999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = np.sum(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
  return(priorities)


#score: {'data3D.txt': -0.37964820000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  # Calculate the average magnetism for each site
  avg_magnetism = np.mean(h)

  # Adjust priorities based on the sign of the spin and the average magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += (avg_magnetism + total_spin)
          priorities[i*N*N+j*N+k][1] -= avg_magnetism - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= (avg_magnetism + total_spin)
          priorities[i*N*N+j*N+k][1] = avg_magnetism - total_spin

  return(priorities)


#score: {'data3D.txt': 0.022253400000000128}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] -= 1 - total_spin - J[d,i,j,l]
              else:
                priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] = -1 + total_spin + J[d,i,j,l]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                priorities[i*N*N+j*N+k][0] -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] = -1 + total_spin + J[d,i,j,l]
              else:
                priorities[i*N*N+j*N+k][0] += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
                priorities[i*N*N+j*N+k][1] -= 1 - total_spin - J[d,i,j,l]

  return(priorities)


#score: {'data3D.txt': -0.22739780000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          hamming_factor = np.exp(-hamming_distance * (total_spin > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_factor
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          hamming_factor = np.exp(-hamming_distance * (total_spin < -0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_factor
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1192174}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = 1 - total_spin
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                site_priority += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              else:
                site_priority -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = site_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = -1 + total_spin
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                site_priority -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              else:
                site_priority += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -site_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2096294}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          site_priority = np.tanh(total_spin) * 0.5 + 0.5
          for d in [0,1,2]:
            for l in range(3):
              site_priority += J[d,i,j,k] * J[d,i,j,l]
          priorities[i*N*N+j*N+k][0] = site_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          site_priority = np.tanh(total_spin) * 0.5 - 0.5
          for d in [0,1,2]:
            for l in range(3):
              site_priority -= J[d,i,j,k] * J[d,i,j,l]
          priorities[i*N*N+j*N+k][0] = -site_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.14940339999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin + magnetism_coeff
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                site_priority += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              else:
                site_priority -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = site_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin - magnetism_coeff
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                site_priority -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              else:
                site_priority += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -site_priority
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.13935020000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin - magnetism_coeff
        for d in [0,1,2]:
          for l in range(3):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,i,j,l]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][1] = -1 + J[d,i,j,l]

    total_spin_sum = np.sum(np.sum(h, axis=2), axis=1)
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[i][j][0] > 0:
          priorities[i*N*N+j*N+0][0] += total_spin_sum[i]
          priorities[i*N*N+j*N+0][1] -= total_spin_sum[i]
        else:
          priorities[i*N*N+j*N+0][0] -= total_spin_sum[i]
          priorities[i*N*N+j*N+0][1] = -total_spin_sum[i]

  return priorities


#score: {'data3D.txt': -0.0257962}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_priority = (total_spin > 0) * (1 - np.exp(-abs(total_spin))) + (total_spin < 0) * (-1 + np.exp(abs(total_spin)))
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        site_priority += magnetism_coeff * sum(np.sign(J[d,i,j,k]) * np.exp(-np.abs(J[d,i,j,l])) for d in [0,1,2] for l in range(3))
        priorities[i*N*N+j*N+k][0] = site_priority
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Calculate priority based on magnetism and total spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Calculate priority based on magnetism and total spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.16822980000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Check if the site is on the boundary
          if i == 0 or j == 0 or k == 0:
            if i == 0: 
              boundaries = [J[1,i-1,j,k], J[4,i,j,k]]
            elif j == 0:
              boundaries = [J[2,i,j-1,k], J[5,i,(j+1)%N,k]]
            else:
              boundaries = []
            hamming_distance += len([val for val in boundaries if val < 0]) / max(len(boundaries), 1)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Check if the site is on the boundary
          if i == N-1 or j == N-1 or k == N-1:
            if i == N-1: 
              boundaries = [J[1,(i-1)%N,j,k], J[4,i,j,k]]
            elif j == N-1:
              boundaries = [J[2,i,j-1,k], J[5,i,(j+1)%N,k]]
            else:
              boundaries = []
            hamming_distance += len([val for val in boundaries if val > 0]) / max(len(boundaries), 1)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.16822980000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= total_spin_coeff
          priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.15140460000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += total_spin
        
        # Calculate priority based on site interactions and magnetism
        for d in [3]:
          for p in [(i-1)%N, (i+1)%N]:
            if h[p][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] = -total_spin
        
        for d in [4, 5]:
          for p in [(i-1)%N, (i+1)%N]:
            if h[p][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.11100860000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Calculate priority based on site interactions and magnetism
        for d in [0, 1, 2]:
          for p in [(i-1)%N, (i+1)%N]:
            if h[p][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] = -total_spin
        
        # Calculate priority based on neighboring sites
        for d in [3, 4, 5]:
          for p in [(i-1)%N, (i+1)%N]:
            if h[p][j][k] > 0:
              priorities[i*N*N+j*N+k][0] += abs(total_spin)
              priorities[i*N*N+j*N+k][1] -= total_spin
            else:
              priorities[i*N*N+j*N+k][0] -= abs(total_spin)
              priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.3433317999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.0910702}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(N):
        if J[0,i,j,k] > 0:
          total_spin += 1
        elif J[0,i,j,k] < 0:
          total_spin -= 1
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins),1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        site_priority = total_spin + magnetism_coeff
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] -= site_priority
  return([p for p in priorities])


#score: {'data3D.txt': -0.06522860000000015}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin - magnetism_coeff
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] -= site_priority

  return([p for p in priorities])


#score: {'data3D.txt': -0.43135580000000034}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          site_priority = abs(total_spin) + np.sum([J[0, i, j, l] < 0 for l in range(N)])
          priorities[i*N*N+j*N+k][0] += site_priority
          priorities[i*N*N+j*N+k][1] -= total_spin - site_priority
        else:
          site_priority = abs(total_spin) + np.sum([J[0, i, j, l] > 0 for l in range(N)])
          priorities[i*N*N+j*N+k][0] -= site_priority
          priorities[i*N*N+j*N+k][1] = -total_spin + site_priority

  return [p for p in priorities]


#score: {'data3D.txt': 0.1233474}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin + sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = total_spin - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return([p for p in priorities])


#score: {'data3D.txt': -0.35264819999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N*N/4))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N*N/4))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.4200074}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) < 0)

        # Additional improvement: Consider the number of same-spin neighbors
        same_spin_neighbors = [val for val in interacting_spins if val == J[0,i,j,k]]
        if len(same_spin_neighbors):
          priorities[i*N*N+j*N+k][1] += sum(1 if val > 0 else -1 for val in same_spin_neighbors)

  return(priorities)


#score: {'data3D.txt': -0.4793434}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37847139999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * min(hamming_distance, 3))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * min(hamming_distance, 3))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.13056580000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.18735860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero([spin <= 0 for spin in interacting_spins]) / 3)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (np.count_nonzero([spin >= 0 for spin in interacting_spins]) / 3)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2159618000000001}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] += magnetism_coeff
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][0] -= magnetism_coeff
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  return [[p[0], p[1]] for p in priorities]


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i + 1) % N, j, k], J[2, i, (j + 1) % N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] += magnetism_coeff
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] -= magnetism_coeff
          priorities[i * N * N + j * N + k][1] = -1 + total_spin
  return [[p[0], p[1]] for p in priorities]


#score: {'data3D.txt': -0.2918530000000003}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  total_spin = np.zeros((N,N,N,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin[i][j][k] += h[i][j][k]
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]))
          priority_coeff = np.exp(-sum(abs(val) for val in interacting_spins))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin[i][j][k][0]
        else:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]))
          priority_coeff = np.exp(sum(abs(val) for val in interacting_spins))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin[i][j][k][0]
  
  return([[p[0], p[1]] for p in priorities])


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin[i][j][k] += h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
        else:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))

        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -1 + total_spin[i][j][k][0]
  return([[p[0], p[1]] for p in priorities])


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin[i][j][k] += h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) > 0.5))
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff
        total_spin[i][j][k][0] += 1 if h[i][j][k] > 0 else -1

  return [[p[0], p[1]] for p in priorities]


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] += priority_coeff
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][0] -= priority_coeff
          priorities[i * N * N + j * N + k][1] = -1 + total_spin

  return [[p[0], p[1]] for p in priorities]


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                     J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2*(total_spin > 0)
        else:
          interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                     J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += 2*(total_spin < 0)
  
  return(priorities)


#score: {'data3D.txt': -0.06522860000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin
          
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            total_spin += 1
          else:
            total_spin -= 1
            
  return(priorities)


#score: {'data3D.txt': -0.2287894}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  for d in range(3):
    for i in range(N):
      for j in range(N):
        if J[d,i,j,2]:
          priorities[i*N*N+j*N+d][0] += 10
          priorities[i*N*N+j*N+d][1] -= 10
  return(priorities)


#score: {'data3D.txt': -0.40511940000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = np.sum(J[:,i,j,k])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(-np.abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(-np.abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.4742918000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += spin_energy + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          spin_energy = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= spin_energy - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        # Add interaction between neighboring sites
        for d in range(3):
          site_nbr2 = (i + ((d-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= J[d,i,j,k]
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.37629700000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += total_spin + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= total_spin + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.0892286}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.2289222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(1 for val in interacting_spins if val > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(1 for val in interacting_spins if val < 0)
  return(priorities)


#score: {'data3D.txt': -0.2289222}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.23178220000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        if h[site_nbr, j, k] > 0:
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.32739260000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff - np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.49894820000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_energy > 0) + abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_energy > 0) + abs(total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48495259999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          priority_coeff = magnetism_coeff * (spin_energy > 0) + (1 - np.exp(-abs(total_spin))) * (hamming_distance > N/2)
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priority_coeff = magnetism_coeff * (spin_energy > 0) + (1 - np.exp(-abs(total_spin))) * (hamming_distance > N/2)
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.28169380000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        for d in range(6):
          site_nbr_d = (i + ((k-1)%2 - 1)) % N if d == 3 else (j + ((d-1)%2 - 1)) % N if d in [0,2] else i
          if h[site_nbr_d][j][k] > 0:
            site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
            priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.16561340000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        if h[site_nbr, j, k] > 0:
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.20445100000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = abs(total_spin) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.44324180000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total + magnetism_coeff * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = priority_total - 1 + total_spin
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] = -priority_total - magnetism_coeff * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = priority_total + 1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0027657999999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priority_total = -sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += -priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= -priority_total
          priorities[i*N*N+j*N+k][1] += priority_total
  return(priorities)


#score: {'data3D.txt': -0.20751820000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        site_nbr_magnetism = h[site_nbr, j, k]
        if site_nbr_magnetism > 0:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_priority_coeff
        else:
          site_priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= site_priority_coeff
  return(priorities)


#score: {'data3D.txt': -0.05780300000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += priority_coeff - site_magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= priority_coeff - site_magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.16428299999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += priority_coeff + site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= priority_coeff - site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.11165339999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  for i in range(N):
    for j in range(N):
      site_nbrs = []
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        site_nbrs.append((site, j))
      if h[i][j].sum() > 0:
        for site, _ in site_nbrs:
          priorities[site*N*N+j*N+0][0] += 1
          priorities[site*N*N+j*N+0][1] -= 1
      else:
        for site, _ in site_nbrs:
          priorities[site*N*N+j*N+0][0] -= 1
          priorities[site*N*N+j*N+0][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.1709601999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        for d in range(6):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.1253862000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        site_neighbors = [(i, j, site_nbr), (site_nbr, j, k)]
        for site in site_neighbors:
          if h[site[0]][site[1]][site[2]] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                    J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Calculate priority based on magnetism and total spin
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + 2*total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Calculate priority based on magnetism and total spin
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - 2*total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + 2*total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                  J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.22102740000000023}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(interacting_spins) + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 * (np.count_nonzero(np.array(interacting_spins) < 0) / 6)
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(interacting_spins) - abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * (np.count_nonzero(np.array(interacting_spins) > 0) / 6)
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)

        # Add the contribution of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.2500454}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff) * (np.count_nonzero([spin <= 0 for spin in interacting_spins]) / 3)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        site_neighbors = [(i, j, site_nbr), (site_nbr, j, k)]
        for site in site_neighbors:
          if h[site[0]][site[1]][site[2]] > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] -= 2
          else:
            priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i*N*N+j*N+k][1] = -2
  return(priorities)


#score: {'data3D.txt': -0.22797820000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
        site_neighbors = [(i, j, site_nbr), (site_nbr, j, k)]
        for site in site_neighbors:
          if h[site[0]][site[1]][site[2]] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
        for d in range(6):
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 1
          else:
            priorities[i*N*N+j*N+k][0] -= 1
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': -0.15442059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff) * np.count_nonzero([spin <= 0 for spin in interacting_spins]) / 3
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  return(priorities)


#score: {'data3D.txt': 0.25963260000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance > 0.5) - np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance < 0.5) - np.sum(np.abs(interacting_spins))
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.31962460000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  for i in range(N**3):
    if h[i//N%N][i%N][i//N//N] > 0:
      priorities[i][0] += abs(h[i//N%N][i%N][i//N//N]) * (priorities[i][0] + priorities[i][1]) / max(abs(priorities[i][0]), 1)
      priorities[i][1] -= abs(h[i//N%N][i%N][i//N//N]) * (priorities[i][0] - priorities[i][1]) / max(abs(priorities[i][0]), 1)
    else:
      priorities[i][0] -= abs(h[i//N%N][i%N][i//N//N]) * (priorities[i][0] + priorities[i][1]) / max(abs(priorities[i][0]), 1)
      priorities[i][1] = -abs(h[i//N%N][i%N][i//N//N]) * (priorities[i][0] - priorities[i][1]) / max(abs(priorities[i][0]), 1)

  return(priorities)


#score: {'data3D.txt': -0.4289798000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 + total_spin) + abs(h[i][j][k]) * (hamming_distance > 0.5) * total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - total_spin) + abs(h[i][j][k]) * (hamming_distance < 0.5) * total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20800180000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          hamming_factor = np.exp(-hamming_distance * (total_spin > 0.5) * (h[i][j][k] > 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_factor
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          hamming_factor = np.exp(-hamming_distance * (total_spin < -0.5) * (h[i][j][k] < 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_factor
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return [[p[0], p[1]] for p in priorities]


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          hamming_factor = np.exp(-hamming_distance * (total_spin > 0.5))
          spin_factor = np.exp(-total_spin * (total_spin > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * hamming_factor * spin_factor
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          hamming_factor = np.exp(-hamming_distance * (total_spin < -0.5))
          spin_factor = np.exp(total_spin * (total_spin < -0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * hamming_factor * spin_factor
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.07558699999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = np.sum([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]], axis=0)
        if h[i][j][k] > 0:
          priority_total = total_spin + np.sum(interacting_spins < 0, dtype=int) - 1
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 2 * priority_total
        else:
          priority_total = total_spin + np.sum(interacting_spins > 0, dtype=int) - 1
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= 2 * priority_total
  return(priorities)


#score: {'data3D.txt': 0.21398859999999992}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          site_priority = np.sum([np.exp(-abs(val) * (val < 0)) for val in interacting_spins]) + 1 - total_spin
        else:
          site_priority = np.sum([np.exp(-abs(val) * (val > 0)) for val in interacting_spins]) - 1 + total_spin
        priorities[i*N*N+j*N+k][0] = site_priority
        priorities[i*N*N+j*N+k][1] = -1 if h[i][j][k] > 0 else 1
  return(priorities)


#score: {'data3D.txt': 0.14785660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                site_priority += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              else:
                site_priority -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -site_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = -total_spin
          for d in [0,1,2]:
            for l in range(3):
              if J[d,i,j,k] > 0:
                site_priority -= magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              else:
                site_priority += magnetism_coeff * np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][1] = -site_priority
        priorities[i*N*N+j*N+k][0] = 1 - priorities[i*N*N+j*N+k][1]
  return(priorities)


#score: {'data3D.txt': -0.2291090000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance

  # Add a global term to the priority
  global_term = np.sum(h, axis=(0,1)) / N**3
  for i in range(N):
    for j in range(N):
      priorities[i*N*N+j*N+N-1][0] += global_term[0]
      priorities[i*N*N+j*N+N-1][1] -= global_term[0]

  return(priorities)


#score: {'data3D.txt': -0.3225305999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
          
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      
      if h[i][j][0] > 0:
        total_spin = sum(J[d,i,j,0] for d in [0,1,2])
        
        priorities[i*N*N+j*N+0][0] += total_spin
        priorities[i*N*N+j*N+0][1] -= total_spin
        
      else:
        total_spin = -sum(J[d,i,j,0] for d in [0,1,2])
        
        priorities[i*N*N+j*N+0][0] -= total_spin
        priorities[i*N*N+j*N+0][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.06778100000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = total_spin + hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -total_spin + hamming_distance
        
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.34339339999999957}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
          
  return(priorities)


#score: {'data3D.txt': -0.3225305999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                    J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
          
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((2)%2 - 1)) % N
      
      if h[i][j][0] > 0:
        total_spin = sum(J[d,i,j,0] for d in [0,1,2])
        
        priorities[i*N*N+j*N+0][0] += total_spin
        priorities[i*N*N+j*N+0][1] -= total_spin
        
      else:
        total_spin = -sum(J[d,i,j,0] for d in [0,1,2])
        
        priorities[i*N*N+j*N+0][0] -= total_spin
        priorities[i*N*N+j*N+0][1] += total_spin
      
  return(priorities)


#score: {'data3D.txt': -0.29380939999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
        
        site_nbr2 = (i + ((2)%2 - 1)) % N
        
        if h[site_nbr][j][k] > 0:
          total_spin2 = sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + abs(total_spin2)
          priorities[i*N*N+j*N+k][1] -= total_spin - total_spin2
          
        else:
          total_spin2 = -sum(J[d,site_nbr,j,k] for d in [0,1,2])
          
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + abs(total_spin2)
          priorities[i*N*N+j*N+k][1] += total_spin - total_spin2
        
  return(priorities)


#score: {'data3D.txt': -0.2867378000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
          
  for i in range(N):
    for j in range(N):
      for k2 in range(3):
        site = (i + ((k2-1)%2 - 1)) % N
        if h[site][j][k2] > 0:
          priorities[i*N*N+j*N+k2][0] += sum(J[d,i,j,k2] for d in [0,1,2])
          priorities[i*N*N+j*N+k2][1] -= sum(J[d,i,j,k2] for d in [0,1,2])
          
        else:
          priorities[i*N*N+j*N+k2][0] -= sum(J[d,i,j,k2] for d in [0,1,2])
          priorities[i*N*N+j*N+k2][1] += sum(J[d,i,j,k2] for d in [0,1,2])
          
  return(priorities)


#score: {'data3D.txt': -0.2713962000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] += magnetism_coeff + total_spin
        
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= total_spin
            
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
        site_nbr = (i + ((2)%2 - 1)) % N
          
        if h[i][j][0] > 0:
          total_spin = sum(J[d,i,j,0] for d in [0,1,2])
          
          priorities[i*N*N+j*N+0][0] += total_spin
          priorities[i*N*N+j*N+0][1] -= total_spin
          
        else:
          total_spin = -sum(J[d,i,j,0] for d in [0,1,2])
          
          priorities[i*N*N+j*N+0][0] -= total_spin
          priorities[i*N*N+j*N+0][1] += total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.044696200000000005}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  total_spin = np.zeros((N,N,N,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin[i][j][k] += h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) > 0.5))
        else:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) > 0.5))

        # Sort interactions by strength
        sorted_interactions = sorted((abs(val), d) for d, val in enumerate(interacting_spins))
        sorted_interactions = [(val, d) for val, d in sorted_interactions]

        site_priority = magnetism_coeff + sum(sorted_interactions[i][0] * (1 if h[i][j][k] > 0 else -1) for i in range(len(sorted_interactions)))
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] = -1 + total_spin[i][j][k][0]

  return([p for p in priorities])


#score: {'data3D.txt': -0.08602460000000002}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  total_spin = np.zeros((N, N, N, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin[i][j][k] += h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1) > 0.5))
        else:
          magnetism_coeff = np.exp(-abs(total_spin[i][j][k][0]) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1) > 0.5))

        site_priority = magnetism_coeff + total_spin[i][j][k][0]
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] = -1 * site_priority

  return([p for p in priorities])


#score: {'data3D.txt': 0.0206398}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
          
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j][0] > 0:
        priorities[i*N*N+j*N+0][0] += sum(J[d,i,j,0] for d in [0,1,2])
        priorities[i*N*N+j*N+0][1] -= sum(J[d,i,j,0] for d in [0,1,2])
        
      else:
        priorities[i*N*N+j*N+0][0] -= sum(J[d,i,j,0] for d in [0,1,2])
        priorities[i*N*N+j*N+0][1] = -sum(J[d,i,j,0] for d in [0,1,2])

  return(priorities)


#score: {'data3D.txt': -0.28412860000000034}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= total_spin
            
          else:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.2534254000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -1
  return(priorities)


#score: {'data3D.txt': -0.2713962000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] -= total_spin
          else:
            hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
            magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin

        site_nbr = (i + ((2)%2 - 1)) % N
        if h[i][j][0] > 0:
          total_spin = sum(J[d,i,j,0] for d in [0,1,2])
          priorities[i*N*N+j*N+0][0] += total_spin
          priorities[i*N*N+j*N+0][1] -= total_spin
        else:
          total_spin = -sum(J[d,i,j,0] for d in [0,1,2])
          priorities[i*N*N+j*N+0][0] -= total_spin
          priorities[i*N*N+j*N+0][1] += total_spin

  return(priorities)


#score: {'data3D.txt': -0.06522860000000015}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_priority = total_spin - magnetism_coeff
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] -= site_priority
  return([p for p in priorities])


#score: {'data3D.txt': -0.3224533999999998}
program:
def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          site_priority = (magnetism_coeff * (hamming_distance > 0.5) + 
                   abs(total_spin) * (hamming_distance <= 0.5))
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          site_priority = -(magnetism_coeff * (hamming_distance <= 0.5) + 
                    abs(total_spin) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += site_priority
        priorities[i*N*N+j*N+k][1] -= site_priority

  return([p for p in priorities])


#score: {'data3D.txt': 0.3073018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.49179900000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          spin_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(spin_energy))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          spin_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(spin_energy))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.48495259999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * min(hamming_distance, 3))
          spin_energy = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_energy > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * min(hamming_distance, 3))
          spin_energy = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_energy > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.22232979999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_total = np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1964418}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] < 0])
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          priority_total = np.sum([J[d,i,j,k] for d in range(6) if J[d,i,j,k] > 0])
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.37433180000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        site_magnetism = h[i][j][k]
        for d in range(3):
          if i!=N-1 and J[d,i,j,k]*h[(i+1)%N,j,k]: hamming_distance += 1
          if j!=N-1 and J[0,i,(j+1)%N,k]*h[i,N-1,k]: hamming_distance += 1
        priority_coeff = total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
        spin_energy = -sum(val for val in interacting_spins if val > 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_magnetism + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - site_magnetism - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.14709659999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbrs = [(i + ((k-1)%2 - 1)) % N, (i+1)%N, i, (j+1)%N, j, (k+1)%N, k]
        for site_nbr in site_nbrs:
          interacting_spins.append(J[(site_nbr//N)%3, i%N, j%N, k])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.15397420000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - len([val for val in interacting_spins if val > 0])
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.26666100000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        site_magnetism = h[site_nbr][j][k]
        priority_coeff = total_spin + sum(1 for val in interacting_spins if val*site_magnetism < 0) - hamming_distance
        spin_energy = -sum(val for val in interacting_spins if val > 0)
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.15298340000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        # calculate magnetism coefficient
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
        
        # calculate hamming distance
        hamming_distance = np.count_nonzero(np.array(interacting_spins) != h[i][j][k])
        
        # calculate priority coefficient
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
        
        # update priorities
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val > 0])
  
  return(priorities)


#score: {'data3D.txt': -0.2075734}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.19899700000000028}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_magnetism = h[i][j][k]
        for d in range(3):
          if i!=N-1 and J[d,i,j,k]*h[(i+1)%N,j,k]: hamming_distance += 1
          if j!=N-1 and J[0,i,(j+1)%N,k]*h[i,N-1,k]: hamming_distance += 1
        priority_coeff += site_magnetism + sum(1 for val in interacting_spins if val > 0) - hamming_distance
        spin_energy = -sum(val for val in interacting_spins if val > 0)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += site_magnetism + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 + spin_energy
        else:
          priorities[i*N*N+j*N+k][0] -= site_magnetism - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 - spin_energy
  return(priorities)


#score: {'data3D.txt': -0.1606658000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          spin_bias = total_spin - sum([J[3,i,j,k] for k in range(N)])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(spin_bias > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= spin_bias
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          spin_bias = total_spin - sum([J[3,i,j,k] for k in range(N)])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(spin_bias < 0)
          else:
            priorities[i*N*N+j*N+k][1] = -spin_bias
  
  return(priorities)


#score: {'data3D.txt': -0.16490020000000022}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(total_spin > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= total_spin - sum([J[3,i,j,k] for k in range(N)])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(total_spin < 0)
          else:
            priorities[i*N*N+j*N+k][1] = total_spin - sum([J[3,i,j,k] for k in range(N)])
  
  return(priorities)


#score: {'data3D.txt': -0.22414300000000026}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(total_spin > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= total_spin - sum([J[3,i,j,k] for k in range(N)])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(total_spin < 0)
          else:
            priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.19861980000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(total_spin > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(total_spin < 0)
          else:
            priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.16178500000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.16178500000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= -total_spin + 2*sum([J[d,i,j,k] for d in [0,1,2]])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + 2*sum([J[d,i,j,k] for d in [0,1,2]])
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + hamming_distance - 0.5
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + hamming_distance - 0.5
  
  return(priorities)


#score: {'data3D.txt': -0.025839400000000116}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,4,5])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin + hamming_distance
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.26366380000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        
        # Calculate total spin
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,4,5])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        # Calculate priority based on magnetism and hamming distance
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Prioritize spins that are aligned with the site's magnetization
          priority_coeff = 2 - abs(h[i][j][k] - total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          
          # Prioritize spins that are aligned with the site's magnetization
          priority_coeff = 2 - abs(h[i][j][k] + total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0225734}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      hamming_distance = [0,0]
      interacting_spins = []
      for k in range(N):
        interacting_spins.append(J[0,i,j,k])
        if J[0,i,j,k] > 0:
          total_spin += 1
          hamming_distance[0] += 1
        elif J[0,i,j,k] < 0:
          total_spin -= 1
          hamming_distance[1] += 1
      magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance[0]/len(interacting_spins) > 0.5))
      if h[i][j][k] > 0:
        priorities[i*N*N+j*N+k][0] += total_spin + magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin
      else:
        priorities[i*N*N+j*N+k][0] -= total_spin + magnetism_coeff
        priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2754306000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin) - np.tanh(abs(total_spin))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin) + np.tanh(abs(total_spin))

  return(priorities)


#score: {'data3D.txt': -0.1348046}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.2649454000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)

        # Add the contribution of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.abs(total_spin) > 0.5)
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin)) * (np.abs(total_spin) < 0.5)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * (np.abs(total_spin) > 0.5)
          priorities[i*N*N+j*N+k][1] = -np.exp(-abs(total_spin)) * (np.abs(total_spin) < 0.5)

  return(priorities)


#score: {'data3D.txt': -0.3372822}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + (hamming_distance >= len([val for val in interacting_spins if val < 0])) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0])) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.02845580000000008}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + (hamming_distance >= len([val for val in interacting_spins if val < 0]))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + (hamming_distance >= len([val for val in interacting_spins if val > 0]))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.19965219999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.13300860000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin
          
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] += total_spin
        
        for k1 in range(3):
          site = (i + ((k1-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.1141466}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spins = np.zeros((N, N, N, 2), dtype=int)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spins[i][j][k][0] += 1
          total_spins[i][j][k][1] -= 1
        else:
          total_spins[i][j][k][0] -= 1
          total_spins[i][j][k][1] += 1
        
        for d in range(6):
          site = (i + ((d-1)%2 - 1)) % N
          if J[d,i,j,k] > 0:
            total_spins[site][j][k][0] += 1
            total_spins[site][j][k][1] -= 1
          else:
            total_spins[site][j][k][0] -= 1
            total_spins[site][j][k][1] += 1
        
        for d in range(6):
          site = (i + ((d-1)%2 - 1)) % N
          if J[d,i,j,k] > 0:
            priorities[i*N*N+j*N+k][0] += total_spins[site][j][k][0]
            priorities[i*N*N+j*N+k][1] -= total_spins[site][j][k][1]
          else:
            priorities[i*N*N+j*N+k][0] -= total_spins[site][j][k][0]
            priorities[i*N*N+j*N+k][1] = -total_spins[site][j][k][1]
  
  return(priorities)


#score: {'data3D.txt': -0.13264020000000004}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        
        # Calculate additional priority terms based on the interaction with other spins
        for d in [0,1,2]:
          for l in range(3):
            site = (i + ((l-1)%2 - 1)) % N
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += np.exp(-abs(J[d,i,j,l])) * J[d,site,j,l]
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,site,j,l]
            else:
              priorities[i*N*N+j*N+k][0] -= np.exp(abs(J[d,i,j,l])) * J[d,site,j,l]
              priorities[i*N*N+j*N+k][1] = -1 + J[d,site,j,l]

  return(priorities)


#score: {'data3D.txt': -0.17890299999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Calculate additional priority terms based on the interaction with other spins
        for d in [0,1,2]:
          for l in range(3):
            if J[d,i,j,k] > 0:
              hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
              magnetism_coeff = np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][0] += magnetism_coeff
              priorities[i*N*N+j*N+k][1] -= 1 - J[d,i,j,l]
            else:
              hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
              magnetism_coeff = np.exp(-abs(J[d,i,j,l]) * (hamming_distance > 0.5))
              priorities[i*N*N+j*N+k][0] -= magnetism_coeff
              priorities[i*N*N+j*N+k][1] = -1 + J[d,i,j,l]

  return([p for p in priorities])


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.26654660000000024}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff
            priorities[i*N*N+j*N+k][1] -= 1 + total_spin - magnetism_coeff
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin + magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.45849060000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': 0.10432820000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          total_spin_bias = total_spin - sum([J[3,i,j,k] for k in range(N)])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(total_spin_bias > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= total_spin_bias
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          total_spin_bias = total_spin - sum([J[3,i,j,k] for k in range(N)])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(total_spin_bias < 0)
          else:
            priorities[i*N*N+j*N+k][1] += total_spin_bias
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for k1 in range(3):
          site = (i + ((k1-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': 0.10432820000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k],
                   J[4,i,(k+1)%N,k], J[5,(i+1)%N,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          spin_bias = total_spin - sum([J[3,i,j,k] for k in range(N)])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] -= 2*(spin_bias > 0)
          else:
            priorities[i*N*N+j*N+k][1] -= spin_bias
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          spin_bias = total_spin - sum([J[3,i,j,k] for k in range(N)])
          if hamming_distance > 0.5:
            priorities[i*N*N+j*N+k][1] += 2*(spin_bias < 0)
          else:
            priorities[i*N*N+j*N+k][1] += spin_bias
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        for k1 in range(3):
          site = (i + ((k1-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
        for k2 in range(3):
          site = (i + ((k2-1)%2 - 1)) % N
          if h[site][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(total_spin)
            priorities[i*N*N+j*N+k][1] += total_spin
          else:
            priorities[i*N*N+j*N+k][0] += abs(total_spin)
            priorities[i*N*N+j*N+k][1] = -total_spin
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_nbr_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin - site_nbr_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + site_nbr_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': 0.25927019999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        site_nbr_spin = h[site_nbr][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + site_nbr_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - site_nbr_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + site_nbr_spin
          priorities[i*N*N+j*N+k][1] = -1 - total_spin + site_nbr_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.15411540000000032}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([spin for spin in interacting_spins if spin < 0]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -(priority_total / 3.5)
          priorities[i*N*N+j*N+k][1] = (priority_total / 3.5)
        else:
          priority_total = np.sum([spin for spin in interacting_spins if spin > 0]) + abs(total_spin)
          priorities[i*N*N+j*N+k][0] = -(priority_total / 2.7)
          priorities[i*N*N+j*N+k][1] = (priority_total / 2.7)
  return(priorities)


#score: {'data3D.txt': 0.12006620000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] += priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= priority_total - total_spin
        else:
          priority_total = 2 * np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] -= priority_total + total_spin
          priorities[i*N*N+j*N+k][1] -= priority_total - total_spin
 
  return(priorities)


#score: {'data3D.txt': -0.1835430000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = 2 * np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)]) + magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -2 * np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)]) - magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -1 - magnetism_coeff * abs(total_spin)

        # Add the contribution of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([abs(val) * (val < 0) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = np.sum([abs(val) * (val > 0) for val in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
  
  return(priorities)


#score: {'data3D.txt': -0.3007438}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] += priority_total + abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= 2 - priority_total
        else:
          priority_total = np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)])
          priorities[i*N*N+j*N+k][0] -= priority_total + abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -2 + priority_total
  return(priorities)


#score: {'data3D.txt': -0.48890380000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.40392259999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.4677226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 2
  return(priorities)


#score: {'data3D.txt': 0.23822579999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.5169162000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        # Add more complex priority calculation here...

  return(priorities)


#score: {'data3D.txt': -0.5178130000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.3692586000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = np.exp(-abs(total_spin))
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = np.exp(-abs(total_spin))
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          priority_total = total_spin
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        
  return(priorities)


#score: {'data3D.txt': -0.15615299999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  return(priorities)


#score: {'data3D.txt': -0.15615299999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2,3,4,5]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2,3,4,5])
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  return(priorities)


#score: {'data3D.txt': -0.20878539999999995}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  return(priorities)


#score: {'data3D.txt': -0.21759419999999988}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.40392259999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.43421580000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + sum(val for val in interacting_spins if val > 0) / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - sum(val for val in interacting_spins if val < 0) / len(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3941826000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.exp(-np.abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.exp(-np.abs(total_spin) * np.abs(interacting_spins))) + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.16267900000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin * np.exp(-np.abs(total_spin) * np.sum([J[d,i,j,k] for d in [0,1,2]]))
          priorities[i*N*N+j*N+k][1] -= -total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin * np.exp(-np.abs(total_spin) * np.sum([J[d,i,j,k] for d in [0,1,2]]))
          priorities[i*N*N+j*N+k][1] = total_spin
  return(priorities)


#score: {'data3D.txt': -0.24946580000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        
        # Calculate the magnetism coefficient
        magnetism_coeff = np.exp(-abs(np.sum(interacting_spins)) / N**3)
        
        # Calculate the hamming distance
        hamming_distance = sum(1 for val in interacting_spins if val > 0)
        
        # Calculate the spin coefficient
        spin_coeff = 1 - abs(np.sum(interacting_spins)) / N**3
        
        # Calculate the priority coefficients
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + np.sum(interacting_spins) * spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + np.sum(interacting_spins) * spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  
  return(priorities)


#score: {'data3D.txt': -0.22829580000000027}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] += (priority_coeff) * (1 - hamming_distance/N**2)
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff
          priorities[i*N*N+j*N+k][0] -= (priority_coeff) * (1 - hamming_distance/N**2)
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.1566630000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.22525260000000014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff + total_spin)
          priorities[i*N*N+j*N+k][1] -= 1 + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff + total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2656306000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N + np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N + np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
        if h[site_nbr, j, k] > 0:
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.07106220000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2])) * len([val for val in [J[0,site_nbr,j,k], J[1,(site_nbr+1)%N,j,k], J[2,site_nbr,(j+1)%N,k]] if val < 0]) / max(len([J[0,site_nbr,j,k], J[1,(site_nbr+1)%N,j,k], J[2,site_nbr,(j+1)%N,k]]), 1))
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          neighbor_magnetism_coeff = np.exp(-abs(sum(J[d,site_nbr,j,k] for d in [0,1,2])) * len([val for val in [J[0,site_nbr,j,k], J[1,(site_nbr+1)%N,j,k], J[2,site_nbr,(j+1)%N,k]] if val > 0]) / max(len([J[0,site_nbr,j,k], J[1,(site_nbr+1)%N,j,k], J[2,site_nbr,(j+1)%N,k]]), 1))
          priority_coeff = magnetism_coeff + total_spin * spin_coeff + (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))/N - neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.46529020000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
  return(priorities)


#score: {'data3D.txt': 0.08064580000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + interaction_term
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + interaction_term
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - interaction_term

  return(priorities)


#score: {'data3D.txt': -0.40392259999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
  
  return(priorities)


#score: {'data3D.txt': -0.21943420000000033}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = 2 - total_spin
  return(priorities)


#score: {'data3D.txt': -0.1803026000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.20271140000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_up_coeff = np.sum([spin < 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * spin_up_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_down_coeff = np.sum([spin > 0 for spin in interacting_spins])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * spin_down_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': 0.24889380000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k], J[3,i,(k+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = total_spin - sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.39312779999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0026162}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        return(priorities)


#score: {'data3D.txt': -0.133783}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          site_nbr_spin = h[site_nbr][j][k]
          if site_nbr_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          site_nbr_spin = h[site_nbr][j][k]
          if site_nbr_spin > 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.3040114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          if abs(total_spin) > N/4:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin - hamming_distance
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          if abs(total_spin) > N/4:
            priorities[i*N*N+j*N+k][1] = 2 + total_spin + hamming_distance
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.46302100000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 1
            priorities[i*N*N+j*N+k][1] -= 2
  return(priorities)


#score: {'data3D.txt': -0.4677226}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 2 * (total_spin > 0)
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        priority_coeff = np.exp(-total_spin**2 / (len(interacting_spins) ** 2)) if total_spin != 0 else 1
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.46302100000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in range(3):
          if J[d,i,j,k] < 0:
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 1
  return(priorities)


#score: {'data3D.txt': -0.0409114}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          spin_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          magnetism_coeff = np.exp(-hamming_distance / N)
          priorities[i*N*N+j*N+k][0] += (spin_coeff + magnetism_coeff) * total_spin
          priorities[i*N*N+j*N+k][1] -= spin_coeff - magnetism_coeff
        else:
          spin_coeff = np.exp(abs(total_spin) / N**3)
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          magnetism_coeff = np.exp(-hamming_distance / N)
          priorities[i*N*N+j*N+k][0] -= (spin_coeff + magnetism_coeff) * total_spin
          priorities[i*N*N+j*N+k][1] = -spin_coeff + magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.44896860000000016}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          spin_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += spin_coeff * (total_spin + hamming_distance)
          priorities[i*N*N+j*N+k][1] -= spin_coeff * (-1 - total_spin + len(interacting_spins) - hamming_distance)
        else:
          spin_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= spin_coeff * (total_spin + hamming_distance)
          priorities[i*N*N+j*N+k][1] = -spin_coeff * (-1 - total_spin + len(interacting_spins) - hamming_distance)
  return(priorities)


#score: {'data3D.txt': -0.054529799999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff) - magnetism_coeff * (-1 - total_spin + hamming_distance)
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff) - magnetism_coeff * (-1 - total_spin + hamming_distance)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.32652500000000045}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] += priority_coeff * (total_spin + spin_coeff)
          priorities[i*N*N+j*N+k][1] -= priority_coeff * (-1 - total_spin + hamming_distance)
        else:
          priority_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_coeff = 1 - abs(total_spin) / N**3
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (total_spin + spin_coeff)
          priorities[i*N*N+j*N+k][1] = -priority_coeff * (-1 - total_spin + hamming_distance)
        if h[i][j][k] > 0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
        else:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
  return(priorities)


#score: {'data3D.txt': 0.020061799999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_bias = total_spin
          neighbor_bias = sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) + spin_bias + neighbor_bias
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_bias = -total_spin
          neighbor_bias = sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_bias + neighbor_bias
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) + spin_bias + neighbor_bias

  return(priorities)


#score: {'data3D.txt': -0.40392259999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.1522426}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.31319900000000006}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + abs(neighbor_magnetism)
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + abs(neighbor_magnetism)
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
  return(priorities)


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
          if any(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += 2
            priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
          if any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= 2
            priorities[i*N*N+j*N+k][1] += 1
  return(priorities)


#score: {'data3D.txt': 0.008287799999999667}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin

  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2735014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(np.array(interacting_spins) < 0) > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) < 0)
          
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(np.array(interacting_spins) > 0) > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
          
  return(priorities)


#score: {'data3D.txt': -0.2735014}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          magnetism_term = h[i][j][k] * (hamming_distance < N/4)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy + magnetism_term
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance + magnetism_term
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          magnetism_term = h[i][j][k] * (hamming_distance > N/4)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy + magnetism_term
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance + magnetism_term
  return(priorities)


#score: {'data3D.txt': -0.2735014}
program:
def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > N/4))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0) - spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.43209580000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins_sum = sum(val for val in interacting_spins if val < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * abs(interacting_spins_sum) / (3*N))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + interacting_spins_sum
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin - sum(val for val in interacting_spins if val < 0)
        else:
          interacting_spins_sum = sum(val for val in interacting_spins if val > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * abs(interacting_spins_sum) / (3*N))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin - interacting_spins_sum
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.16049819999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)


#score: {'data3D.txt': -0.1810109999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val < 0 else -1 for val in interacting_spins]) > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin + np.sum(interacting_spins)) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean([1 if val > 0 else -1 for val in interacting_spins]) > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin + np.sum(interacting_spins)) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': 0.0726642}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.sum(np.tanh(np.array([total_spin] + interacting_spins)))
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.sum(np.tanh(np.array([-total_spin] + [-val for val in interacting_spins])))
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  return(priorities)


#score: {'data3D.txt': -0.22867780000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff + abs(total_spin) / N**3)
          priorities[i*N*N+j*N+k][1] -= magnetism_coeff * (-1 - priority_coeff)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff + abs(total_spin) / N**3)
          priorities[i*N*N+j*N+k][1] = -magnetism_coeff * (-1 - priority_coeff)
  return(priorities)


#score: {'data3D.txt': 0.0010997999999998887}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * (-1 - total_spin + len(interacting_spins) - hamming_distance)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff + 1)
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * (-1 - total_spin + len(interacting_spins) - hamming_distance)
  return(priorities)


#score: {'data3D.txt': 0.10151580000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff)
          priorities[i*N*N+j*N+k][1] -= 1 + total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.486061}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[site_nbr][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.47329180000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.5074846000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.3887418}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

        interacting_spins.sort()
        if sum(interacting_spins[:3]) < 0:
          priorities[i*N*N+j*N+k][0] += 2 * (total_spin > 0)
          priorities[i*N*N+j*N+k][1] -= 1
        elif sum(interacting_spins[3:]) > 0:
          priorities[i*N*N+j*N+k][0] += 2 * (total_spin < 0)
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)


#score: {'data3D.txt': -0.503129}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N].sum() > 0:
      priorities[i*N+i][0] += 1 + total_spin.sum()
      priorities[i*N+i][1] -= 1 - total_spin.sum()
    else:
      priorities[i*N+i][0] -= 1 + total_spin.sum()
      priorities[i*N+i][1] = -1 + total_spin.sum()

  return(priorities)


#score: {'data3D.txt': -0.5081062000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.48181699999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.35826980000000025}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - 1
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + 1

  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.5178130000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.34046699999999963}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin
          priorities[i*N*N+j*N+k][1] += 1 - total_spin

  return(priorities)


#score: {'data3D.txt': 0.00021499999999999192}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_up = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_up > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - priority_up
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_down = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_down > 0)
          priorities[i*N*N+j*N+k][1] = -1 + priority_down
  return(priorities)


#score: {'data3D.txt': -0.11998099999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          spin_up_parity = total_spin + 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (spin_up_parity > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][1] -= 1 - spin_up_parity
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          spin_down_parity = total_spin - 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (spin_down_parity > 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][1] = -1 + spin_down_parity

  return(priorities)


#score: {'data3D.txt': -0.39312779999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.39312779999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff*(total_spin+2)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff*(total_spin-2)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.26706219999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - np.count_nonzero(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= total_spin - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -total_spin + len([val for val in interacting_spins if val < 0])
  return(priorities)


#score: {'data3D.txt': -0.2752874000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + len([val for val in interacting_spins if val < 0])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.31773099999999976}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = -total_spin + np.sum(np.exp(-abs(total_spin) * np.abs(interacting_spins))) + len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0667174}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if h[i][j][k]*val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        site_magnetism = h[i][j][k]
        for d in range(3):
          if i!=N-1 and J[d,i,j,k]*h[(i+1)%N,j,k]: hamming_distance += 1
          if j!=N-1 and J[0,i,(j+1)%N,k]*h[i,N-1,k]: hamming_distance += 1
        priority_coeff = total_spin + sum(1 for val in interacting_spins if h[i][j][k]*val > 0) - hamming_distance
        spin_energy = -sum(J[d,i,j,k] * np.sign(h[i][j][k]) for d in [0,1,2])
        priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
        priorities[i*N*N+j*N+k][1] -= site_magnetism - spin_energy
  return(priorities)


#score: {'data3D.txt': -0.2734154000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        site_nbr_spin = h[site_nbr][j][k]
        if abs(site_nbr_spin) > 0:
          priorities[i*N*N+j*N+k][0] += site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= site_nbr_spin
  return(priorities)


#score: {'data3D.txt': -0.2035778000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

        # Additional term to improve the algorithm:
        interacting_spins.sort()
        if h[i][j][k] > 0:
          if interacting_spins[0] < 0:
            priorities[i*N*N+j*N+k][1] += 1
          elif interacting_spins[-1] > 0:
            priorities[i*N*N+j*N+k][0] -= 1
        else:
          if interacting_spins[0] > 0:
            priorities[i*N*N+j*N+k][1] -= 1
          elif interacting_spins[-1] < 0:
            priorities[i*N*N+j*N+k][0] += 1

  return(priorities)


#score: {'data3D.txt': -0.2291034000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)

  # Add the bias term for the total spin at each site
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][1] += abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.2016230000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism + 2
          if any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * (abs(total_spin) - site_magnetism)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -total_spin - abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism + 2
          if any(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * (abs(total_spin) - site_magnetism)
  return(priorities)


#score: {'data3D.txt': 0.1579322000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_sum = sum(1 if J[d,i,j,k] < 0 else -1 for d in range(6))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + spin_sum
          priorities[i*N*N+j*N+k][1] -= 2 * total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_sum = sum(1 if J[d,i,j,k] > 0 else -1 for d in range(6))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + spin_sum
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.15442059999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -total_spin + hamming_distance
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total

  return(priorities)


#score: {'data3D.txt': 0.17753859999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        # Calculate the priority based on symmetry
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.022524200000000116}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
  return(priorities)


#score: {'data3D.txt': -0.36216139999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 + total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - total_spin) * hamming_distance
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.41650940000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] += (hamming_distance > 0.5) * total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= (hamming_distance < 0.5) * total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.45535660000000017}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin_coeff = np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][0] += total_spin_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          total_spin_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= total_spin_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  
  return(priorities)


#score: {'data3D.txt': -0.49833979999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.5092594000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = magnetism_coeff + total_spin + total_magnetism
          priority_down = -magnetism_coeff - total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] += priority_up
          priorities[i*N*N+j*N+k][1] -= priority_down
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priority_up = -magnetism_coeff - total_spin + total_magnetism
          priority_down = magnetism_coeff + total_spin - total_magnetism
          priorities[i*N*N+j*N+k][0] -= priority_up
          priorities[i*N*N+j*N+k][1] += priority_down

  return(priorities)


#score: {'data3D.txt': -0.2849994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
            priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.48181699999999994}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          total_magnetism = abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + total_magnetism
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.4341130000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.411985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += abs(total_spin) + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - magnetism_coeff
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= abs(total_spin) - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.2846446}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin) * len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val < 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = len([val for val in [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]] if val > 0]) / max(len([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.16049819999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism

  return(priorities)


#score: {'data3D.txt': -0.23548419999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (1 - spin_magnetization)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_magnetization = np.sign(total_spin) * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (1 - spin_magnetization)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism
  return(priorities)


#score: {'data3D.txt': -0.3919122}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - neighbor_magnetism

  return(priorities)


#score: {'data3D.txt': -0.1745802000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0) + neighbor_magnetism

        # Additional term to favor spins with the same sign as the magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= abs(total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -abs(total_spin)

  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
  return(priorities)


#score: {'data3D.txt': -0.5213745999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.47709580000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k]]
        neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
        priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.021979000000000207}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (priority_coeff + 1)
          priorities[i*N*N+j*N+k][1] -= 1 - magnetism_coeff * (-1 - total_spin + len(interacting_spins) - hamming_distance)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (priority_coeff + 1)
          priorities[i*N*N+j*N+k][1] = -1 + magnetism_coeff * (-1 - total_spin + len(interacting_spins) - hamming_distance)
        if i < N//2:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin / N**3)
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(total_spin / N**3)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.2053438}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) / N**3)
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.22793220000000036}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + np.count_nonzero(np.array(interacting_spins) < 0)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0])) + priority_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          priority_coeff = -total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0])) + priority_coeff - spin_energy
          priorities[i*N*N+j*N+k][1] = 2 + total_spin + np.count_nonzero(np.array(interacting_spins) < 0)
  return(priorities)


#score: {'data3D.txt': -0.3658782000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + (hamming_distance >= len([val for val in interacting_spins if val < 0])) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          if abs(total_spin) > N/4:
            priorities[i*N*N+j*N+k][1] -= 2 - total_spin - hamming_distance
          else:
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + (hamming_distance >= len([val for val in interacting_spins if val > 0])) + spin_energy
          site_nbr_spin = h[site_nbr][j][k]
          if abs(total_spin) > N/4:
            priorities[i*N*N+j*N+k][1] = 2 + total_spin + hamming_distance
          else:
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.19223500000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (max(priority_coeff, 0) + np.count_nonzero(np.array(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (max(priority_coeff, 0) + np.count_nonzero(np.array(interacting_spins) > 0))
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.3598934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance + sum(1 for val in interacting_spins if val > 0)
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(1 for val in interacting_spins if val < 0) + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.20406740000000037}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance + sum(1 for val in interacting_spins if val > 0)
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
  return(priorities)


#score: {'data3D.txt': -0.2693646000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': 0.1126482}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val < 0)
          total_magnetism = abs(total_spin) + 1
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_magnetism + interaction_term
          priorities[i*N*N+j*N+k][1] -= 2 - total_magnetism - interaction_term
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_term = sum(2*val for val in interacting_spins if val > 0)
          total_magnetism = abs(total_spin) + 1
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_magnetism - interaction_term
          priorities[i*N*N+j*N+k][1] = -2 + total_magnetism - interaction_term

  return(priorities)


#score: {'data3D.txt': 0.0453662}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] = priority_total
          priorities[i*N*N+j*N+k][1] = -priority_total
        else:
          priority_total = total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] = -priority_total
          priorities[i*N*N+j*N+k][1] = priority_total

  return(priorities)


#score: {'data3D.txt': -0.24006340000000012}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * 2
          for d in range(6):
            if J[d,i,j,k] < 0:
              priority_total += 3
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = -priority_total - total_spin
        else:
          priority_total = abs(total_spin) * 2
          for d in range(6):
            if J[d,i,j,k] > 0:
              priority_total += 3
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] = -priority_total + total_spin
          priorities[i*N*N+j*N+k][1] = priority_total + total_spin

  return(priorities)


#score: {'data3D.txt': -0.33053740000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priority_coeff = 0.8 + 0.2 * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff * (1 - abs(total_spin) / N)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)

  return(priorities)


#score: {'data3D.txt': -0.027892599999999993}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in interacting_spins if val < 0)
          site_nbr_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2]) * (h[site_nbr][j][k] > 0) * (abs(h[site_nbr][j][k]) > 0.5)
          priorities[i*N*N+j*N+k][0] += site_nbr_energy
          priorities[i*N*N+j*N+k][1] -= -site_nbr_energy
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - sum(val for val in interacting_spins if val > 0)
          site_nbr_energy = sum(J[d,site_nbr,j,k] for d in [0,1,2]) * (h[site_nbr][j][k] < 0) * (abs(h[site_nbr][j][k]) > 0.5)
          priorities[i*N*N+j*N+k][0] -= site_nbr_energy
          priorities[i*N*N+j*N+k][1] = -site_nbr_energy

  return(priorities)


#score: {'data3D.txt': -0.030954599999999773}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + spin_diff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin_magnitude = abs(total_spin)
          interacting_spins_sum = sum(val for val in interacting_spins if val != 0)
          spin_diff = -total_spin_magnitude - sum(abs(val) for val in interacting_spins)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin_magnitude + interacting_spins_sum) / N
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + spin_diff

  return(priorities)


#score: {'data3D.txt': -0.5214034000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + sum(val for val in site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.38641980000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0])))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin - len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0])))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin - sum(val for val in interacting_spins if val > 0)

        for d in range(3):
          site_neighbors = [J[d,i,(j+1)%N,k], J[d,(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (len([val for val in site_neighbors if val < 0]) > len([val for val in interacting_spins if val < 0])))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff + total_spin - len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)


#score: {'data3D.txt': -0.5127094000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff * (len([val for val in interacting_spins if val < 0]) > len([val for val in interacting_spins if val > 0]))
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          neighbor_magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff * (len([val for val in interacting_spins if val > 0]) > len([val for val in interacting_spins if val < 0]))
  return(priorities)


#score: {'data3D.txt': -0.2697018000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val > 0)
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          site_nbr_spin = h[site_nbr][j][k]
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_nbr_spin * (h[i][j][k] > 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          hamming_distance = sum(1 for val in interacting_spins if val < 0)
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + hamming_distance
  return(priorities)


#score: {'data3D.txt': -0.09684979999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += priority_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          priority_coeff = abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= priority_coeff + spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - np.count_nonzero(np.array(interacting_spins) > 0)
  return(priorities)


#score: {'data3D.txt': -0.1733522000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance + sum(1 for val in interacting_spins if val > 0) / (len(interacting_spins) + 1)
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin + np.count_nonzero(np.array(interacting_spins) > 0) / (len(interacting_spins) + 1)
  return(priorities)


#score: {'data3D.txt': -0.07277940000000009}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + spin_energy
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + hamming_distance - spin_energy
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - hamming_distance
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - spin_energy
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - hamming_distance + spin_energy
  return(priorities)


#score: {'data3D.txt': -0.49775620000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

  return(priorities)


#score: {'data3D.txt': -0.0022994000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  total_spin_counts = np.zeros(2)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin_counts[1] += 1
          total_spin_counts[0] -= 1
        else:
          total_spin_counts[1] -= 1
          total_spin_counts[0] += 1

        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin_counts[0] - total_spin_counts[1]) * (hamming_distance > 0.5))
        priorities[i*N*N+j*N+k][0] += magnetism_coeff
        priorities[i*N*N+j*N+k][1] -= 2 - (total_spin_counts[0] + total_spin_counts[1])

  return(priorities)


#score: {'data3D.txt': -0.15765300000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_energy = -total_spin
          priorities[i*N*N+j*N+k][0] += 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*spin_energy
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          spin_energy = total_spin
          priorities[i*N*N+j*N+k][0] -= 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*spin_energy

  return(priorities)


#score: {'data3D.txt': 0.2505002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = 2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] += total_priority
          priorities[i*N*N+j*N+k][1] -= total_priority
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_priority = -2*magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][0] -= total_priority
          priorities[i*N*N+j*N+k][1] = -total_priority

  return(priorities)


#score: {'data3D.txt': -0.4000530000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = max(1-abs(total_spin)/N**3, 0) * (1+sum(1 for val in interacting_spins if val < 0))
          priorities[i*N*N+j*N+k][0] += priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          priority_coeff = max(1-abs(total_spin)/N**3, 0) * (1+sum(1 for val in interacting_spins if val > 0))
          priorities[i*N*N+j*N+k][0] -= priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.20517100000000013}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + 2 * sum(1 for val in interacting_spins if val > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + np.count_nonzero(np.array(interacting_spins) > 0)
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + 2 * sum(1 for val in interacting_spins if val < 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        for d in [0,1,2]:
          if h[site_nbr][j][k] > 0:
            site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
            priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.2576358000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
        if h[site_nbr, j, k] > 0:
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += site_magnetism_coeff
  return(priorities)


#score: {'data3D.txt': -0.21204820000000038}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = 2 * np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)]) + magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin) - sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)])
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -2 * np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)]) - magnetism_coeff * total_spin + abs(total_spin)
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -1 - magnetism_coeff * abs(total_spin) - sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)])

        # Add the contribution of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': 0.2665093999999999}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -np.sum([1 if J[d,i,j,k] < 0 else -1 for d in range(6)]) + 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] += priority_total
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -np.sum([1 if J[d,i,j,k] > 0 else -1 for d in range(6)]) + 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= priority_total

        # Add the contribution of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] += 1
        else:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.13466539999999985}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin += 2 * hamming_distance - 1
          priorities[i*N*N+j*N+k][0] = -(total_spin + magnetism_coeff)
          priorities[i*N*N+j*N+k][1] = total_spin - magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          total_spin -= 2 * hamming_distance + 1
          priorities[i*N*N+j*N+k][0] = -total_spin + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -(total_spin - magnetism_coeff)
  return(priorities)


#score: {'data3D.txt': 0.22786739999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = -1
          for d in range(6):
            site_magnetism += J[d,i,j,k]
          priority_total = site_magnetism + magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -2 * priority_total
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          site_magnetism = 1
          for d in range(6):
            site_magnetism += J[d,i,j,k]
          priority_total = -site_magnetism + magnetism_coeff * total_spin
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = 2 * priority_total

        # Add the contribution of the site itself
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] -= 2
          priorities[i*N*N+j*N+k][1] = -1

  return(priorities)


#score: {'data3D.txt': -0.44988819999999996}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin

        for d in range(3):
          site_neighbors = [J[d][i][(j+1)%N][k], J[d][(i+1)%N][j][k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)

  return(priorities)


#score: {'data3D.txt': 0.46946380000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        total_spin = sum(J[d][i][j][k] for d in range(3)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val < 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = sum(val > 0 for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
        
        for d in range(3):
          site_neighbors = [J[d][i,(j+1)%N,k], J[d][(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val < 0 for val in site_neighbors) > sum(val < 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] += neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + sum(val for val in site_neighbors if val < 0)
        
        for d in range(3):
          site_neighbors = [J[d][i,(j+1)%N,k], J[d][(i+1)%N,j,k]]
          neighbor_magnetism_coeff = np.exp(-abs(total_spin) * (sum(val > 0 for val in site_neighbors) > sum(val > 0 for val in interacting_spins)))
          priorities[i*N*N+j*N+k][0] -= neighbor_magnetism_coeff
          priorities[i*N*N+j*N+k][1] += 1 - total_spin + sum(val for val in site_neighbors if val > 0)
          
  return(priorities)


#score: {'data3D.txt': -0.2291338000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * (sum(1 for val in interacting_spins if val < 0) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] += priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * (sum(1 for val in interacting_spins if val > 0) / max(len(interacting_spins), 1)))
          priorities[i*N*N+j*N+k][0] -= priority_coeff + total_spin
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.49333860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += 1 + total_spin + priority_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin - priority_coeff
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= 1 + total_spin + priority_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin - priority_coeff
  return(priorities)


#score: {'data3D.txt': 0.08391180000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += priority_coeff * (h[site_nbr][i][j] + total_spin)
          priorities[i*N*N+j*N+k][1] -= -1 + total_spin
        else:
          priority_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= priority_coeff * (h[site_nbr][i][j] + total_spin)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.13260300000000003}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.14245260000000018}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) + sum([spin*np.exp(-np.abs(spin)*0.5) for spin in interacting_spins])
          priorities[i*N*N+j*N+k][1] -= total_spin - sum(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) + sum([spin*np.exp(-np.abs(spin)*0.5) for spin in interacting_spins])
          priorities[i*N*N+j*N+k][1] = -total_spin - sum(interacting_spins)
  return(priorities)


#score: {'data3D.txt': -0.3153642000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2]) + h[i][j][k]
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - magnetism_coeff/2
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -total_spin + magnetism_coeff/2
  return(priorities)


#score: {'data3D.txt': -0.2512086000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val < 0]) * total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) + neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + abs(neighbor_magnetism) + len([val for val in interacting_spins if val > 0]) * total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
  return(priorities)


#score: {'data3D.txt': -0.27208860000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          site_magnetism_coeff = np.exp(-abs(h[site_nbr][j][k]) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0) + site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          site_magnetism_coeff = np.exp(-abs(h[site_nbr][j][k]) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0) - site_magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.27462900000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          site_magnetism_coeff = np.exp(-abs(h[site_nbr][j][k]) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * site_magnetism_coeff * (max(priority_coeff, 0) - 1)
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          site_magnetism_coeff = np.exp(-abs(h[site_nbr][j][k]) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * site_magnetism_coeff * (max(priority_coeff, 0) + 1)
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.0025038000000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          site_magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][1] = -2 + total_spin
        return(priorities)


#score: {'data3D.txt': -0.2947066}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          spin_polarization = sum(val for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (hamming_distance > 0.5) + total_spin + spin_polarization
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin - spin_polarization
        else:
          magnetism_coeff = np.exp(-abs(total_spin))
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          spin_polarization = sum(val for val in interacting_spins) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (hamming_distance > 0.5) - total_spin - spin_polarization
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin + spin_polarization
  return(priorities)


#score: {'data3D.txt': 0.3582974000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priority_plus = (total_spin + np.sum([val for val in interacting_spins if val < 0])) * (np.count_nonzero(interacting_spins) >= N//2)
          priority_minus = -2 + 2*total_spin - np.sum([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += priority_plus
          priorities[i*N*N+j*N+k][1] -= priority_minus
        else:
          priority_plus = -2 - 2*total_spin + np.sum([val for val in interacting_spins if val < 0])
          priority_minus = (total_spin + np.sum([val for val in interacting_spins if val > 0])) * (np.count_nonzero(interacting_spins) >= N//2)
          priorities[i*N*N+j*N+k][0] -= priority_plus
          priorities[i*N*N+j*N+k][1] += priority_minus
  return(priorities)


#score: {'data3D.txt': -0.40392259999999997}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
        # Add a term to favor the same spin as the majority of neighbors
        neighbor_spin = int(np.mean([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]))
        priorities[i*N*N+j*N+k][0] += 0.5 * (neighbor_spin == 1)
        priorities[i*N*N+j*N+k][1] -= 0.5 * (neighbor_spin == -1)
  return(priorities)


#score: {'data3D.txt': -0.23513220000000035}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          priority_total = 2 * (total_spin + hamming_distance)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + priority_total
          priorities[i*N*N+j*N+k][1] -= 1 + spin_energy
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          priority_total = 2 * (-total_spin + hamming_distance)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff + priority_total
          priorities[i*N*N+j*N+k][1] = -1 + spin_energy
  return(priorities)


#score: {'data3D.txt': -0.003801}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val > 0)
          site_nbr_spin = h[site_nbr][j][k]
          if abs(site_nbr_spin) > 0:
            site_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + hamming_distance + spin_energy + site_coeff
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance - spin_energy
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + hamming_distance + spin_energy
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - hamming_distance
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          spin_energy = -sum(val for val in interacting_spins if val < 0)
          site_nbr_spin = h[site_nbr][j][k]
          if abs(site_nbr_spin) > 0:
            site_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin - hamming_distance - spin_energy - site_coeff
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin - hamming_distance - spin_energy
            priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.23723820000000007}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * priority_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


#score: {'data3D.txt': -0.1688286}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
  return(priorities)


#score: {'data3D.txt': -0.20518979999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = 1 - total_spin + magnetism_coeff
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_total = -1 + total_spin - magnetism_coeff
        priorities[i*N*N+j*N+k][0] += abs(priority_total)
        priorities[i*N*N+j*N+k][1] -= int(np.sign(priority_total))

  return(priorities)


#score: {'data3D.txt': -0.20995740000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        if h[i][j][k] > 0:
          priority_total = abs(total_spin) * (sum([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] += priority_total
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_total = abs(total_spin) * (sum([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priorities[i*N*N+j*N+k][0] -= priority_total
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.2546382}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6)) + h[i][j][k]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin + magnetism_coeff
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - magnetism_coeff

  return(priorities)


#score: {'data3D.txt': -0.06947980000000015}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
        # Add a term to favor the same spin as the majority of neighbors
        neighbor_spin = int(np.mean([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]))
        priorities[i*N*N+j*N+k][0] += 0.5 * (neighbor_spin == 1)
        priorities[i*N*N+j*N+k][1] -= 0.5 * (neighbor_spin == -1)
        # Add a term to favor the site with magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.31657060000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0)
          # Add a term to favor the same spin as the majority of neighbors
          neighbor_spin = int(np.mean([J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]))
          priorities[i*N*N+j*N+k][0] += 0.5 * (neighbor_spin == 1) - 0.25
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0)
  return(priorities)


#score: {'data3D.txt': -0.3746362}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
        magnetism_coeff = np.exp(-abs(total_spin) * hamming_distance)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2*total_spin
          for d in range(3):
            if J[d,i,j,k] < 0:
              priorities[i*N*N+j*N+k][0] -= 0.5 * np.exp(-abs(total_spin) * abs(J[d,i,j,k]))
              priorities[i*N*N+j*N+k][1] += 0.5 * np.exp(-abs(total_spin) * abs(J[d,i,j,k]))
        else:
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2*total_spin
          for d in range(3):
            if J[d,i,j,k] > 0:
              priorities[i*N*N+j*N+k][0] += 0.5 * np.exp(-abs(total_spin) * abs(J[d,i,j,k]))
              priorities[i*N*N+j*N+k][1] -= 0.5 * np.exp(-abs(total_spin) * abs(J[d,i,j,k]))
  return(priorities)


#score: {'data3D.txt': -0.3912922000000002}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] += 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * np.mean(interacting_spins))
          priorities[i*N*N+j*N+k][0] -= 1 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -2 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.3392234000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        magnetism_coeff = np.exp(-abs(total_spin) * (np.mean(interacting_spins) < 0))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += 2 + magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= total_spin - np.count_nonzero(interacting_spins)
        else:
          priorities[i*N*N+j*N+k][0] -= 2 - magnetism_coeff
          priorities[i*N*N+j*N+k][1] = total_spin + np.count_nonzero(interacting_spins)

  return(priorities)


#score: {'data3D.txt': 0.0069754}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance > 0.5) + np.sum([abs(J[d,i,j,k]) for d in range(6)])
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance < 0.5) - np.sum([abs(J[d,i,j,k]) for d in range(6)])
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.1954934}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          interaction_coeff = sum(abs(val) for val in interacting_spins) / max(sum(abs(val) for val in interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance > 0.5) + interaction_coeff
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance < 0.5))
          interaction_coeff = sum(abs(val) for val in interacting_spins) / max(sum(abs(val) for val in interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance < 0.5) - interaction_coeff
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin)
  return(priorities)


#score: {'data3D.txt': -0.0358702}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in range(6)]
        total_spin = sum(J[d,i,j,k] for d in range(6))
        if h[i][j][k] > 0:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance > 0.5)
          priorities[i*N*N+j*N+k][1] -= 2 - magnetism_coeff * abs(total_spin) - np.sum(np.abs(interacting_spins))
        else:
          magnetism_coeff = np.exp(-abs(total_spin) * (np.count_nonzero(interacting_spins) % 2 == 0))
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * total_spin + abs(h[i][j][k]) * (hamming_distance < 0.5)
          priorities[i*N*N+j*N+k][1] = -2 + magnetism_coeff * abs(total_spin) + np.sum(np.abs(interacting_spins))
  return(priorities)


#score: {'data3D.txt': 0.1920498}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin + abs(sum(val for val in interacting_spins if val < 0)) + 2*abs(J[0,site_nbr,i,k])
          priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin - sum(val for val in interacting_spins if val < 0) - 2*J[0,site_nbr,i,k]
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin - abs(sum(val for val in interacting_spins if val > 0)) - 2*abs(J[0,site_nbr,i,k])
          priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin + sum(val for val in interacting_spins if val > 0) + 2*J[0,site_nbr,i,k]
        # Add a term to favor the site with magnetism
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += total_spin
          priorities[i*N*N+j*N+k][1] -= total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= total_spin
          priorities[i*N*N+j*N+k][1] = -total_spin
  return(priorities)


#score: {'data3D.txt': -0.04627020000000001}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = magnetism_coeff + total_spin + abs(sum(val for val in interacting_spins if val > 0)) - len([val for val in interacting_spins if val < 0])
          priority_down = -1 + 2*total_spin - sum(val for val in interacting_spins if val < 0) - sum(val for val in interacting_spins if val > 0)
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priority_up = -magnetism_coeff - total_spin + abs(sum(val for val in interacting_spins if val < 0)) - len([val for val in interacting_spins if val > 0])
          priority_down = -1 - 2*total_spin + sum(val for val in interacting_spins if val > 0) + sum(val for val in interacting_spins if val < 0)
        priorities[i*N*N+j*N+k][0] += priority_up
        priorities[i*N*N+j*N+k][1] += priority_down
  return priorities


#score: {'data3D.txt': -0.1387594}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          if total_spin > 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff + total_spin - 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 1 - 2*total_spin + sum(val for val in interacting_spins if val < 0) - neighbor_magnetism
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff + total_spin + 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
        else:
          hamming_distance = len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          neighbor_magnetism = sum(J[d,site_nbr,i,k] for d in [0,1,2])
          if total_spin < 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff - total_spin + 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] = -1 + 2*total_spin - sum(val for val in interacting_spins if val > 0) - neighbor_magnetism
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff - total_spin - 0.5 * (hamming_distance > 0.5)
            priorities[i*N*N+j*N+k][1] -= 1 + 2*total_spin + sum(val for val in interacting_spins if val < 0) - neighbor_magnetism
  return priorities


#score: {'data3D.txt': -0.3299229999999998}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += abs(total_spin)
          priorities[i*N*N+j*N+k][1] -= total_spin
          if any(val < 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] += 2 * len([val for val in interacting_spins if val < 0])
            priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= abs(total_spin)
          priorities[i*N*N+j*N+k][1] = -total_spin
          if any(val > 0 for val in interacting_spins):
            priorities[i*N*N+j*N+k][0] -= 2 * len([val for val in interacting_spins if val > 0])
            priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0])
  return(priorities)


#score: {'data3D.txt': -0.35770900000000005}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          total_spin += sum(J[d,site_nbr,j,k] for d in [3,4,5])
          hamming_distance = len([val for val in interacting_spins + list(J[d,site_nbr,j,k] for d in [3,4,5]) if val < 0]) / max(len(interacting_spins + list(J[d,site_nbr,j,k] for d in [3,4,5])), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] += magnetism_coeff
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          total_spin -= sum(J[d,site_nbr,j,k] for d in [3,4,5])
          hamming_distance = len([val for val in interacting_spins + list(J[d,site_nbr,j,k] for d in [3,4,5]) if val > 0]) / max(len(interacting_spins + list(J[d,site_nbr,j,k] for d in [3,4,5])), 1)
          magnetism_coeff = np.exp(-abs(total_spin) * (hamming_distance > 0.5))
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff
          priorities[i*N*N+j*N+k][1] = -1 + total_spin

  return(priorities)


#score: {'data3D.txt': -0.1794598}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_total = total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total += 1
            else:
              priority_total -= 1
          priorities[i*N*N+j*N+k][0] += abs(priority_total)
          priorities[i*N*N+j*N+k][1] -= priority_total
        else:
          priority_total = -total_spin
          for d in range(3):
            site = (i + ((d-1)%2 - 1)) % N
            if h[site][j][k] > 0:
              priority_total -= 1
            else:
              priority_total += 1
          priorities[i*N*N+j*N+k][0] -= abs(priority_total)
          priorities[i*N*N+j*N+k][1] = -priority_total
  return(priorities)


#score: {'data3D.txt': -0.43543980000000004}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          if total_spin >= 0:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
          else:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          if total_spin >= 0:
            priorities[i*N*N+j*N+k][0] -= magnetism_coeff * max(-priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
          else:
            priorities[i*N*N+j*N+k][0] += magnetism_coeff * max(priority_coeff, 0)
            priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
  return priorities


#score: {'data3D.txt': -0.324363}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) < 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val < 0]) / max(len(interacting_spins), 1))
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] += magnetism_coeff * (total_spin >= 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin - (hamming_distance >= len([val for val in interacting_spins if val > 0]))
        else:
          hamming_distance = np.count_nonzero(np.array(interacting_spins) > 0)
          magnetism_coeff = np.exp(-abs(total_spin) * len([val for val in interacting_spins if val > 0]) / max(len(interacting_spins), 1))
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - hamming_distance
          priorities[i*N*N+j*N+k][0] -= magnetism_coeff * (total_spin <= 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin - (hamming_distance >= len([val for val in interacting_spins if val < 0]))
  return(priorities)


#score: {'data3D.txt': -0.4578558}
program:
def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,(i+1)%N,j,k], J[2,i,(j+1)%N,k]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[i][j][k] > 0:
          priority_coeff = total_spin + sum(1 for val in interacting_spins if val > 0) - np.count_nonzero(np.array(interacting_spins) < 0)
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] -= 1 - total_spin
        else:
          priority_coeff = -total_spin + sum(1 for val in interacting_spins if val < 0) - np.count_nonzero(np.array(interacting_spins) > 0)
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * max(priority_coeff, 0)
          priorities[i*N*N+j*N+k][1] = -1 + total_spin
  return(priorities)


